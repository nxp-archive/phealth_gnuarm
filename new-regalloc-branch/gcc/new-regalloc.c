/* Graph coloring register allocator
   Copyright (C) 2001 Free Software Foundation, Inc.
   Contributed by Daniel Berlin <dberlin@redhat.com>

   This file is part of GNU CC.

   GNU CC is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GNU CC is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GNU CC; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* TODO:
   1. Rip spill code insertion from reload, put it here instead, so we
   can iterate.
   2. Allow spill code heuristics to be plugged in. (50% done)
   3. Large amounts of tuning.
   4. Use right size for various bitmaps. We don't actually need
   max_reg_num (), just max_reg_num - FIRST_PSEUDO_REGISTER.

   STATUS:
   When we don't spill, we have perfect allocation. Reload doesn't change
   anything. Thus, we are satistfying all constraints required, at least on
   PowerPC.

   The algorithm used is iterated register coalescing by George and Appel.

   The divergence from the paper is twofold.  First, in the use of register
   freedom to allow the graph to have registers with different/multiple
   classes, and properly allocate for them, on it.  This adds 7 or 8 lines
   of code, total -- no joke.

   The second is in edge weighting, which allows us to properly express the
   interference when some pseudos really need more hard regs than other
   pseudos.  The other way to do this is with multi-graphs (IE treat a
   pseudo as multiple on the graph), but this way is equivalent, and easier
   to implement.

   We assume consecutive regs are necessary to express a pseudo that
   requires multiple hard registers.

   We try to take into account the register preference, even with multiple
   hard regs needed.  This is what find_reg_given_constraints does -- given
   a set of okay registers, constraints (ie allocation order, whether the
   register is okay for this mode, pseudo needing multiple hard regs, etc)
   and preferences, find the best register.  We do this by finding the most
   preferred register (using the allocation order) that has the right number
   of usable registers in either direction.  We then treat the register as
   if it had multiple colors (by excluding those extra consecutive registers
   when coloring it's neighbors).

   This register allocator needs to be able to generate the spill code, and
   handles register allocation for temporaries generated by that spill
   code.  It does this by redoing register allocation whenever we spill.
   Each round of register allocation is linear, so this is not a drag at all.

   We rarely spill. It takes a serious amount of work to make us spill on an
   architecture with a reasonable amount of registers.  Even on x86, it
   takes a *lot* to make us spill.

   Advantages over old allocator:

   Eliminates regmove - We coalesce more moves anyway.

   Eliminates spill allocation, just need to insert spill code, and rerun
   register allocation.

   Performs a *ton* better. On my powerpc, I haven't hit a spill in
   compiling gcc's associated libraries (libiberty, libstdc++-v3, etc). We
   used to spill multiple times per procedure for each file.  On x86, with
   it's severely limited register classes

   Easy to understand - you can look at the paper, and actually understand
   it, and look at the pseudocode given, and match it up with the code here.

   Easy to maintain - the algorithms are elegant, and simple. There is no
   machine-specific cruftiness here.  Liveness analysis is taken care of by
   the dataflow analysis module.

   Easy to debug - The code necessary to print out the sets being used in an
   easy to read form is included, as is enough debugging info to tell you
   what is going on at a high level, and a low level (you can control the
   level of spew)

   Possible Improvements (in order of bang for the buck):

   (Very easy, significant improvement in running time of register allocator)
   It is safe (ie won't increase the number of spills) to keep all
   coalescings performed before the first spill node is removed from the
   graph.  Since many coalescings occur before the first spill, the graph
   used in subsequent rounds would be smaller, and the algorithm would go
   significantly faster.

   (Easy, significant improvement in spill selection)
   Variables with constant values can be spilled very cheaply (since no
   store is necessary, and we can recompute the value at any point if
   needed).  We should use this information in choosing spills, since the
   constant propagation pass gives it to us (right?).

   (Medium difficulty, unless you are an optimization person, in which
   case this is probably easy.  No idea on improvement.)
   Try out optimistic register coalescing.  This gives you all the building
   blocks to do it, it wouldn't take very long at all to do this.

   We could integrate copy/const propagation into this register allocator if
   we wanted to.  */

#include "config.h"
#include "system.h"
#include "rtl.h"
#include "sbitmap.h"
#include "tm_p.h"
#include "regs.h"
#include "hard-reg-set.h"
#include "rtl.h"
#include "basic-block.h"
#include "function.h"
#include "output.h"
#include "ggc.h"
#include "df.h"
#include "varray.h"
#include "hashtab.h"
#include "glimits.h"
#include "new-regalloc.h"

/* Hashed set. */
typedef htab_t hset;
typedef htab_trav hset_trav;

static hashval_t hset_hash PARAMS ((const void *));
static int hset_equal PARAMS ((const void *, const void *));
static void hset_free PARAMS ((void *));
static hset hset_new PARAMS ((void));
static void hset_delete PARAMS ((hset));
static void hset_insert PARAMS ((hset, void *));
static void hset_remove PARAMS ((hset, void *));
static int hset_member PARAMS ((hset, void *));
static int hset_union_1 PARAMS ((void **, void *));
static void hset_union PARAMS ((hset, hset));
static int hset_empty PARAMS ((hset));
static void hset_traverse PARAMS ((hset, hset_trav, void *));
static int hset_difference_1 PARAMS ((void **, void *));
static void hset_difference PARAMS ((hset, hset));
static int hset_intersect_1 PARAMS ((void **, void *));
static void hset_intersect PARAMS ((hset, hset));
static int hset_print_intset_1 PARAMS ((void **, void *));
static void hset_print_intset PARAMS ((FILE *, hset, const char *));
void debug_integer_hset PARAMS ((hset));

/* This macro exists because there are places where we'd have to
   create large structs just to pass all the information we need. */
#define HSET_TRAVERSAL(set, counter, entry, code)	\
  do {							\
    for (counter = 0; counter < set->size; counter++)	\
      if (set->entries[counter] != (void *) 0 &&	\
	  set->entries[counter] != (void *) 1)		\
	{						\
	  entry = set->entries[counter];		\
	  code;						\
	}						\
  } while (0)

/* XXX:Extra regset routine, move into bitmap.c??? */
static int regset_first_set_bit PARAMS((regset));

/* IRC routines */
static float (*spill_heuristic) PARAMS ((unsigned int));

static int edge_weight PARAMS ((unsigned int, unsigned int));
static void add_edge PARAMS ((unsigned int, unsigned int));
static void add_move PARAMS ((unsigned int, rtx));
static int is_reg_candidate PARAMS ((unsigned int));
static int is_candidate_move PARAMS ((rtx, regset));
static void make_worklist PARAMS ((regset));
static hset node_moves PARAMS ((unsigned int));
static int move_related PARAMS ((unsigned int));
static int varray_contains PARAMS ((varray_type, unsigned int));
static regset adjacent PARAMS ((unsigned int));
static int enable_moves_1 PARAMS ((void **, void *));
static void enable_moves PARAMS ((unsigned int));
static void decrement_degree PARAMS ((unsigned int, unsigned int));
static void simplify PARAMS ((void));
static void coalesce PARAMS ((void));
static void freeze_moves PARAMS ((unsigned int));
static void freeze PARAMS ((void));
static float default_heuristic PARAMS ((unsigned int));
static void select_spill PARAMS ((void));
static int x_okay_in_direction PARAMS ((HARD_REG_SET, int, int,
					enum machine_mode));

static void assign_regs PARAMS ((void));
static void rewrite_program PARAMS ((int));
static unsigned int get_alias PARAMS ((unsigned int));
static rtx find_costliest_move PARAMS ((hset));
static float find_move_cost PARAMS ((rtx));

static void add_worklist PARAMS ((unsigned int));
static int precolored_OK PARAMS ((unsigned int, unsigned int));
static int conservative PARAMS ((unsigned int, unsigned int));
static void combine PARAMS ((unsigned int, unsigned int));
static int reg_freedom PARAMS ((unsigned int));

void init_new_regalloc PARAMS ((void));
void perform_new_regalloc_init PARAMS ((void));
void perform_new_regalloc PARAMS ((void));
void finish_new_regalloc PARAMS ((void));


/* The naming convention of the routines/variables follows the paper,
   I'll clean it up later */
typedef struct i_g_node
{
  hset move_list;
  regset adj_list;
  unsigned int alias;
  int degree;
} *ig_node;

static ig_node ig_node_new PARAMS ((void));
static void ig_node_delete PARAMS ((ig_node));
static void print_ig_node PARAMS ((FILE *, void *));
void debug_ig_node PARAMS ((void *));

/* Return a new interference graph node.  */
static ig_node
ig_node_new ()
{
  ig_node retval;

  retval = ggc_alloc_cleared (sizeof (struct i_g_node));
  retval->adj_list = BITMAP_XMALLOC ();
  CLEAR_REG_SET (retval->adj_list);

  retval->move_list = hset_new ();
  return retval;
}

static void
ig_node_delete (node)
  ig_node node;
{
  hset_delete (node->move_list);
  FREE_REG_SET (node->adj_list);
}
  
static void
print_ig_node (file, node)
     FILE *file;
     void *node;
{
  ig_node thenode = (ig_node) node;
  fprintf (file, "{ Degree:%d, Alias:%d, ", thenode->degree,
	  thenode->alias);
  fprintf (file, "}\n");
}

void
debug_ig_node (node)
     void *node;
{
  print_ig_node (stderr, node);
}


/* Hash function for hashed sets.  */
static hashval_t
hset_hash (a)
     const void *a;
{
  return (size_t) a;
}

/* Hashed set element equality.  */
static int
hset_equal (a, b)
     const void *a;
     const void *b;
{
  return a==b;
}

/* Hashed set element free.  We have nothing that isn't a pointer, or needs
   freeing, so we no-op this routine.  */
static void
hset_free (a)
     void *a ATTRIBUTE_UNUSED;
{
}

/* Create a new hashed set.  */
static hset
hset_new ()
{
  return htab_create (119, hset_hash, hset_equal, hset_free);
}

/* Delete an existing hashed set.  */
static void
hset_delete (set)
     hset set;
{
  htab_delete (set);
}

/* Insert an element into the hashed set.  */
static void
hset_insert (set, elt)
     hset set;
     void *elt;

{
  *(htab_find_slot (set, elt, INSERT)) = elt;
}

/* Remove an element from the hashed set.  */
static void
hset_remove (set, elt)
     hset set;
     void *elt;
{
  htab_remove_elt (set, elt);
}

/* Determine if elt is a member of hashed set set.  */
static int
hset_member (set, elt)
     hset set;
     void *elt;
{
  return htab_find (set, elt) != 0;
}

/* Temporary value passing structure.  */
struct twosets
{
  hset set1;
  hset set2;
};

/* Union helper routine.  */
static int
hset_union_1 (entry, data)
     void **entry;
     void *data;
{
  hset currset = (hset) data;

  hset_insert (currset, *entry);
  return 1;
}

/* Hashed set union.  */
static void
hset_union (set1, set2)
     hset set1;
     hset set2;
{
  htab_traverse (set2, hset_union_1, set1);
}

/* Hashed set traversal.  */
static void
hset_traverse (set, func, data)
     hset set;
     hset_trav func;
     void *data;
{
  htab_traverse (set, func, data);
}

/* Return 1 if hashed set is empty */
static int
hset_empty (set)
     hset set;
{
  return htab_elements (set) == 0;
}

/* Helper routine for hset_difference.  */
static int
hset_difference_1 (entry, data)
     void **entry;
     void *data;
{
  struct twosets *twosets = (struct twosets *) data;

  if (hset_member (twosets->set2, *entry))
    hset_remove (twosets->set1, *entry);
  return 1;
}

/* Perform a set difference, ie. set1 <- set1 - set2.  */
static void
hset_difference (set1, set2)
     hset set1;
     hset set2;
{
  struct twosets two;
  two.set1 = set1;
  two.set2 = set2;

  htab_traverse (set1, hset_difference_1, &two);
}

/* Helper routine for hset_intersect.  */
static int
hset_intersect_1 (entry, data)
     void **entry;
     void *data;
{
  struct twosets *twosets = (struct twosets *) data;

  if (! hset_member (twosets->set2, *entry))
    hset_remove (twosets->set1, *entry);
  return 1;
}

/* Perform a set intersection, ie.  set1 <- set1 INTERSECT set2.  */
static void
hset_intersect (set1, set2)
     hset set1;
     hset set2;
{
  struct twosets two;
  two.set1 = set1;
  two.set2 = set2;

  htab_traverse (set1, hset_intersect_1, &two);
}

/* Print out an integer set helper.  */
static int
hset_print_intset_1 (entry, data)
     void **entry;
     void *data;
{
  FILE *file = (FILE *) data;

  fprintf (file, HOST_PTR_PRINTF, *entry);
  fputc (' ', file);
  return 1;
}

/* Print out an integer set.  */
static void
hset_print_intset (file, set, name)
     FILE *file;
     hset set;
     const char *name;
{
  fprintf (file, "Integer set \"%s\":{", name);
  htab_traverse (set, hset_print_intset_1, file);
  fprintf (file, "}\n");
}

/* Debugger function to print out integer set.  */
void
debug_integer_hset (set)
     hset set;
{
  hset_print_intset (stderr, set, "");
}

/* Precolored nodes */
static regset precolored;

/* Rest are from paper */
static regset simplify_worklist;
static regset freeze_worklist;
static regset spill_worklist;
static regset spilled_nodes;
static regset coalesced_nodes;
static hset coalesced_moves;
static hset constrained_moves;
static hset frozen_moves;
static hset worklist_moves;
static hset active_moves;

/* Biased coloring costs */
static double *costs;
/* Map register numbers to interference graph nodes */
static ig_node *ra_reg_info;
/* Map registers to colors */
static int *colors;
/* What nodes are on the stack (So we don't have to look through the
   stack continuously */ 
static regset select_nodes;
/* _stack of nodes to color */
static varray_type select_stack;
/* Data flow analyzer structure */
static struct df *df_analyzer;


/* Amazingly useful for debugging this allocator:
   0 = no spew, 1 = not much spew, 2 = lots of spew.  */
static int debug_new_regalloc = 2;

/* Whether to use biased coloring or not */
static int biased_coloring = 0;



static int
regset_first_set_bit (regs)
     regset regs;
{
  unsigned int i;
  EXECUTE_IF_SET_IN_REG_SET (regs, 0, i, return i; );
  return -1;
}

/* Determine if regno is a candidate for this pass of register
   allocation.  */
static int
is_reg_candidate (regno)
     unsigned int regno;
{
  return DF_REGNO_FIRST_DEF (df_analyzer, regno) != 0;
}

/* Determine if a given rtx is a candidate move.  */
static int
is_candidate_move (insn, candidates)
     rtx insn;
     regset candidates;
{
  rtx set;

  if (GET_CODE (insn) != INSN)
    return 0;

  /* ??? Perhaps use single_set, or do we count on no other side effects?  */
  set = PATTERN (insn);
  if (GET_CODE (set) != SET)
    return 0;

  if (GET_CODE (SET_SRC (set)) == REG
      && GET_CODE (SET_DEST (set)) == REG
      && REGNO_REG_SET_P (candidates, REGNO (SET_SRC (set)))
      && REGNO_REG_SET_P (candidates, REGNO (SET_DEST (set))))
    return 1;

  return 0;
}

/* Determine the edge weight from reg v1 to reg v2.  */
static int
edge_weight (v1, v2)
     unsigned int v1;
     unsigned int v2;
{
  int w1 = 0, w2 = 0;

  if (! REGNO_REG_SET_P (precolored, v1))
    w1 = CLASS_MAX_NREGS (reg_preferred_class (v1), PSEUDO_REGNO_MODE (v1));
  if (! REGNO_REG_SET_P (precolored, v2))
    w2 = CLASS_MAX_NREGS (reg_preferred_class (v2), PSEUDO_REGNO_MODE (v2));

  switch (w1 + w2)
    {
    case 0:
    case 1:
    case 2:
      return 1;
    case 3:
      return 2;
    case 4:
      /* FIXME: Test for unaligned pairs.  */
      return 2;
    default:
      abort ();
    }
}

/* Add an interference edge from reg v1 to reg v2 */
static void
add_edge (v1, v2)
     unsigned int v1;
     unsigned int v2;
{
  if (v1 != v2 && ! REGNO_REG_SET_P (ra_reg_info[v1]->adj_list, v2))
    {
      /* Precolored nodes that interfere with each other are irrelevant,
	 we don't color them anyway (since they are precolored).  */
      if (! REGNO_REG_SET_P (precolored, v1))
	{
	  /* Add v2 to v1's adjacency list.  */
	  SET_REGNO_REG_SET (ra_reg_info[v1]->adj_list, v2);
	  ra_reg_info[v1]->degree += edge_weight (v1, v2);
	}
      if (! REGNO_REG_SET_P (precolored, v2))
	{
	  /* Add v1 to v2's adjacency list.  */
	  SET_REGNO_REG_SET (ra_reg_info[v2]->adj_list, v1);
	  ra_reg_info[v2]->degree += edge_weight (v2, v1);
	}
    }
}

/* Add a move to the regno's movelist.  */
static void
add_move (regno, insn)
     unsigned int regno;
     rtx insn;
{
  hset_insert (ra_reg_info[regno]->move_list, (void *) insn);
}

/* node_moves (n) = move_list[n] INTERSECT (active_moves U worklist_moves) */
static hset
node_moves (reg_num)
     unsigned int reg_num;
{
  hset result = hset_new ();
  hset_union (result, active_moves);
  hset_union (result, worklist_moves);
  hset_intersect (result, ra_reg_info[reg_num]->move_list);
  return result;
}

/* Determine if reg_num is involved in a move.  */
static int
move_related (reg_num)
     unsigned int reg_num;
{
  int retval;
  hset moves;

  moves = node_moves (reg_num);
  retval = ! hset_empty (moves);
  hset_delete (moves);

  return retval;
}

/* Determine the size of a hard register set.
   If this gets to be a bottleneck, cache it, it won't change. */
#define HARD_REG_SET_SIZE(SET, VAR)		\
  do {						\
    int i;					\
    for (i=0; i < FIRST_PSEUDO_REGISTER; i++)	\
      if (TEST_HARD_REG_BIT (SET, i))		\
	VAR++;					\
  } while (0)

/* Cache the register freedoms */
static int *reg_freedoms;

/* Determine the register freedom of reg_num.
   Register freedom is what lets us allocate all the register types in one
   pass. It determines the number of registers in the register set this
   reg_num prefers.  This assumes that registers only have preferences that
   are valid classes, which they do, AFAIK. */
static int
reg_freedom (reg_num)
     unsigned int reg_num;
{
  HARD_REG_SET temp;
  unsigned int j=0;
  
  if (reg_freedoms [reg_num] >= 0)
    return reg_freedoms[reg_num];
  
  COPY_HARD_REG_SET (temp, reg_class_contents[reg_preferred_class (reg_num)]);
  IOR_HARD_REG_SET (temp, reg_class_contents[reg_alternate_class (reg_num)]);
  AND_COMPL_HARD_REG_SET (temp, fixed_reg_set);
  HARD_REG_SET_SIZE (temp, j);
  reg_freedoms[reg_num] = j;
  return j;
}

/* Make the worklists from the inital set of candidates.  */
static void
make_worklist (set)
     regset set;
{
  unsigned int entry;

  EXECUTE_IF_SET_IN_REG_SET (set, 0, entry,
    {
      unsigned int reg_num = entry;

      /* Remove it from the initial set */
      CLEAR_REGNO_REG_SET (set, entry);

      /* If it's of significant degree, place it on the spill_worklist.  */
      if (ra_reg_info[reg_num]->degree >= reg_freedom (reg_num))
	{
	  if (rtl_dump_file != NULL && debug_new_regalloc > 1)
	    fprintf (rtl_dump_file, "Inserting %d onto spill_worklist\n", reg_num);
	  SET_REGNO_REG_SET (spill_worklist, reg_num);
	}
      /* If it's move related, put it on the freeze worklist.  */
      else if (move_related (reg_num))
	{
	  if (rtl_dump_file != NULL && debug_new_regalloc > 1)
	    fprintf (rtl_dump_file, "Inserting %d onto freeze_worklist\n", reg_num);
	  SET_REGNO_REG_SET (freeze_worklist, reg_num);
	}
      /* Otherwise, put it on the simplify worklist.  */
      else
	{
	  if (rtl_dump_file != NULL && debug_new_regalloc > 1)
	    fprintf (rtl_dump_file, "Inserting %d onto simplify_worklist\n", reg_num);
	  SET_REGNO_REG_SET (simplify_worklist, reg_num);
	}
    });
}

/* Returns 1 if the varray contains the register reg_num.  */
static int
varray_contains (array, reg_num)
     varray_type array;
     unsigned int reg_num;
{
  unsigned int i;

  for (i = 0; i < VARRAY_SIZE (array); i++)
    if (VARRAY_UINT (array, i) == reg_num)
      return 1;
  return 0;
}

/* adjacent (n) = adj_list[n] - (select_stack U coalesced_moves) */
static regset
adjacent (reg_num)
     unsigned int reg_num;
{
  regset result;
  unsigned int entry;
  
  result = BITMAP_XMALLOC ();
  
  CLEAR_REG_SET (result);
  COPY_REG_SET (result, ra_reg_info[reg_num]->adj_list);
  AND_COMPL_REG_SET (result, coalesced_nodes);
  EXECUTE_IF_SET_IN_REG_SET (result, 0, entry,
  {
      
    if (REGNO_REG_SET_P (select_nodes, entry))
      CLEAR_REGNO_REG_SET (result, entry);
  });
  
  return result;
}

/* Helper function for enable_moves.  */
static int
enable_moves_1 (entry, data)
     void **entry;
     void *data ATTRIBUTE_UNUSED;
{
  /* If it is currently an active move, put it on the worklist
     for moves.  */
  if (hset_member (active_moves, *entry))
    {
      hset_remove (active_moves, *entry);
      hset_insert (worklist_moves, *entry);
    }
  return 1;
}

/* Enable moves for register number reg_num.  Takes the moves for this
   register, and puts them on the worklist to be processed.  */
static void
enable_moves (reg_num)
     unsigned int reg_num;
{
  hset moves;
  moves = node_moves (reg_num);
  hset_traverse (moves, enable_moves_1, NULL);
  hset_delete (moves);
}

/* Decrement the degree of the register, handle possible effect
   (ie it might move from significant degree to insignificant degree).  */
static void
decrement_degree (reg_num, from)
     unsigned int reg_num;
     unsigned int from;
{
  int w = edge_weight (reg_num, from);
  int d = ra_reg_info[reg_num]->degree;
  regset adj;
  unsigned int entry;

  /* If it was of significant degree before, and isn't now, we need to
     enable its moves, and move it off the spill_worklist.  */
  ra_reg_info[reg_num]->degree -= w;

  if (ra_reg_info[reg_num]->degree < reg_freedom (reg_num)
      && d >= reg_freedom (reg_num))
    {
      /* Make all moves involving variable ready for coalescing.  */
      enable_moves (reg_num);
      adj = adjacent (reg_num);
      EXECUTE_IF_SET_IN_REG_SET (adj, 0, entry, { enable_moves (entry); });
      FREE_REG_SET (adj);

      /* This variable is now low-degree... treat it that way.  */
      CLEAR_REGNO_REG_SET (spill_worklist, reg_num);

      if (move_related (reg_num))
	SET_REGNO_REG_SET (freeze_worklist, reg_num);
      else
	SET_REGNO_REG_SET (simplify_worklist, reg_num);
    }
}

/* Simplify the graph.  */
static void
simplify ()
{
  unsigned int curr_reg;
  unsigned int entry;
  regset adj;

  /* Pick the first thing on the worklist.  */
  curr_reg = regset_first_set_bit (simplify_worklist);
  if (rtl_dump_file != NULL && debug_new_regalloc > 1)
    fprintf (rtl_dump_file, "picked reg %d in simplify\n", curr_reg);

  /* Remove it.  */
  CLEAR_REGNO_REG_SET (simplify_worklist, curr_reg);

  /* Push it onto the select_stack to be colored.  */
  VARRAY_PUSH_UINT (select_stack, curr_reg);
  SET_REGNO_REG_SET (select_nodes, curr_reg);
  adj = adjacent (curr_reg);

  /* From new register allocator paper.  */
  /* ??? My that's a descriptive comment.  */
  if (ra_reg_info[curr_reg]->degree > reg_freedom (curr_reg))
    EXECUTE_IF_SET_IN_REG_SET (adj, 0, entry, { enable_moves (entry); });

  /* Now that we've removed it, everything adjacent to it gets
     decremented in degree.  */
  EXECUTE_IF_SET_IN_REG_SET (adj, 0, entry,
    {
      if (rtl_dump_file != NULL && debug_new_regalloc > 1)
	fprintf (rtl_dump_file, "Decrementing degree of %d\n", entry);
      decrement_degree (entry, curr_reg);
    });

  FREE_REG_SET (adj);
}

/* If reg_num was coalesced, find out where it went, recursively if
   necessary.  */
static unsigned int
get_alias (reg_num)
     unsigned int reg_num;
{
  unsigned int result;

  if (REGNO_REG_SET_P (coalesced_nodes, reg_num))
    result = get_alias (ra_reg_info[reg_num]->alias);
  else
    result = reg_num;
  return result;
}

static
float find_move_cost (move)
     rtx move;
{
  rtx body = PATTERN (move);
  enum reg_class lhs;
  enum reg_class rhs;
  if (HARD_REGISTER_NUM_P (REGNO (SET_DEST (body))))
    lhs = REGNO_REG_CLASS (REGNO (SET_DEST (body)));
  else
    lhs = reg_preferred_class (REGNO (SET_DEST (body)));
  if (HARD_REGISTER_NUM_P (REGNO (SET_SRC (body))))
    rhs = REGNO_REG_CLASS (REGNO (SET_SRC (body)));
  else
    rhs = reg_preferred_class (REGNO (SET_SRC (body)));
  return (BLOCK_FOR_INSN (move)->loop_depth + 1) 
    * REGISTER_MOVE_COST (GET_MODE (SET_SRC (body)), rhs, lhs);
}

/* Find the move with the maximum cost */
static 
rtx find_costliest_move (moves)
     hset moves;
{
  unsigned int i;
  void *entry;
  float max_cost = (float) -1.0;
  rtx costliest = NULL_RTX;


  HSET_TRAVERSAL (moves, i, entry, 
  {
    /* XXX: Do we have a better heuristic, or real move costs? I
       didn't look very hard at all.
       Right now we assume move cost is based on loop depth, since the
       move gets done every iteration .
    */
    float cost;
    cost = find_move_cost ((rtx) entry);
    
    if (cost > max_cost)
      {
	max_cost = cost;
	costliest = entry;
      }
  });

  return costliest;

}


/* Add_worklist takes a register, and if it's not move related, and it
   is of insignificant degree, puts it on the simplify_worklist.  */
static void
add_worklist (reg_num)
     unsigned int reg_num;
{
  if (! move_related (reg_num)
      && ra_reg_info[reg_num]->degree < reg_freedom (reg_num))
    {
      CLEAR_REGNO_REG_SET (freeze_worklist, reg_num);
      SET_REGNO_REG_SET (simplify_worklist, reg_num);
    }
}

/* precolored_OK is the precolored coalescing heuristic.  */
static int
precolored_OK (f, r)
     unsigned int f;
     unsigned int r;
{
  regset adjacent_set = ra_reg_info[f]->adj_list;
  unsigned int entry;

  if (TEST_HARD_REG_BIT (fixed_reg_set, f) || TEST_HARD_REG_BIT (fixed_reg_set, r))
    return 0;
  EXECUTE_IF_SET_IN_REG_SET (adjacent_set, 0, entry,
    {
      if (! REGNO_REG_SET_P (select_nodes, entry) 
	  && ! REGNO_REG_SET_P (coalesced_nodes, entry) 
	  && ! (ra_reg_info[entry]->degree < reg_freedom (entry)
		|| REGNO_REG_SET_P (precolored, entry)
		|| REGNO_REG_SET_P (ra_reg_info[entry]->adj_list, f)))
	return 0;
    });

  return 1;
}

/* Called when both rhs and lhs are candidates (not precolored).  It returns
   true when the result of coalescing the two would be guaranteed to become
   a node of "insignificant degree", and thus, easy to color.  */
static int
conservative (rhs, lhs)
     unsigned int rhs;
     unsigned int lhs;
{
  int k = 0;
  int freedom;
  unsigned int entry;
  enum machine_mode lhsmode, rhsmode;
  int result;
  regset visited;

  /* XXX: If they aren't the same mode, they can't possibly be
     combined, right?  */
  if (HARD_REGISTER_NUM_P (rhs))
    rhsmode = reg_raw_mode[rhs];
  else
    rhsmode = PSEUDO_REGNO_MODE (rhs);

  if (HARD_REGISTER_NUM_P (lhs))
    lhsmode = reg_raw_mode[lhs];
  else
    lhsmode = PSEUDO_REGNO_MODE (lhs);

  if (rhsmode != lhsmode)
    return 0;

  freedom = MAX (reg_freedom (lhs), reg_freedom (rhs));

  /* FIXME: We really should to keep the class with the node, so we can
    combine the classes when we coalesce.  */

  /* Cache visited entries so we don't waste a ton of time.  */
  visited = BITMAP_XMALLOC ();
  CLEAR_REG_SET (visited);
  result = 0;

  /* We don't figure out the full set of neighbors beforehand, as it's
     much slower than prescreening.  */
  EXECUTE_IF_SET_IN_REG_SET (ra_reg_info[lhs]->adj_list, 0, entry,
    {
      if (! REGNO_REG_SET_P (visited, entry))
	{
	  SET_REGNO_REG_SET (visited, entry);
	  if (ra_reg_info[entry]->degree >= reg_freedom (entry))
	    {
	      k += edge_weight (lhs, entry);
	      if (k >= freedom)
		goto fail;
	    }
	}
    });

  EXECUTE_IF_SET_IN_REG_SET (ra_reg_info[rhs]->adj_list, 0, entry,
    {
      if (! REGNO_REG_SET_P (visited, entry))
	{
	  SET_REGNO_REG_SET (visited, entry);
	  if (ra_reg_info[entry]->degree >= reg_freedom (entry))
	    {
	      k += edge_weight (rhs, entry);
	      if (k >= freedom)
		goto fail;
	    }
	}
    });

  result = 1;
 fail:
  FREE_REG_SET (visited);
  return result;
}

/* Combine two nodes into one, throw it on the right worklists, insert it
   into the list of coalesced nodes, union the movelists, handle the new
   neighbors, and setup the alias.  */
static void
combine (u, v)
     unsigned int u;
     unsigned int v;
{
  regset adj;
  unsigned int entry;

  if (rtl_dump_file != NULL && debug_new_regalloc > 0)
    fprintf (rtl_dump_file, "Coalescing %d and %d\n", u, v);

  /* Remove v from the worklists, and make it a coalesced node. */
  if (REGNO_REG_SET_P (freeze_worklist, v))
    CLEAR_REGNO_REG_SET (freeze_worklist, v);
  else
    CLEAR_REGNO_REG_SET (spill_worklist, v);

  /* Throw it on the coalesced node list.  */
  SET_REGNO_REG_SET (coalesced_nodes, v);

  /* Set up the alias.  */
  ra_reg_info[v]->alias = u;

  /* Union the move lists.  */
  hset_union (ra_reg_info[u]->move_list, ra_reg_info[v]->move_list);

  /* Add our new neighbors, decrement the degree of the old ones.  */
  adj = adjacent (v);
  EXECUTE_IF_SET_IN_REG_SET (adj, 0, entry,
    {
      add_edge (entry, u);
      decrement_degree (entry, v);
    });
  FREE_REG_SET (adj);

  /* The new node might be of significant degree now.  */
  if (ra_reg_info[u]->degree >= reg_freedom (u) && REGNO_REG_SET_P (freeze_worklist, u))
    {
      CLEAR_REGNO_REG_SET (freeze_worklist, u);
      SET_REGNO_REG_SET (spill_worklist, u);
    }
}

/* Coalescing pass */
static void
coalesce ()
{
  rtx as = find_costliest_move (worklist_moves);
  /* AS will never be NULL_RTX, if we had no worklist_moves, we
     wouldn't have called coalesce.  */
  unsigned int lhs = get_alias (REGNO (SET_DEST (PATTERN (as))));
  unsigned int rhs = get_alias (REGNO (SET_SRC (PATTERN (as))));

  /* If the right hand side is precolored, swap the sides.  */
  if (REGNO_REG_SET_P (precolored, rhs))
    {
      unsigned int temp;
      temp = lhs;
      lhs = rhs;
      rhs = temp;
    }

  /* Remove it from the worklist, since we are processing it now.  */
  hset_remove (worklist_moves, as);
  if (lhs == rhs)
    {
      /* Really the same node.  */
      hset_insert (coalesced_moves, as);
      add_worklist (lhs);
    }
  else
    {
      /* It's constrained if it's precolored, or they interefere.  */
      if (REGNO_REG_SET_P (precolored, rhs)
	  || REGNO_REG_SET_P (ra_reg_info[rhs]->adj_list, lhs))
	{
	  if (rtl_dump_file != NULL && debug_new_regalloc > 1)
	    fprintf (rtl_dump_file, "Move from %d to %d is constrained\n", lhs, rhs);

	  /* If they interfere, can't coalesce.  */
	  hset_insert (constrained_moves, as);
	  add_worklist (lhs);
	  add_worklist (rhs);
	}
      /* Otherwise, check the heuristics, and DTRT.  */
      else
	{
	  /* We are going to compute the adjacent sets on the fly, so
	     we don't do it here.  */
	  if ((conservative (lhs, rhs) && ! REGNO_REG_SET_P (precolored, lhs))
	      || (REGNO_REG_SET_P (precolored, lhs) && precolored_OK (rhs, lhs)))
	    {
	      /* Coalesce lhs and rhs conservatively.  */
	      hset_insert (coalesced_moves, as);
	      combine (lhs, rhs);
	      add_worklist (lhs);
	    }
	  else
	    {
	      /* Can't safely coalesce (yet) */
	      hset_insert (active_moves, as);
	    }
	}
    }
}

/* Freeze the moves involving the register reg_num.  */
static void
freeze_moves (reg_num)
     unsigned int reg_num;
{
  hset moves = node_moves (reg_num);
  unsigned int i;
  void *entry;

  HSET_TRAVERSAL (moves, i, entry,
    {
      unsigned int v;
      rtx as = (rtx) entry;
      hset nodemoves;

      if (hset_member (active_moves, (void *)as))
	hset_remove (active_moves, (void *)as);
      else
	hset_remove (worklist_moves, (void *)as);
      hset_insert (frozen_moves, (void *)as);

      v = REGNO (SET_SRC (PATTERN (as)));
      if (v == reg_num)
	v = REGNO (SET_DEST (PATTERN (as)));

      nodemoves = node_moves (v);
      if (hset_empty (nodemoves)
	  && ra_reg_info[v]->degree < reg_freedom (v))
	{
	  CLEAR_REGNO_REG_SET (freeze_worklist, v);
	  SET_REGNO_REG_SET (simplify_worklist, v);
	}
      hset_delete (nodemoves);

      if (rtl_dump_file != NULL && debug_new_regalloc > 1)
	fprintf (rtl_dump_file, "chug...");
    });

  hset_delete (moves);
}

/* Freeze pass.  */
static void
freeze ()
{
  /* Pick a random element from the freeze worklist.  */
  unsigned int reg_num = regset_first_set_bit (freeze_worklist);

  /* And freeze it's moves.  */
  CLEAR_REGNO_REG_SET (freeze_worklist, reg_num);
  SET_REGNO_REG_SET (simplify_worklist, reg_num);
  freeze_moves (reg_num);
}

/* Heuristic to determine cheapest spill.  */
static float
default_heuristic (reg_num)
     unsigned int reg_num;
{
  /* FIXME: probably have a better heuristic.  */
  return (float) reg_spill_cost (reg_num) / (float) ra_reg_info[reg_num]->degree;
}

/* Select the cheapest spill.  We aren't necessarily spilling
   anything yet, but...  */
static void
select_spill ()
{
  /* FIXME: Without FLOAT_MAX, a node of degree 1 with a spill cost of
     UINT_MAX will not get picked.  What should I be doing here? */

  float min_cost = UINT_MAX;

  unsigned int min_node = 0;
  unsigned int entry;

  EXECUTE_IF_SET_IN_REG_SET (spill_worklist, 0, entry,
    {
      float h = (*spill_heuristic) (entry);
      if (h < min_cost)
	{
	  min_cost = h;
	  min_node = entry;
	}
    });

  if (rtl_dump_file != NULL && debug_new_regalloc > 1)
    fprintf (rtl_dump_file, "almost-spilling node %d\n", min_node);

  CLEAR_REGNO_REG_SET (spill_worklist, min_node);
  SET_REGNO_REG_SET (simplify_worklist, min_node);
  freeze_moves (min_node);
}

#define FIRST_HARD_REG_BIT_SET (SET, VAR)	\
  do {						\
    int i;					\
    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)	\
      if (TEST_HARD_REG_BIT (SET, i))		\
	{					\
	  VAR = i;				\
	  break;				\
	}					\
    if (i == FIRST_PSEUDO_REGISTER)		\
      VAR = -1;					\
  } while (0)

static int
x_okay_in_direction (okay, curr_reg, num_regs, mode)
     HARD_REG_SET okay;
     int curr_reg;
     int num_regs;
     enum machine_mode mode;
{
  int k;

  for (k = 1; k < num_regs; k++)
    {
      int regno = curr_reg + k;
      if (regno < 0
	  || ! TEST_HARD_REG_BIT (okay, regno)
	  || ! HARD_REGNO_MODE_OK (regno, mode))
	return 0;
    }
  return 1;
}

int
find_reg_given_constraints (okay, curr_reg)
     HARD_REG_SET okay;
     unsigned int curr_reg;
{
  int i;
  int pref_reg = -1;
  int alt_reg = -1;
  int pref_reg_order = INT_MAX;
  unsigned int num_regs = 0;
  enum machine_mode reg_mode = PSEUDO_REGNO_MODE (curr_reg);

  /* Watch as we attempt to handle the preference, and the number of hard
     registers needed for the pseudo, at the same time.  We find the most
     preferred reg that lets us allocate the right number of hard regs
     that are consecutive.

     FIXME: Just use a simple scoring, to get rid of this ugliness? Or
     maybe just ask the arch dependent code to tell us what it prefers?  */

  num_regs = 1;
  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
    {
      if (! TEST_HARD_REG_BIT (okay, i))
	continue;

      if (! HARD_REGNO_MODE_OK (i, reg_mode))
	continue;

      /* The number of hard regs required depends on the hard reg tested.  */
      num_regs = HARD_REGNO_NREGS (i, reg_mode);
      if (num_regs > 1
	  && ! x_okay_in_direction (okay, i, num_regs, reg_mode))
	continue;

      if (inv_reg_alloc_order[i] < pref_reg_order)
	{
	  pref_reg = i;
	  pref_reg_order = inv_reg_alloc_order[i];
	}
    }
  if (pref_reg == -1)
    return -1;

  /* Get right value for the preferred register.  */
  num_regs = HARD_REGNO_NREGS (pref_reg, reg_mode);
  alt_reg = pref_reg + (num_regs - 1);

  if (HARD_REGNO_MODE_OK (alt_reg, reg_mode))
    pref_reg = MIN (pref_reg, alt_reg);

  return pref_reg;
}

/* Assign registers by coloring the graph.  We handle both the preferred
   class, and the alternate class, at the same time.  If we can't place it
   in either, we assume we have to spill.  We could pretty easily handle all
   the constraints here by simply excluding registers in multiple classes
   that are currently used.  This would require the architecture dependent
   code having a routine to tell us "given these excluded registers, this
   register size, and this register, where can we put this?".

   However, I believe we can completely get rid of reload if we did this.  */
static void
assign_regs ()
{
  int first_ok_bit = -1;
  unsigned int entry;

  regset colored_nodes = BITMAP_XMALLOC ();
  HARD_REG_SET *excluded = xcalloc (max_reg_num (), sizeof (HARD_REG_SET));

  if (biased_coloring)
    costs = ggc_alloc_cleared (sizeof (double) * FIRST_PSEUDO_REGISTER);
  
  while (VARRAY_ACTIVE_SIZE (select_stack) != 0)
    {
      unsigned int curr_reg = VARRAY_TOP_UINT (select_stack);
      enum reg_class pref;
      HARD_REG_SET ok_colors, bad_colors, avoid;
      
      VARRAY_POP (select_stack);
      CLEAR_REGNO_REG_SET (select_nodes, curr_reg);
      
      /* Eliminate colors of neighbors. Also exclude all fixed
	 registers. */
      COPY_HARD_REG_SET (bad_colors, fixed_reg_set);
      EXECUTE_IF_SET_IN_BITMAP (ra_reg_info[curr_reg]->adj_list, 0, entry, 
      {
	unsigned int w = get_alias (entry);
	if (REGNO_REG_SET_P (colored_nodes, w) 
	    || REGNO_REG_SET_P (precolored, w))
	  {
	    int index = colors[w];
	    if (index >= 0)
	      {
		/* If one is a superset of the other, this should already
		   handle it, because we'll still clear the right bits.  */
		SET_HARD_REG_BIT (bad_colors, index);
		IOR_HARD_REG_SET (bad_colors, excluded[w]);
	      }
	  }
      });
      /* Biased coloring, not finished yet by a long shot */
      if (biased_coloring)
	{
	  unsigned int best_color;
	  double best_cost = -1.0;
	  unsigned int l;
	  void *move_node;
	  for (l = 0; l < FIRST_PSEUDO_REGISTER; l++)
	    costs[l] = 0.0;
	  CLEAR_HARD_REG_SET (avoid);
	  HSET_TRAVERSAL (ra_reg_info[curr_reg]->move_list, l, move_node, 
	  {
	    rtx copy = (rtx) move_node;
	    
	    if (hset_member (frozen_moves, (void *)copy))
	      {
		unsigned int source = get_alias (REGNO (SET_SRC (PATTERN (copy)))); 
		unsigned int dest = get_alias (REGNO (SET_DEST (PATTERN (copy))));
		unsigned int partner = curr_reg == source ? dest : source;
		unsigned int color = colors[partner];
		if (0 < color && color < FIRST_PSEUDO_REGISTER)
		  costs[color] += find_move_cost (copy);
		else if (! REGNO_REG_SET_P (spilled_nodes, partner))
		  {
		    unsigned int m;
		    EXECUTE_IF_SET_IN_REG_SET (ra_reg_info[partner]->adj_list, 0, m,
		    {
		      unsigned int neighbor = get_alias (m);
		      unsigned int color = colors[neighbor];
		      if (0 < color && color < FIRST_PSEUDO_REGISTER)
			SET_HARD_REG_BIT (avoid, color);
		    });
		  }
	      }
	  });
	  for (l = 0; l < FIRST_PSEUDO_REGISTER; l++)
	    if (TEST_HARD_REG_BIT (ok_colors, l) && costs[l] > best_cost)
	      {
		best_cost = costs[l];
		best_color = l;
	      }
	  for (l = 0; l <FIRST_PSEUDO_REGISTER; l++)
	    if (TEST_HARD_REG_BIT (ok_colors, l) 
		&& costs[l] == best_cost && ! TEST_HARD_REG_BIT (avoid, l))
	      {
		best_color = l;
		break;
	      }
	  colors[curr_reg] = best_color;
	  reg_renumber[curr_reg] = best_color;
	  if (rtl_dump_file != NULL && debug_new_regalloc > 0)
	    fprintf (rtl_dump_file, "Color of register %d is %d\n",
		     curr_reg, colors[curr_reg]);
	}
      else
	{
	  /* Non-biased coloring stuff. */
	  
	  /* First try the preferred register class. */
	  pref = reg_preferred_class (curr_reg);
	  COPY_HARD_REG_SET (ok_colors, reg_class_contents[pref]);
	  AND_COMPL_HARD_REG_SET (ok_colors, bad_colors);
	  first_ok_bit = find_reg_given_constraints (ok_colors, curr_reg);
	  /* If that fails, try the alternate register class, if
	     any. */
	  
	  if (first_ok_bit == -1
	      && (pref = reg_alternate_class (curr_reg)) != NO_REGS)
	    {
	      COPY_HARD_REG_SET (ok_colors, reg_class_contents[pref]);
	      AND_COMPL_HARD_REG_SET (ok_colors, bad_colors);
	      first_ok_bit = find_reg_given_constraints (ok_colors, curr_reg);
	    }

	  if (first_ok_bit == -1)
	    {
	      /* Couldn't find a color to set -- guess we have to spill.  */
	      SET_REGNO_REG_SET (spilled_nodes, curr_reg);
	      if (rtl_dump_file != NULL && debug_new_regalloc > 0)
		fprintf (rtl_dump_file, "Spilling register %d\n", curr_reg);
	      reg_renumber[curr_reg] = -1;
	    }
	  else
	    {
	      /* We can color it. Yay!  */
	      int num_regs;
	      int k;
	      
	      SET_REGNO_REG_SET (colored_nodes, curr_reg);
	      colors[curr_reg] = first_ok_bit;
	      num_regs = HARD_REGNO_NREGS (first_ok_bit, PSEUDO_REGNO_MODE (curr_reg));
	      
	      /* Exclude the other regs this color is also using, from
		 being used by this node's neighbors.  */
	      for (k = 1; k < num_regs; k++)
		SET_HARD_REG_BIT (excluded[curr_reg], colors[curr_reg] + k);
	      
	      if (rtl_dump_file != NULL && debug_new_regalloc > 0)
		fprintf (rtl_dump_file, "Color of register %d is %d\n",
			 curr_reg, colors[curr_reg]);
	    }
	}
    }
  

  /* Now take care of coalesced variables.  */
  EXECUTE_IF_SET_IN_REG_SET (coalesced_nodes, 0, entry,
    {
      unsigned int v1 = entry;
      unsigned int v2 = get_alias (v1);

      /* XXX: Why does reload bitch if we do this?
      df_reg_replace (df_analyzer, 0,
		      DF_REF_REG (DF_REGNO_LAST_USE (df_analyzer, v1)),
		      DF_REF_REG (DF_REGNO_LAST_USE (df_analyzer,
						     colors[v2])));
      df_analyse (df_analyzer, 0, DF_ALL);
      */

      if (rtl_dump_file != NULL && debug_new_regalloc > 0)
	fprintf (rtl_dump_file,
		 "Setting color of register %d to %d due to coalescing\n",
		 v1, colors[v2]);
      colors[v1] = colors[v2];
    });
  FREE_REG_SET (colored_nodes);
  free (excluded);
}

static void
rewrite_program (call_reload)
     int call_reload;
{
  unsigned int i, max = max_reg_num ();
  void *entry;

  for (i = 0; i < max; i++)
    reg_renumber[i] = colors[i];

  HSET_TRAVERSAL (coalesced_moves, i, entry,
    {
      rtx insn = (rtx) entry;

      /* XXX: Why does reload seem to turn this into a spill?  */
      df_insn_delete (df_analyzer, BLOCK_FOR_INSN (insn), insn);
    });

  build_insn_chain (get_insns ());
  if (call_reload)
    reload (get_insns (), 1);
}

/* Perform iterated register coalescing.  */
void
perform_new_regalloc ()
{
  /* simplify-coalesce-freeze-spill loop */
  while (1)
    {
      if (regset_first_set_bit (simplify_worklist) != -1)
	{
	  if (rtl_dump_file != NULL && debug_new_regalloc > 0)
	    fprintf (rtl_dump_file, "simplifying\n");
	  simplify ();
	}
      else if (! hset_empty (worklist_moves))
	{
	  if (rtl_dump_file != NULL && debug_new_regalloc > 0)
	    fprintf (rtl_dump_file, "coalescing\n");
	  coalesce ();
	}
      else if (regset_first_set_bit (freeze_worklist) != -1)
	{
	  if (rtl_dump_file != NULL && debug_new_regalloc > 0)
	    fprintf (rtl_dump_file, "freezing\n");
	  freeze ();
	}
      else if (regset_first_set_bit (spill_worklist) != -1)
	{
	  if (rtl_dump_file != NULL && debug_new_regalloc > 0)
	    fprintf (rtl_dump_file, "spilling\n");
	  select_spill ();
	}
      else
	{
	  if (rtl_dump_file != NULL && debug_new_regalloc > 0)
	    fprintf (rtl_dump_file, "done\n");
	  break;
	}
    }

  /* Now assign the registers (color the graph).  */
  assign_regs ();

  /* If we spilled */
  if (regset_first_set_bit (spilled_nodes) != -1)
    {
      /* FIXME: Insert spill code insertion here.  */
      rewrite_program (1);
      ggc_collect ();
      /* FIXME: Then iterate */
      /*
	  finish_new_regalloc ();
	  init_new_regalloc ();
      */
    }
  else
    rewrite_program (1);
}

/* Perform register allocation.  */
void
perform_new_regalloc_init ()
{
  int i;
  regset initial;
  regset move_candidates;

  initial = BITMAP_XMALLOC ();
  CLEAR_REG_SET (initial);

  /* Do dataflow analysis on all blocks.  */
  df_analyse (df_analyzer, 0, DF_ALL | DF_HARD_REGS);

  /* Place register candidates into initial, and setup interference
     graph nodes for them.  */
  for (i=0; i < max_reg_num (); i++)
    {
      if ((HARD_REGISTER_NUM_P (i) && is_reg_candidate (i)) 
	  || (HARD_REGISTER_NUM_P (i) && (DF_REGNO_LAST_USE (df_analyzer, i) != 0))
	  || (HARD_REGISTER_NUM_P (i) && fixed_regs[i]))
	{
	  ra_reg_info[i] = ig_node_new ();
	  ra_reg_info[i]->degree = INT_MAX;
	  colors[i] = i;
	  SET_REGNO_REG_SET (precolored, i);
	  if (rtl_dump_file != NULL && debug_new_regalloc > 1)
	    fprintf (rtl_dump_file, "Inserting precolored node for hard reg %d\n", i);
	}
      else if (is_reg_candidate (i))
	{
	  if (rtl_dump_file != NULL && debug_new_regalloc > 1)
	    fprintf (rtl_dump_file, "Inserting new candidate %d\n", i);
	  SET_REGNO_REG_SET (initial, i);
	  ra_reg_info[i] = ig_node_new ();
	}
    }
  if (rtl_dump_file != NULL && debug_new_regalloc > 0)
    {
      fprintf (rtl_dump_file, "Initial set:");
      dump_regset (initial, rtl_dump_file);
      fprintf (rtl_dump_file, "\n");
      fprintf (rtl_dump_file, "Precolored set:");
      dump_regset (precolored, rtl_dump_file);
      fprintf (rtl_dump_file, "\n");
      
    }

  move_candidates = BITMAP_XMALLOC ();
  
  IOR_REG_SET (move_candidates, precolored);

  /* Process all the basic blocks.  */
  for (i = 0; i < n_basic_blocks; i++)
    {
      basic_block currblock = BASIC_BLOCK (i);
      rtx currinsn;
      sbitmap live;
      int j;

      live = sbitmap_alloc (max_reg_num ());
      sbitmap_zero (live);

      /* Find all move statements in this block.  */
      currinsn = currblock->head;
      while (1)
	{
	  if (is_candidate_move (currinsn, move_candidates))
	    {
	      if (rtl_dump_file != NULL && debug_new_regalloc > 1)
		{
		  fprintf (rtl_dump_file, "Inserting new move candidate:");
		  print_rtl (rtl_dump_file, PATTERN (currinsn));
		  fprintf (rtl_dump_file, "\n");
		}
	      add_move (REGNO (SET_DEST (PATTERN (currinsn))), currinsn);
	      add_move (REGNO (SET_SRC (PATTERN (currinsn))), currinsn);
	      hset_insert (worklist_moves, currinsn);
	    }
	  if (currinsn == currblock->end)
	    break;
	  currinsn = NEXT_INSN (currinsn);
	}

      /* Was lr_def.  */
      sbitmap_a_or_b (live, live,
		      DF_BB_INFO (df_analyzer, currblock)->lr_out);

      /* Work backwards through instructions.  */
      currinsn = currblock->end;
      while (1)
	{
	  if (INSN_P (currinsn))
	    {
	      struct df_link *currdef;
	      struct df_link *curruse;

	      currdef = DF_INSN_DEFS (df_analyzer, currinsn);
	      for (; currdef; currdef = currdef->next)
		EXECUTE_IF_SET_IN_SBITMAP (live, 0, j,
		  {
		    if (rtl_dump_file != NULL && debug_new_regalloc > 1)
		      fprintf (rtl_dump_file, "Inserting edge from %d to %d\n",
			       DF_REF_REGNO (currdef->ref), j);

		    add_edge (DF_REF_REGNO (currdef->ref), j);
		  });

	      currdef = DF_INSN_DEFS (df_analyzer, currinsn);
	      for (; currdef; currdef = currdef->next)
		RESET_BIT (live, DF_REF_REGNO (currdef->ref));

	      curruse = DF_INSN_USES (df_analyzer, currinsn);
	      for (; curruse; curruse = curruse->next)
		SET_BIT (live, DF_REF_REGNO (curruse->ref));
	    }
	  if (currinsn == currblock->head)
	    break;
	  currinsn = PREV_INSN (currinsn);
	}
    }

  /* XXX: We could add a macro that can be defined to let architectures add
     extra interference edges if necessary for very weird constraints.  It's
     really no skin off our back, or theirs. */
  make_worklist (initial);
  FREE_REG_SET (move_candidates);
  FREE_REG_SET (initial);

  compute_bb_for_insn (get_max_uid ());
}

/* Initialize and call the new register allocator.  */
void
init_new_regalloc ()
{
  int i, max_reg = max_reg_num ();
  
  /* Initialize our variables.  */
  spill_heuristic = default_heuristic;
  
  precolored = BITMAP_XMALLOC ();
  CLEAR_REG_SET (precolored);

  simplify_worklist = BITMAP_XMALLOC ();
  CLEAR_REG_SET (simplify_worklist);

  freeze_worklist = BITMAP_XMALLOC ();
  CLEAR_REG_SET (freeze_worklist);

  spill_worklist = BITMAP_XMALLOC ();
  CLEAR_REG_SET (spill_worklist);

  spilled_nodes = BITMAP_XMALLOC ();
  CLEAR_REG_SET (spilled_nodes);

  coalesced_nodes = BITMAP_XMALLOC ();
  CLEAR_REG_SET (coalesced_nodes);

  coalesced_moves = hset_new ();
  constrained_moves = hset_new ();
  frozen_moves = hset_new ();
  worklist_moves = hset_new ();
  active_moves = hset_new ();

  ra_reg_info = ggc_alloc_cleared (sizeof (ig_node) * max_reg);
  reg_freedoms = ggc_alloc_cleared (sizeof (int) * max_reg);
  colors = ggc_alloc (sizeof (int) * max_reg);
  for (i = 0; i < max_reg; i++)
    {
      colors[i] = -1;
      reg_freedoms[i] = -1;
    }

  select_nodes = BITMAP_XMALLOC ();
  CLEAR_REG_SET (select_nodes);
  VARRAY_UINT_INIT (select_stack, 1, "Interference graph stack");
  df_analyzer = df_init ();
  allocate_reg_info (max_reg, FALSE, TRUE);
  update_equiv_regs ();

  perform_new_regalloc_init ();
  perform_new_regalloc ();

  finish_new_regalloc ();
}

/* Clean up after the new allocator */
void
finish_new_regalloc ()
{
  int i;
  for (i=0; i < max_reg_num (); i++)
    if (ra_reg_info[i] != 0)
      ig_node_delete (ra_reg_info[i]);
 
  /* Cleanup after ourselves */
   
  FREE_REG_SET (simplify_worklist);
  FREE_REG_SET (freeze_worklist);
  FREE_REG_SET (spill_worklist);
  FREE_REG_SET (spilled_nodes);
  FREE_REG_SET (coalesced_nodes);
  FREE_REG_SET (select_nodes);
  hset_free (coalesced_moves);
  hset_free (constrained_moves);
  hset_free (frozen_moves);
  hset_free (worklist_moves);
  hset_free (active_moves);
  VARRAY_FREE (select_stack);
  df_finish (df_analyzer);
}
