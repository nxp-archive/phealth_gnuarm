#line 29 "x86-64.float.py"
lhsd : REGX_DF [0, 0]
#line 36 "x86-64.float.py"
  names {
    $$->spilled = false;
  },
  kinds {
    icg_reg_vector[$$->r].kind = FLOAT_REGISTER;
  },
  costs {
    cost_store($$->r);
  },
  spill {
    dirty |= make_spill_code(find($$->r), $$);
  },
  final {
    $$->r = icg_reg_vector[find($$->r)].color;
  };
#line 30 "x86-64.float.py"
lhsf : REGX_SF [0, 0]
#line 36 "x86-64.float.py"
  names {
    $$->spilled = false;
  },
  kinds {
    icg_reg_vector[$$->r].kind = FLOAT_REGISTER;
  },
  costs {
    cost_store($$->r);
  },
  spill {
    dirty |= make_spill_code(find($$->r), $$);
  },
  final {
    $$->r = icg_reg_vector[find($$->r)].color;
  };
#line 31 "x86-64.float.py"
lhsd : REG_DF [0, 0]
#line 36 "x86-64.float.py"
  names {
    $$->spilled = false;
  },
  kinds {
    icg_reg_vector[$$->r].kind = FLOAT_REGISTER;
  },
  costs {
    cost_store($$->r);
  },
  spill {
    dirty |= make_spill_code(find($$->r), $$);
  },
  final {
    $$->r = icg_reg_vector[find($$->r)].color;
  };
#line 32 "x86-64.float.py"
lhsf : REG_SF [0, 0]
#line 36 "x86-64.float.py"
  names {
    $$->spilled = false;
  },
  kinds {
    icg_reg_vector[$$->r].kind = FLOAT_REGISTER;
  },
  costs {
    cost_store($$->r);
  },
  spill {
    dirty |= make_spill_code(find($$->r), $$);
  },
  final {
    $$->r = icg_reg_vector[find($$->r)].color;
  };
#line 59 "x86-64.float.py"
lhsd : MEM_DF(addr) [0, 0]
#line 64 "x86-64.float.py"
  names {
    $$->spilled  = true;
    $$->a.base   = $1->a.base;
    $$->a.base_valid = $1->a.base_valid;
    $$->a.index  = $1->a.index;
    $$->a.scale  = $1->a.scale;
    $$->a.disp   = $1->a.disp;
    $$->a.string = $1->a.string;
  },
  emit {
    $$->rtl = $1->rtl;
  };
#line 60 "x86-64.float.py"
lhsf : MEM_SF(addr) [0, 0]
#line 64 "x86-64.float.py"
  names {
    $$->spilled  = true;
    $$->a.base   = $1->a.base;
    $$->a.base_valid = $1->a.base_valid;
    $$->a.index  = $1->a.index;
    $$->a.scale  = $1->a.scale;
    $$->a.disp   = $1->a.disp;
    $$->a.string = $1->a.string;
  },
  emit {
    $$->rtl = $1->rtl;
  };
#line 86 "x86-64.float.py"
stmt : SET_ALL(lhsd, rd) [0, 0]
#line 91 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  coalesce {
    if (!$1->spilled)
      coalesces += attempt_coalesce(pass, $1->r, $2->r);
  },
  build {
    if ($1->spilled) {
      sparseset_set_bit(live, find($2->r));
      add_addr(live, $1);
    }
    else
      add_copy_edges($1->r, $2->r, live);
  },
  remat {
    flags = 0;
  },
  costs {
    if (!$1->spilled)
      cost_copy($2->r, $1->r);
  },
  debug {
    if ($1->spilled)
      dumpRM("movsd", $2->r, 'x', $1);
    else
      dump_copy("movsd", $2->r, $1->r, 'x');
  },
  emit {
    rtx src = gen_rtx_REG(DFmode, $2->r);
    rtx dst = $1->spilled ? gen_rtx_MEM(DFmode, $1->rtl) : gen_rtx_REG(DFmode, $1->r);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 87 "x86-64.float.py"
stmt : SET_ALL(lhsf, rf) [0, 0]
#line 91 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  coalesce {
    if (!$1->spilled)
      coalesces += attempt_coalesce(pass, $1->r, $2->r);
  },
  build {
    if ($1->spilled) {
      sparseset_set_bit(live, find($2->r));
      add_addr(live, $1);
    }
    else
      add_copy_edges($1->r, $2->r, live);
  },
  remat {
    flags = 0;
  },
  costs {
    if (!$1->spilled)
      cost_copy($2->r, $1->r);
  },
  debug {
    if ($1->spilled)
      dumpRM("movss", $2->r, 'x', $1);
    else
      dump_copy("movss", $2->r, $1->r, 'x');
  },
  emit {
    rtx src = gen_rtx_REG(SFmode, $2->r);
    rtx dst = $1->spilled ? gen_rtx_MEM(SFmode, $1->rtl) : gen_rtx_REG(SFmode, $1->r);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 133 "x86-64.float.py"
rd   : REG_DF [0, 0]
#line 140 "x86-64.float.py"
  kinds {
    icg_reg_vector[$$->r].kind = FLOAT_REGISTER;
  },
  costs {
    cost_load($$->r);
  },
  supairs {
    $$->extra = 0;	/* TODO? only for rdx: rules */
    $$->freed = 0;	/* TODO? only for rdx: rules */
  },
  spill {
    dirty |= make_spill_code(find($$->r), $$);
  },
  final {
    $$->r = icg_reg_vector[find($$->r)].color;
  };
#line 134 "x86-64.float.py"
rf   : REG_SF [0, 0]
#line 140 "x86-64.float.py"
  kinds {
    icg_reg_vector[$$->r].kind = FLOAT_REGISTER;
  },
  costs {
    cost_load($$->r);
  },
  supairs {
    $$->extra = 0;	/* TODO? only for rdx: rules */
    $$->freed = 0;	/* TODO? only for rdx: rules */
  },
  spill {
    dirty |= make_spill_code(find($$->r), $$);
  },
  final {
    $$->r = icg_reg_vector[find($$->r)].color;
  };
#line 135 "x86-64.float.py"
rdx  : REGX_DF [0, 0]
#line 140 "x86-64.float.py"
  kinds {
    icg_reg_vector[$$->rx].kind = FLOAT_REGISTER;
  },
  costs {
    cost_load($$->rx);
  },
  supairs {
    $$->extra = 0;	/* TODO? only for rdx: rules */
    $$->freed = 0;	/* TODO? only for rdx: rules */
  },
  spill {
    dirty |= make_spill_code(find($$->rx), $$);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  };
#line 136 "x86-64.float.py"
rfx  : REGX_SF [0, 0]
#line 140 "x86-64.float.py"
  kinds {
    icg_reg_vector[$$->rx].kind = FLOAT_REGISTER;
  },
  costs {
    cost_load($$->rx);
  },
  supairs {
    $$->extra = 0;	/* TODO? only for rdx: rules */
    $$->freed = 0;	/* TODO? only for rdx: rules */
  },
  spill {
    dirty |= make_spill_code(find($$->rx), $$);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  };
#line 162 "x86-64.float.py"
rd : rdx [0, 0]
#line 167 "x86-64.float.py"
  supairs {
    $$->freed++; /* assuming that the register will eventually be freed */
  },
  names {
    $$->r = $1->rx;
  },
  final {
    $$->r = $1->rx;
  };
#line 163 "x86-64.float.py"
rf : rfx [0, 0]
#line 167 "x86-64.float.py"
  supairs {
    $$->freed++; /* assuming that the register will eventually be freed */
  },
  names {
    $$->r = $1->rx;
  },
  final {
    $$->r = $1->rx;
  };
#line 185 "x86-64.float.py"
rdx : rd [2, 4]
#line 190 "x86-64.float.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = FLOAT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $$->rx, $1->r);
  },
  build {
    add_copy_edges($$->rx, $1->r, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($$->rx, $1->r);
  },
  debug {
    dump_copy("movapd", $1->r, $$->rx, 'x');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    const rtx src = gen_rtx_REG(DFmode, $1->r);
    const rtx dst = gen_rtx_REG(DFmode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 186 "x86-64.float.py"
rfx : rf [2, 4]
#line 190 "x86-64.float.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = FLOAT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $$->rx, $1->r);
  },
  build {
    add_copy_edges($$->rx, $1->r, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($$->rx, $1->r);
  },
  debug {
    dump_copy("movaps", $1->r, $$->rx, 'x');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    const rtx src = gen_rtx_REG(SFmode, $1->r);
    const rtx dst = gen_rtx_REG(SFmode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 236 "x86-64.float.py"
rdx  : MEM_DF(addr) [3, 2]
#line 241 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = FLOAT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movsd", $1, $$->rx, 'x');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = gen_rtx_MEM(DFmode, $1->rtl);
    rtx dst = gen_rtx_REG(DFmode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 237 "x86-64.float.py"
rfx  : MEM_SF(addr) [3, 2]
#line 241 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = FLOAT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movss", $1, $$->rx, 'x');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = gen_rtx_MEM(SFmode, $1->rtl);
    rtx dst = gen_rtx_REG(SFmode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 292 "x86-64.float.py"
r64x  : FIX_DI(rd) [1, 1]
#line 314 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    /* NYI */
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    if (1) {
      sparseset_set_bit(live, find($1->r));	/* r, not rx, as rhs is rd */
    }
    else add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1) {
      memorable($1->r);
    }
  },
  debug {
    if (1) {
      dumpRR("cvttsd2siq", $1->r, 'x', $$->rx, 'q');
    } else {
      dumpMR("cvttsd2siq", $1, $$->rx, 'q');
    }
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = 1
       ? gen_rtx_REG(DFmode, $1->r)
       : gen_rtx_MEM(DFmode, $1->rtl);
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, gen_rtx_FIX(DImode, src)));
  };
#line 293 "x86-64.float.py"
r32x  : FIX_SI(rd) [1, 1]
#line 314 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    /* NYI */
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    if (1) {
      sparseset_set_bit(live, find($1->r));	/* r, not rx, as rhs is rd */
    }
    else add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1) {
      memorable($1->r);
    }
  },
  debug {
    if (1) {
      dumpRR("cvttsd2siq", $1->r, 'x', $$->rx, 'q');
    } else {
      dumpMR("cvttsd2siq", $1, $$->rx, 'q');
    }
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = 1
       ? gen_rtx_REG(DFmode, $1->r)
       : gen_rtx_MEM(DFmode, $1->rtl);
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, gen_rtx_FIX(SImode, src)));
  };
#line 294 "x86-64.float.py"
r16x  : FIX_HI(rd) [1, 1]
#line 314 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    /* NYI */
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    if (1) {
      sparseset_set_bit(live, find($1->r));	/* r, not rx, as rhs is rd */
    }
    else add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1) {
      memorable($1->r);
    }
  },
  debug {
    if (1) {
      dumpRR("cvttsd2siq", $1->r, 'x', $$->rx, 'q');
    } else {
      dumpMR("cvttsd2siq", $1, $$->rx, 'q');
    }
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = 1
       ? gen_rtx_REG(DFmode, $1->r)
       : gen_rtx_MEM(DFmode, $1->rtl);
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, gen_rtx_FIX(HImode, src)));
  };
#line 295 "x86-64.float.py"
r8x   : FIX_QI(rd) [1, 1]
#line 314 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    /* NYI */
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    if (1) {
      sparseset_set_bit(live, find($1->r));	/* r, not rx, as rhs is rd */
    }
    else add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1) {
      memorable($1->r);
    }
  },
  debug {
    if (1) {
      dumpRR("cvttsd2siq", $1->r, 'x', $$->rx, 'q');
    } else {
      dumpMR("cvttsd2siq", $1, $$->rx, 'q');
    }
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = 1
       ? gen_rtx_REG(DFmode, $1->r)
       : gen_rtx_MEM(DFmode, $1->rtl);
    rtx dst = gen_rtx_REG(QImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, gen_rtx_FIX(QImode, src)));
  };
#line 297 "x86-64.float.py"
r64x  : FIX_DI(rf) [1, 1]
#line 314 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    /* NYI */
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    if (1) {
      sparseset_set_bit(live, find($1->r));	/* r, not rx, as rhs is rd */
    }
    else add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1) {
      memorable($1->r);
    }
  },
  debug {
    if (1) {
      dumpRR("cvttsd2siq", $1->r, 'x', $$->rx, 'q');
    } else {
      dumpMR("cvttsd2siq", $1, $$->rx, 'q');
    }
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = 1
       ? gen_rtx_REG(SFmode, $1->r)
       : gen_rtx_MEM(SFmode, $1->rtl);
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, gen_rtx_FIX(DImode, src)));
  };
#line 298 "x86-64.float.py"
r32x  : FIX_SI(rf) [1, 1]
#line 314 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    /* NYI */
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    if (1) {
      sparseset_set_bit(live, find($1->r));	/* r, not rx, as rhs is rd */
    }
    else add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1) {
      memorable($1->r);
    }
  },
  debug {
    if (1) {
      dumpRR("cvttsd2siq", $1->r, 'x', $$->rx, 'q');
    } else {
      dumpMR("cvttsd2siq", $1, $$->rx, 'q');
    }
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = 1
       ? gen_rtx_REG(SFmode, $1->r)
       : gen_rtx_MEM(SFmode, $1->rtl);
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, gen_rtx_FIX(SImode, src)));
  };
#line 299 "x86-64.float.py"
r16x  : FIX_HI(rf) [1, 1]
#line 314 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    /* NYI */
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    if (1) {
      sparseset_set_bit(live, find($1->r));	/* r, not rx, as rhs is rd */
    }
    else add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1) {
      memorable($1->r);
    }
  },
  debug {
    if (1) {
      dumpRR("cvttsd2siq", $1->r, 'x', $$->rx, 'q');
    } else {
      dumpMR("cvttsd2siq", $1, $$->rx, 'q');
    }
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = 1
       ? gen_rtx_REG(SFmode, $1->r)
       : gen_rtx_MEM(SFmode, $1->rtl);
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, gen_rtx_FIX(HImode, src)));
  };
#line 300 "x86-64.float.py"
r8x   : FIX_QI(rf) [1, 1]
#line 314 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    /* NYI */
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    if (1) {
      sparseset_set_bit(live, find($1->r));	/* r, not rx, as rhs is rd */
    }
    else add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1) {
      memorable($1->r);
    }
  },
  debug {
    if (1) {
      dumpRR("cvttsd2siq", $1->r, 'x', $$->rx, 'q');
    } else {
      dumpMR("cvttsd2siq", $1, $$->rx, 'q');
    }
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = 1
       ? gen_rtx_REG(SFmode, $1->r)
       : gen_rtx_MEM(SFmode, $1->rtl);
    rtx dst = gen_rtx_REG(QImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, gen_rtx_FIX(QImode, src)));
  };
#line 302 "x86-64.float.py"
r64x  : FIX_DI(MEM_DF(addr)) [1, 1]
#line 314 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    /* NYI */
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    if (0) {
      sparseset_set_bit(live, find($1->r));	/* r, not rx, as rhs is rd */
    }
    else add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0) {
      memorable($1->r);
    }
  },
  debug {
    if (0) {
      dumpRR("cvttsd2siq", $1->r, 'x', $$->rx, 'q');
    } else {
      dumpMR("cvttsd2siq", $1, $$->rx, 'q');
    }
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = 0
       ? gen_rtx_REG(DFmode, $1->r)
       : gen_rtx_MEM(DFmode, $1->rtl);
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, gen_rtx_FIX(DImode, src)));
  };
#line 303 "x86-64.float.py"
r32x  : FIX_SI(MEM_DF(addr)) [1, 1]
#line 314 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    /* NYI */
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    if (0) {
      sparseset_set_bit(live, find($1->r));	/* r, not rx, as rhs is rd */
    }
    else add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0) {
      memorable($1->r);
    }
  },
  debug {
    if (0) {
      dumpRR("cvttsd2siq", $1->r, 'x', $$->rx, 'q');
    } else {
      dumpMR("cvttsd2siq", $1, $$->rx, 'q');
    }
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = 0
       ? gen_rtx_REG(DFmode, $1->r)
       : gen_rtx_MEM(DFmode, $1->rtl);
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, gen_rtx_FIX(SImode, src)));
  };
#line 304 "x86-64.float.py"
r16x  : FIX_HI(MEM_DF(addr)) [1, 1]
#line 314 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    /* NYI */
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    if (0) {
      sparseset_set_bit(live, find($1->r));	/* r, not rx, as rhs is rd */
    }
    else add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0) {
      memorable($1->r);
    }
  },
  debug {
    if (0) {
      dumpRR("cvttsd2siq", $1->r, 'x', $$->rx, 'q');
    } else {
      dumpMR("cvttsd2siq", $1, $$->rx, 'q');
    }
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = 0
       ? gen_rtx_REG(DFmode, $1->r)
       : gen_rtx_MEM(DFmode, $1->rtl);
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, gen_rtx_FIX(HImode, src)));
  };
#line 305 "x86-64.float.py"
r8x   : FIX_QI(MEM_DF(addr)) [1, 1]
#line 314 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    /* NYI */
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    if (0) {
      sparseset_set_bit(live, find($1->r));	/* r, not rx, as rhs is rd */
    }
    else add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0) {
      memorable($1->r);
    }
  },
  debug {
    if (0) {
      dumpRR("cvttsd2siq", $1->r, 'x', $$->rx, 'q');
    } else {
      dumpMR("cvttsd2siq", $1, $$->rx, 'q');
    }
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = 0
       ? gen_rtx_REG(DFmode, $1->r)
       : gen_rtx_MEM(DFmode, $1->rtl);
    rtx dst = gen_rtx_REG(QImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, gen_rtx_FIX(QImode, src)));
  };
#line 307 "x86-64.float.py"
r64x  : FIX_DI(MEM_SF(addr)) [1, 1]
#line 314 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    /* NYI */
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    if (0) {
      sparseset_set_bit(live, find($1->r));	/* r, not rx, as rhs is rd */
    }
    else add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0) {
      memorable($1->r);
    }
  },
  debug {
    if (0) {
      dumpRR("cvttsd2siq", $1->r, 'x', $$->rx, 'q');
    } else {
      dumpMR("cvttsd2siq", $1, $$->rx, 'q');
    }
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = 0
       ? gen_rtx_REG(SFmode, $1->r)
       : gen_rtx_MEM(SFmode, $1->rtl);
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, gen_rtx_FIX(DImode, src)));
  };
#line 308 "x86-64.float.py"
r32x  : FIX_SI(MEM_SF(addr)) [1, 1]
#line 314 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    /* NYI */
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    if (0) {
      sparseset_set_bit(live, find($1->r));	/* r, not rx, as rhs is rd */
    }
    else add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0) {
      memorable($1->r);
    }
  },
  debug {
    if (0) {
      dumpRR("cvttsd2siq", $1->r, 'x', $$->rx, 'q');
    } else {
      dumpMR("cvttsd2siq", $1, $$->rx, 'q');
    }
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = 0
       ? gen_rtx_REG(SFmode, $1->r)
       : gen_rtx_MEM(SFmode, $1->rtl);
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, gen_rtx_FIX(SImode, src)));
  };
#line 309 "x86-64.float.py"
r16x  : FIX_HI(MEM_SF(addr)) [1, 1]
#line 314 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    /* NYI */
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    if (0) {
      sparseset_set_bit(live, find($1->r));	/* r, not rx, as rhs is rd */
    }
    else add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0) {
      memorable($1->r);
    }
  },
  debug {
    if (0) {
      dumpRR("cvttsd2siq", $1->r, 'x', $$->rx, 'q');
    } else {
      dumpMR("cvttsd2siq", $1, $$->rx, 'q');
    }
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = 0
       ? gen_rtx_REG(SFmode, $1->r)
       : gen_rtx_MEM(SFmode, $1->rtl);
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, gen_rtx_FIX(HImode, src)));
  };
#line 310 "x86-64.float.py"
r8x   : FIX_QI(MEM_SF(addr)) [1, 1]
#line 314 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    /* NYI */
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    if (0) {
      sparseset_set_bit(live, find($1->r));	/* r, not rx, as rhs is rd */
    }
    else add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0) {
      memorable($1->r);
    }
  },
  debug {
    if (0) {
      dumpRR("cvttsd2siq", $1->r, 'x', $$->rx, 'q');
    } else {
      dumpMR("cvttsd2siq", $1, $$->rx, 'q');
    }
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = 0
       ? gen_rtx_REG(SFmode, $1->r)
       : gen_rtx_MEM(SFmode, $1->rtl);
    rtx dst = gen_rtx_REG(QImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, gen_rtx_FIX(QImode, src)));
  };
#line 370 "x86-64.float.py"
rfx : FLOAT_TRUNCATE_SF(rd) [1, 1]
#line 381 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = FLOAT_REGISTER;
  },
  supairs {
    /* NYI */
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    if (1) {
      sparseset_set_bit(live, find($1->r));	/* r, not rx, as rhs is rd */
    }
    else add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1) {
      memorable($1->r);
    }
  },
  debug {
    if (1) {
      dumpRR("cvtsd2ss", $1->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cvtsd2ss", $1, $$->rx, 'x');
    }
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = 1
      ? gen_rtx_REG(DFmode, $1->r)
      : gen_rtx_MEM(DFmode, $1->rtl);
    rtx dst = gen_rtx_REG(SFmode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, gen_rtx_FLOAT_TRUNCATE(SFmode, src)));
  };
#line 372 "x86-64.float.py"
rfx : FLOAT_TRUNCATE_SF(MEM_DF(addr)) [1, 1]
#line 381 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = FLOAT_REGISTER;
  },
  supairs {
    /* NYI */
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    if (0) {
      sparseset_set_bit(live, find($1->r));	/* r, not rx, as rhs is rd */
    }
    else add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0) {
      memorable($1->r);
    }
  },
  debug {
    if (0) {
      dumpRR("cvtsd2ss", $1->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cvtsd2ss", $1, $$->rx, 'x');
    }
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = 0
      ? gen_rtx_REG(DFmode, $1->r)
      : gen_rtx_MEM(DFmode, $1->rtl);
    rtx dst = gen_rtx_REG(SFmode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, gen_rtx_FLOAT_TRUNCATE(SFmode, src)));
  };
#line 374 "x86-64.float.py"
rdx : FLOAT_EXTEND_DF(rf) [1, 1]
#line 381 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = FLOAT_REGISTER;
  },
  supairs {
    /* NYI */
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    if (1) {
      sparseset_set_bit(live, find($1->r));	/* r, not rx, as rhs is rd */
    }
    else add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1) {
      memorable($1->r);
    }
  },
  debug {
    if (1) {
      dumpRR("cvtss2sd", $1->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cvtss2sd", $1, $$->rx, 'x');
    }
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = 1
      ? gen_rtx_REG(SFmode, $1->r)
      : gen_rtx_MEM(SFmode, $1->rtl);
    rtx dst = gen_rtx_REG(DFmode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, gen_rtx_FLOAT_EXTEND(DFmode, src)));
  };
#line 376 "x86-64.float.py"
rdx : FLOAT_EXTEND_DF(MEM_SF(addr)) [1, 1]
#line 381 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = FLOAT_REGISTER;
  },
  supairs {
    /* NYI */
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    if (0) {
      sparseset_set_bit(live, find($1->r));	/* r, not rx, as rhs is rd */
    }
    else add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0) {
      memorable($1->r);
    }
  },
  debug {
    if (0) {
      dumpRR("cvtss2sd", $1->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cvtss2sd", $1, $$->rx, 'x');
    }
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = 0
      ? gen_rtx_REG(SFmode, $1->r)
      : gen_rtx_MEM(SFmode, $1->rtl);
    rtx dst = gen_rtx_REG(DFmode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, gen_rtx_FLOAT_EXTEND(DFmode, src)));
  };
#line 432 "x86-64.float.py"
rdx : FLOAT_DF(r64) [1, 1]
#line 444 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = FLOAT_REGISTER;
  },
  supairs {
    /* NYI */
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    if (1) {
      sparseset_set_bit(live, find($1->r));	/* r, not rx, as rhs is r64 */
    }
    else add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1) {
      memorable($1->r);
    }
  },
  debug {
    if (1) {
      dumpRR("cvtsi2sdq", $1->r, 'q', $$->rx, 'x');
    } else {
      dumpMR("cvtsi2sdq", $1, $$->rx, 'x');
    }
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = 1
      ? gen_rtx_REG(DImode, $1->r)
      : gen_rtx_MEM(DImode, $1->rtl);
    rtx dst = gen_rtx_REG(DFmode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, gen_rtx_FLOAT(DFmode, src)));
  };
#line 433 "x86-64.float.py"
rdx : FLOAT_DF(MEM_DI(addr)) [1, 1]
#line 444 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = FLOAT_REGISTER;
  },
  supairs {
    /* NYI */
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    if (0) {
      sparseset_set_bit(live, find($1->r));	/* r, not rx, as rhs is r64 */
    }
    else add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0) {
      memorable($1->r);
    }
  },
  debug {
    if (0) {
      dumpRR("cvtsi2sdq", $1->r, 'q', $$->rx, 'x');
    } else {
      dumpMR("cvtsi2sdq", $1, $$->rx, 'x');
    }
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = 0
      ? gen_rtx_REG(DImode, $1->r)
      : gen_rtx_MEM(DImode, $1->rtl);
    rtx dst = gen_rtx_REG(DFmode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, gen_rtx_FLOAT(DFmode, src)));
  };
#line 434 "x86-64.float.py"
rfx : FLOAT_SF(r64) [1, 1]
#line 444 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = FLOAT_REGISTER;
  },
  supairs {
    /* NYI */
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    if (1) {
      sparseset_set_bit(live, find($1->r));	/* r, not rx, as rhs is r64 */
    }
    else add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1) {
      memorable($1->r);
    }
  },
  debug {
    if (1) {
      dumpRR("cvtsi2ssq", $1->r, 'q', $$->rx, 'x');
    } else {
      dumpMR("cvtsi2ssq", $1, $$->rx, 'x');
    }
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = 1
      ? gen_rtx_REG(DImode, $1->r)
      : gen_rtx_MEM(DImode, $1->rtl);
    rtx dst = gen_rtx_REG(SFmode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, gen_rtx_FLOAT(SFmode, src)));
  };
#line 435 "x86-64.float.py"
rfx : FLOAT_SF(MEM_DI(addr)) [1, 1]
#line 444 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = FLOAT_REGISTER;
  },
  supairs {
    /* NYI */
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    if (0) {
      sparseset_set_bit(live, find($1->r));	/* r, not rx, as rhs is r64 */
    }
    else add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0) {
      memorable($1->r);
    }
  },
  debug {
    if (0) {
      dumpRR("cvtsi2ssq", $1->r, 'q', $$->rx, 'x');
    } else {
      dumpMR("cvtsi2ssq", $1, $$->rx, 'x');
    }
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = 0
      ? gen_rtx_REG(DImode, $1->r)
      : gen_rtx_MEM(DImode, $1->rtl);
    rtx dst = gen_rtx_REG(SFmode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, gen_rtx_FLOAT(SFmode, src)));
  };
#line 437 "x86-64.float.py"
rdx : FLOAT_DF(r32) [1, 1]
#line 444 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = FLOAT_REGISTER;
  },
  supairs {
    /* NYI */
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    if (1) {
      sparseset_set_bit(live, find($1->r));	/* r, not rx, as rhs is r64 */
    }
    else add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1) {
      memorable($1->r);
    }
  },
  debug {
    if (1) {
      dumpRR("cvtsi2sdl", $1->r, 'q', $$->rx, 'x');
    } else {
      dumpMR("cvtsi2sdl", $1, $$->rx, 'x');
    }
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = 1
      ? gen_rtx_REG(SImode, $1->r)
      : gen_rtx_MEM(SImode, $1->rtl);
    rtx dst = gen_rtx_REG(DFmode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, gen_rtx_FLOAT(DFmode, src)));
  };
#line 438 "x86-64.float.py"
rdx : FLOAT_DF(MEM_SI(addr)) [1, 1]
#line 444 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = FLOAT_REGISTER;
  },
  supairs {
    /* NYI */
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    if (0) {
      sparseset_set_bit(live, find($1->r));	/* r, not rx, as rhs is r64 */
    }
    else add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0) {
      memorable($1->r);
    }
  },
  debug {
    if (0) {
      dumpRR("cvtsi2sdl", $1->r, 'q', $$->rx, 'x');
    } else {
      dumpMR("cvtsi2sdl", $1, $$->rx, 'x');
    }
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = 0
      ? gen_rtx_REG(SImode, $1->r)
      : gen_rtx_MEM(SImode, $1->rtl);
    rtx dst = gen_rtx_REG(DFmode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, gen_rtx_FLOAT(DFmode, src)));
  };
#line 439 "x86-64.float.py"
rfx : FLOAT_SF(r32) [1, 1]
#line 444 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = FLOAT_REGISTER;
  },
  supairs {
    /* NYI */
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    if (1) {
      sparseset_set_bit(live, find($1->r));	/* r, not rx, as rhs is r64 */
    }
    else add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1) {
      memorable($1->r);
    }
  },
  debug {
    if (1) {
      dumpRR("cvtsi2ssl", $1->r, 'q', $$->rx, 'x');
    } else {
      dumpMR("cvtsi2ssl", $1, $$->rx, 'x');
    }
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = 1
      ? gen_rtx_REG(SImode, $1->r)
      : gen_rtx_MEM(SImode, $1->rtl);
    rtx dst = gen_rtx_REG(SFmode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, gen_rtx_FLOAT(SFmode, src)));
  };
#line 440 "x86-64.float.py"
rfx : FLOAT_SF(MEM_SI(addr)) [1, 1]
#line 444 "x86-64.float.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = FLOAT_REGISTER;
  },
  supairs {
    /* NYI */
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    if (0) {
      sparseset_set_bit(live, find($1->r));	/* r, not rx, as rhs is r64 */
    }
    else add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0) {
      memorable($1->r);
    }
  },
  debug {
    if (0) {
      dumpRR("cvtsi2ssl", $1->r, 'q', $$->rx, 'x');
    } else {
      dumpMR("cvtsi2ssl", $1, $$->rx, 'x');
    }
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = 0
      ? gen_rtx_REG(SImode, $1->r)
      : gen_rtx_MEM(SImode, $1->rtl);
    rtx dst = gen_rtx_REG(SFmode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, gen_rtx_FLOAT(SFmode, src)));
  };
#line 491 "x86-64.float.py"
rdx: PLUS_DF(rdx  | rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("addsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("addsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_PLUS(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_PLUS(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 492 "x86-64.float.py"
rfx: PLUS_SF(rfx  | rf) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("addss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("addss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_PLUS(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_PLUS(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 493 "x86-64.float.py"
rdx: PLUS_VDI(rdx | rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("paddq", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("paddq", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V2DImode, $1->rx);
    rtx src = 1
      ? gen_rtx_PLUS(V2DImode, dst, gen_rtx_REG(V2DImode, $2->r))
      : gen_rtx_PLUS(V2DImode, dst, gen_rtx_MEM(V2DImode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 494 "x86-64.float.py"
rdx: PLUS_VSI(rdx | rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("paddd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("paddd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V4SImode, $1->rx);
    rtx src = 1
      ? gen_rtx_PLUS(V4SImode, dst, gen_rtx_REG(V4SImode, $2->r))
      : gen_rtx_PLUS(V4SImode, dst, gen_rtx_MEM(V4SImode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 495 "x86-64.float.py"
rdx: PLUS_VHI(rdx | rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("paddw", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("paddw", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V8HImode, $1->rx);
    rtx src = 1
      ? gen_rtx_PLUS(V8HImode, dst, gen_rtx_REG(V8HImode, $2->r))
      : gen_rtx_PLUS(V8HImode, dst, gen_rtx_MEM(V8HImode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 496 "x86-64.float.py"
rdx: PLUS_VQI(rdx | rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("paddb", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("paddb", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V16QImode, $1->rx);
    rtx src = 1
      ? gen_rtx_PLUS(V16QImode, dst, gen_rtx_REG(V16QImode, $2->r))
      : gen_rtx_PLUS(V16QImode, dst, gen_rtx_MEM(V16QImode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 497 "x86-64.float.py"
rdx: PLUS_VDF(rdx | rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("addpd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("addpd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V2DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_PLUS(V2DFmode, dst, gen_rtx_REG(V2DFmode, $2->r))
      : gen_rtx_PLUS(V2DFmode, dst, gen_rtx_MEM(V2DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 498 "x86-64.float.py"
rdx: PLUS_VSF(rdx | rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("addps", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("addps", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V4SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_PLUS(V4SFmode, dst, gen_rtx_REG(V4SFmode, $2->r))
      : gen_rtx_PLUS(V4SFmode, dst, gen_rtx_MEM(V4SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 500 "x86-64.float.py"
rdx: PLUS_DF(rdx  | MEM_DF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("addsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("addsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_PLUS(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_PLUS(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 501 "x86-64.float.py"
rfx: PLUS_SF(rfx  | MEM_SF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("addss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("addss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_PLUS(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_PLUS(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 502 "x86-64.float.py"
rdx: PLUS_VDI(rdx | MEM_VDI(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("paddq", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("paddq", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V2DImode, $1->rx);
    rtx src = 0
      ? gen_rtx_PLUS(V2DImode, dst, gen_rtx_REG(V2DImode, $2->r))
      : gen_rtx_PLUS(V2DImode, dst, gen_rtx_MEM(V2DImode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 503 "x86-64.float.py"
rdx: PLUS_VSI(rdx | MEM_VSI(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("paddd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("paddd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V4SImode, $1->rx);
    rtx src = 0
      ? gen_rtx_PLUS(V4SImode, dst, gen_rtx_REG(V4SImode, $2->r))
      : gen_rtx_PLUS(V4SImode, dst, gen_rtx_MEM(V4SImode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 504 "x86-64.float.py"
rdx: PLUS_VHI(rdx | MEM_VHI(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("paddw", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("paddw", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V8HImode, $1->rx);
    rtx src = 0
      ? gen_rtx_PLUS(V8HImode, dst, gen_rtx_REG(V8HImode, $2->r))
      : gen_rtx_PLUS(V8HImode, dst, gen_rtx_MEM(V8HImode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 505 "x86-64.float.py"
rdx: PLUS_VQI(rdx | MEM_VQI(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("paddb", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("paddb", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V16QImode, $1->rx);
    rtx src = 0
      ? gen_rtx_PLUS(V16QImode, dst, gen_rtx_REG(V16QImode, $2->r))
      : gen_rtx_PLUS(V16QImode, dst, gen_rtx_MEM(V16QImode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 506 "x86-64.float.py"
rdx: PLUS_VDF(rdx | MEM_VDF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("addpd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("addpd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V2DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_PLUS(V2DFmode, dst, gen_rtx_REG(V2DFmode, $2->r))
      : gen_rtx_PLUS(V2DFmode, dst, gen_rtx_MEM(V2DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 507 "x86-64.float.py"
rdx: PLUS_VSF(rdx | MEM_VSF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("addps", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("addps", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V4SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_PLUS(V4SFmode, dst, gen_rtx_REG(V4SFmode, $2->r))
      : gen_rtx_PLUS(V4SFmode, dst, gen_rtx_MEM(V4SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 509 "x86-64.float.py"
rdx: PLUS_DF(rdx ,  NEG_DF(rd)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("subsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("subsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_MINUS(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_MINUS(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 510 "x86-64.float.py"
rfx: PLUS_SF(rfx ,  NEG_SF(rf)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("subss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("subss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_MINUS(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_MINUS(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 511 "x86-64.float.py"
rdx: PLUS_VDI(rdx , NEG_VDI(rd)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("psubq", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("psubq", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V2DImode, $1->rx);
    rtx src = 1
      ? gen_rtx_MINUS(V2DImode, dst, gen_rtx_REG(V2DImode, $2->r))
      : gen_rtx_MINUS(V2DImode, dst, gen_rtx_MEM(V2DImode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 512 "x86-64.float.py"
rdx: PLUS_VSI(rdx , NEG_VSI(rd)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("psubd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("psubd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V4SImode, $1->rx);
    rtx src = 1
      ? gen_rtx_MINUS(V4SImode, dst, gen_rtx_REG(V4SImode, $2->r))
      : gen_rtx_MINUS(V4SImode, dst, gen_rtx_MEM(V4SImode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 513 "x86-64.float.py"
rdx: PLUS_VHI(rdx , NEG_VHI(rd)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("psubw", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("psubw", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V8HImode, $1->rx);
    rtx src = 1
      ? gen_rtx_MINUS(V8HImode, dst, gen_rtx_REG(V8HImode, $2->r))
      : gen_rtx_MINUS(V8HImode, dst, gen_rtx_MEM(V8HImode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 514 "x86-64.float.py"
rdx: PLUS_VQI(rdx , NEG_VQI(rd)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("psubb", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("psubb", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V16QImode, $1->rx);
    rtx src = 1
      ? gen_rtx_MINUS(V16QImode, dst, gen_rtx_REG(V16QImode, $2->r))
      : gen_rtx_MINUS(V16QImode, dst, gen_rtx_MEM(V16QImode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 515 "x86-64.float.py"
rdx: PLUS_VDF(rdx , NEG_VDF(rd)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("subpd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("subpd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V2DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_MINUS(V2DFmode, dst, gen_rtx_REG(V2DFmode, $2->r))
      : gen_rtx_MINUS(V2DFmode, dst, gen_rtx_MEM(V2DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 516 "x86-64.float.py"
rdx: PLUS_VSF(rdx , NEG_VSF(rd)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("subps", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("subps", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V4SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_MINUS(V4SFmode, dst, gen_rtx_REG(V4SFmode, $2->r))
      : gen_rtx_MINUS(V4SFmode, dst, gen_rtx_MEM(V4SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 518 "x86-64.float.py"
rdx: PLUS_DF(rdx ,  NEG_DF(MEM_DF(addr))) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("subsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("subsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_MINUS(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_MINUS(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 519 "x86-64.float.py"
rfx: PLUS_SF(rfx ,  NEG_SF(MEM_SF(addr))) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("subss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("subss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_MINUS(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_MINUS(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 520 "x86-64.float.py"
rdx: PLUS_VDI(rdx , NEG_VDI(MEM_VDI(addr))) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("psubq", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("psubq", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V2DImode, $1->rx);
    rtx src = 0
      ? gen_rtx_MINUS(V2DImode, dst, gen_rtx_REG(V2DImode, $2->r))
      : gen_rtx_MINUS(V2DImode, dst, gen_rtx_MEM(V2DImode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 521 "x86-64.float.py"
rdx: PLUS_VSI(rdx , NEG_VSI(MEM_VSI(addr))) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("psubd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("psubd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V4SImode, $1->rx);
    rtx src = 0
      ? gen_rtx_MINUS(V4SImode, dst, gen_rtx_REG(V4SImode, $2->r))
      : gen_rtx_MINUS(V4SImode, dst, gen_rtx_MEM(V4SImode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 522 "x86-64.float.py"
rdx: PLUS_VHI(rdx , NEG_VHI(MEM_VHI(addr))) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("psubw", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("psubw", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V8HImode, $1->rx);
    rtx src = 0
      ? gen_rtx_MINUS(V8HImode, dst, gen_rtx_REG(V8HImode, $2->r))
      : gen_rtx_MINUS(V8HImode, dst, gen_rtx_MEM(V8HImode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 523 "x86-64.float.py"
rdx: PLUS_VQI(rdx , NEG_VQI(MEM_VQI(addr))) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("psubb", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("psubb", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V16QImode, $1->rx);
    rtx src = 0
      ? gen_rtx_MINUS(V16QImode, dst, gen_rtx_REG(V16QImode, $2->r))
      : gen_rtx_MINUS(V16QImode, dst, gen_rtx_MEM(V16QImode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 524 "x86-64.float.py"
rdx: PLUS_VDF(rdx , NEG_VDF(MEM_VDF(addr))) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("subpd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("subpd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V2DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_MINUS(V2DFmode, dst, gen_rtx_REG(V2DFmode, $2->r))
      : gen_rtx_MINUS(V2DFmode, dst, gen_rtx_MEM(V2DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 525 "x86-64.float.py"
rdx: PLUS_VSF(rdx , NEG_VSF(MEM_VSF(addr))) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("subps", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("subps", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V4SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_MINUS(V4SFmode, dst, gen_rtx_REG(V4SFmode, $2->r))
      : gen_rtx_MINUS(V4SFmode, dst, gen_rtx_MEM(V4SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 527 "x86-64.float.py"
rdx: MINUS_DF(rdx ,  rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("subsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("subsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_MINUS(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_MINUS(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 528 "x86-64.float.py"
rfx: MINUS_SF(rfx ,  rf) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("subss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("subss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_MINUS(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_MINUS(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 529 "x86-64.float.py"
rdx: MINUS_VDI(rdx , rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("psubq", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("psubq", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V2DImode, $1->rx);
    rtx src = 1
      ? gen_rtx_MINUS(V2DImode, dst, gen_rtx_REG(V2DImode, $2->r))
      : gen_rtx_MINUS(V2DImode, dst, gen_rtx_MEM(V2DImode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 530 "x86-64.float.py"
rdx: MINUS_VSI(rdx , rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("psubd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("psubd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V4SImode, $1->rx);
    rtx src = 1
      ? gen_rtx_MINUS(V4SImode, dst, gen_rtx_REG(V4SImode, $2->r))
      : gen_rtx_MINUS(V4SImode, dst, gen_rtx_MEM(V4SImode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 531 "x86-64.float.py"
rdx: MINUS_VHI(rdx , rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("psubw", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("psubw", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V8HImode, $1->rx);
    rtx src = 1
      ? gen_rtx_MINUS(V8HImode, dst, gen_rtx_REG(V8HImode, $2->r))
      : gen_rtx_MINUS(V8HImode, dst, gen_rtx_MEM(V8HImode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 532 "x86-64.float.py"
rdx: MINUS_VQI(rdx , rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("psubb", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("psubb", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V16QImode, $1->rx);
    rtx src = 1
      ? gen_rtx_MINUS(V16QImode, dst, gen_rtx_REG(V16QImode, $2->r))
      : gen_rtx_MINUS(V16QImode, dst, gen_rtx_MEM(V16QImode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 533 "x86-64.float.py"
rdx: MINUS_VDF(rdx , rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("subpd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("subpd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V2DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_MINUS(V2DFmode, dst, gen_rtx_REG(V2DFmode, $2->r))
      : gen_rtx_MINUS(V2DFmode, dst, gen_rtx_MEM(V2DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 534 "x86-64.float.py"
rdx: MINUS_VSF(rdx , rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("subps", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("subps", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V4SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_MINUS(V4SFmode, dst, gen_rtx_REG(V4SFmode, $2->r))
      : gen_rtx_MINUS(V4SFmode, dst, gen_rtx_MEM(V4SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 536 "x86-64.float.py"
rdx: MINUS_DF(rdx ,  MEM_DF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("subsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("subsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_MINUS(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_MINUS(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 537 "x86-64.float.py"
rfx: MINUS_SF(rfx ,  MEM_SF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("subss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("subss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_MINUS(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_MINUS(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 538 "x86-64.float.py"
rdx: MINUS_VDI(rdx , MEM_VDI(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("psubq", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("psubq", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V2DImode, $1->rx);
    rtx src = 0
      ? gen_rtx_MINUS(V2DImode, dst, gen_rtx_REG(V2DImode, $2->r))
      : gen_rtx_MINUS(V2DImode, dst, gen_rtx_MEM(V2DImode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 539 "x86-64.float.py"
rdx: MINUS_VSI(rdx , MEM_VSI(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("psubd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("psubd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V4SImode, $1->rx);
    rtx src = 0
      ? gen_rtx_MINUS(V4SImode, dst, gen_rtx_REG(V4SImode, $2->r))
      : gen_rtx_MINUS(V4SImode, dst, gen_rtx_MEM(V4SImode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 540 "x86-64.float.py"
rdx: MINUS_VHI(rdx , MEM_VHI(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("psubw", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("psubw", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V8HImode, $1->rx);
    rtx src = 0
      ? gen_rtx_MINUS(V8HImode, dst, gen_rtx_REG(V8HImode, $2->r))
      : gen_rtx_MINUS(V8HImode, dst, gen_rtx_MEM(V8HImode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 541 "x86-64.float.py"
rdx: MINUS_VQI(rdx , MEM_VQI(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("psubb", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("psubb", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V16QImode, $1->rx);
    rtx src = 0
      ? gen_rtx_MINUS(V16QImode, dst, gen_rtx_REG(V16QImode, $2->r))
      : gen_rtx_MINUS(V16QImode, dst, gen_rtx_MEM(V16QImode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 542 "x86-64.float.py"
rdx: MINUS_VDF(rdx , MEM_VDF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("subpd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("subpd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V2DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_MINUS(V2DFmode, dst, gen_rtx_REG(V2DFmode, $2->r))
      : gen_rtx_MINUS(V2DFmode, dst, gen_rtx_MEM(V2DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 543 "x86-64.float.py"
rdx: MINUS_VSF(rdx , MEM_VSF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("subps", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("subps", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V4SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_MINUS(V4SFmode, dst, gen_rtx_REG(V4SFmode, $2->r))
      : gen_rtx_MINUS(V4SFmode, dst, gen_rtx_MEM(V4SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 545 "x86-64.float.py"
rdx: MULT_DF(rdx  | rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("mulsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("mulsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_MULT(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_MULT(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 546 "x86-64.float.py"
rfx: MULT_SF(rfx  | rf) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("mulss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("mulss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_MULT(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_MULT(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 547 "x86-64.float.py"
rdx: MULT_VHI(rdx | rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("pmullw", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("pmullw", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V8HImode, $1->rx);
    rtx src = 1
      ? gen_rtx_MULT(V8HImode, dst, gen_rtx_REG(V8HImode, $2->r))
      : gen_rtx_MULT(V8HImode, dst, gen_rtx_MEM(V8HImode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 548 "x86-64.float.py"
rdx: MULT_VDF(rdx | rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("mulpd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("mulpd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V2DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_MULT(V2DFmode, dst, gen_rtx_REG(V2DFmode, $2->r))
      : gen_rtx_MULT(V2DFmode, dst, gen_rtx_MEM(V2DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 549 "x86-64.float.py"
rdx: MULT_VSF(rdx | rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("mulps", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("mulps", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V4SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_MULT(V4SFmode, dst, gen_rtx_REG(V4SFmode, $2->r))
      : gen_rtx_MULT(V4SFmode, dst, gen_rtx_MEM(V4SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 551 "x86-64.float.py"
rdx: MULT_DF(rdx  | MEM_DF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("mulsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("mulsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_MULT(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_MULT(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 552 "x86-64.float.py"
rfx: MULT_SF(rfx  | MEM_SF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("mulss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("mulss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_MULT(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_MULT(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 553 "x86-64.float.py"
rdx: MULT_VHI(rdx | MEM_VHI(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("pmullw", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("pmullw", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V8HImode, $1->rx);
    rtx src = 0
      ? gen_rtx_MULT(V8HImode, dst, gen_rtx_REG(V8HImode, $2->r))
      : gen_rtx_MULT(V8HImode, dst, gen_rtx_MEM(V8HImode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 554 "x86-64.float.py"
rdx: MULT_VDF(rdx | MEM_VDF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("mulpd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("mulpd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V2DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_MULT(V2DFmode, dst, gen_rtx_REG(V2DFmode, $2->r))
      : gen_rtx_MULT(V2DFmode, dst, gen_rtx_MEM(V2DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 555 "x86-64.float.py"
rdx: MULT_VSF(rdx | MEM_VSF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("mulps", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("mulps", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V4SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_MULT(V4SFmode, dst, gen_rtx_REG(V4SFmode, $2->r))
      : gen_rtx_MULT(V4SFmode, dst, gen_rtx_MEM(V4SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 557 "x86-64.float.py"
rdx: DIV_DF(rdx , rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("divsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("divsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_DIV(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_DIV(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 558 "x86-64.float.py"
rfx: DIV_SF(rfx , rf) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("divss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("divss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_DIV(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_DIV(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 559 "x86-64.float.py"
rdx: DIV_VDF(rdx , rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("divpd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("divpd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V2DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_DIV(V2DFmode, dst, gen_rtx_REG(V2DFmode, $2->r))
      : gen_rtx_DIV(V2DFmode, dst, gen_rtx_MEM(V2DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 560 "x86-64.float.py"
rdx: DIV_VSF(rdx , rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("divps", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("divps", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V4SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_DIV(V4SFmode, dst, gen_rtx_REG(V4SFmode, $2->r))
      : gen_rtx_DIV(V4SFmode, dst, gen_rtx_MEM(V4SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 562 "x86-64.float.py"
rdx: DIV_DF(rdx , MEM_DF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("divsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("divsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_DIV(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_DIV(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 563 "x86-64.float.py"
rfx: DIV_SF(rfx , MEM_SF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("divss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("divss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_DIV(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_DIV(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 564 "x86-64.float.py"
rdx: DIV_VDF(rdx , MEM_VHI(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("divpd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("divpd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V8HImode, $1->rx);
    rtx src = 0
      ? gen_rtx_DIV(V8HImode, dst, gen_rtx_REG(V8HImode, $2->r))
      : gen_rtx_DIV(V8HImode, dst, gen_rtx_MEM(V8HImode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 565 "x86-64.float.py"
rdx: DIV_VSF(rdx , MEM_VSF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("divps", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("divps", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V4SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_DIV(V4SFmode, dst, gen_rtx_REG(V4SFmode, $2->r))
      : gen_rtx_DIV(V4SFmode, dst, gen_rtx_MEM(V4SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 567 "x86-64.float.py"
rdx: IOR_DF(rdx | rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("orpd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("orpd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_IOR(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_IOR(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 568 "x86-64.float.py"
rfx: IOR_SF(rfx | rf) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("orps", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("orps", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_IOR(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_IOR(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 569 "x86-64.float.py"
rdx: XOR_DF(rdx | rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("xorpd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("xorpd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_XOR(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_XOR(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 570 "x86-64.float.py"
rfx: XOR_SF(rfx | rf) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("xorps", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("xorps", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_XOR(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_XOR(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 571 "x86-64.float.py"
rdx: AND_DF(rdx | rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("andpd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("andpd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_AND(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_AND(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 572 "x86-64.float.py"
rfx: AND_SF(rfx | rf) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("andps", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("andps", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_AND(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_AND(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 573 "x86-64.float.py"
rdx: AND_DF(NOT_DF(rdx) | rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("andnpd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("andnpd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_ANDNOT(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_ANDNOT(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 574 "x86-64.float.py"
rfx: AND_SF(NOT_SF(rfx) | rf) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("andnps", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("andnps", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_ANDNOT(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_ANDNOT(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 613 "x86-64.float.py"
rdx: UNLT_ALL(rdx , rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpltsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpltsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_UNLT(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_UNLT(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 614 "x86-64.float.py"
rdx: UNLE_ALL(rdx , rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmplesd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmplesd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_UNLE(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_UNLE(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 615 "x86-64.float.py"
rdx: UNEQ_ALL(rdx | rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpeqsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpeqsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_UNEQ(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_UNEQ(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 616 "x86-64.float.py"
rdx: LTGT_ALL(rdx | rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpneqsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpneqsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_LTGT(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_LTGT(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 617 "x86-64.float.py"
rdx: UNGE_ALL(rdx , rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpnltsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpnltsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_UNGE(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_UNGE(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 618 "x86-64.float.py"
rdx: UNGT_ALL(rdx , rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpnlesd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpnlesd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_UNGT(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_UNGT(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 620 "x86-64.float.py"
rfx: UNLT_ALL(rfx , rf) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpltss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpltss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_UNLT(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_UNLT(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 621 "x86-64.float.py"
rfx: UNLE_ALL(rfx , rf) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpless", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpless", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_UNLE(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_UNLE(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 622 "x86-64.float.py"
rfx: UNEQ_ALL(rfx | rf) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpeqss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpeqss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_UNEQ(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_UNEQ(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 623 "x86-64.float.py"
rfx: LTGT_ALL(rfx | rf) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpneqss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpneqss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_LTGT(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_LTGT(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 624 "x86-64.float.py"
rfx: UNGE_ALL(rfx , rf) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpnltss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpnltss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_UNGE(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_UNGE(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 625 "x86-64.float.py"
rfx: UNGT_ALL(rfx , rf) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpnless", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpnless", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_UNGT(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_UNGT(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 627 "x86-64.float.py"
rdx: UNLT_ALL(rdx , MEM_DF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpltsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpltsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_UNLT(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_UNLT(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 628 "x86-64.float.py"
rdx: UNLE_ALL(rdx , MEM_DF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmplesd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmplesd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_UNLE(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_UNLE(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 629 "x86-64.float.py"
rdx: UNEQ_ALL(rdx | MEM_DF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpeqsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpeqsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_UNEQ(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_UNEQ(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 630 "x86-64.float.py"
rdx: LTGT_ALL(rdx | MEM_DF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpneqsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpneqsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_LTGT(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_LTGT(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 631 "x86-64.float.py"
rdx: UNGE_ALL(rdx , MEM_DF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpnltsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpnltsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_UNGE(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_UNGE(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 632 "x86-64.float.py"
rdx: UNGT_ALL(rdx , MEM_DF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpnlesd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpnlesd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_UNGT(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_UNGT(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 634 "x86-64.float.py"
rfx: UNLT_ALL(rfx , MEM_SF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpltss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpltss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_UNLT(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_UNLT(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 635 "x86-64.float.py"
rfx: UNLE_ALL(rfx , MEM_SF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpless", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpless", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_UNLE(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_UNLE(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 636 "x86-64.float.py"
rfx: UNEQ_ALL(rfx | MEM_SF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpeqss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpeqss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_UNEQ(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_UNEQ(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 637 "x86-64.float.py"
rfx: LTGT_ALL(rfx | MEM_SF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpneqss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpneqss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_LTGT(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_LTGT(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 638 "x86-64.float.py"
rfx: UNGE_ALL(rfx , MEM_SF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpnltss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpnltss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_UNGE(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_UNGE(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 639 "x86-64.float.py"
rfx: UNGT_ALL(rfx , MEM_SF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpnless", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpnless", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_UNGT(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_UNGT(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 644 "x86-64.float.py"
rdx: FLT_DF(rdx , rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpltsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpltsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_LT(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_LT(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 645 "x86-64.float.py"
rdx: FLE_DF(rdx , rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmplesd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmplesd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_LE(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_LE(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 646 "x86-64.float.py"
rdx: FEQ_DF(rdx | rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpeqsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpeqsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_EQ(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_EQ(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 647 "x86-64.float.py"
rdx: FNEQ_DF(rdx| rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpnesd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpnesd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_NE(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_NE(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 648 "x86-64.float.py"
rdx: FGE_DF(rdx @ rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpltsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpltsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_LT_swap(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_LT_swap(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 649 "x86-64.float.py"
rdx: FGT_DF(rdx @ rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmplesd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmplesd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_LE_swap(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_LE_swap(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 651 "x86-64.float.py"
rfx: FLT_SF(rfx , rf) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpltss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpltss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_LT(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_LT(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 652 "x86-64.float.py"
rfx: FLE_SF(rfx , rf) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpless", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpless", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_LE(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_LE(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 653 "x86-64.float.py"
rfx: FEQ_SF(rfx | rf) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpeqss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpeqss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_EQ(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_EQ(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 654 "x86-64.float.py"
rfx: FNEQ_SF(rfx| rf) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpneqss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpneqss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_NE(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_NE(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 655 "x86-64.float.py"
rfx: FGE_SF(rfx @ rf) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpltss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpltss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_LT_swap(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_LT_swap(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 656 "x86-64.float.py"
rfx: FGT_SF(rfx @ rf) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpless", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpless", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_LE_swap(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_LE_swap(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 658 "x86-64.float.py"
rdx: FLT_DF(rdx , MEM_DF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpltsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpltsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_LT(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_LT(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 659 "x86-64.float.py"
rdx: FLE_DF(rdx , MEM_DF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmplesd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmplesd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_LE(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_LE(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 660 "x86-64.float.py"
rdx: FEQ_DF(rdx | MEM_DF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpeqsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpeqsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_EQ(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_EQ(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 661 "x86-64.float.py"
rdx: FNEQ_DF(rdx| MEM_DF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpneqsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpneqsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_NE(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_NE(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 662 "x86-64.float.py"
rdx: FGE_DF(rdx @ MEM_DF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpltsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpltsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_LT_swap(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_LT_swap(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 663 "x86-64.float.py"
rdx: FGT_DF(rdx @ MEM_DF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmplesd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmplesd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_LE_swap(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_LE_swap(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 665 "x86-64.float.py"
rfx: FLT_SF(rfx , MEM_SF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpltss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpltss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_LT(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_LT(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 666 "x86-64.float.py"
rfx: FLE_SF(rfx , MEM_SF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpless", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpless", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_LE(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_LE(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 667 "x86-64.float.py"
rfx: FEQ_SF(rfx | MEM_SF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpeqss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpeqss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_EQ(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_EQ(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 668 "x86-64.float.py"
rfx: FNEQ_SF(rfx| MEM_SF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpneqss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpneqss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_NE(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_NE(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 669 "x86-64.float.py"
rfx: FGE_SF(rfx @ MEM_SF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpltss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpltss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_LT_swap(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_LT_swap(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 670 "x86-64.float.py"
rfx: FGT_SF(rfx @ MEM_SF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpless", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpless", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_LE_swap(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_LE_swap(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 672 "x86-64.float.py"
rdx: LT_ALL(rdx , rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpltsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpltsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_LT(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_LT(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 673 "x86-64.float.py"
rdx: LE_ALL(rdx , rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmplesd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmplesd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_LE(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_LE(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 674 "x86-64.float.py"
rdx: EQ_ALL(rdx | rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpeqsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpeqsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_EQ(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_EQ(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 675 "x86-64.float.py"
rdx: NE_ALL(rdx | rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpnesd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpnesd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_NE(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_NE(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 676 "x86-64.float.py"
rdx: GE_ALL(rdx @ rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpltsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpltsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_LT_swap(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_LT_swap(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 677 "x86-64.float.py"
rdx: GT_ALL(rdx @ rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmplesd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmplesd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_LE_swap(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_LE_swap(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 679 "x86-64.float.py"
rfx: LT_ALL(rfx , rf) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpltss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpltss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_LT(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_LT(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 680 "x86-64.float.py"
rfx: LE_ALL(rfx , rf) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpless", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpless", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_LE(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_LE(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 681 "x86-64.float.py"
rfx: EQ_ALL(rfx | rf) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpeqss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpeqss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_EQ(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_EQ(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 682 "x86-64.float.py"
rfx: NE_ALL(rfx | rf) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpneqss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpneqss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_NE(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_NE(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 683 "x86-64.float.py"
rfx: GE_ALL(rfx @ rf) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpltss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpltss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_LT_swap(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_LT_swap(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 684 "x86-64.float.py"
rfx: GT_ALL(rfx @ rf) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("cmpless", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpless", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_LE_swap(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_LE_swap(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 686 "x86-64.float.py"
rdx: LT_ALL(rdx , MEM_DF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpltsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpltsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_LT(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_LT(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 687 "x86-64.float.py"
rdx: LE_ALL(rdx , MEM_DF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmplesd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmplesd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_LE(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_LE(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 688 "x86-64.float.py"
rdx: EQ_ALL(rdx | MEM_DF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpeqsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpeqsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_EQ(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_EQ(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 689 "x86-64.float.py"
rdx: NE_ALL(rdx | MEM_DF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpneqsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpneqsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_NE(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_NE(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 690 "x86-64.float.py"
rdx: GE_ALL(rdx @ MEM_DF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpltsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpltsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_LT_swap(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_LT_swap(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 691 "x86-64.float.py"
rdx: GT_ALL(rdx @ MEM_DF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmplesd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmplesd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_LE_swap(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_LE_swap(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 693 "x86-64.float.py"
rfx: LT_ALL(rfx , MEM_SF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpltss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpltss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_LT(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_LT(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 694 "x86-64.float.py"
rfx: LE_ALL(rfx , MEM_SF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpless", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpless", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_LE(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_LE(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 695 "x86-64.float.py"
rfx: EQ_ALL(rfx | MEM_SF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpeqss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpeqss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_EQ(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_EQ(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 696 "x86-64.float.py"
rfx: NE_ALL(rfx | MEM_SF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpneqss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpneqss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_NE(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_NE(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 697 "x86-64.float.py"
rfx: GE_ALL(rfx @ MEM_SF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpltss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpltss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_LT_swap(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_LT_swap(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 698 "x86-64.float.py"
rfx: GT_ALL(rfx @ MEM_SF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("cmpless", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("cmpless", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_LE_swap(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_LE_swap(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 700 "x86-64.float.py"
rdx: ICG_UNSPEC_IEEE_MAX_DF(rdx  | rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("maxsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("maxsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_IEEE_MAX_helper(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_IEEE_MAX_helper(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 701 "x86-64.float.py"
rfx: ICG_UNSPEC_IEEE_MAX_SF(rfx  | rf) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("maxss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("maxss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_IEEE_MAX_helper(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_IEEE_MAX_helper(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 702 "x86-64.float.py"
rdx: ICG_UNSPEC_IEEE_MAX_VDF(rdx | rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("maxpd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("maxpd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V2DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_IEEE_MAX_helper(V2DFmode, dst, gen_rtx_REG(V2DFmode, $2->r))
      : gen_rtx_IEEE_MAX_helper(V2DFmode, dst, gen_rtx_MEM(V2DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 703 "x86-64.float.py"
rdx: ICG_UNSPEC_IEEE_MAX_VSF(rdx | rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("maxps", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("maxps", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V4SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_IEEE_MAX_helper(V4SFmode, dst, gen_rtx_REG(V4SFmode, $2->r))
      : gen_rtx_IEEE_MAX_helper(V4SFmode, dst, gen_rtx_MEM(V4SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 705 "x86-64.float.py"
rdx: ICG_UNSPEC_IEEE_MAX_DF(rdx  | MEM_DF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("maxsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("maxsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_IEEE_MAX_helper(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_IEEE_MAX_helper(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 706 "x86-64.float.py"
rfx: ICG_UNSPEC_IEEE_MAX_SF(rfx  | MEM_SF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("maxss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("maxss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_IEEE_MAX_helper(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_IEEE_MAX_helper(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 707 "x86-64.float.py"
rdx: ICG_UNSPEC_IEEE_MAX_VDF(rdx | MEM_VDF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("maxpd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("maxpd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V2DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_IEEE_MAX_helper(V2DFmode, dst, gen_rtx_REG(V2DFmode, $2->r))
      : gen_rtx_IEEE_MAX_helper(V2DFmode, dst, gen_rtx_MEM(V2DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 708 "x86-64.float.py"
rdx: ICG_UNSPEC_IEEE_MAX_VSF(rdx | MEM_VSF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("maxps", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("maxps", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V4SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_IEEE_MAX_helper(V4SFmode, dst, gen_rtx_REG(V4SFmode, $2->r))
      : gen_rtx_IEEE_MAX_helper(V4SFmode, dst, gen_rtx_MEM(V4SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 710 "x86-64.float.py"
rdx: ICG_UNSPEC_IEEE_MIN_DF(rdx  | rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("minsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("minsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_IEEE_MIN_helper(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_IEEE_MIN_helper(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 711 "x86-64.float.py"
rfx: ICG_UNSPEC_IEEE_MIN_SF(rfx  | rf) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("minss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("minss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_IEEE_MIN_helper(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_IEEE_MIN_helper(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 712 "x86-64.float.py"
rdx: ICG_UNSPEC_IEEE_MIN_VDF(rdx | rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("minpd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("minpd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V2DFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_IEEE_MIN_helper(V2DFmode, dst, gen_rtx_REG(V2DFmode, $2->r))
      : gen_rtx_IEEE_MIN_helper(V2DFmode, dst, gen_rtx_MEM(V2DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 713 "x86-64.float.py"
rdx: ICG_UNSPEC_IEEE_MIN_VSF(rdx | rd) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (1) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($2->r);
    if (1)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (1) {
      dumpRR("minps", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("minps", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V4SFmode, $1->rx);
    rtx src = 1
      ? gen_rtx_IEEE_MIN_helper(V4SFmode, dst, gen_rtx_REG(V4SFmode, $2->r))
      : gen_rtx_IEEE_MIN_helper(V4SFmode, dst, gen_rtx_MEM(V4SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 715 "x86-64.float.py"
rdx: ICG_UNSPEC_IEEE_MIN_DF(rdx  | MEM_DF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("minsd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("minsd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_IEEE_MIN_helper(DFmode, dst, gen_rtx_REG(DFmode, $2->r))
      : gen_rtx_IEEE_MIN_helper(DFmode, dst, gen_rtx_MEM(DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 716 "x86-64.float.py"
rfx: ICG_UNSPEC_IEEE_MIN_SF(rfx  | MEM_SF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("minss", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("minss", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_IEEE_MIN_helper(SFmode, dst, gen_rtx_REG(SFmode, $2->r))
      : gen_rtx_IEEE_MIN_helper(SFmode, dst, gen_rtx_MEM(SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 717 "x86-64.float.py"
rdx: ICG_UNSPEC_IEEE_MIN_VDF(rdx | MEM_VDF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("minpd", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("minpd", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V2DFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_IEEE_MIN_helper(V2DFmode, dst, gen_rtx_REG(V2DFmode, $2->r))
      : gen_rtx_IEEE_MIN_helper(V2DFmode, dst, gen_rtx_MEM(V2DFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 718 "x86-64.float.py"
rdx: ICG_UNSPEC_IEEE_MIN_VSF(rdx | MEM_VSF(addr)) [1, 1]
#line 723 "x86-64.float.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    if (0) {
      sparseset_set_bit(live, find($2->r));
    }
    else add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($2->r);
    if (0)
      memorable($1->rx);
    else
      forgettable($1->rx);
  },
  debug {
    if (0) {
      dumpRR("minps", $2->r, 'x', $$->rx, 'x');
    } else {
      dumpMR("minps", $2, $$->rx, 'x');
    }
  },
  emit {
    rtx dst = gen_rtx_REG(V4SFmode, $1->rx);
    rtx src = 0
      ? gen_rtx_IEEE_MIN_helper(V4SFmode, dst, gen_rtx_REG(V4SFmode, $2->r))
      : gen_rtx_IEEE_MIN_helper(V4SFmode, dst, gen_rtx_MEM(V4SFmode, $2->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
