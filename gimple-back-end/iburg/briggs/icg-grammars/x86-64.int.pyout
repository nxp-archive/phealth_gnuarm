#line 17 "x86-64.int.py"
lhs64 : REGX_DI [0, 0]
#line 28 "x86-64.int.py"
  names {
    $$->spilled = false;
  },
  kinds {
    icg_reg_vector[$$->r].kind = INT_REGISTER;
  },
  remat {
    flags |= LHS_REG;
  },
  costs {
    cost_store($$->r);
  },
  spill {
    dirty |= make_spill_code(find($$->r), $$);
  },
  final {
    $$->r = icg_reg_vector[find($$->r)].color;
  };
#line 18 "x86-64.int.py"
lhs32 : REGX_SI [0, 0]
#line 28 "x86-64.int.py"
  names {
    $$->spilled = false;
  },
  kinds {
    icg_reg_vector[$$->r].kind = INT_REGISTER;
  },
  remat {
    flags |= LHS_REG;
  },
  costs {
    cost_store($$->r);
  },
  spill {
    dirty |= make_spill_code(find($$->r), $$);
  },
  final {
    $$->r = icg_reg_vector[find($$->r)].color;
  };
#line 19 "x86-64.int.py"
lhs16 : REGX_HI [0, 0]
#line 28 "x86-64.int.py"
  names {
    $$->spilled = false;
  },
  kinds {
    icg_reg_vector[$$->r].kind = INT_REGISTER;
  },
  remat {
    flags |= LHS_REG;
  },
  costs {
    cost_store($$->r);
  },
  spill {
    dirty |= make_spill_code(find($$->r), $$);
  },
  final {
    $$->r = icg_reg_vector[find($$->r)].color;
  };
#line 20 "x86-64.int.py"
lhs8  : REGX_QI [0, 0]
#line 28 "x86-64.int.py"
  names {
    $$->spilled = false;
  },
  kinds {
    icg_reg_vector[$$->r].kind = INT_REGISTER;
  },
  remat {
    flags |= LHS_REG;
  },
  costs {
    cost_store($$->r);
  },
  spill {
    dirty |= make_spill_code(find($$->r), $$);
  },
  final {
    $$->r = icg_reg_vector[find($$->r)].color;
  };
#line 21 "x86-64.int.py"
lhs64 : REG_DI [0, 0]
#line 28 "x86-64.int.py"
  names {
    $$->spilled = false;
  },
  kinds {
    icg_reg_vector[$$->r].kind = INT_REGISTER;
  },
  remat {
    flags |= LHS_REG;
  },
  costs {
    cost_store($$->r);
  },
  spill {
    dirty |= make_spill_code(find($$->r), $$);
  },
  final {
    $$->r = icg_reg_vector[find($$->r)].color;
  };
#line 22 "x86-64.int.py"
lhs32 : REG_SI [0, 0]
#line 28 "x86-64.int.py"
  names {
    $$->spilled = false;
  },
  kinds {
    icg_reg_vector[$$->r].kind = INT_REGISTER;
  },
  remat {
    flags |= LHS_REG;
  },
  costs {
    cost_store($$->r);
  },
  spill {
    dirty |= make_spill_code(find($$->r), $$);
  },
  final {
    $$->r = icg_reg_vector[find($$->r)].color;
  };
#line 23 "x86-64.int.py"
lhs16 : REG_HI [0, 0]
#line 28 "x86-64.int.py"
  names {
    $$->spilled = false;
  },
  kinds {
    icg_reg_vector[$$->r].kind = INT_REGISTER;
  },
  remat {
    flags |= LHS_REG;
  },
  costs {
    cost_store($$->r);
  },
  spill {
    dirty |= make_spill_code(find($$->r), $$);
  },
  final {
    $$->r = icg_reg_vector[find($$->r)].color;
  };
#line 24 "x86-64.int.py"
lhs8  : REG_QI [0, 0]
#line 28 "x86-64.int.py"
  names {
    $$->spilled = false;
  },
  kinds {
    icg_reg_vector[$$->r].kind = INT_REGISTER;
  },
  remat {
    flags |= LHS_REG;
  },
  costs {
    cost_store($$->r);
  },
  spill {
    dirty |= make_spill_code(find($$->r), $$);
  },
  final {
    $$->r = icg_reg_vector[find($$->r)].color;
  };
#line 53 "x86-64.int.py"
lhs64 : MEM_DI(addr) [3, 0]
#line 73 "x86-64.int.py"
  names {
    $$->spilled  = true;
    $$->a.base   = $1->a.base;
    $$->a.base_valid = $1->a.base_valid;
    $$->a.index  = $1->a.index;
    $$->a.scale  = $1->a.scale;
    $$->a.disp   = $1->a.disp;
    $$->a.string = $1->a.string;
  },
  remat {
    flags = 0;
  },
  emit {
    $$->rtl = $1->rtl;
  };
#line 54 "x86-64.int.py"
lhs32 : MEM_SI(addr) [3, 0]
#line 73 "x86-64.int.py"
  names {
    $$->spilled  = true;
    $$->a.base   = $1->a.base;
    $$->a.base_valid = $1->a.base_valid;
    $$->a.index  = $1->a.index;
    $$->a.scale  = $1->a.scale;
    $$->a.disp   = $1->a.disp;
    $$->a.string = $1->a.string;
  },
  remat {
    flags = 0;
  },
  emit {
    $$->rtl = $1->rtl;
  };
#line 55 "x86-64.int.py"
lhs16 : MEM_HI(addr) [3, 0]
#line 73 "x86-64.int.py"
  names {
    $$->spilled  = true;
    $$->a.base   = $1->a.base;
    $$->a.base_valid = $1->a.base_valid;
    $$->a.index  = $1->a.index;
    $$->a.scale  = $1->a.scale;
    $$->a.disp   = $1->a.disp;
    $$->a.string = $1->a.string;
  },
  remat {
    flags = 0;
  },
  emit {
    $$->rtl = $1->rtl;
  };
#line 56 "x86-64.int.py"
lhs8  : MEM_QI(addr) [3, 0]
#line 73 "x86-64.int.py"
  names {
    $$->spilled  = true;
    $$->a.base   = $1->a.base;
    $$->a.base_valid = $1->a.base_valid;
    $$->a.index  = $1->a.index;
    $$->a.scale  = $1->a.scale;
    $$->a.disp   = $1->a.disp;
    $$->a.string = $1->a.string;
  },
  remat {
    flags = 0;
  },
  emit {
    $$->rtl = $1->rtl;
  };
#line 68 "x86-64.int.py"
lhs64 : MEM_DF(addr) [0, 0]
#line 73 "x86-64.int.py"
  names {
    $$->spilled  = true;
    $$->a.base   = $1->a.base;
    $$->a.base_valid = $1->a.base_valid;
    $$->a.index  = $1->a.index;
    $$->a.scale  = $1->a.scale;
    $$->a.disp   = $1->a.disp;
    $$->a.string = $1->a.string;
  },
  remat {
    flags = 0;
  },
  emit {
    $$->rtl = $1->rtl;
  };
#line 69 "x86-64.int.py"
lhs32 : MEM_SF(addr) [0, 0]
#line 73 "x86-64.int.py"
  names {
    $$->spilled  = true;
    $$->a.base   = $1->a.base;
    $$->a.base_valid = $1->a.base_valid;
    $$->a.index  = $1->a.index;
    $$->a.scale  = $1->a.scale;
    $$->a.disp   = $1->a.disp;
    $$->a.string = $1->a.string;
  },
  remat {
    flags = 0;
  },
  emit {
    $$->rtl = $1->rtl;
  };
#line 97 "x86-64.int.py"
stmt : SET_ALL(lhs64, r64) [0, 0]
#line 112 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  coalesce {
    if (!$1->spilled)
      coalesces += attempt_coalesce(pass, $1->r, $2->r);
  },
  build {
    if ($1->spilled) {
      sparseset_set_bit(live, find($2->r));
      add_addr(live, $1);
    }
    else
      add_copy_edges($1->r, $2->r, live);
  },
  costs {
    if (!$1->spilled)
      cost_copy($2->r, $1->r);
  },
  debug {
    if ($1->spilled)
      dumpRM("movq", $2->r, 'q', $1);
    else
      dump_copy("movq", $2->r, $1->r, 'q');
  },
  emit {
    if ($1->spilled) {
      rtx src = gen_rtx_REG(DImode, $2->r);
      rtx dst = gen_rtx_MEM(DImode, $1->rtl);
      icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
    }
    else {
      rtx src = gen_rtx_REG(DImode, $2->r);
      rtx dst = gen_rtx_REG(DImode, $1->r);
      icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
    }
  };
#line 98 "x86-64.int.py"
stmt : SET_ALL(lhs32, r32) [0, 0]
#line 112 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  coalesce {
    if (!$1->spilled)
      coalesces += attempt_coalesce(pass, $1->r, $2->r);
  },
  build {
    if ($1->spilled) {
      sparseset_set_bit(live, find($2->r));
      add_addr(live, $1);
    }
    else
      add_copy_edges($1->r, $2->r, live);
  },
  costs {
    if (!$1->spilled)
      cost_copy($2->r, $1->r);
  },
  debug {
    if ($1->spilled)
      dumpRM("movl", $2->r, 'l', $1);
    else
      dump_copy("movl", $2->r, $1->r, 'l');
  },
  emit {
    if ($1->spilled) {
      rtx src = gen_rtx_REG(SImode, $2->r);
      rtx dst = gen_rtx_MEM(SImode, $1->rtl);
      icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
    }
    else {
      rtx src = gen_rtx_REG(SImode, $2->r);
      rtx dst = gen_rtx_REG(SImode, $1->r);
      icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
    }
  };
#line 99 "x86-64.int.py"
stmt : SET_ALL(lhs16, r16) [0, 0]
#line 112 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  coalesce {
    if (!$1->spilled)
      coalesces += attempt_coalesce(pass, $1->r, $2->r);
  },
  build {
    if ($1->spilled) {
      sparseset_set_bit(live, find($2->r));
      add_addr(live, $1);
    }
    else
      add_copy_edges($1->r, $2->r, live);
  },
  costs {
    if (!$1->spilled)
      cost_copy($2->r, $1->r);
  },
  debug {
    if ($1->spilled)
      dumpRM("movw", $2->r, 'w', $1);
    else
      dump_copy("movl", $2->r, $1->r, 'l');
  },
  emit {
    if ($1->spilled) {
      rtx src = gen_rtx_REG(HImode, $2->r);
      rtx dst = gen_rtx_MEM(HImode, $1->rtl);
      icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
    }
    else {
      rtx src = gen_rtx_REG(SImode, $2->r);
      rtx dst = gen_rtx_REG(SImode, $1->r);
      icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
    }
  };
#line 100 "x86-64.int.py"
stmt : SET_ALL(lhs8,  r8) [0, 0]
#line 112 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  coalesce {
    if (!$1->spilled)
      coalesces += attempt_coalesce(pass, $1->r, $2->r);
  },
  build {
    if ($1->spilled) {
      sparseset_set_bit(live, find($2->r));
      add_addr(live, $1);
    }
    else
      add_copy_edges($1->r, $2->r, live);
  },
  costs {
    if (!$1->spilled)
      cost_copy($2->r, $1->r);
  },
  debug {
    if ($1->spilled)
      dumpRM("movb", $2->r, 'b', $1);
    else
      dump_copy("movl", $2->r, $1->r, 'l');
  },
  emit {
    if ($1->spilled) {
      rtx src = gen_rtx_REG(QImode, $2->r);
      rtx dst = gen_rtx_MEM(QImode, $1->rtl);
      icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
    }
    else {
      rtx src = gen_rtx_REG(SImode, $2->r);
      rtx dst = gen_rtx_REG(SImode, $1->r);
      icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
    }
  };
#line 103 "x86-64.int.py"
stmt : SET_ALL(SUBREG_DI(lhs32, CONST_0), r64) [0, 0]
#line 112 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  coalesce {
    if (!$1->spilled)
      coalesces += attempt_coalesce(pass, $1->r, $2->r);
  },
  build {
    if ($1->spilled) {
      sparseset_set_bit(live, find($2->r));
      add_addr(live, $1);
    }
    else
      add_copy_edges($1->r, $2->r, live);
  },
  costs {
    if (!$1->spilled)
      cost_copy($2->r, $1->r);
  },
  debug {
    if ($1->spilled)
      dumpRM("movl", $2->r, 'l', $1);
    else
      dump_copy("movl", $2->r, $1->r, 'l');
  },
  emit {
    if ($1->spilled) {
      rtx src = gen_rtx_REG(SImode, $2->r);
      rtx dst = gen_rtx_MEM(SImode, $1->rtl);
      icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
    }
    else {
      rtx src = gen_rtx_REG(SImode, $2->r);
      rtx dst = gen_rtx_REG(SImode, $1->r);
      icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
    }
  };
#line 104 "x86-64.int.py"
stmt : SET_ALL(SUBREG_DI(lhs16, CONST_0), r64) [0, 0]
#line 112 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  coalesce {
    if (!$1->spilled)
      coalesces += attempt_coalesce(pass, $1->r, $2->r);
  },
  build {
    if ($1->spilled) {
      sparseset_set_bit(live, find($2->r));
      add_addr(live, $1);
    }
    else
      add_copy_edges($1->r, $2->r, live);
  },
  costs {
    if (!$1->spilled)
      cost_copy($2->r, $1->r);
  },
  debug {
    if ($1->spilled)
      dumpRM("movw", $2->r, 'w', $1);
    else
      dump_copy("movl", $2->r, $1->r, 'l');
  },
  emit {
    if ($1->spilled) {
      rtx src = gen_rtx_REG(HImode, $2->r);
      rtx dst = gen_rtx_MEM(HImode, $1->rtl);
      icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
    }
    else {
      rtx src = gen_rtx_REG(SImode, $2->r);
      rtx dst = gen_rtx_REG(SImode, $1->r);
      icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
    }
  };
#line 105 "x86-64.int.py"
stmt : SET_ALL(SUBREG_DI(lhs8,  CONST_0), r64) [0, 0]
#line 112 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  coalesce {
    if (!$1->spilled)
      coalesces += attempt_coalesce(pass, $1->r, $2->r);
  },
  build {
    if ($1->spilled) {
      sparseset_set_bit(live, find($2->r));
      add_addr(live, $1);
    }
    else
      add_copy_edges($1->r, $2->r, live);
  },
  costs {
    if (!$1->spilled)
      cost_copy($2->r, $1->r);
  },
  debug {
    if ($1->spilled)
      dumpRM("movb", $2->r, 'b', $1);
    else
      dump_copy("movl", $2->r, $1->r, 'l');
  },
  emit {
    if ($1->spilled) {
      rtx src = gen_rtx_REG(QImode, $2->r);
      rtx dst = gen_rtx_MEM(QImode, $1->rtl);
      icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
    }
    else {
      rtx src = gen_rtx_REG(SImode, $2->r);
      rtx dst = gen_rtx_REG(SImode, $1->r);
      icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
    }
  };
#line 106 "x86-64.int.py"
stmt : SET_ALL(SUBREG_SI(lhs16, CONST_0), r32) [0, 0]
#line 112 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  coalesce {
    if (!$1->spilled)
      coalesces += attempt_coalesce(pass, $1->r, $2->r);
  },
  build {
    if ($1->spilled) {
      sparseset_set_bit(live, find($2->r));
      add_addr(live, $1);
    }
    else
      add_copy_edges($1->r, $2->r, live);
  },
  costs {
    if (!$1->spilled)
      cost_copy($2->r, $1->r);
  },
  debug {
    if ($1->spilled)
      dumpRM("movw", $2->r, 'w', $1);
    else
      dump_copy("movl", $2->r, $1->r, 'l');
  },
  emit {
    if ($1->spilled) {
      rtx src = gen_rtx_REG(HImode, $2->r);
      rtx dst = gen_rtx_MEM(HImode, $1->rtl);
      icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
    }
    else {
      rtx src = gen_rtx_REG(SImode, $2->r);
      rtx dst = gen_rtx_REG(SImode, $1->r);
      icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
    }
  };
#line 107 "x86-64.int.py"
stmt : SET_ALL(SUBREG_SI(lhs8,  CONST_0), r32) [0, 0]
#line 112 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  coalesce {
    if (!$1->spilled)
      coalesces += attempt_coalesce(pass, $1->r, $2->r);
  },
  build {
    if ($1->spilled) {
      sparseset_set_bit(live, find($2->r));
      add_addr(live, $1);
    }
    else
      add_copy_edges($1->r, $2->r, live);
  },
  costs {
    if (!$1->spilled)
      cost_copy($2->r, $1->r);
  },
  debug {
    if ($1->spilled)
      dumpRM("movb", $2->r, 'b', $1);
    else
      dump_copy("movl", $2->r, $1->r, 'l');
  },
  emit {
    if ($1->spilled) {
      rtx src = gen_rtx_REG(QImode, $2->r);
      rtx dst = gen_rtx_MEM(QImode, $1->rtl);
      icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
    }
    else {
      rtx src = gen_rtx_REG(SImode, $2->r);
      rtx dst = gen_rtx_REG(SImode, $1->r);
      icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
    }
  };
#line 108 "x86-64.int.py"
stmt : SET_ALL(SUBREG_HI(lhs8,  CONST_0), r16) [0, 0]
#line 112 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  coalesce {
    if (!$1->spilled)
      coalesces += attempt_coalesce(pass, $1->r, $2->r);
  },
  build {
    if ($1->spilled) {
      sparseset_set_bit(live, find($2->r));
      add_addr(live, $1);
    }
    else
      add_copy_edges($1->r, $2->r, live);
  },
  costs {
    if (!$1->spilled)
      cost_copy($2->r, $1->r);
  },
  debug {
    if ($1->spilled)
      dumpRM("movb", $2->r, 'b', $1);
    else
      dump_copy("movl", $2->r, $1->r, 'l');
  },
  emit {
    if ($1->spilled) {
      rtx src = gen_rtx_REG(QImode, $2->r);
      rtx dst = gen_rtx_MEM(QImode, $1->rtl);
      icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
    }
    else {
      rtx src = gen_rtx_REG(SImode, $2->r);
      rtx dst = gen_rtx_REG(SImode, $1->r);
      icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
    }
  };
#line 155 "x86-64.int.py"
stmt : SET_ALL(MEM_DI(addr), imm32) [3, 2]
#line 162 "x86-64.int.py"
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("movq", $2, $1);
  },
  emit {
    rtx src = gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl);
    rtx dst = gen_rtx_MEM(DImode, $1->rtl);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 156 "x86-64.int.py"
stmt : SET_ALL(MEM_SI(addr), imm32) [3, 1]
#line 162 "x86-64.int.py"
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("movl", $2, $1);
  },
  emit {
    rtx src = gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl);
    rtx dst = gen_rtx_MEM(SImode, $1->rtl);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 157 "x86-64.int.py"
stmt : SET_ALL(MEM_HI(addr), imm16) [3, 2]
#line 162 "x86-64.int.py"
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("movw", $2, $1);
  },
  emit {
    rtx src = gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl);
    rtx dst = gen_rtx_MEM(HImode, $1->rtl);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 158 "x86-64.int.py"
stmt : SET_ALL(MEM_QI(addr), imm8) [3, 1]
#line 162 "x86-64.int.py"
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("movb", $2, $1);
  },
  emit {
    rtx src = gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl);
    rtx dst = gen_rtx_MEM(QImode, $1->rtl);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 187 "x86-64.int.py"
r64 : REG_DI [0, 0]
#line 194 "x86-64.int.py"
  kinds {
    icg_reg_vector[$$->r].kind = INT_REGISTER;
  },
  costs {
    cost_load($$->r);
  },
  spill {
    dirty |= make_spill_code(find($$->r), $$);
  },
  final {
    $$->r = icg_reg_vector[find($$->r)].color;
  };
#line 188 "x86-64.int.py"
r32 : REG_SI [0, 0]
#line 194 "x86-64.int.py"
  kinds {
    icg_reg_vector[$$->r].kind = INT_REGISTER;
  },
  costs {
    cost_load($$->r);
  },
  spill {
    dirty |= make_spill_code(find($$->r), $$);
  },
  final {
    $$->r = icg_reg_vector[find($$->r)].color;
  };
#line 189 "x86-64.int.py"
r16 : REG_HI [0, 0]
#line 194 "x86-64.int.py"
  kinds {
    icg_reg_vector[$$->r].kind = INT_REGISTER;
  },
  costs {
    cost_load($$->r);
  },
  spill {
    dirty |= make_spill_code(find($$->r), $$);
  },
  final {
    $$->r = icg_reg_vector[find($$->r)].color;
  };
#line 190 "x86-64.int.py"
r8  : REG_QI [0, 0]
#line 194 "x86-64.int.py"
  kinds {
    icg_reg_vector[$$->r].kind = INT_REGISTER;
  },
  costs {
    cost_load($$->r);
  },
  spill {
    dirty |= make_spill_code(find($$->r), $$);
  },
  final {
    $$->r = icg_reg_vector[find($$->r)].color;
  };
#line 214 "x86-64.int.py"
r64x : REGX_DI [0, 0]
#line 221 "x86-64.int.py"
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  costs {
    cost_load($$->rx);
  },
  supairs {
    $$->extra = 0;
    $$->freed = 0;
  },
  spill {
    dirty |= make_spill_code(find($$->rx), $$);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  };
#line 215 "x86-64.int.py"
r32x : REGX_SI [0, 0]
#line 221 "x86-64.int.py"
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  costs {
    cost_load($$->rx);
  },
  supairs {
    $$->extra = 0;
    $$->freed = 0;
  },
  spill {
    dirty |= make_spill_code(find($$->rx), $$);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  };
#line 216 "x86-64.int.py"
r16x : REGX_HI [0, 0]
#line 221 "x86-64.int.py"
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  costs {
    cost_load($$->rx);
  },
  supairs {
    $$->extra = 0;
    $$->freed = 0;
  },
  spill {
    dirty |= make_spill_code(find($$->rx), $$);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  };
#line 217 "x86-64.int.py"
r8x  : REGX_QI [0, 0]
#line 221 "x86-64.int.py"
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  costs {
    cost_load($$->rx);
  },
  supairs {
    $$->extra = 0;
    $$->freed = 0;
  },
  spill {
    dirty |= make_spill_code(find($$->rx), $$);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  };
#line 250 "x86-64.int.py"
r32 : rz32 [0, 0]
#line 282 "x86-64.int.py"
    ;
#line 251 "x86-64.int.py"
r16 : rz16 [0, 0]
#line 282 "x86-64.int.py"
    ;
#line 252 "x86-64.int.py"
r16 : rs16 [0, 0]
#line 282 "x86-64.int.py"
    ;
#line 253 "x86-64.int.py"
r8  : rz8 [0, 0]
#line 282 "x86-64.int.py"
    ;
#line 254 "x86-64.int.py"
r8  : rs8 [0, 0]
#line 282 "x86-64.int.py"
    ;
#line 256 "x86-64.int.py"
r32x : rz32x [0, 0]
#line 282 "x86-64.int.py"
    ;
#line 257 "x86-64.int.py"
r16x : rz16x [0, 0]
#line 282 "x86-64.int.py"
    ;
#line 258 "x86-64.int.py"
r16x : rs16x [0, 0]
#line 282 "x86-64.int.py"
    ;
#line 259 "x86-64.int.py"
r8x  : rz8x [0, 0]
#line 282 "x86-64.int.py"
    ;
#line 260 "x86-64.int.py"
r8x  : rs8x [0, 0]
#line 282 "x86-64.int.py"
    ;
#line 262 "x86-64.int.py"
ccr32x : ccrz32x [0, 0]
#line 282 "x86-64.int.py"
    ;
#line 263 "x86-64.int.py"
ccr16x : ccrz16x [0, 0]
#line 282 "x86-64.int.py"
    ;
#line 264 "x86-64.int.py"
ccr16x : ccrs16x [0, 0]
#line 282 "x86-64.int.py"
    ;
#line 265 "x86-64.int.py"
ccr8x  : ccrz8x [0, 0]
#line 282 "x86-64.int.py"
    ;
#line 266 "x86-64.int.py"
ccr8x  : ccrs8x [0, 0]
#line 282 "x86-64.int.py"
    ;
#line 270 "x86-64.int.py"
r64x  : ccr64x [0, 0]
#line 282 "x86-64.int.py"
    ;
#line 271 "x86-64.int.py"
r32x  : ccr32x [0, 0]
#line 282 "x86-64.int.py"
    ;
#line 272 "x86-64.int.py"
rz32x : ccrz32x [0, 0]
#line 282 "x86-64.int.py"
    ;
#line 273 "x86-64.int.py"
r16x  : ccr16x [0, 0]
#line 282 "x86-64.int.py"
    ;
#line 274 "x86-64.int.py"
rz16x : ccrz16x [0, 0]
#line 282 "x86-64.int.py"
    ;
#line 275 "x86-64.int.py"
rs16x : ccrs16x [0, 0]
#line 282 "x86-64.int.py"
    ;
#line 276 "x86-64.int.py"
r8x   : ccr8x [0, 0]
#line 282 "x86-64.int.py"
    ;
#line 277 "x86-64.int.py"
rz8x  : ccrz8x [0, 0]
#line 282 "x86-64.int.py"
    ;
#line 278 "x86-64.int.py"
rs8x  : ccrs8x [0, 0]
#line 282 "x86-64.int.py"
    ;
#line 294 "x86-64.int.py"
r32:  TRUNCATE_SI(r64) [0, 0]
#line 319 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 295 "x86-64.int.py"
r16:  TRUNCATE_HI(r64) [0, 0]
#line 319 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 296 "x86-64.int.py"
r8:   TRUNCATE_QI(r64) [0, 0]
#line 319 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 297 "x86-64.int.py"
r16:  TRUNCATE_HI(r32) [0, 0]
#line 319 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 298 "x86-64.int.py"
r8:   TRUNCATE_QI(r32) [0, 0]
#line 319 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 299 "x86-64.int.py"
r8:   TRUNCATE_QI(r16) [0, 0]
#line 319 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 302 "x86-64.int.py"
r32 : SUBREG_SI(r64, CONST_0) [0, 0]
#line 319 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 303 "x86-64.int.py"
r16 : SUBREG_HI(r64, CONST_0) [0, 0]
#line 319 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 304 "x86-64.int.py"
r8  : SUBREG_QI(r64, CONST_0) [0, 0]
#line 319 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 305 "x86-64.int.py"
r16 : SUBREG_HI(r32, CONST_0) [0, 0]
#line 319 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 306 "x86-64.int.py"
r8  : SUBREG_QI(r32, CONST_0) [0, 0]
#line 319 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 307 "x86-64.int.py"
r8  : SUBREG_QI(r16, CONST_0) [0, 0]
#line 319 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 310 "x86-64.int.py"
r64 : SUBREG_DI(r32, CONST_0) [0, 0]
#line 319 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 311 "x86-64.int.py"
r64 : SUBREG_DI(r16, CONST_0) [0, 0]
#line 319 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 312 "x86-64.int.py"
r64 : SUBREG_DI(r8,  CONST_0) [0, 0]
#line 319 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 313 "x86-64.int.py"
r32 : SUBREG_SI(r16, CONST_0) [0, 0]
#line 319 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 314 "x86-64.int.py"
r32 : SUBREG_SI(r8,  CONST_0) [0, 0]
#line 319 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 315 "x86-64.int.py"
r16 : SUBREG_HI(r8,  CONST_0) [0, 0]
#line 319 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 333 "x86-64.int.py"
r32x: TRUNCATE_SI(r64x) [0, 0]
#line 356 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 334 "x86-64.int.py"
r16x: TRUNCATE_HI(r64x) [0, 0]
#line 356 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 335 "x86-64.int.py"
r8x:  TRUNCATE_QI(r64x) [0, 0]
#line 356 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 336 "x86-64.int.py"
r16x: TRUNCATE_HI(r32x) [0, 0]
#line 356 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 337 "x86-64.int.py"
r8x:  TRUNCATE_QI(r32x) [0, 0]
#line 356 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 338 "x86-64.int.py"
r8x:  TRUNCATE_QI(r16x) [0, 0]
#line 356 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 340 "x86-64.int.py"
r32x : SUBREG_SI(r64x, CONST_0) [0, 0]
#line 356 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 341 "x86-64.int.py"
r16x : SUBREG_HI(r64x, CONST_0) [0, 0]
#line 356 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 342 "x86-64.int.py"
r8x  : SUBREG_QI(r64x, CONST_0) [0, 0]
#line 356 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 343 "x86-64.int.py"
r16x : SUBREG_HI(r32x, CONST_0) [0, 0]
#line 356 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 344 "x86-64.int.py"
r8x  : SUBREG_QI(r32x, CONST_0) [0, 0]
#line 356 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 345 "x86-64.int.py"
r8x  : SUBREG_QI(r16x, CONST_0) [0, 0]
#line 356 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 347 "x86-64.int.py"
r64x : SUBREG_DI(r32x, CONST_0) [0, 0]
#line 356 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 348 "x86-64.int.py"
r64x : SUBREG_DI(r16x, CONST_0) [0, 0]
#line 356 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 349 "x86-64.int.py"
r64x : SUBREG_DI(r8x,  CONST_0) [0, 0]
#line 356 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 350 "x86-64.int.py"
r32x : SUBREG_SI(r16x, CONST_0) [0, 0]
#line 356 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 351 "x86-64.int.py"
r32x : SUBREG_SI(r8x,  CONST_0) [0, 0]
#line 356 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 352 "x86-64.int.py"
r16x : SUBREG_HI(r8x,  CONST_0) [0, 0]
#line 356 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 374 "x86-64.int.py"
r64  : r64x [0, 0]
#line 386 "x86-64.int.py"
  supairs {
    $$->freed++; /* assuming that the register will eventually be freed */
  },
  names {
    $$->r = $1->rx;
  },
  final {
    $$->r = $1->rx;
  };
#line 375 "x86-64.int.py"
r32  : r32x [0, 0]
#line 386 "x86-64.int.py"
  supairs {
    $$->freed++; /* assuming that the register will eventually be freed */
  },
  names {
    $$->r = $1->rx;
  },
  final {
    $$->r = $1->rx;
  };
#line 376 "x86-64.int.py"
rz32 : rz32x [0, 0]
#line 386 "x86-64.int.py"
  supairs {
    $$->freed++; /* assuming that the register will eventually be freed */
  },
  names {
    $$->r = $1->rx;
  },
  final {
    $$->r = $1->rx;
  };
#line 377 "x86-64.int.py"
r16  : r16x [0, 0]
#line 386 "x86-64.int.py"
  supairs {
    $$->freed++; /* assuming that the register will eventually be freed */
  },
  names {
    $$->r = $1->rx;
  },
  final {
    $$->r = $1->rx;
  };
#line 378 "x86-64.int.py"
rz16 : rz16x [0, 0]
#line 386 "x86-64.int.py"
  supairs {
    $$->freed++; /* assuming that the register will eventually be freed */
  },
  names {
    $$->r = $1->rx;
  },
  final {
    $$->r = $1->rx;
  };
#line 379 "x86-64.int.py"
rs16 : rs16x [0, 0]
#line 386 "x86-64.int.py"
  supairs {
    $$->freed++; /* assuming that the register will eventually be freed */
  },
  names {
    $$->r = $1->rx;
  },
  final {
    $$->r = $1->rx;
  };
#line 380 "x86-64.int.py"
r8   : r8x [0, 0]
#line 386 "x86-64.int.py"
  supairs {
    $$->freed++; /* assuming that the register will eventually be freed */
  },
  names {
    $$->r = $1->rx;
  },
  final {
    $$->r = $1->rx;
  };
#line 381 "x86-64.int.py"
rz8  : rz8x [0, 0]
#line 386 "x86-64.int.py"
  supairs {
    $$->freed++; /* assuming that the register will eventually be freed */
  },
  names {
    $$->r = $1->rx;
  },
  final {
    $$->r = $1->rx;
  };
#line 382 "x86-64.int.py"
rs8  : rs8x [0, 0]
#line 386 "x86-64.int.py"
  supairs {
    $$->freed++; /* assuming that the register will eventually be freed */
  },
  names {
    $$->r = $1->rx;
  },
  final {
    $$->r = $1->rx;
  };
#line 402 "x86-64.int.py"
r64x  : r64 [1, 3]
#line 413 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $$->rx, $1->r);
  },
  build {
    add_copy_edges($$->rx, $1->r, live);
  },
  costs {
    cost_copy($$->rx, $1->r);
  },
  debug {
    dump_copy("movq", $1->r, $$->rx, 'q');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = gen_rtx_REG(DImode, $1->r);
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 403 "x86-64.int.py"
rz32x : r32 [1, 2]
#line 413 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $$->rx, $1->r);
  },
  build {
    add_copy_edges($$->rx, $1->r, live);
  },
  costs {
    cost_copy($$->rx, $1->r);
  },
  debug {
    dump_copy("movl", $1->r, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = gen_rtx_REG(SImode, $1->r);
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 404 "x86-64.int.py"
r16x  : r16 [1, 2]
#line 413 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $$->rx, $1->r);
  },
  build {
    add_copy_edges($$->rx, $1->r, live);
  },
  costs {
    cost_copy($$->rx, $1->r);
  },
  debug {
    dump_copy("movl", $1->r, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = gen_rtx_REG(SImode, $1->r);
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 405 "x86-64.int.py"
rz16x : rz16 [1, 2]
#line 413 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $$->rx, $1->r);
  },
  build {
    add_copy_edges($$->rx, $1->r, live);
  },
  costs {
    cost_copy($$->rx, $1->r);
  },
  debug {
    dump_copy("movl", $1->r, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = gen_rtx_REG(SImode, $1->r);
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 406 "x86-64.int.py"
rs16x : rs16 [1, 2]
#line 413 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $$->rx, $1->r);
  },
  build {
    add_copy_edges($$->rx, $1->r, live);
  },
  costs {
    cost_copy($$->rx, $1->r);
  },
  debug {
    dump_copy("movl", $1->r, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = gen_rtx_REG(SImode, $1->r);
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 407 "x86-64.int.py"
r8x   : r8 [1, 2]
#line 413 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $$->rx, $1->r);
  },
  build {
    add_copy_edges($$->rx, $1->r, live);
  },
  costs {
    cost_copy($$->rx, $1->r);
  },
  debug {
    dump_copy("movl", $1->r, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = gen_rtx_REG(SImode, $1->r);
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 408 "x86-64.int.py"
rz8x  : rz8 [1, 2]
#line 413 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $$->rx, $1->r);
  },
  build {
    add_copy_edges($$->rx, $1->r, live);
  },
  costs {
    cost_copy($$->rx, $1->r);
  },
  debug {
    dump_copy("movl", $1->r, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = gen_rtx_REG(SImode, $1->r);
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 409 "x86-64.int.py"
rs8x  : rs8 [1, 2]
#line 413 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $$->rx, $1->r);
  },
  build {
    add_copy_edges($$->rx, $1->r, live);
  },
  costs {
    cost_copy($$->rx, $1->r);
  },
  debug {
    dump_copy("movl", $1->r, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = gen_rtx_REG(SImode, $1->r);
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 454 "x86-64.int.py"
r64    : PLUS_DI(r64     | CONST_0) [0, 0]
#line 476 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 455 "x86-64.int.py"
r32    : PLUS_SI(r32     | CONST_0) [0, 0]
#line 476 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 456 "x86-64.int.py"
r16    : PLUS_HI(r16     | CONST_0) [0, 0]
#line 476 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 457 "x86-64.int.py"
r8     : PLUS_QI(r8      | CONST_0) [0, 0]
#line 476 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 458 "x86-64.int.py"
rz32   : PLUS_SI(rz32    | CONST_0) [0, 0]
#line 476 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 459 "x86-64.int.py"
rz16   : PLUS_HI(rz16    | CONST_0) [0, 0]
#line 476 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 460 "x86-64.int.py"
rz8    : PLUS_QI(rz8     | CONST_0) [0, 0]
#line 476 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 461 "x86-64.int.py"
rs16   : PLUS_HI(rs16    | CONST_0) [0, 0]
#line 476 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 462 "x86-64.int.py"
rs8    : PLUS_QI(rs8     | CONST_0) [0, 0]
#line 476 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 464 "x86-64.int.py"
r64    : MINUS_DI(r64    | CONST_0) [0, 0]
#line 476 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 465 "x86-64.int.py"
r32    : MINUS_SI(r32    | CONST_0) [0, 0]
#line 476 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 466 "x86-64.int.py"
r16    : MINUS_HI(r16    | CONST_0) [0, 0]
#line 476 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 467 "x86-64.int.py"
r8     : MINUS_QI(r8     | CONST_0) [0, 0]
#line 476 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 468 "x86-64.int.py"
rz32   : MINUS_SI(rz32   | CONST_0) [0, 0]
#line 476 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 469 "x86-64.int.py"
rz16   : MINUS_HI(rz16   | CONST_0) [0, 0]
#line 476 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 470 "x86-64.int.py"
rz8    : MINUS_QI(rz8    | CONST_0) [0, 0]
#line 476 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 471 "x86-64.int.py"
rs16   : MINUS_HI(rs16   | CONST_0) [0, 0]
#line 476 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 472 "x86-64.int.py"
rs8    : MINUS_QI(rs8    | CONST_0) [0, 0]
#line 476 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 494 "x86-64.int.py"
r64x    : PLUS_DI(r64x     | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 495 "x86-64.int.py"
r32x    : PLUS_SI(r32x     | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 496 "x86-64.int.py"
r16x    : PLUS_HI(r16x     | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 497 "x86-64.int.py"
r8x     : PLUS_QI(r8x      | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 498 "x86-64.int.py"
rz32x   : PLUS_SI(rz32x    | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 499 "x86-64.int.py"
rz16x   : PLUS_HI(rz16x    | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 500 "x86-64.int.py"
rz8x    : PLUS_QI(rz8x     | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 501 "x86-64.int.py"
rs16x   : PLUS_HI(rs16x    | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 502 "x86-64.int.py"
rs8x    : PLUS_QI(rs8x     | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 504 "x86-64.int.py"
ccr64x  : PLUS_DI(ccr64x   | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 505 "x86-64.int.py"
ccr32x  : PLUS_SI(ccr32x   | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 506 "x86-64.int.py"
ccr16x  : PLUS_HI(ccr16x   | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 507 "x86-64.int.py"
ccr8x   : PLUS_QI(ccr8x    | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 508 "x86-64.int.py"
ccrz32x : PLUS_SI(ccrz32x  | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 509 "x86-64.int.py"
ccrz16x : PLUS_HI(ccrz16x  | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 510 "x86-64.int.py"
ccrz8x  : PLUS_QI(ccrz8x   | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 511 "x86-64.int.py"
ccrs16x : PLUS_HI(ccrs16x  | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 512 "x86-64.int.py"
ccrs8x  : PLUS_QI(ccrs8x   | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 514 "x86-64.int.py"
r64x    : MINUS_DI(r64x    | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 515 "x86-64.int.py"
r32x    : MINUS_SI(r32x    | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 516 "x86-64.int.py"
r16x    : MINUS_HI(r16x    | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 517 "x86-64.int.py"
r8x     : MINUS_QI(r8x     | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 518 "x86-64.int.py"
rz32x   : MINUS_SI(rz32x   | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 519 "x86-64.int.py"
rz16x   : MINUS_HI(rz16x   | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 520 "x86-64.int.py"
rz8x    : MINUS_QI(rz8x    | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 521 "x86-64.int.py"
rs16x   : MINUS_HI(rs16x   | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 522 "x86-64.int.py"
rs8x    : MINUS_QI(rs8x    | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 524 "x86-64.int.py"
ccr64x  : MINUS_DI(ccr64x  | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 525 "x86-64.int.py"
ccr32x  : MINUS_SI(ccr32x  | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 526 "x86-64.int.py"
ccr16x  : MINUS_HI(ccr16x  | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 527 "x86-64.int.py"
ccr8x   : MINUS_QI(ccr8x   | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 528 "x86-64.int.py"
ccrz32x : MINUS_SI(ccrz32x | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 529 "x86-64.int.py"
ccrz16x : MINUS_HI(ccrz16x | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 530 "x86-64.int.py"
ccrz8x  : MINUS_QI(ccrz8x  | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 531 "x86-64.int.py"
ccrs16x : MINUS_HI(ccrs16x | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 532 "x86-64.int.py"
ccrs8x  : MINUS_QI(ccrs8x  | CONST_0) [0, 0]
#line 536 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 559 "x86-64.int.py"
ccr64x  : CONST_0 [1, 2]
#line 570 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    $$->extra = 1;
    $$->freed = 0;
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
  },
  remat {
    flags |= RHS_REMAT;
  },
  debug {
    dumpRR("xorl", $$->rx, 'l', $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_XOR(SImode, dst, dst);
    icg_emit_clobber(gen_rtx_SET(SImode, dst, src));
  };
#line 560 "x86-64.int.py"
ccrz32x : CONST_0 [1, 2]
#line 570 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    $$->extra = 1;
    $$->freed = 0;
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
  },
  remat {
    flags |= RHS_REMAT;
  },
  debug {
    dumpRR("xorl", $$->rx, 'l', $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_XOR(SImode, dst, dst);
    icg_emit_clobber(gen_rtx_SET(SImode, dst, src));
  };
#line 561 "x86-64.int.py"
ccrz16x : CONST_0 [1, 2]
#line 570 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    $$->extra = 1;
    $$->freed = 0;
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
  },
  remat {
    flags |= RHS_REMAT;
  },
  debug {
    dumpRR("xorl", $$->rx, 'l', $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_XOR(SImode, dst, dst);
    icg_emit_clobber(gen_rtx_SET(SImode, dst, src));
  };
#line 562 "x86-64.int.py"
ccrs16x : CONST_0 [1, 2]
#line 570 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    $$->extra = 1;
    $$->freed = 0;
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
  },
  remat {
    flags |= RHS_REMAT;
  },
  debug {
    dumpRR("xorl", $$->rx, 'l', $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_XOR(SImode, dst, dst);
    icg_emit_clobber(gen_rtx_SET(SImode, dst, src));
  };
#line 563 "x86-64.int.py"
ccrz8x  : CONST_0 [1, 2]
#line 570 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    $$->extra = 1;
    $$->freed = 0;
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
  },
  remat {
    flags |= RHS_REMAT;
  },
  debug {
    dumpRR("xorl", $$->rx, 'l', $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_XOR(SImode, dst, dst);
    icg_emit_clobber(gen_rtx_SET(SImode, dst, src));
  };
#line 564 "x86-64.int.py"
ccrs8x  : CONST_0 [1, 2]
#line 570 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    $$->extra = 1;
    $$->freed = 0;
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
  },
  remat {
    flags |= RHS_REMAT;
  },
  debug {
    dumpRR("xorl", $$->rx, 'l', $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_XOR(SImode, dst, dst);
    icg_emit_clobber(gen_rtx_SET(SImode, dst, src));
  };
#line 559 "x86-64.int.py"
rdx  : CONST_0 [2, 4]
#line 570 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = FLOAT_REGISTER;
  },
  supairs {
    $$->extra = 1;
    $$->freed = 0;
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
  },
  remat {
    flags |= RHS_REMAT;
  },
  debug {
    dumpRR("xorpd", $$->rx, 'x', $$->rx, 'x');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(DFmode, $$->rx);
    rtx src = gen_rtx_XOR(DFmode, dst, dst);
    icg_emit_clobber(gen_rtx_SET(DFmode, dst, src));
  };
#line 559 "x86-64.int.py"
rfx  : CONST_0 [2, 4]
#line 570 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = FLOAT_REGISTER;
  },
  supairs {
    $$->extra = 1;
    $$->freed = 0;
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
  },
  remat {
    flags |= RHS_REMAT;
  },
  debug {
    dumpRR("xorps", $$->rx, 'x', $$->rx, 'x');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SFmode, $$->rx);
    rtx src = gen_rtx_XOR(SFmode, dst, dst);
    icg_emit_clobber(gen_rtx_SET(SFmode, dst, src));
  };
#line 605 "x86-64.int.py"
r64x  : imm64 [1, 2]
#line 624 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    $$->extra = 1;
    $$->freed = 0;
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
  },
  remat {
    flags |= RHS_REMAT;
  },
  debug {
    dumpIR("movabsq", $1, $$->rx, 'q');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = gen_rtx_imm_constant($1->val, $1->a.string, $1->rtl);
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 606 "x86-64.int.py"
r64x  : pos32 [1, 1]
#line 624 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    $$->extra = 1;
    $$->freed = 0;
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
  },
  remat {
    flags |= RHS_REMAT;
  },
  debug {
    dumpIR("movl", $1, $$->rx, 'd');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = gen_rtx_imm_constant($1->val, $1->a.string, $1->rtl);
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 607 "x86-64.int.py"
rz32x : imm32 [1, 1]
#line 624 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    $$->extra = 1;
    $$->freed = 0;
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
  },
  remat {
    flags |= RHS_REMAT;
  },
  debug {
    dumpIR("movl", $1, $$->rx, 'd');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = gen_rtx_imm_constant($1->val, $1->a.string, $1->rtl);
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 612 "x86-64.int.py"
r16x : imm16 [2, 2]
#line 624 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    $$->extra = 1;
    $$->freed = 0;
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
  },
  remat {
    flags |= RHS_REMAT;
  },
  debug {
    dumpIR("movw", $1, $$->rx, 'w');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = gen_rtx_imm_constant($1->val, $1->a.string, $1->rtl);
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 613 "x86-64.int.py"
r8x  : imm8 [2, 1]
#line 624 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    $$->extra = 1;
    $$->freed = 0;
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
  },
  remat {
    flags |= RHS_REMAT;
  },
  debug {
    dumpIR("movb", $1, $$->rx, 'b');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = gen_rtx_imm_constant($1->val, $1->a.string, $1->rtl);
    rtx dst = gen_rtx_REG(QImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 617 "x86-64.int.py"
r16x  : imm32 [1, 1]
#line 624 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    $$->extra = 1;
    $$->freed = 0;
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
  },
  remat {
    flags |= RHS_REMAT;
  },
  debug {
    dumpIR("movl", $1, $$->rx, 'd');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = gen_rtx_imm_constant($1->val, $1->a.string, $1->rtl);
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 618 "x86-64.int.py"
rz16x : pos16 [1, 3]
#line 624 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    $$->extra = 1;
    $$->freed = 0;
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
  },
  remat {
    flags |= RHS_REMAT;
  },
  debug {
    dumpIR("movl", $1, $$->rx, 'd');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = gen_rtx_imm_constant($1->val, $1->a.string, $1->rtl);
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 619 "x86-64.int.py"
r8x   : imm32 [1, 1]
#line 624 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    $$->extra = 1;
    $$->freed = 0;
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
  },
  remat {
    flags |= RHS_REMAT;
  },
  debug {
    dumpIR("movl", $1, $$->rx, 'd');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = gen_rtx_imm_constant($1->val, $1->a.string, $1->rtl);
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 620 "x86-64.int.py"
rz8x  : pos8 [1, 4]
#line 624 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    $$->extra = 1;
    $$->freed = 0;
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
  },
  remat {
    flags |= RHS_REMAT;
  },
  debug {
    dumpIR("movl", $1, $$->rx, 'd');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx src = gen_rtx_imm_constant($1->val, $1->a.string, $1->rtl);
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 670 "x86-64.int.py"
r64x  : PLUS_DI(r64x   | CONST_P1) [1, 3]
#line 711 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("incq", $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_PLUS(DImode, dst, GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 671 "x86-64.int.py"
rz32x : PLUS_SI(r32x   | CONST_P1) [1, 2]
#line 711 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("incl", $$->rx, 'd');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_PLUS(SImode, dst, GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 687 "x86-64.int.py"
r16x  : PLUS_HI(r16x   | CONST_P1) [1, 3]
#line 711 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("incw", $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_PLUS(HImode, dst, GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 673 "x86-64.int.py"
r8x   : PLUS_QI(r8x    | CONST_P1) [1, 2]
#line 711 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("incb", $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_PLUS(QImode, dst, GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 675 "x86-64.int.py"
r64x  : PLUS_DI(r64x   | CONST_N1) [1, 3]
#line 711 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("decq", $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_MINUS(DImode, dst, GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 676 "x86-64.int.py"
rz32x : PLUS_SI(r32x   | CONST_N1) [1, 2]
#line 711 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("decl", $$->rx, 'd');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_MINUS(SImode, dst, GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 688 "x86-64.int.py"
r16x  : PLUS_HI(r16x   | CONST_N1) [1, 3]
#line 711 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("decw", $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MINUS(HImode, dst, GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 678 "x86-64.int.py"
r8x   : PLUS_QI(r8x    | CONST_N1) [1, 2]
#line 711 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("decb", $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_MINUS(QImode, dst, GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 681 "x86-64.int.py"
rz16x : PLUS_HI(rz16x  | CONST_P1) [1, 3]
#line 711 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("incw", $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_PLUS(HImode, dst, GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 682 "x86-64.int.py"
rz8x  : PLUS_QI(rz8x   | CONST_P1) [1, 2]
#line 711 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("incb", $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_PLUS(QImode, dst, GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 683 "x86-64.int.py"
rz16x : PLUS_HI(rz16x  | CONST_N1) [1, 3]
#line 711 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("decw", $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MINUS(HImode, dst, GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 684 "x86-64.int.py"
rz8x  : PLUS_QI(rz8x   | CONST_N1) [1, 2]
#line 711 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("decb", $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_MINUS(QImode, dst, GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 687 "x86-64.int.py"
r16x  : PLUS_HI(r16x   | CONST_P1) [1, 2]
#line 711 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("incl", $$->rx, 'd');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_PLUS(SImode, dst, GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 688 "x86-64.int.py"
r16x  : PLUS_HI(r16x   | CONST_N1) [1, 2]
#line 711 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("decl", $$->rx, 'd');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_MINUS(SImode, dst, GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 691 "x86-64.int.py"
r64x  : MINUS_DI(r64x  | CONST_N1) [1, 3]
#line 711 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("incq", $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_PLUS(DImode, dst, GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 692 "x86-64.int.py"
rz32x : MINUS_SI(r32x  | CONST_N1) [1, 2]
#line 711 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("incl", $$->rx, 'd');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_PLUS(SImode, dst, GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 706 "x86-64.int.py"
r16x  : MINUS_HI(r16x  | CONST_N1) [1, 3]
#line 711 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("incw", $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_PLUS(HImode, dst, GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 694 "x86-64.int.py"
r8x   : MINUS_QI(r8x   | CONST_N1) [1, 2]
#line 711 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("incb", $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_PLUS(QImode, dst, GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 696 "x86-64.int.py"
r64x  : MINUS_DI(r64x  | CONST_P1) [1, 3]
#line 711 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("decq", $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_MINUS(DImode, dst, GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 697 "x86-64.int.py"
rz32x : MINUS_SI(r32x  | CONST_P1) [1, 2]
#line 711 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("decl", $$->rx, 'd');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_MINUS(SImode, dst, GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 707 "x86-64.int.py"
r16x  : MINUS_HI(r16x  | CONST_P1) [1, 3]
#line 711 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("decw", $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MINUS(HImode, dst, GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 699 "x86-64.int.py"
r8x   : MINUS_QI(r8x   | CONST_P1) [1, 2]
#line 711 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("decb", $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_MINUS(QImode, dst, GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 701 "x86-64.int.py"
rz16x : MINUS_HI(rz16x | CONST_N1) [1, 3]
#line 711 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("incw", $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_PLUS(HImode, dst, GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 702 "x86-64.int.py"
rz8x  : MINUS_QI(rz8x  | CONST_N1) [1, 2]
#line 711 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("incb", $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_PLUS(QImode, dst, GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 703 "x86-64.int.py"
rz16x : MINUS_HI(rz16x | CONST_P1) [1, 3]
#line 711 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("decw", $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MINUS(HImode, dst, GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 704 "x86-64.int.py"
rz8x  : MINUS_QI(rz8x  | CONST_P1) [1, 2]
#line 711 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("decb", $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_MINUS(QImode, dst, GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 706 "x86-64.int.py"
r16x  : MINUS_HI(r16x  | CONST_N1) [1, 2]
#line 711 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("incl", $$->rx, 'd');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_PLUS(SImode, dst, GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 707 "x86-64.int.py"
r16x  : MINUS_HI(r16x  | CONST_P1) [1, 2]
#line 711 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("decl", $$->rx, 'd');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_MINUS(SImode, dst, GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 742 "x86-64.int.py"
ccr64x  : PLUS_DI(r64x | imm8) [1, 3]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("addq", $2, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_PLUS(DImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 743 "x86-64.int.py"
ccr64x  : PLUS_DI(r64x | imm32) [1, 3]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("addq", $2, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_PLUS(DImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 744 "x86-64.int.py"
ccrz32x : PLUS_SI(r32x | imm8) [1, 2]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("addl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_PLUS(SImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 745 "x86-64.int.py"
ccrz32x : PLUS_SI(r32x | imm32) [1, 2]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("addl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_PLUS(SImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 746 "x86-64.int.py"
ccr16x  : PLUS_HI(r16x | imm8) [1, 3]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("addw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_PLUS(HImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 747 "x86-64.int.py"
ccr16x  : PLUS_HI(r16x | imm16) [1, 3]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("addw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_PLUS(HImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 748 "x86-64.int.py"
ccr8x   : PLUS_QI(r8x  | imm8) [1, 2]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("addb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_PLUS(QImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 751 "x86-64.int.py"
ccrz16x : PLUS_HI(rz16x | imm8) [1, 3]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("addw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_PLUS(HImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 752 "x86-64.int.py"
ccrz16x : PLUS_HI(rz16x | imm16) [1, 3]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("addw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_PLUS(HImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 753 "x86-64.int.py"
ccrz8x  : PLUS_QI(rz8x  | imm8) [1, 2]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("addb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_PLUS(QImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 756 "x86-64.int.py"
r16x    : PLUS_HI(r16x | imm8) [1, 2]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("addl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_PLUS(SImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 759 "x86-64.int.py"
ccr64x  : MINUS_DI(r64x, imm8) [1, 3]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("subq", $2, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_MINUS(DImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 760 "x86-64.int.py"
ccr64x  : MINUS_DI(r64x, imm32) [1, 3]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("subq", $2, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_MINUS(DImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 761 "x86-64.int.py"
ccrz32x : MINUS_SI(r32x, imm8) [1, 2]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("subl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_MINUS(SImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 762 "x86-64.int.py"
ccrz32x : MINUS_SI(r32x, imm32) [1, 2]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("subl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_MINUS(SImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 763 "x86-64.int.py"
ccr16x  : MINUS_HI(r16x, imm8) [1, 3]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("subw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MINUS(HImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 764 "x86-64.int.py"
ccr16x  : MINUS_HI(r16x, imm16) [1, 3]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("subw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MINUS(HImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 765 "x86-64.int.py"
ccr8x   : MINUS_QI(r8x,  imm8) [1, 2]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("subb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_MINUS(QImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 767 "x86-64.int.py"
ccrz16x : MINUS_HI(rz16x, imm8) [1, 3]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("subw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MINUS(HImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 768 "x86-64.int.py"
ccrz16x : MINUS_HI(rz16x, imm16) [1, 3]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("subw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MINUS(HImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 769 "x86-64.int.py"
ccrz8x  : MINUS_QI(rz8x,  imm8) [1, 2]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("subb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_MINUS(QImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 771 "x86-64.int.py"
r16x  : MINUS_HI(r16x, imm8) [1, 2]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("subl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_MINUS(SImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 774 "x86-64.int.py"
ccr64x  : AND_DI(r64x | imm8) [1, 3]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("andq", $2, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_AND(DImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 775 "x86-64.int.py"
ccr64x  : AND_DI(r64x | imm32) [1, 3]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("andq", $2, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_AND(DImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 776 "x86-64.int.py"
ccrz32x : AND_SI(r32x | imm8) [1, 2]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("andl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_AND(SImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 777 "x86-64.int.py"
ccrz32x : AND_SI(r32x | imm32) [1, 2]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("andl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_AND(SImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 778 "x86-64.int.py"
ccr16x  : AND_HI(r16x | imm8) [1, 3]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("andw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_AND(HImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 779 "x86-64.int.py"
ccr16x  : AND_HI(r16x | imm16) [1, 3]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("andw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_AND(HImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 780 "x86-64.int.py"
ccr8x   : AND_QI(r8x  | imm8) [1, 2]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("andb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_AND(QImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 783 "x86-64.int.py"
r16x    : AND_HI(r16x | imm8) [1, 2]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("andl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_AND(SImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 786 "x86-64.int.py"
ccr64x  : XOR_DI(r64x | imm8) [1, 3]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("xorq", $2, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_XOR(DImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 787 "x86-64.int.py"
ccr64x  : XOR_DI(r64x | imm32) [1, 3]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("xorq", $2, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_XOR(DImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 788 "x86-64.int.py"
ccrz32x : XOR_SI(r32x | imm8) [1, 2]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("xorl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_XOR(SImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 789 "x86-64.int.py"
ccrz32x : XOR_SI(r32x | imm32) [1, 2]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("xorl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_XOR(SImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 790 "x86-64.int.py"
ccr16x  : XOR_HI(r16x | imm8) [1, 3]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("xorw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_XOR(HImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 791 "x86-64.int.py"
ccr16x  : XOR_HI(r16x | imm16) [1, 3]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("xorw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_XOR(HImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 792 "x86-64.int.py"
ccr8x   : XOR_QI(r8x  | imm8) [1, 2]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("xorb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_XOR(QImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 794 "x86-64.int.py"
r16x    : XOR_HI(r16x | imm8) [1, 2]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("xorl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_XOR(SImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 797 "x86-64.int.py"
ccr64x  : IOR_DI(r64x | imm8) [1, 3]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("orq", $2, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_IOR(DImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 798 "x86-64.int.py"
ccr64x  : IOR_DI(r64x | imm32) [1, 3]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("orq", $2, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_IOR(DImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 799 "x86-64.int.py"
ccrz32x : IOR_SI(r32x | imm8) [1, 2]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("orl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_IOR(SImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 800 "x86-64.int.py"
ccrz32x : IOR_SI(r32x | imm32) [1, 2]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("orl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_IOR(SImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 801 "x86-64.int.py"
ccr16x  : IOR_HI(r16x | imm8) [1, 3]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("orw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_IOR(HImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 802 "x86-64.int.py"
ccr16x  : IOR_HI(r16x | imm16) [1, 3]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("orw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_IOR(HImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 803 "x86-64.int.py"
ccr8x   : IOR_QI(r8x  | imm8) [1, 2]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("orb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_IOR(QImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 805 "x86-64.int.py"
r16x    : IOR_HI(r16x | imm8) [1, 2]
#line 809 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("orl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_IOR(SImode, dst, gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 840 "x86-64.int.py"
ccr64x  : PLUS_DI(r64x  | MEM_DI(addr)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addq", $2, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_PLUS(DImode, dst, gen_rtx_MEM(DImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 841 "x86-64.int.py"
ccrz32x : PLUS_SI(r32x  | MEM_SI(addr)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_PLUS(SImode, dst, gen_rtx_MEM(SImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 842 "x86-64.int.py"
ccr16x  : PLUS_HI(r16x  | MEM_HI(addr)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_PLUS(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 843 "x86-64.int.py"
ccr8x   : PLUS_QI(r8x   | MEM_QI(addr)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_PLUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 845 "x86-64.int.py"
ccrz16x : PLUS_HI(rz16x | MEM_HI(addr)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_PLUS(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 846 "x86-64.int.py"
ccrz8x  : PLUS_QI(rz8x  | MEM_QI(addr)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_PLUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 849 "x86-64.int.py"
ccrz32x : PLUS_SI(r32x  | SUBREG_SI(MEM_DI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_PLUS(SImode, dst, gen_rtx_MEM(SImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 850 "x86-64.int.py"
ccr16x  : PLUS_HI(r16x  | SUBREG_HI(MEM_DI(addr), CONST_0)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_PLUS(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 851 "x86-64.int.py"
ccr16x  : PLUS_HI(r16x  | SUBREG_HI(MEM_SI(addr), CONST_0)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_PLUS(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 852 "x86-64.int.py"
ccr8x   : PLUS_QI(r8x   | SUBREG_QI(MEM_DI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_PLUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 853 "x86-64.int.py"
ccr8x   : PLUS_QI(r8x   | SUBREG_QI(MEM_SI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_PLUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 854 "x86-64.int.py"
ccr8x   : PLUS_QI(r8x   | SUBREG_QI(MEM_HI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_PLUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 856 "x86-64.int.py"
ccrz16x : PLUS_HI(rz16x | SUBREG_HI(MEM_DI(addr), CONST_0)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_PLUS(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 857 "x86-64.int.py"
ccrz16x : PLUS_HI(rz16x | SUBREG_HI(MEM_SI(addr), CONST_0)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_PLUS(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 858 "x86-64.int.py"
ccrz8x  : PLUS_QI(rz8x  | SUBREG_QI(MEM_DI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_PLUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 859 "x86-64.int.py"
ccrz8x  : PLUS_QI(rz8x  | SUBREG_QI(MEM_SI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_PLUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 860 "x86-64.int.py"
ccrz8x  : PLUS_QI(rz8x  | SUBREG_QI(MEM_HI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_PLUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 864 "x86-64.int.py"
ccr64x  : MINUS_DI(r64x,  NEG_DI(MEM_DI(addr))) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addq", $2, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_PLUS(DImode, dst, gen_rtx_MEM(DImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 865 "x86-64.int.py"
ccrz32x : MINUS_SI(r32x,  NEG_SI(MEM_SI(addr))) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_PLUS(SImode, dst, gen_rtx_MEM(SImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 866 "x86-64.int.py"
ccr16x  : MINUS_HI(r16x,  NEG_HI(MEM_HI(addr))) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_PLUS(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 867 "x86-64.int.py"
ccr8x   : MINUS_QI(r8x,   NEG_QI(MEM_QI(addr))) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_PLUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 869 "x86-64.int.py"
ccrz16x : MINUS_HI(rz16x, NEG_HI(MEM_HI(addr))) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_PLUS(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 870 "x86-64.int.py"
ccrz8x  : MINUS_QI(rz8x,  NEG_QI(MEM_QI(addr))) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_PLUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 873 "x86-64.int.py"
ccrz32x : MINUS_SI(r32x,  NEG_SI(SUBREG_SI(MEM_DI(addr), CONST_0))) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_PLUS(SImode, dst, gen_rtx_MEM(SImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 874 "x86-64.int.py"
ccr16x  : MINUS_HI(r16x,  NEG_HI(SUBREG_HI(MEM_DI(addr), CONST_0))) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_PLUS(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 875 "x86-64.int.py"
ccr16x  : MINUS_HI(r16x,  NEG_HI(SUBREG_HI(MEM_SI(addr), CONST_0))) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_PLUS(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 876 "x86-64.int.py"
ccr8x   : MINUS_QI(r8x,   NEG_QI(SUBREG_QI(MEM_DI(addr), CONST_0))) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_PLUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 877 "x86-64.int.py"
ccr8x   : MINUS_QI(r8x,   NEG_QI(SUBREG_QI(MEM_SI(addr), CONST_0))) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_PLUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 878 "x86-64.int.py"
ccr8x   : MINUS_QI(r8x,   NEG_QI(SUBREG_QI(MEM_HI(addr), CONST_0))) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_PLUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 880 "x86-64.int.py"
ccrz16x : MINUS_HI(rz16x, NEG_HI(SUBREG_HI(MEM_DI(addr), CONST_0))) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_PLUS(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 881 "x86-64.int.py"
ccrz16x : MINUS_HI(rz16x, NEG_HI(SUBREG_HI(MEM_SI(addr), CONST_0))) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_PLUS(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 882 "x86-64.int.py"
ccrz8x  : MINUS_QI(rz8x,  NEG_QI(SUBREG_QI(MEM_DI(addr), CONST_0))) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_PLUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 883 "x86-64.int.py"
ccrz8x  : MINUS_QI(rz8x,  NEG_QI(SUBREG_QI(MEM_SI(addr), CONST_0))) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_PLUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 884 "x86-64.int.py"
ccrz8x  : MINUS_QI(rz8x,  NEG_QI(SUBREG_QI(MEM_HI(addr), CONST_0))) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("addb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_PLUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 888 "x86-64.int.py"
ccr64x  : MINUS_DI(r64x,  MEM_DI(addr)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subq", $2, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_MINUS(DImode, dst, gen_rtx_MEM(DImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 889 "x86-64.int.py"
ccrz32x : MINUS_SI(r32x,  MEM_SI(addr)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_MINUS(SImode, dst, gen_rtx_MEM(SImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 890 "x86-64.int.py"
ccr16x  : MINUS_HI(r16x,  MEM_HI(addr)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MINUS(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 891 "x86-64.int.py"
ccr8x   : MINUS_QI(r8x,   MEM_QI(addr)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_MINUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 893 "x86-64.int.py"
ccrz16x : MINUS_HI(rz16x, MEM_HI(addr)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MINUS(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 894 "x86-64.int.py"
ccrz8x  : MINUS_QI(rz8x,  MEM_QI(addr)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_MINUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 897 "x86-64.int.py"
ccrz32x : MINUS_SI(r32x,  SUBREG_SI(MEM_DI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_MINUS(SImode, dst, gen_rtx_MEM(SImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 898 "x86-64.int.py"
ccr16x  : MINUS_HI(r16x,  SUBREG_HI(MEM_DI(addr), CONST_0)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MINUS(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 899 "x86-64.int.py"
ccr16x  : MINUS_HI(r16x,  SUBREG_HI(MEM_SI(addr), CONST_0)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MINUS(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 900 "x86-64.int.py"
ccr8x   : MINUS_QI(r8x,   SUBREG_QI(MEM_DI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_MINUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 901 "x86-64.int.py"
ccr8x   : MINUS_QI(r8x,   SUBREG_QI(MEM_SI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_MINUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 902 "x86-64.int.py"
ccr8x   : MINUS_QI(r8x,   SUBREG_QI(MEM_HI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_MINUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 904 "x86-64.int.py"
ccrz16x : MINUS_HI(rz16x, SUBREG_HI(MEM_DI(addr), CONST_0)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MINUS(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 905 "x86-64.int.py"
ccrz16x : MINUS_HI(rz16x, SUBREG_HI(MEM_SI(addr), CONST_0)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MINUS(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 906 "x86-64.int.py"
ccrz8x  : MINUS_QI(rz8x,  SUBREG_QI(MEM_DI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_MINUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 907 "x86-64.int.py"
ccrz8x  : MINUS_QI(rz8x,  SUBREG_QI(MEM_SI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_MINUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 908 "x86-64.int.py"
ccrz8x  : MINUS_QI(rz8x,  SUBREG_QI(MEM_HI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_MINUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 912 "x86-64.int.py"
ccr64x  : PLUS_DI(r64x  | NEG_DI(MEM_DI(addr))) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subq", $2, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_MINUS(DImode, dst, gen_rtx_MEM(DImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 913 "x86-64.int.py"
ccrz32x : PLUS_SI(r32x  | NEG_SI(MEM_SI(addr))) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_MINUS(SImode, dst, gen_rtx_MEM(SImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 914 "x86-64.int.py"
ccr16x  : PLUS_HI(r16x  | NEG_HI(MEM_HI(addr))) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MINUS(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 915 "x86-64.int.py"
ccr8x   : PLUS_QI(r8x   | NEG_QI(MEM_QI(addr))) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_MINUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 917 "x86-64.int.py"
ccrz16x : PLUS_HI(rz16x | NEG_HI(MEM_HI(addr))) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MINUS(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 918 "x86-64.int.py"
ccrz8x  : PLUS_QI(rz8x  | NEG_QI(MEM_QI(addr))) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_MINUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 921 "x86-64.int.py"
ccrz32x : PLUS_SI(r32x  | NEG_SI(SUBREG_SI(MEM_DI(addr), CONST_0))) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_MINUS(SImode, dst, gen_rtx_MEM(SImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 922 "x86-64.int.py"
ccr16x  : PLUS_HI(r16x  | NEG_HI(SUBREG_HI(MEM_DI(addr), CONST_0))) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MINUS(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 923 "x86-64.int.py"
ccr16x  : PLUS_HI(r16x  | NEG_HI(SUBREG_HI(MEM_SI(addr), CONST_0))) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MINUS(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 924 "x86-64.int.py"
ccr8x   : PLUS_QI(r8x   | NEG_QI(SUBREG_QI(MEM_DI(addr), CONST_0))) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_MINUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 925 "x86-64.int.py"
ccr8x   : PLUS_QI(r8x   | NEG_QI(SUBREG_QI(MEM_SI(addr), CONST_0))) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_MINUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 926 "x86-64.int.py"
ccr8x   : PLUS_QI(r8x   | NEG_QI(SUBREG_QI(MEM_HI(addr), CONST_0))) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_MINUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 928 "x86-64.int.py"
ccrz16x : PLUS_HI(rz16x | NEG_HI(SUBREG_HI(MEM_DI(addr), CONST_0))) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MINUS(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 929 "x86-64.int.py"
ccrz16x : PLUS_HI(rz16x | NEG_HI(SUBREG_HI(MEM_SI(addr), CONST_0))) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MINUS(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 930 "x86-64.int.py"
ccrz8x  : PLUS_QI(rz8x  | NEG_QI(SUBREG_QI(MEM_DI(addr), CONST_0))) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_MINUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 931 "x86-64.int.py"
ccrz8x  : PLUS_QI(rz8x  | NEG_QI(SUBREG_QI(MEM_SI(addr), CONST_0))) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_MINUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 932 "x86-64.int.py"
ccrz8x  : PLUS_QI(rz8x  | NEG_QI(SUBREG_QI(MEM_HI(addr), CONST_0))) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("subb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_MINUS(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 937 "x86-64.int.py"
r64x    : MULT_DI(r64x  | MEM_DI(addr)) [7, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("imulq", $2, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_MULT(DImode, dst, gen_rtx_MEM(DImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 938 "x86-64.int.py"
rz32x   : MULT_SI(r32x  | MEM_SI(addr)) [6, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("imull", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_MULT(SImode, dst, gen_rtx_MEM(SImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 939 "x86-64.int.py"
r16x    : MULT_HI(r16x  | MEM_HI(addr)) [6, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("imulw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MULT(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 941 "x86-64.int.py"
rz16x   : MULT_HI(rz16x | MEM_HI(addr)) [6, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("imulw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MULT(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 944 "x86-64.int.py"
rz32x   : MULT_SI(r32x  | SUBREG_SI(MEM_DI(addr), CONST_0)) [6, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("imull", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_MULT(SImode, dst, gen_rtx_MEM(SImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 945 "x86-64.int.py"
r16x    : MULT_HI(r16x  | SUBREG_HI(MEM_DI(addr), CONST_0)) [6, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("imulw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MULT(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 946 "x86-64.int.py"
r16x    : MULT_HI(r16x  | SUBREG_HI(MEM_SI(addr), CONST_0)) [6, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("imulw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MULT(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 948 "x86-64.int.py"
rz16x   : MULT_HI(rz16x | SUBREG_HI(MEM_DI(addr), CONST_0)) [6, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("imulw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MULT(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 949 "x86-64.int.py"
rz16x   : MULT_HI(rz16x | SUBREG_HI(MEM_SI(addr), CONST_0)) [6, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("imulw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MULT(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 953 "x86-64.int.py"
ccr64x  : AND_DI(r64x  | MEM_DI(addr)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("andq", $2, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_AND(DImode, dst, gen_rtx_MEM(DImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 954 "x86-64.int.py"
ccrz32x : AND_SI(r32x  | MEM_SI(addr)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("andl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_AND(SImode, dst, gen_rtx_MEM(SImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 955 "x86-64.int.py"
ccr16x  : AND_HI(r16x  | MEM_HI(addr)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("andw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_AND(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 956 "x86-64.int.py"
ccr8x   : AND_QI(r8x   | MEM_QI(addr)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("andb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_AND(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 958 "x86-64.int.py"
ccrz16x : AND_HI(rz16x | MEM_HI(addr)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("andw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_AND(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 959 "x86-64.int.py"
ccrz8x  : AND_QI(rz8x  | MEM_QI(addr)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("andb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_AND(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 962 "x86-64.int.py"
ccrz32x : AND_SI(r32x  | SUBREG_SI(MEM_DI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("andl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_AND(SImode, dst, gen_rtx_MEM(SImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 963 "x86-64.int.py"
ccr16x  : AND_HI(r16x  | SUBREG_HI(MEM_DI(addr), CONST_0)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("andw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_AND(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 964 "x86-64.int.py"
ccr16x  : AND_HI(r16x  | SUBREG_HI(MEM_SI(addr), CONST_0)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("andw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_AND(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 965 "x86-64.int.py"
ccr8x   : AND_QI(r8x   | SUBREG_QI(MEM_DI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("andb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_AND(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 966 "x86-64.int.py"
ccr8x   : AND_QI(r8x   | SUBREG_QI(MEM_SI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("andb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_AND(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 967 "x86-64.int.py"
ccr8x   : AND_QI(r8x   | SUBREG_QI(MEM_HI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("andb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_AND(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 969 "x86-64.int.py"
ccrz16x : AND_HI(rz16x | SUBREG_HI(MEM_DI(addr), CONST_0)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("andw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_AND(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 970 "x86-64.int.py"
ccrz16x : AND_HI(rz16x | SUBREG_HI(MEM_SI(addr), CONST_0)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("andw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_AND(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 971 "x86-64.int.py"
ccrz8x  : AND_QI(rz8x  | SUBREG_QI(MEM_DI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("andb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_AND(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 972 "x86-64.int.py"
ccrz8x  : AND_QI(rz8x  | SUBREG_QI(MEM_SI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("andb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_AND(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 973 "x86-64.int.py"
ccrz8x  : AND_QI(rz8x  | SUBREG_QI(MEM_HI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("andb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_AND(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 977 "x86-64.int.py"
ccr64x  : IOR_DI(r64x  | MEM_DI(addr)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("orq", $2, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_IOR(DImode, dst, gen_rtx_MEM(DImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 978 "x86-64.int.py"
ccrz32x : IOR_SI(r32x  | MEM_SI(addr)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("orl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_IOR(SImode, dst, gen_rtx_MEM(SImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 979 "x86-64.int.py"
ccr16x  : IOR_HI(r16x  | MEM_HI(addr)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("orw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_IOR(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 980 "x86-64.int.py"
ccr8x   : IOR_QI(r8x   | MEM_QI(addr)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("orb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_IOR(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 982 "x86-64.int.py"
ccrz16x : IOR_HI(rz16x | MEM_HI(addr)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("orw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_IOR(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 983 "x86-64.int.py"
ccrz8x  : IOR_QI(rz8x  | MEM_QI(addr)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("orb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_IOR(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 986 "x86-64.int.py"
ccrz32x : IOR_SI(r32x  | SUBREG_SI(MEM_DI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("orl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_IOR(SImode, dst, gen_rtx_MEM(SImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 987 "x86-64.int.py"
ccr16x  : IOR_HI(r16x  | SUBREG_HI(MEM_DI(addr), CONST_0)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("orw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_IOR(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 988 "x86-64.int.py"
ccr16x  : IOR_HI(r16x  | SUBREG_HI(MEM_SI(addr), CONST_0)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("orw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_IOR(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 989 "x86-64.int.py"
ccr8x   : IOR_QI(r8x   | SUBREG_QI(MEM_DI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("orb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_IOR(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 990 "x86-64.int.py"
ccr8x   : IOR_QI(r8x   | SUBREG_QI(MEM_SI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("orb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_IOR(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 991 "x86-64.int.py"
ccr8x   : IOR_QI(r8x   | SUBREG_QI(MEM_HI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("orb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_IOR(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 993 "x86-64.int.py"
ccrz16x : IOR_HI(rz16x | SUBREG_HI(MEM_DI(addr), CONST_0)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("orw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_IOR(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 994 "x86-64.int.py"
ccrz16x : IOR_HI(rz16x | SUBREG_HI(MEM_SI(addr), CONST_0)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("orw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_IOR(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 995 "x86-64.int.py"
ccrz8x  : IOR_QI(rz8x  | SUBREG_QI(MEM_DI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("orb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_IOR(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 996 "x86-64.int.py"
ccrz8x  : IOR_QI(rz8x  | SUBREG_QI(MEM_SI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("orb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_IOR(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 997 "x86-64.int.py"
ccrz8x  : IOR_QI(rz8x  | SUBREG_QI(MEM_HI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("orb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_IOR(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1001 "x86-64.int.py"
ccr64x  : XOR_DI(r64x  | MEM_DI(addr)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("xorq", $2, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_XOR(DImode, dst, gen_rtx_MEM(DImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1002 "x86-64.int.py"
ccrz32x : XOR_SI(r32x  | MEM_SI(addr)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("xorl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_XOR(SImode, dst, gen_rtx_MEM(SImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1003 "x86-64.int.py"
ccr16x  : XOR_HI(r16x  | MEM_HI(addr)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("xorw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_XOR(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1004 "x86-64.int.py"
ccr8x   : XOR_QI(r8x   | MEM_QI(addr)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("xorb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_XOR(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1006 "x86-64.int.py"
ccrz16x : XOR_HI(rz16x | MEM_HI(addr)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("xorw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_XOR(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1007 "x86-64.int.py"
ccrz8x  : XOR_QI(rz8x  | MEM_QI(addr)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("xorb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_XOR(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1010 "x86-64.int.py"
ccrz32x : XOR_SI(r32x  | SUBREG_SI(MEM_DI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("xorl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_XOR(SImode, dst, gen_rtx_MEM(SImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1011 "x86-64.int.py"
ccr16x  : XOR_HI(r16x  | SUBREG_HI(MEM_DI(addr), CONST_0)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("xorw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_XOR(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1012 "x86-64.int.py"
ccr16x  : XOR_HI(r16x  | SUBREG_HI(MEM_SI(addr), CONST_0)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("xorw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_XOR(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1013 "x86-64.int.py"
ccr8x   : XOR_QI(r8x   | SUBREG_QI(MEM_DI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("xorb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_XOR(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1014 "x86-64.int.py"
ccr8x   : XOR_QI(r8x   | SUBREG_QI(MEM_SI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("xorb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_XOR(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1015 "x86-64.int.py"
ccr8x   : XOR_QI(r8x   | SUBREG_QI(MEM_HI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("xorb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_XOR(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1017 "x86-64.int.py"
ccrz16x : XOR_HI(rz16x | SUBREG_HI(MEM_DI(addr), CONST_0)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("xorw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_XOR(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1018 "x86-64.int.py"
ccrz16x : XOR_HI(rz16x | SUBREG_HI(MEM_SI(addr), CONST_0)) [4, 2]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("xorw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_XOR(HImode, dst, gen_rtx_MEM(HImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1019 "x86-64.int.py"
ccrz8x  : XOR_QI(rz8x  | SUBREG_QI(MEM_DI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("xorb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_XOR(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1020 "x86-64.int.py"
ccrz8x  : XOR_QI(rz8x  | SUBREG_QI(MEM_SI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("xorb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_XOR(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1021 "x86-64.int.py"
ccrz8x  : XOR_QI(rz8x  | SUBREG_QI(MEM_HI(addr), CONST_0)) [4, 1]
#line 1025 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $2);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpMR("xorb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_XOR(QImode, dst, gen_rtx_MEM(QImode, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1064 "x86-64.int.py"
ccr64x  : PLUS_DI(r64x  | r64) [1, 4]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("addq", $2->r, 'q', $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_PLUS(DImode, dst, gen_rtx_REG(DImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1065 "x86-64.int.py"
ccrz32x : PLUS_SI(r32x  | r32) [1, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("addl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_PLUS(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1066 "x86-64.int.py"
ccr16x  : PLUS_HI(r16x  | r16) [1, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("addw", $2->r, 'w', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_PLUS(HImode, dst, gen_rtx_REG(HImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1067 "x86-64.int.py"
ccr8x   : PLUS_QI(r8x   | r8) [1, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("addb", $2->r, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_PLUS(QImode, dst, gen_rtx_REG(QImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1070 "x86-64.int.py"
ccrz16x : PLUS_HI(rz16x | r16) [1, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("addw", $2->r, 'w', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_PLUS(HImode, dst, gen_rtx_REG(HImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1071 "x86-64.int.py"
ccrz8x  : PLUS_QI(rz8x  | r8) [1, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("addb", $2->r, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_PLUS(QImode, dst, gen_rtx_REG(QImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1074 "x86-64.int.py"
r16x    : PLUS_HI(r16x  | r16) [1, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("addl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_PLUS(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1077 "x86-64.int.py"
ccr64x  : MINUS_DI(r64x,  NEG_DI(r64)) [1, 4]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("addq", $2->r, 'q', $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_PLUS(DImode, dst, gen_rtx_REG(DImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1078 "x86-64.int.py"
ccrz32x : MINUS_SI(r32x,  NEG_SI(r32)) [1, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("addl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_PLUS(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1079 "x86-64.int.py"
ccr16x  : MINUS_HI(r16x,  NEG_HI(r16)) [1, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("addw", $2->r, 'w', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_PLUS(HImode, dst, gen_rtx_REG(HImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1080 "x86-64.int.py"
ccr8x   : MINUS_QI(r8x,   NEG_QI(r8)) [1, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("addb", $2->r, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_PLUS(QImode, dst, gen_rtx_REG(QImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1083 "x86-64.int.py"
ccrz16x : MINUS_HI(rz16x, NEG_HI(r16)) [1, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("addw", $2->r, 'w', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_PLUS(HImode, dst, gen_rtx_REG(HImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1084 "x86-64.int.py"
ccrz8x  : MINUS_QI(rz8x,  NEG_HI(r8)) [1, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("addb", $2->r, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_PLUS(QImode, dst, gen_rtx_REG(QImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1087 "x86-64.int.py"
r16x    : MINUS_HI(r16x,  NEG_HI(r16)) [1, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("addl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_PLUS(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1090 "x86-64.int.py"
ccr64x  : PLUS_DI(r64x | NEG_DI(r64)) [1, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("subq", $2->r, 'q', $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_MINUS(DImode, dst, gen_rtx_REG(DImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1091 "x86-64.int.py"
ccrz32x : PLUS_SI(r32x | NEG_SI(r32)) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("subl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_MINUS(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1092 "x86-64.int.py"
ccr16x  : PLUS_HI(r16x | NEG_HI(r16)) [1, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("subw", $2->r, 'w', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MINUS(HImode, dst, gen_rtx_REG(HImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1093 "x86-64.int.py"
ccr8x   : PLUS_QI(r8x  | NEG_QI(r8)) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("subb", $2->r, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_MINUS(QImode, dst, gen_rtx_REG(QImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1096 "x86-64.int.py"
ccrz16x : PLUS_HI(rz16x | NEG_HI(r16)) [1, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("subw", $2->r, 'w', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MINUS(HImode, dst, gen_rtx_REG(HImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1097 "x86-64.int.py"
ccrz8x  : PLUS_QI(rz8x  | NEG_QI(r8)) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("subb", $2->r, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_MINUS(QImode, dst, gen_rtx_REG(QImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1100 "x86-64.int.py"
r16x    : PLUS_HI(r16x | NEG_HI(r16)) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("subl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_MINUS(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1103 "x86-64.int.py"
ccr64x  : MINUS_DI(r64x,  r64) [1, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("subq", $2->r, 'q', $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_MINUS(DImode, dst, gen_rtx_REG(DImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1104 "x86-64.int.py"
ccrz32x : MINUS_SI(r32x,  r32) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("subl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_MINUS(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1105 "x86-64.int.py"
ccr16x  : MINUS_HI(r16x,  r16) [1, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("subw", $2->r, 'w', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MINUS(HImode, dst, gen_rtx_REG(HImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1106 "x86-64.int.py"
ccr8x   : MINUS_QI(r8x,   r8) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("subb", $2->r, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_MINUS(QImode, dst, gen_rtx_REG(QImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1109 "x86-64.int.py"
ccrz16x : MINUS_HI(rz16x, r16) [1, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("subw", $2->r, 'w', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MINUS(HImode, dst, gen_rtx_REG(HImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1110 "x86-64.int.py"
ccrz8x  : MINUS_QI(rz8x,  r8) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("subb", $2->r, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_MINUS(QImode, dst, gen_rtx_REG(QImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1113 "x86-64.int.py"
r16x    : MINUS_HI(r16x,  r16) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (0)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("subl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_MINUS(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1117 "x86-64.int.py"
r64x  : MULT_DI(r64x  | r64) [4, 4]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("imulq", $2->r, 'q', $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_MULT(DImode, dst, gen_rtx_REG(DImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1118 "x86-64.int.py"
rz32x : MULT_SI(r32x  | r32) [3, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("imull", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_MULT(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1119 "x86-64.int.py"
r16x  : MULT_HI(r16x  | r16) [3, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("imull", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_MULT(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1120 "x86-64.int.py"
r8x   : MULT_QI(r8x   | r8) [3, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("imull", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_MULT(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1123 "x86-64.int.py"
rz16x : MULT_HI(rz16x | r16) [3, 4]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("imulw", $2->r, 'w', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_MULT(HImode, dst, gen_rtx_REG(HImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1126 "x86-64.int.py"
ccr64x  : AND_DI(r64x  | r64) [1, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("andq", $2->r, 'q', $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_AND(DImode, dst, gen_rtx_REG(DImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1127 "x86-64.int.py"
ccrz32x : AND_SI(r32x  | r32) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("andl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_AND(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1128 "x86-64.int.py"
ccr16x  : AND_HI(r16x  | r16) [1, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("andw", $2->r, 'w', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_AND(HImode, dst, gen_rtx_REG(HImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1129 "x86-64.int.py"
ccr8x   : AND_QI(r8x   | r8) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("andb", $2->r, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_AND(QImode, dst, gen_rtx_REG(QImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1132 "x86-64.int.py"
ccrz16x : AND_HI(rz16x | r16) [1, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("andw", $2->r, 'w', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_AND(HImode, dst, gen_rtx_REG(HImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1133 "x86-64.int.py"
ccrz8x  : AND_QI(rz8x  | r8) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("andb", $2->r, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_AND(QImode, dst, gen_rtx_REG(QImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1136 "x86-64.int.py"
r16x    : AND_HI(r16x  | r16) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("andl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_AND(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1137 "x86-64.int.py"
rz16x   : AND_HI(rz16x | r16) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("andl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_AND(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1138 "x86-64.int.py"
rz16x   : AND_HI(r16x  | rz16) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("andl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_AND(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1139 "x86-64.int.py"
rs16x   : AND_HI(rs16x | rs16) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("andl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_AND(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1140 "x86-64.int.py"
r8x     : AND_QI(r8x   | r8) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("andl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_AND(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1141 "x86-64.int.py"
rz8x    : AND_QI(rz8x  | r8) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("andl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_AND(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1142 "x86-64.int.py"
rz8x    : AND_QI(r8x   | rz8) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("andl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_AND(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1143 "x86-64.int.py"
rs8x    : AND_QI(rs8x  | rs8) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("andl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_AND(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1146 "x86-64.int.py"
ccr64x  : IOR_DI(r64x  | r64) [1, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("orq", $2->r, 'q', $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_IOR(DImode, dst, gen_rtx_REG(DImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1147 "x86-64.int.py"
ccrz32x : IOR_SI(r32x  | r32) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("orl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_IOR(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1148 "x86-64.int.py"
ccr16x  : IOR_HI(r16x  | r16) [1, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("orw", $2->r, 'w', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_IOR(HImode, dst, gen_rtx_REG(HImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1149 "x86-64.int.py"
ccr8x   : IOR_QI(r8x   | r8) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("orb", $2->r, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_IOR(QImode, dst, gen_rtx_REG(QImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1152 "x86-64.int.py"
ccrz16x : IOR_HI(rz16x | r16) [1, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("orw", $2->r, 'w', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_IOR(HImode, dst, gen_rtx_REG(HImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1153 "x86-64.int.py"
ccrz8x  : IOR_QI(rz8x  | r8) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("orb", $2->r, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_IOR(QImode, dst, gen_rtx_REG(QImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1157 "x86-64.int.py"
r16x    : IOR_HI(r16x  | r16) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("orl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_IOR(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1158 "x86-64.int.py"
rz16x   : IOR_HI(rz16x | rz16) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("orl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_IOR(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1159 "x86-64.int.py"
rs16x   : IOR_HI(rs16x | rs16) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("orl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_IOR(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1160 "x86-64.int.py"
rz8x    : IOR_QI(rz8x  | rz8) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("orl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_IOR(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1161 "x86-64.int.py"
rs8x    : IOR_QI(rs8x  | rs8) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("orl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_IOR(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1165 "x86-64.int.py"
ccr64x  : XOR_DI(r64x  | r64) [1, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("xorq", $2->r, 'q', $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_XOR(DImode, dst, gen_rtx_REG(DImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1166 "x86-64.int.py"
ccrz32x : XOR_SI(r32x  | r32) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("xorl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_XOR(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1167 "x86-64.int.py"
ccr16x  : XOR_HI(r16x  | r16) [1, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("xorw", $2->r, 'w', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_XOR(HImode, dst, gen_rtx_REG(HImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1168 "x86-64.int.py"
ccr8x   : XOR_QI(r8x   | r8) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("xorb", $2->r, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_XOR(QImode, dst, gen_rtx_REG(QImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1171 "x86-64.int.py"
ccrz16x : XOR_HI(rz16x | r16) [1, 3]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("xorw", $2->r, 'w', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_XOR(HImode, dst, gen_rtx_REG(HImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1172 "x86-64.int.py"
ccrz8x  : XOR_QI(rz8x  | r8) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("xorb", $2->r, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_XOR(QImode, dst, gen_rtx_REG(QImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1175 "x86-64.int.py"
r16x    : XOR_HI(r16x  | r16) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("xorl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_XOR(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1176 "x86-64.int.py"
rz16x   : XOR_HI(rz16x | rz16) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("xorl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_XOR(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1177 "x86-64.int.py"
rs16x   : XOR_HI(rs16x | rs16) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("xorl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_XOR(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1178 "x86-64.int.py"
rz8x    : XOR_QI(rz8x  | rz8) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("xorl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_XOR(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1179 "x86-64.int.py"
rs8x    : XOR_QI(rs8x  | rs8) [1, 2]
#line 1184 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    if (1)
      memorable($1->r);
    else
      forgettable($1->rx);
    memorable($2->r);
  },
  debug {
    dumpRR("xorl", $2->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_XOR(SImode, dst, gen_rtx_REG(SImode, $2->r));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1223 "x86-64.int.py"
ccr64x  : NEG_DI(r64x) [1, 3]
#line 1257 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("negq", $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_NEG(DImode, gen_rtx_REG(DImode, $1->rx));
    (1 ? icg_emit_clobber : icg_emit_plain)(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1224 "x86-64.int.py"
ccrz32x : NEG_SI(r32x) [1, 2]
#line 1257 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("negl", $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_NEG(SImode, gen_rtx_REG(SImode, $1->rx));
    (1 ? icg_emit_clobber : icg_emit_plain)(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1225 "x86-64.int.py"
ccr16x  : NEG_HI(r16x) [1, 3]
#line 1257 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("negw", $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_NEG(HImode, gen_rtx_REG(HImode, $1->rx));
    (1 ? icg_emit_clobber : icg_emit_plain)(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1226 "x86-64.int.py"
ccr8x   : NEG_QI(r8x) [1, 2]
#line 1257 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("negb", $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_NEG(QImode, gen_rtx_REG(QImode, $1->rx));
    (1 ? icg_emit_clobber : icg_emit_plain)(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1229 "x86-64.int.py"
ccrz16x : NEG_HI(rz16x) [1, 3]
#line 1257 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("negw", $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_NEG(HImode, gen_rtx_REG(HImode, $1->rx));
    (1 ? icg_emit_clobber : icg_emit_plain)(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1230 "x86-64.int.py"
ccrz8x  : NEG_QI(rz8x) [1, 2]
#line 1257 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("negb", $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_NEG(QImode, gen_rtx_REG(QImode, $1->rx));
    (1 ? icg_emit_clobber : icg_emit_plain)(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1233 "x86-64.int.py"
r16x    : NEG_HI(r16x) [1, 2]
#line 1257 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("negl", $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_NEG(SImode, gen_rtx_REG(SImode, $1->rx));
    (1 ? icg_emit_clobber : icg_emit_plain)(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1236 "x86-64.int.py"
ccrs16x : NEG_HI(rs16x) [1, 2]
#line 1257 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("negl", $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_NEG(SImode, gen_rtx_REG(SImode, $1->rx));
    (1 ? icg_emit_clobber : icg_emit_plain)(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1237 "x86-64.int.py"
ccrs8x  : NEG_HI(rs8x) [1, 2]
#line 1257 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("negl", $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_NEG(SImode, gen_rtx_REG(SImode, $1->rx));
    (1 ? icg_emit_clobber : icg_emit_plain)(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1241 "x86-64.int.py"
r64x  : NOT_DI(r64x) [1, 3]
#line 1257 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("notq", $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx src = gen_rtx_NOT(DImode, gen_rtx_REG(DImode, $1->rx));
    (0 ? icg_emit_clobber : icg_emit_plain)(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1242 "x86-64.int.py"
rz32x : NOT_SI(r32x) [1, 2]
#line 1257 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("notl", $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_NOT(SImode, gen_rtx_REG(SImode, $1->rx));
    (0 ? icg_emit_clobber : icg_emit_plain)(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1251 "x86-64.int.py"
r16x  : NOT_HI(r16x) [1, 3]
#line 1257 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("notw", $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_NOT(HImode, gen_rtx_REG(HImode, $1->rx));
    (0 ? icg_emit_clobber : icg_emit_plain)(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1244 "x86-64.int.py"
r8x   : NOT_QI(r8x) [1, 2]
#line 1257 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("notb", $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_NOT(QImode, gen_rtx_REG(QImode, $1->rx));
    (0 ? icg_emit_clobber : icg_emit_plain)(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1247 "x86-64.int.py"
rz16x : NOT_HI(rz16x) [1, 3]
#line 1257 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("notw", $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx src = gen_rtx_NOT(HImode, gen_rtx_REG(HImode, $1->rx));
    (0 ? icg_emit_clobber : icg_emit_plain)(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1248 "x86-64.int.py"
rz8x  : NOT_QI(rz8x) [1, 2]
#line 1257 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("notb", $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx src = gen_rtx_NOT(QImode, gen_rtx_REG(QImode, $1->rx));
    (0 ? icg_emit_clobber : icg_emit_plain)(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1251 "x86-64.int.py"
r16x  : NOT_HI(r16x) [1, 2]
#line 1257 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("notl", $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_NOT(SImode, gen_rtx_REG(SImode, $1->rx));
    (0 ? icg_emit_clobber : icg_emit_plain)(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1252 "x86-64.int.py"
rs16x : NOT_HI(rs16x) [1, 2]
#line 1257 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("notl", $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_NOT(SImode, gen_rtx_REG(SImode, $1->rx));
    (0 ? icg_emit_clobber : icg_emit_plain)(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1253 "x86-64.int.py"
rs8x  : NOT_QI(rs8x) [1, 2]
#line 1257 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpR("notl", $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx src = gen_rtx_NOT(SImode, gen_rtx_REG(SImode, $1->rx));
    (0 ? icg_emit_clobber : icg_emit_plain)(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1289 "x86-64.int.py"
r64x  : NEG_DI(NEG_DI(r64x)) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1290 "x86-64.int.py"
r32x  : NEG_SI(NEG_SI(r32x)) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1291 "x86-64.int.py"
rz32x : NEG_SI(NEG_SI(rz32x)) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1292 "x86-64.int.py"
r16x  : NEG_HI(NEG_HI(r16x)) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1293 "x86-64.int.py"
rz16x : NEG_HI(NEG_HI(rz16x)) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1294 "x86-64.int.py"
rs16x : NEG_HI(NEG_HI(rs16x)) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1295 "x86-64.int.py"
r8x   : NEG_QI(NEG_QI(r8x)) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1296 "x86-64.int.py"
rz8x  : NEG_QI(NEG_QI(rz8x)) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1297 "x86-64.int.py"
rs8x  : NEG_QI(NEG_QI(rs8x)) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1298 "x86-64.int.py"
rdx   : NEG_DF(NEG_DF(rdx)) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1299 "x86-64.int.py"
rfx   : NEG_SF(NEG_SF(rfx)) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1301 "x86-64.int.py"
rz32  : SIGN_EXTEND_SI(rs16) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1302 "x86-64.int.py"
rz32  : SIGN_EXTEND_SI(rs8) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1303 "x86-64.int.py"
rs16  : SIGN_EXTEND_HI(rs8) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1304 "x86-64.int.py"
rz32x : SIGN_EXTEND_SI(rs16x) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1305 "x86-64.int.py"
rz32x : SIGN_EXTEND_SI(rs8x) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1306 "x86-64.int.py"
rs16x : SIGN_EXTEND_HI(rs8x) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1308 "x86-64.int.py"
rz32  : ZERO_EXTEND_SI(rz16) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1309 "x86-64.int.py"
rz32  : ZERO_EXTEND_SI(rz8) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1310 "x86-64.int.py"
rz16  : ZERO_EXTEND_HI(rz8) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1311 "x86-64.int.py"
rz32x : ZERO_EXTEND_SI(rz16x) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1312 "x86-64.int.py"
rz32x : ZERO_EXTEND_SI(rz8x) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1313 "x86-64.int.py"
rz16x : ZERO_EXTEND_HI(rz8x) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1321 "x86-64.int.py"
r64x : ZERO_EXTEND_DI(rz32x) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1322 "x86-64.int.py"
r64x : ZERO_EXTEND_DI(rz16x) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1323 "x86-64.int.py"
r64x : ZERO_EXTEND_DI(rz8x) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1324 "x86-64.int.py"
r64  : ZERO_EXTEND_DI(rz32) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1325 "x86-64.int.py"
r64  : ZERO_EXTEND_DI(rz16) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1326 "x86-64.int.py"
r64  : ZERO_EXTEND_DI(rz8) [0, 0]
#line 1330 "x86-64.int.py"
  names {
    $$->r = $1->r;
  },
  final {
    $$->r = $1->r;
  },
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  };
#line 1352 "x86-64.int.py"
r64x  : MULT_DI(r64  | imm8) [4, 3]
#line 1371 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;            /* think about these */
    $$->freed = $1->freed;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  remat {
    flags = 0;
  },
  costs {
    memorable($1->r);
  },
  debug {
    dumpIRR("imulq", $2, $1->r, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src = gen_rtx_MULT(DImode,
			   gen_rtx_REG(DImode, $1->r),
			   gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1353 "x86-64.int.py"
r64x  : MULT_DI(r64  | imm32) [4, 3]
#line 1371 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;            /* think about these */
    $$->freed = $1->freed;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  remat {
    flags = 0;
  },
  costs {
    memorable($1->r);
  },
  debug {
    dumpIRR("imulq", $2, $1->r, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src = gen_rtx_MULT(DImode,
			   gen_rtx_REG(DImode, $1->r),
			   gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1354 "x86-64.int.py"
rz32x : MULT_SI(r32  | imm8) [3, 2]
#line 1371 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;            /* think about these */
    $$->freed = $1->freed;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  remat {
    flags = 0;
  },
  costs {
    memorable($1->r);
  },
  debug {
    dumpIRR("imull", $2, $1->r, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_MULT(SImode,
			   gen_rtx_REG(SImode, $1->r),
			   gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1355 "x86-64.int.py"
rz32x : MULT_SI(r32  | imm32) [3, 2]
#line 1371 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;            /* think about these */
    $$->freed = $1->freed;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  remat {
    flags = 0;
  },
  costs {
    memorable($1->r);
  },
  debug {
    dumpIRR("imull", $2, $1->r, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_MULT(SImode,
			   gen_rtx_REG(SImode, $1->r),
			   gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1364 "x86-64.int.py"
r16x  : MULT_HI(r16  | imm8) [4, 3]
#line 1371 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;            /* think about these */
    $$->freed = $1->freed;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  remat {
    flags = 0;
  },
  costs {
    memorable($1->r);
  },
  debug {
    dumpIRR("imulw", $2, $1->r, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_MULT(HImode,
			   gen_rtx_REG(HImode, $1->r),
			   gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1357 "x86-64.int.py"
r16x  : MULT_HI(r16  | imm16) [4, 3]
#line 1371 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;            /* think about these */
    $$->freed = $1->freed;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  remat {
    flags = 0;
  },
  costs {
    memorable($1->r);
  },
  debug {
    dumpIRR("imulw", $2, $1->r, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_MULT(HImode,
			   gen_rtx_REG(HImode, $1->r),
			   gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1360 "x86-64.int.py"
rz16x : MULT_HI(rz16 | imm8) [4, 3]
#line 1371 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;            /* think about these */
    $$->freed = $1->freed;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  remat {
    flags = 0;
  },
  costs {
    memorable($1->r);
  },
  debug {
    dumpIRR("imulw", $2, $1->r, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_MULT(HImode,
			   gen_rtx_REG(HImode, $1->r),
			   gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1361 "x86-64.int.py"
rz16x : MULT_HI(rz16 | imm16) [4, 3]
#line 1371 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;            /* think about these */
    $$->freed = $1->freed;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  remat {
    flags = 0;
  },
  costs {
    memorable($1->r);
  },
  debug {
    dumpIRR("imulw", $2, $1->r, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_MULT(HImode,
			   gen_rtx_REG(HImode, $1->r),
			   gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1364 "x86-64.int.py"
r16x  : MULT_HI(r16  | imm8) [3, 2]
#line 1371 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;            /* think about these */
    $$->freed = $1->freed;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  remat {
    flags = 0;
  },
  costs {
    memorable($1->r);
  },
  debug {
    dumpIRR("imull", $2, $1->r, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_MULT(SImode,
			   gen_rtx_REG(SImode, $1->r),
			   gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1365 "x86-64.int.py"
r16x  : MULT_HI(r16  | imm32) [3, 2]
#line 1371 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;            /* think about these */
    $$->freed = $1->freed;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  remat {
    flags = 0;
  },
  costs {
    memorable($1->r);
  },
  debug {
    dumpIRR("imull", $2, $1->r, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_MULT(SImode,
			   gen_rtx_REG(SImode, $1->r),
			   gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1366 "x86-64.int.py"
r8x   : MULT_QI(r8   | imm8) [3, 2]
#line 1371 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;            /* think about these */
    $$->freed = $1->freed;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  remat {
    flags = 0;
  },
  costs {
    memorable($1->r);
  },
  debug {
    dumpIRR("imull", $2, $1->r, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_MULT(SImode,
			   gen_rtx_REG(SImode, $1->r),
			   gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1367 "x86-64.int.py"
r8x   : MULT_QI(r8   | imm32) [3, 2]
#line 1371 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;            /* think about these */
    $$->freed = $1->freed;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  remat {
    flags = 0;
  },
  costs {
    memorable($1->r);
  },
  debug {
    dumpIRR("imull", $2, $1->r, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_MULT(SImode,
			   gen_rtx_REG(SImode, $1->r),
			   gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1412 "x86-64.int.py"
r64x  : MULT_DI(MEM_DI(addr) | imm8) [8, 3]
#line 1428 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    add_addr(live, $1);
  },
  debug {
    dumpIMR("imulq", $2, $1, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src = gen_rtx_MULT(DImode,
			   gen_rtx_MEM(DImode, $1->rtl),
			   gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1413 "x86-64.int.py"
r64x  : MULT_DI(MEM_DI(addr) | imm32) [8, 3]
#line 1428 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    add_addr(live, $1);
  },
  debug {
    dumpIMR("imulq", $2, $1, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src = gen_rtx_MULT(DImode,
			   gen_rtx_MEM(DImode, $1->rtl),
			   gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1414 "x86-64.int.py"
rz32x : MULT_SI(MEM_SI(addr) | imm8) [7, 2]
#line 1428 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    add_addr(live, $1);
  },
  debug {
    dumpIMR("imull", $2, $1, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_MULT(SImode,
			   gen_rtx_MEM(SImode, $1->rtl),
			   gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1415 "x86-64.int.py"
rz32x : MULT_SI(MEM_SI(addr) | imm32) [7, 2]
#line 1428 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    add_addr(live, $1);
  },
  debug {
    dumpIMR("imull", $2, $1, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_MULT(SImode,
			   gen_rtx_MEM(SImode, $1->rtl),
			   gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1416 "x86-64.int.py"
r16x  : MULT_HI(MEM_HI(addr) | imm8) [7, 3]
#line 1428 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    add_addr(live, $1);
  },
  debug {
    dumpIMR("imulw", $2, $1, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_MULT(HImode,
			   gen_rtx_MEM(HImode, $1->rtl),
			   gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1417 "x86-64.int.py"
r16x  : MULT_HI(MEM_HI(addr) | imm16) [7, 3]
#line 1428 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    add_addr(live, $1);
  },
  debug {
    dumpIMR("imulw", $2, $1, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_MULT(HImode,
			   gen_rtx_MEM(HImode, $1->rtl),
			   gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1419 "x86-64.int.py"
rz32x : MULT_SI(SUBREG_SI(MEM_DI(addr), CONST_0) | imm8) [7, 2]
#line 1428 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    add_addr(live, $1);
  },
  debug {
    dumpIMR("imull", $2, $1, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_MULT(SImode,
			   gen_rtx_MEM(SImode, $1->rtl),
			   gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1420 "x86-64.int.py"
rz32x : MULT_SI(SUBREG_SI(MEM_DI(addr), CONST_0) | imm32) [7, 2]
#line 1428 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    add_addr(live, $1);
  },
  debug {
    dumpIMR("imull", $2, $1, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_MULT(SImode,
			   gen_rtx_MEM(SImode, $1->rtl),
			   gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1421 "x86-64.int.py"
r16x  : MULT_HI(SUBREG_HI(MEM_DI(addr), CONST_0) | imm8) [7, 3]
#line 1428 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    add_addr(live, $1);
  },
  debug {
    dumpIMR("imulw", $2, $1, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_MULT(HImode,
			   gen_rtx_MEM(HImode, $1->rtl),
			   gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1422 "x86-64.int.py"
r16x  : MULT_HI(SUBREG_HI(MEM_SI(addr), CONST_0) | imm8) [7, 3]
#line 1428 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    add_addr(live, $1);
  },
  debug {
    dumpIMR("imulw", $2, $1, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_MULT(HImode,
			   gen_rtx_MEM(HImode, $1->rtl),
			   gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1423 "x86-64.int.py"
r16x  : MULT_HI(SUBREG_HI(MEM_DI(addr), CONST_0) | imm16) [7, 3]
#line 1428 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    add_addr(live, $1);
  },
  debug {
    dumpIMR("imulw", $2, $1, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_MULT(HImode,
			   gen_rtx_MEM(HImode, $1->rtl),
			   gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1424 "x86-64.int.py"
r16x  : MULT_HI(SUBREG_HI(MEM_SI(addr), CONST_0) | imm16) [7, 3]
#line 1428 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    add_addr(live, $1);
  },
  debug {
    dumpIMR("imulw", $2, $1, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_MULT(HImode,
			   gen_rtx_MEM(HImode, $1->rtl),
			   gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1470 "x86-64.int.py"
r64x  :  DIV_DI(r64x, r64) [52, 8]
#line 1518 "x86-64.int.py"
  supairs {
    if (1) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RAX);
  },
  build {
    if (REG_RAX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (1)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('q' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (1)
      memorable($2->r);
    cost_copy(REG_RAX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movq", $1->rx, REG_RAX, 'q');
    if ('q' != 'b') {
      if (1) {
	dump("cqo");					/* such as cqo or cdq */
      } else {
	dumpRR("cqo", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (1) {
      dumpR("idivq", $2->r, 'q');
    } else {
      dumpM("idivq", $2);
    }
    dump_copy("movq", REG_RAX, $$->rx, 'q');
  },
  emit {
    rtx dst  = gen_rtx_REG(DImode, $$->rx);
    rtx src1 = gen_rtx_REG(DImode, $1->rx);
    rtx src2 = 1
      ? gen_rtx_REG(DImode, $2->r)
      : gen_rtx_MEM(DImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(DImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('q' != 'b') ? gen_rtx_REG(DImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('q' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(1, DImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(1, DImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(1, DImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RAX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1471 "x86-64.int.py"
rz32x :  DIV_SI(r32x, r32) [52, 6]
#line 1518 "x86-64.int.py"
  supairs {
    if (1) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RAX);
  },
  build {
    if (REG_RAX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (1)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('d' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (1)
      memorable($2->r);
    cost_copy(REG_RAX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movl", $1->rx, REG_RAX, 'd');
    if ('d' != 'b') {
      if (1) {
	dump("cdq");					/* such as cqo or cdq */
      } else {
	dumpRR("cdq", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (1) {
      dumpR("idivl", $2->r, 'd');
    } else {
      dumpM("idivl", $2);
    }
    dump_copy("movl", REG_RAX, $$->rx, 'd');
  },
  emit {
    rtx dst  = gen_rtx_REG(SImode, $$->rx);
    rtx src1 = gen_rtx_REG(SImode, $1->rx);
    rtx src2 = 1
      ? gen_rtx_REG(SImode, $2->r)
      : gen_rtx_MEM(SImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(SImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('d' != 'b') ? gen_rtx_REG(SImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('d' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(1, SImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(1, SImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(1, SImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RAX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1473 "x86-64.int.py"
r64x  :  MOD_DI(r64x, r64) [52, 8]
#line 1518 "x86-64.int.py"
  supairs {
    if (1) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RDX);
  },
  build {
    if (REG_RDX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (1)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('q' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (1)
      memorable($2->r);
    cost_copy(REG_RDX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movq", $1->rx, REG_RAX, 'q');
    if ('q' != 'b') {
      if (1) {
	dump("cqo");					/* such as cqo or cdq */
      } else {
	dumpRR("cqo", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (1) {
      dumpR("idivq", $2->r, 'q');
    } else {
      dumpM("idivq", $2);
    }
    dump_copy("movq", REG_RDX, $$->rx, 'q');
  },
  emit {
    rtx dst  = gen_rtx_REG(DImode, $$->rx);
    rtx src1 = gen_rtx_REG(DImode, $1->rx);
    rtx src2 = 1
      ? gen_rtx_REG(DImode, $2->r)
      : gen_rtx_MEM(DImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(DImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('q' != 'b') ? gen_rtx_REG(DImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('q' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(1, DImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(1, DImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(1, DImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RDX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1474 "x86-64.int.py"
rz32x :  MOD_SI(r32x, r32) [52, 5]
#line 1518 "x86-64.int.py"
  supairs {
    if (1) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RDX);
  },
  build {
    if (REG_RDX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (1)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('d' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (1)
      memorable($2->r);
    cost_copy(REG_RDX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movl", $1->rx, REG_RAX, 'd');
    if ('d' != 'b') {
      if (1) {
	dump("cdq");					/* such as cqo or cdq */
      } else {
	dumpRR("cdq", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (1) {
      dumpR("idivl", $2->r, 'd');
    } else {
      dumpM("idivl", $2);
    }
    dump_copy("movl", REG_RDX, $$->rx, 'd');
  },
  emit {
    rtx dst  = gen_rtx_REG(SImode, $$->rx);
    rtx src1 = gen_rtx_REG(SImode, $1->rx);
    rtx src2 = 1
      ? gen_rtx_REG(SImode, $2->r)
      : gen_rtx_MEM(SImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(SImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('d' != 'b') ? gen_rtx_REG(SImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('d' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(1, SImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(1, SImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(1, SImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RDX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1476 "x86-64.int.py"
r64x :   DIV_DI(r64x, MEM_DI(addr)) [52, 8]
#line 1518 "x86-64.int.py"
  supairs {
    if (0) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RAX);
  },
  build {
    if (REG_RAX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (0)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('q' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (0)
      memorable($2->r);
    cost_copy(REG_RAX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movq", $1->rx, REG_RAX, 'q');
    if ('q' != 'b') {
      if (1) {
	dump("cqo");					/* such as cqo or cdq */
      } else {
	dumpRR("cqo", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (0) {
      dumpR("idivq", $2->r, 'q');
    } else {
      dumpM("idivq", $2);
    }
    dump_copy("movq", REG_RAX, $$->rx, 'q');
  },
  emit {
    rtx dst  = gen_rtx_REG(DImode, $$->rx);
    rtx src1 = gen_rtx_REG(DImode, $1->rx);
    rtx src2 = 0
      ? gen_rtx_REG(DImode, $2->r)
      : gen_rtx_MEM(DImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(DImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('q' != 'b') ? gen_rtx_REG(DImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('q' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(1, DImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(1, DImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(1, DImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RAX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1477 "x86-64.int.py"
rz32x :  DIV_SI(r32x, MEM_SI(addr)) [52, 4]
#line 1518 "x86-64.int.py"
  supairs {
    if (0) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RAX);
  },
  build {
    if (REG_RAX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (0)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('d' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (0)
      memorable($2->r);
    cost_copy(REG_RAX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movl", $1->rx, REG_RAX, 'd');
    if ('d' != 'b') {
      if (1) {
	dump("cdq");					/* such as cqo or cdq */
      } else {
	dumpRR("cdq", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (0) {
      dumpR("idivl", $2->r, 'd');
    } else {
      dumpM("idivl", $2);
    }
    dump_copy("movl", REG_RAX, $$->rx, 'd');
  },
  emit {
    rtx dst  = gen_rtx_REG(SImode, $$->rx);
    rtx src1 = gen_rtx_REG(SImode, $1->rx);
    rtx src2 = 0
      ? gen_rtx_REG(SImode, $2->r)
      : gen_rtx_MEM(SImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(SImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('d' != 'b') ? gen_rtx_REG(SImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('d' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(1, SImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(1, SImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(1, SImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RAX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1478 "x86-64.int.py"
rz32x :  DIV_SI(r32x, SUBREG_SI(MEM_DI(addr), CONST_0)) [52, 4]
#line 1518 "x86-64.int.py"
  supairs {
    if (0) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RAX);
  },
  build {
    if (REG_RAX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (0)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('d' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (0)
      memorable($2->r);
    cost_copy(REG_RAX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movl", $1->rx, REG_RAX, 'd');
    if ('d' != 'b') {
      if (1) {
	dump("cdq");					/* such as cqo or cdq */
      } else {
	dumpRR("cdq", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (0) {
      dumpR("idivl", $2->r, 'd');
    } else {
      dumpM("idivl", $2);
    }
    dump_copy("movl", REG_RAX, $$->rx, 'd');
  },
  emit {
    rtx dst  = gen_rtx_REG(SImode, $$->rx);
    rtx src1 = gen_rtx_REG(SImode, $1->rx);
    rtx src2 = 0
      ? gen_rtx_REG(SImode, $2->r)
      : gen_rtx_MEM(SImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(SImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('d' != 'b') ? gen_rtx_REG(SImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('d' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(1, SImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(1, SImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(1, SImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RAX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1480 "x86-64.int.py"
r64x :   MOD_DI(r64x, MEM_DI(addr)) [52, 8]
#line 1518 "x86-64.int.py"
  supairs {
    if (0) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RDX);
  },
  build {
    if (REG_RDX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (0)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('q' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (0)
      memorable($2->r);
    cost_copy(REG_RDX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movq", $1->rx, REG_RAX, 'q');
    if ('q' != 'b') {
      if (1) {
	dump("cqo");					/* such as cqo or cdq */
      } else {
	dumpRR("cqo", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (0) {
      dumpR("idivq", $2->r, 'q');
    } else {
      dumpM("idivq", $2);
    }
    dump_copy("movq", REG_RDX, $$->rx, 'q');
  },
  emit {
    rtx dst  = gen_rtx_REG(DImode, $$->rx);
    rtx src1 = gen_rtx_REG(DImode, $1->rx);
    rtx src2 = 0
      ? gen_rtx_REG(DImode, $2->r)
      : gen_rtx_MEM(DImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(DImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('q' != 'b') ? gen_rtx_REG(DImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('q' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(1, DImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(1, DImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(1, DImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RDX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1481 "x86-64.int.py"
rz32x :  MOD_SI(r32x, MEM_SI(addr)) [52, 4]
#line 1518 "x86-64.int.py"
  supairs {
    if (0) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RDX);
  },
  build {
    if (REG_RDX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (0)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('d' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (0)
      memorable($2->r);
    cost_copy(REG_RDX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movl", $1->rx, REG_RAX, 'd');
    if ('d' != 'b') {
      if (1) {
	dump("cdq");					/* such as cqo or cdq */
      } else {
	dumpRR("cdq", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (0) {
      dumpR("idivl", $2->r, 'd');
    } else {
      dumpM("idivl", $2);
    }
    dump_copy("movl", REG_RDX, $$->rx, 'd');
  },
  emit {
    rtx dst  = gen_rtx_REG(SImode, $$->rx);
    rtx src1 = gen_rtx_REG(SImode, $1->rx);
    rtx src2 = 0
      ? gen_rtx_REG(SImode, $2->r)
      : gen_rtx_MEM(SImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(SImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('d' != 'b') ? gen_rtx_REG(SImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('d' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(1, SImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(1, SImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(1, SImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RDX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1482 "x86-64.int.py"
rz32x :  MOD_SI(r32x, SUBREG_SI(MEM_DI(addr), CONST_0)) [52, 4]
#line 1518 "x86-64.int.py"
  supairs {
    if (0) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RDX);
  },
  build {
    if (REG_RDX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (0)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('d' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (0)
      memorable($2->r);
    cost_copy(REG_RDX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movl", $1->rx, REG_RAX, 'd');
    if ('d' != 'b') {
      if (1) {
	dump("cdq");					/* such as cqo or cdq */
      } else {
	dumpRR("cdq", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (0) {
      dumpR("idivl", $2->r, 'd');
    } else {
      dumpM("idivl", $2);
    }
    dump_copy("movl", REG_RDX, $$->rx, 'd');
  },
  emit {
    rtx dst  = gen_rtx_REG(SImode, $$->rx);
    rtx src1 = gen_rtx_REG(SImode, $1->rx);
    rtx src2 = 0
      ? gen_rtx_REG(SImode, $2->r)
      : gen_rtx_MEM(SImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(SImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('d' != 'b') ? gen_rtx_REG(SImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('d' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(1, SImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(1, SImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(1, SImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RDX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1490 "x86-64.int.py"
r64x  : UDIV_DI(r64x, r64) [52, 8]
#line 1518 "x86-64.int.py"
  supairs {
    if (1) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RAX);
  },
  build {
    if (REG_RAX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (1)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('q' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (1)
      memorable($2->r);
    cost_copy(REG_RAX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movq", $1->rx, REG_RAX, 'q');
    if ('q' != 'b') {
      if (0) {
	dump("xorl");					/* such as cqo or cdq */
      } else {
	dumpRR("xorl", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (1) {
      dumpR("divq", $2->r, 'q');
    } else {
      dumpM("divq", $2);
    }
    dump_copy("movq", REG_RAX, $$->rx, 'q');
  },
  emit {
    rtx dst  = gen_rtx_REG(DImode, $$->rx);
    rtx src1 = gen_rtx_REG(DImode, $1->rx);
    rtx src2 = 1
      ? gen_rtx_REG(DImode, $2->r)
      : gen_rtx_MEM(DImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(DImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('q' != 'b') ? gen_rtx_REG(DImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('q' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, DImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, DImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(0, DImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RAX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1491 "x86-64.int.py"
rz32x : UDIV_SI(r32x, r32) [52, 6]
#line 1518 "x86-64.int.py"
  supairs {
    if (1) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RAX);
  },
  build {
    if (REG_RAX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (1)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('d' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (1)
      memorable($2->r);
    cost_copy(REG_RAX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movl", $1->rx, REG_RAX, 'd');
    if ('d' != 'b') {
      if (0) {
	dump("xorl");					/* such as cqo or cdq */
      } else {
	dumpRR("xorl", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (1) {
      dumpR("divl", $2->r, 'd');
    } else {
      dumpM("divl", $2);
    }
    dump_copy("movl", REG_RAX, $$->rx, 'd');
  },
  emit {
    rtx dst  = gen_rtx_REG(SImode, $$->rx);
    rtx src1 = gen_rtx_REG(SImode, $1->rx);
    rtx src2 = 1
      ? gen_rtx_REG(SImode, $2->r)
      : gen_rtx_MEM(SImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(SImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('d' != 'b') ? gen_rtx_REG(SImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('d' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, SImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, SImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(0, SImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RAX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1492 "x86-64.int.py"
r16x  : UDIV_HI(r16x, r16) [52, 6]
#line 1518 "x86-64.int.py"
  supairs {
    if (1) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RAX);
  },
  build {
    if (REG_RAX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (1)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('w' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (1)
      memorable($2->r);
    cost_copy(REG_RAX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movl", $1->rx, REG_RAX, 'w');
    if ('w' != 'b') {
      if (0) {
	dump("xorl");					/* such as cqo or cdq */
      } else {
	dumpRR("xorl", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (1) {
      dumpR("divw", $2->r, 'w');
    } else {
      dumpM("divw", $2);
    }
    dump_copy("movl", REG_RAX, $$->rx, 'w');
  },
  emit {
    rtx dst  = gen_rtx_REG(HImode, $$->rx);
    rtx src1 = gen_rtx_REG(HImode, $1->rx);
    rtx src2 = 1
      ? gen_rtx_REG(HImode, $2->r)
      : gen_rtx_MEM(HImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(HImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('w' != 'b') ? gen_rtx_REG(HImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('w' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, HImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, HImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(0, HImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RAX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1493 "x86-64.int.py"
r8x   : UDIV_QI(r16x, r8) [52, 6]
#line 1518 "x86-64.int.py"
  supairs {
    if (1) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RAX);
  },
  build {
    if (REG_RAX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (1)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('b' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (1)
      memorable($2->r);
    cost_copy(REG_RAX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movl", $1->rx, REG_RAX, 'b');
    if ('b' != 'b') {
      if (0) {
	dump("xor?");					/* such as cqo or cdq */
      } else {
	dumpRR("xor?", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (1) {
      dumpR("divb", $2->r, 'b');
    } else {
      dumpM("divb", $2);
    }
    dump_copy("movl", REG_RAX, $$->rx, 'b');
  },
  emit {
    rtx dst  = gen_rtx_REG(QImode, $$->rx);
    rtx src1 = gen_rtx_REG(QImode, $1->rx);
    rtx src2 = 1
      ? gen_rtx_REG(QImode, $2->r)
      : gen_rtx_MEM(QImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(QImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('b' != 'b') ? gen_rtx_REG(QImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('b' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, QImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, QImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(0, QImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RAX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1495 "x86-64.int.py"
r64x  : UMOD_DI(r64x, r64) [52, 8]
#line 1518 "x86-64.int.py"
  supairs {
    if (1) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RDX);
  },
  build {
    if (REG_RDX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (1)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('q' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (1)
      memorable($2->r);
    cost_copy(REG_RDX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movq", $1->rx, REG_RAX, 'q');
    if ('q' != 'b') {
      if (0) {
	dump("xorl");					/* such as cqo or cdq */
      } else {
	dumpRR("xorl", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (1) {
      dumpR("divq", $2->r, 'q');
    } else {
      dumpM("divq", $2);
    }
    dump_copy("movq", REG_RDX, $$->rx, 'q');
  },
  emit {
    rtx dst  = gen_rtx_REG(DImode, $$->rx);
    rtx src1 = gen_rtx_REG(DImode, $1->rx);
    rtx src2 = 1
      ? gen_rtx_REG(DImode, $2->r)
      : gen_rtx_MEM(DImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(DImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('q' != 'b') ? gen_rtx_REG(DImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('q' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, DImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, DImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(0, DImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RDX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1496 "x86-64.int.py"
rz32x : UMOD_SI(r32x, r32) [52, 6]
#line 1518 "x86-64.int.py"
  supairs {
    if (1) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RDX);
  },
  build {
    if (REG_RDX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (1)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('d' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (1)
      memorable($2->r);
    cost_copy(REG_RDX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movl", $1->rx, REG_RAX, 'd');
    if ('d' != 'b') {
      if (0) {
	dump("xorl");					/* such as cqo or cdq */
      } else {
	dumpRR("xorl", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (1) {
      dumpR("divl", $2->r, 'd');
    } else {
      dumpM("divl", $2);
    }
    dump_copy("movl", REG_RDX, $$->rx, 'd');
  },
  emit {
    rtx dst  = gen_rtx_REG(SImode, $$->rx);
    rtx src1 = gen_rtx_REG(SImode, $1->rx);
    rtx src2 = 1
      ? gen_rtx_REG(SImode, $2->r)
      : gen_rtx_MEM(SImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(SImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('d' != 'b') ? gen_rtx_REG(SImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('d' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, SImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, SImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(0, SImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RDX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1497 "x86-64.int.py"
r16x  : UMOD_HI(r16x, r16) [52, 6]
#line 1518 "x86-64.int.py"
  supairs {
    if (1) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RDX);
  },
  build {
    if (REG_RDX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (1)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('w' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (1)
      memorable($2->r);
    cost_copy(REG_RDX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movl", $1->rx, REG_RAX, 'w');
    if ('w' != 'b') {
      if (0) {
	dump("xorl");					/* such as cqo or cdq */
      } else {
	dumpRR("xorl", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (1) {
      dumpR("divw", $2->r, 'w');
    } else {
      dumpM("divw", $2);
    }
    dump_copy("movl", REG_RDX, $$->rx, 'w');
  },
  emit {
    rtx dst  = gen_rtx_REG(HImode, $$->rx);
    rtx src1 = gen_rtx_REG(HImode, $1->rx);
    rtx src2 = 1
      ? gen_rtx_REG(HImode, $2->r)
      : gen_rtx_MEM(HImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(HImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('w' != 'b') ? gen_rtx_REG(HImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('w' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, HImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, HImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(0, HImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RDX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1499 "x86-64.int.py"
r64x  : UDIV_DI(r64x,           MEM_DI(addr)) [52, 8]
#line 1518 "x86-64.int.py"
  supairs {
    if (0) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RAX);
  },
  build {
    if (REG_RAX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (0)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('q' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (0)
      memorable($2->r);
    cost_copy(REG_RAX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movq", $1->rx, REG_RAX, 'q');
    if ('q' != 'b') {
      if (0) {
	dump("xorl");					/* such as cqo or cdq */
      } else {
	dumpRR("xorl", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (0) {
      dumpR("divq", $2->r, 'q');
    } else {
      dumpM("divq", $2);
    }
    dump_copy("movq", REG_RAX, $$->rx, 'q');
  },
  emit {
    rtx dst  = gen_rtx_REG(DImode, $$->rx);
    rtx src1 = gen_rtx_REG(DImode, $1->rx);
    rtx src2 = 0
      ? gen_rtx_REG(DImode, $2->r)
      : gen_rtx_MEM(DImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(DImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('q' != 'b') ? gen_rtx_REG(DImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('q' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, DImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, DImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(0, DImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RAX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1500 "x86-64.int.py"
rz32x : UDIV_SI(r32x,           MEM_SI(addr)) [52, 5]
#line 1518 "x86-64.int.py"
  supairs {
    if (0) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RAX);
  },
  build {
    if (REG_RAX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (0)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('d' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (0)
      memorable($2->r);
    cost_copy(REG_RAX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movl", $1->rx, REG_RAX, 'd');
    if ('d' != 'b') {
      if (0) {
	dump("xorl");					/* such as cqo or cdq */
      } else {
	dumpRR("xorl", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (0) {
      dumpR("divl", $2->r, 'd');
    } else {
      dumpM("divl", $2);
    }
    dump_copy("movl", REG_RAX, $$->rx, 'd');
  },
  emit {
    rtx dst  = gen_rtx_REG(SImode, $$->rx);
    rtx src1 = gen_rtx_REG(SImode, $1->rx);
    rtx src2 = 0
      ? gen_rtx_REG(SImode, $2->r)
      : gen_rtx_MEM(SImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(SImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('d' != 'b') ? gen_rtx_REG(SImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('d' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, SImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, SImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(0, SImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RAX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1501 "x86-64.int.py"
rz32x : UDIV_SI(r32x, SUBREG_SI(MEM_DI(addr), CONST_0)) [52, 5]
#line 1518 "x86-64.int.py"
  supairs {
    if (0) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RAX);
  },
  build {
    if (REG_RAX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (0)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('d' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (0)
      memorable($2->r);
    cost_copy(REG_RAX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movl", $1->rx, REG_RAX, 'd');
    if ('d' != 'b') {
      if (0) {
	dump("xorl");					/* such as cqo or cdq */
      } else {
	dumpRR("xorl", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (0) {
      dumpR("divl", $2->r, 'd');
    } else {
      dumpM("divl", $2);
    }
    dump_copy("movl", REG_RAX, $$->rx, 'd');
  },
  emit {
    rtx dst  = gen_rtx_REG(SImode, $$->rx);
    rtx src1 = gen_rtx_REG(SImode, $1->rx);
    rtx src2 = 0
      ? gen_rtx_REG(SImode, $2->r)
      : gen_rtx_MEM(SImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(SImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('d' != 'b') ? gen_rtx_REG(SImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('d' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, SImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, SImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(0, SImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RAX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1502 "x86-64.int.py"
r16x  : UDIV_HI(r16x,           MEM_HI(addr)) [52, 6]
#line 1518 "x86-64.int.py"
  supairs {
    if (0) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RAX);
  },
  build {
    if (REG_RAX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (0)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('w' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (0)
      memorable($2->r);
    cost_copy(REG_RAX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movl", $1->rx, REG_RAX, 'w');
    if ('w' != 'b') {
      if (0) {
	dump("xorl");					/* such as cqo or cdq */
      } else {
	dumpRR("xorl", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (0) {
      dumpR("divw", $2->r, 'w');
    } else {
      dumpM("divw", $2);
    }
    dump_copy("movl", REG_RAX, $$->rx, 'w');
  },
  emit {
    rtx dst  = gen_rtx_REG(HImode, $$->rx);
    rtx src1 = gen_rtx_REG(HImode, $1->rx);
    rtx src2 = 0
      ? gen_rtx_REG(HImode, $2->r)
      : gen_rtx_MEM(HImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(HImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('w' != 'b') ? gen_rtx_REG(HImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('w' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, HImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, HImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(0, HImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RAX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1503 "x86-64.int.py"
r16x  : UDIV_HI(r16x, SUBREG_HI(MEM_DI(addr), CONST_0)) [52, 6]
#line 1518 "x86-64.int.py"
  supairs {
    if (0) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RAX);
  },
  build {
    if (REG_RAX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (0)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('w' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (0)
      memorable($2->r);
    cost_copy(REG_RAX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movl", $1->rx, REG_RAX, 'w');
    if ('w' != 'b') {
      if (0) {
	dump("xorl");					/* such as cqo or cdq */
      } else {
	dumpRR("xorl", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (0) {
      dumpR("divw", $2->r, 'w');
    } else {
      dumpM("divw", $2);
    }
    dump_copy("movl", REG_RAX, $$->rx, 'w');
  },
  emit {
    rtx dst  = gen_rtx_REG(HImode, $$->rx);
    rtx src1 = gen_rtx_REG(HImode, $1->rx);
    rtx src2 = 0
      ? gen_rtx_REG(HImode, $2->r)
      : gen_rtx_MEM(HImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(HImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('w' != 'b') ? gen_rtx_REG(HImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('w' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, HImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, HImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(0, HImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RAX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1504 "x86-64.int.py"
r16x  : UDIV_HI(r16x, SUBREG_HI(MEM_SI(addr), CONST_0)) [52, 6]
#line 1518 "x86-64.int.py"
  supairs {
    if (0) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RAX);
  },
  build {
    if (REG_RAX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (0)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('w' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (0)
      memorable($2->r);
    cost_copy(REG_RAX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movl", $1->rx, REG_RAX, 'w');
    if ('w' != 'b') {
      if (0) {
	dump("xorl");					/* such as cqo or cdq */
      } else {
	dumpRR("xorl", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (0) {
      dumpR("divw", $2->r, 'w');
    } else {
      dumpM("divw", $2);
    }
    dump_copy("movl", REG_RAX, $$->rx, 'w');
  },
  emit {
    rtx dst  = gen_rtx_REG(HImode, $$->rx);
    rtx src1 = gen_rtx_REG(HImode, $1->rx);
    rtx src2 = 0
      ? gen_rtx_REG(HImode, $2->r)
      : gen_rtx_MEM(HImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(HImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('w' != 'b') ? gen_rtx_REG(HImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('w' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, HImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, HImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(0, HImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RAX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1505 "x86-64.int.py"
r8x   : UDIV_QI(r16x, SUBREG_QI(MEM_DI(addr), CONST_0)) [52, 6]
#line 1518 "x86-64.int.py"
  supairs {
    if (0) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RAX);
  },
  build {
    if (REG_RAX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (0)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('b' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (0)
      memorable($2->r);
    cost_copy(REG_RAX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movl", $1->rx, REG_RAX, 'b');
    if ('b' != 'b') {
      if (0) {
	dump("xor?");					/* such as cqo or cdq */
      } else {
	dumpRR("xor?", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (0) {
      dumpR("divb", $2->r, 'b');
    } else {
      dumpM("divb", $2);
    }
    dump_copy("movl", REG_RAX, $$->rx, 'b');
  },
  emit {
    rtx dst  = gen_rtx_REG(QImode, $$->rx);
    rtx src1 = gen_rtx_REG(QImode, $1->rx);
    rtx src2 = 0
      ? gen_rtx_REG(QImode, $2->r)
      : gen_rtx_MEM(QImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(QImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('b' != 'b') ? gen_rtx_REG(QImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('b' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, QImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, QImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(0, QImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RAX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1506 "x86-64.int.py"
r8x   : UDIV_QI(r16x, SUBREG_QI(MEM_SI(addr), CONST_0)) [52, 6]
#line 1518 "x86-64.int.py"
  supairs {
    if (0) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RAX);
  },
  build {
    if (REG_RAX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (0)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('b' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (0)
      memorable($2->r);
    cost_copy(REG_RAX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movl", $1->rx, REG_RAX, 'b');
    if ('b' != 'b') {
      if (0) {
	dump("xor?");					/* such as cqo or cdq */
      } else {
	dumpRR("xor?", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (0) {
      dumpR("divb", $2->r, 'b');
    } else {
      dumpM("divb", $2);
    }
    dump_copy("movl", REG_RAX, $$->rx, 'b');
  },
  emit {
    rtx dst  = gen_rtx_REG(QImode, $$->rx);
    rtx src1 = gen_rtx_REG(QImode, $1->rx);
    rtx src2 = 0
      ? gen_rtx_REG(QImode, $2->r)
      : gen_rtx_MEM(QImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(QImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('b' != 'b') ? gen_rtx_REG(QImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('b' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, QImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, QImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(0, QImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RAX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1507 "x86-64.int.py"
r8x   : UDIV_QI(r16x, SUBREG_QI(MEM_HI(addr), CONST_0)) [52, 6]
#line 1518 "x86-64.int.py"
  supairs {
    if (0) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RAX);
  },
  build {
    if (REG_RAX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (0)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('b' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (0)
      memorable($2->r);
    cost_copy(REG_RAX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movl", $1->rx, REG_RAX, 'b');
    if ('b' != 'b') {
      if (0) {
	dump("xor?");					/* such as cqo or cdq */
      } else {
	dumpRR("xor?", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (0) {
      dumpR("divb", $2->r, 'b');
    } else {
      dumpM("divb", $2);
    }
    dump_copy("movl", REG_RAX, $$->rx, 'b');
  },
  emit {
    rtx dst  = gen_rtx_REG(QImode, $$->rx);
    rtx src1 = gen_rtx_REG(QImode, $1->rx);
    rtx src2 = 0
      ? gen_rtx_REG(QImode, $2->r)
      : gen_rtx_MEM(QImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(QImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('b' != 'b') ? gen_rtx_REG(QImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('b' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, QImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, QImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(0, QImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RAX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1509 "x86-64.int.py"
r64x  : UMOD_DI(r64x,           MEM_DI(addr)) [52, 8]
#line 1518 "x86-64.int.py"
  supairs {
    if (0) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RDX);
  },
  build {
    if (REG_RDX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (0)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('q' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (0)
      memorable($2->r);
    cost_copy(REG_RDX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movq", $1->rx, REG_RAX, 'q');
    if ('q' != 'b') {
      if (0) {
	dump("xorl");					/* such as cqo or cdq */
      } else {
	dumpRR("xorl", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (0) {
      dumpR("divq", $2->r, 'q');
    } else {
      dumpM("divq", $2);
    }
    dump_copy("movq", REG_RDX, $$->rx, 'q');
  },
  emit {
    rtx dst  = gen_rtx_REG(DImode, $$->rx);
    rtx src1 = gen_rtx_REG(DImode, $1->rx);
    rtx src2 = 0
      ? gen_rtx_REG(DImode, $2->r)
      : gen_rtx_MEM(DImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(DImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('q' != 'b') ? gen_rtx_REG(DImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('q' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, DImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, DImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(0, DImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RDX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1510 "x86-64.int.py"
rz32x : UMOD_SI(r32x,           MEM_SI(addr)) [52, 5]
#line 1518 "x86-64.int.py"
  supairs {
    if (0) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RDX);
  },
  build {
    if (REG_RDX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (0)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('d' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (0)
      memorable($2->r);
    cost_copy(REG_RDX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movl", $1->rx, REG_RAX, 'd');
    if ('d' != 'b') {
      if (0) {
	dump("xorl");					/* such as cqo or cdq */
      } else {
	dumpRR("xorl", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (0) {
      dumpR("divl", $2->r, 'd');
    } else {
      dumpM("divl", $2);
    }
    dump_copy("movl", REG_RDX, $$->rx, 'd');
  },
  emit {
    rtx dst  = gen_rtx_REG(SImode, $$->rx);
    rtx src1 = gen_rtx_REG(SImode, $1->rx);
    rtx src2 = 0
      ? gen_rtx_REG(SImode, $2->r)
      : gen_rtx_MEM(SImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(SImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('d' != 'b') ? gen_rtx_REG(SImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('d' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, SImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, SImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(0, SImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RDX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1511 "x86-64.int.py"
rz32x : UMOD_SI(r32x, SUBREG_SI(MEM_DI(addr), CONST_0)) [52, 5]
#line 1518 "x86-64.int.py"
  supairs {
    if (0) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RDX);
  },
  build {
    if (REG_RDX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (0)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('d' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (0)
      memorable($2->r);
    cost_copy(REG_RDX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movl", $1->rx, REG_RAX, 'd');
    if ('d' != 'b') {
      if (0) {
	dump("xorl");					/* such as cqo or cdq */
      } else {
	dumpRR("xorl", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (0) {
      dumpR("divl", $2->r, 'd');
    } else {
      dumpM("divl", $2);
    }
    dump_copy("movl", REG_RDX, $$->rx, 'd');
  },
  emit {
    rtx dst  = gen_rtx_REG(SImode, $$->rx);
    rtx src1 = gen_rtx_REG(SImode, $1->rx);
    rtx src2 = 0
      ? gen_rtx_REG(SImode, $2->r)
      : gen_rtx_MEM(SImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(SImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('d' != 'b') ? gen_rtx_REG(SImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('d' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, SImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, SImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(0, SImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RDX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1512 "x86-64.int.py"
r16x  : UMOD_HI(r16x,           MEM_HI(addr)) [52, 6]
#line 1518 "x86-64.int.py"
  supairs {
    if (0) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RDX);
  },
  build {
    if (REG_RDX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (0)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('w' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (0)
      memorable($2->r);
    cost_copy(REG_RDX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movl", $1->rx, REG_RAX, 'w');
    if ('w' != 'b') {
      if (0) {
	dump("xorl");					/* such as cqo or cdq */
      } else {
	dumpRR("xorl", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (0) {
      dumpR("divw", $2->r, 'w');
    } else {
      dumpM("divw", $2);
    }
    dump_copy("movl", REG_RDX, $$->rx, 'w');
  },
  emit {
    rtx dst  = gen_rtx_REG(HImode, $$->rx);
    rtx src1 = gen_rtx_REG(HImode, $1->rx);
    rtx src2 = 0
      ? gen_rtx_REG(HImode, $2->r)
      : gen_rtx_MEM(HImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(HImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('w' != 'b') ? gen_rtx_REG(HImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('w' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, HImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, HImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(0, HImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RDX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1513 "x86-64.int.py"
r16x  : UMOD_HI(r16x, SUBREG_HI(MEM_DI(addr), CONST_0)) [52, 6]
#line 1518 "x86-64.int.py"
  supairs {
    if (0) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RDX);
  },
  build {
    if (REG_RDX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (0)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('w' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (0)
      memorable($2->r);
    cost_copy(REG_RDX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movl", $1->rx, REG_RAX, 'w');
    if ('w' != 'b') {
      if (0) {
	dump("xorl");					/* such as cqo or cdq */
      } else {
	dumpRR("xorl", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (0) {
      dumpR("divw", $2->r, 'w');
    } else {
      dumpM("divw", $2);
    }
    dump_copy("movl", REG_RDX, $$->rx, 'w');
  },
  emit {
    rtx dst  = gen_rtx_REG(HImode, $$->rx);
    rtx src1 = gen_rtx_REG(HImode, $1->rx);
    rtx src2 = 0
      ? gen_rtx_REG(HImode, $2->r)
      : gen_rtx_MEM(HImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(HImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('w' != 'b') ? gen_rtx_REG(HImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('w' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, HImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, HImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(0, HImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RDX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1514 "x86-64.int.py"
r16x  : UMOD_HI(r16x, SUBREG_HI(MEM_SI(addr), CONST_0)) [52, 6]
#line 1518 "x86-64.int.py"
  supairs {
    if (0) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RDX);
  },
  build {
    if (REG_RDX == REG_RAX)
      add_copy_edges($$->rx, REG_RAX, live);

    else
      add_copy_edges($$->rx, REG_RDX, live);

    add_edges(REG_RAX, live);
    if (0)
      sparseset_set_bit(live, find($2->r));
    else
      add_addr(live, $2);

    if ('w' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);
    }

    add_copy_edges(REG_RAX, $1->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy($1->rx, REG_RAX);
    memorable($1->rx);
    if (0)
      memorable($2->r);
    cost_copy(REG_RDX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movl", $1->rx, REG_RAX, 'w');
    if ('w' != 'b') {
      if (0) {
	dump("xorl");					/* such as cqo or cdq */
      } else {
	dumpRR("xorl", REG_RDX, 'd', REG_RDX, 'd');	/* xorl */
      }
    }
    if (0) {
      dumpR("divw", $2->r, 'w');
    } else {
      dumpM("divw", $2);
    }
    dump_copy("movl", REG_RDX, $$->rx, 'w');
  },
  emit {
    rtx dst  = gen_rtx_REG(HImode, $$->rx);
    rtx src1 = gen_rtx_REG(HImode, $1->rx);
    rtx src2 = 0
      ? gen_rtx_REG(HImode, $2->r)
      : gen_rtx_MEM(HImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(HImode, REG_RAX);
    rtx rax1 = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx = ('w' != 'b') ? gen_rtx_REG(HImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * TODO? emit RTL for the sign_extend (true sign extend, or zero fill with xor) using rdx/rdxm
     */
    parset = ('w' == 'b')
      ? gen_rtvec(2,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, HImode, rax1, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
      : gen_rtvec(3,
	  gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, HImode, rax, src2)),
	  gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(0, HImode, rax, src2)),
	  gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))
    ;
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RDX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 1647 "x86-64.int.py"
stmt : PARALLEL_ALL(SET_ALL(lhs64, DIV_DI(r64, r64)),
#line 1660 "x86-64.int.py"
                          SET_ALL(lhs64, MOD_DI(r64, r64))) [52, 8]
  supairs {
    /* suOrder2($$, $1, $2, kid, kids); */
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->r, REG_RAX);
    if (!$1->spilled)
      coalesces += attempt_coalesce(pass, $1->r, REG_RAX);
    if (!$4->spilled)
      coalesces += attempt_coalesce(pass, $4->r, REG_RDX);
  },
  build {
    /* final copy instruction */
    if ($4->spilled) {
      sparseset_set_bit(live, REG_RDX);
      add_addr(live, $4);
    }
    else
      add_copy_edges($4->r, REG_RDX, live);

    /* penultimate copy instruction */
    if ($1->spilled) {
      sparseset_set_bit(live, REG_RAX);
      add_addr(live, $1);
    }
    else
      add_copy_edges($1->r, REG_RAX, live);

    /* divide instruction */
    add_edges(REG_RAX, live);
    if (1)
      sparseset_set_bit(live, find($3->r));
    else
      add_addr(live, $3);

    /* extension instruction */
    sparseset_clear_bit(live, REG_RDX);
    add_edges(REG_RDX, live);

    /* final copy instruction */
    add_copy_edges(REG_RAX, $2->r, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
    cost_copy($2->r, REG_RAX);
    if (1)
      memorable($3->r);
    if (!$1->spilled)
      cost_copy($1->r, REG_RAX);
    if (!$4->spilled)
      cost_copy(REG_RDX, $4->r);
  },
  debug {
    dump_copy("movq", $2->r, REG_RAX, 'q');

    if (1)
      dump("cqo");
    else
      dumpRR("cqo", REG_RDX, 'q', REG_RDX, 'q');

    if (1)
      dumpR("idivq", $3->r, 'q');
    else
      dumpM("idivq", $3);

    if ($1->spilled)
      dumpRM("movq", REG_RAX, 'q', $1);
    else
      dump_copy("movq", REG_RAX, $1->r, 'q');

    if ($1->spilled)
      dumpRM("movq", REG_RDX, 'q', $4);
    else
      dump_copy("movq", REG_RDX, $4->r, 'q');
  },
  emit {
    rtx src1 = gen_rtx_REG(DImode, $2->r);
    rtx src2 = 1
      ? gen_rtx_REG(DImode, $3->r)
      : gen_rtx_MEM(DImode, $3->rtl);
    rtx dst1 = $1->spilled
      ? gen_rtx_MEM(DImode, $1->rtl)
      : gen_rtx_REG(DImode, $1->r);
    rtx dst2 = $4->spilled
      ? gen_rtx_MEM(DImode, $4->rtl)
      : gen_rtx_REG(DImode, $4->r);
    rtx rax  = gen_rtx_REG(DImode, REG_RAX);
    rtx rdx  = gen_rtx_REG(DImode, REG_RDX);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax, src1));
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode,
      gen_rtvec(3,
	gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(1, DImode, rax, src2)),
	gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(1, DImode, rax, src2)),
	gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst1, rax));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst2, rdx));
  };
#line 1647 "x86-64.int.py"
stmt : PARALLEL_ALL(SET_ALL(lhs32, DIV_SI(r32, r32)),
#line 1660 "x86-64.int.py"
                          SET_ALL(lhs32, MOD_SI(r32, r32))) [52, 8]
  supairs {
    /* suOrder2($$, $1, $2, kid, kids); */
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->r, REG_RAX);
    if (!$1->spilled)
      coalesces += attempt_coalesce(pass, $1->r, REG_RAX);
    if (!$4->spilled)
      coalesces += attempt_coalesce(pass, $4->r, REG_RDX);
  },
  build {
    /* final copy instruction */
    if ($4->spilled) {
      sparseset_set_bit(live, REG_RDX);
      add_addr(live, $4);
    }
    else
      add_copy_edges($4->r, REG_RDX, live);

    /* penultimate copy instruction */
    if ($1->spilled) {
      sparseset_set_bit(live, REG_RAX);
      add_addr(live, $1);
    }
    else
      add_copy_edges($1->r, REG_RAX, live);

    /* divide instruction */
    add_edges(REG_RAX, live);
    if (1)
      sparseset_set_bit(live, find($3->r));
    else
      add_addr(live, $3);

    /* extension instruction */
    sparseset_clear_bit(live, REG_RDX);
    add_edges(REG_RDX, live);

    /* final copy instruction */
    add_copy_edges(REG_RAX, $2->r, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
    cost_copy($2->r, REG_RAX);
    if (1)
      memorable($3->r);
    if (!$1->spilled)
      cost_copy($1->r, REG_RAX);
    if (!$4->spilled)
      cost_copy(REG_RDX, $4->r);
  },
  debug {
    dump_copy("movl", $2->r, REG_RAX, 'd');

    if (1)
      dump("cdq");
    else
      dumpRR("cdq", REG_RDX, 'd', REG_RDX, 'd');

    if (1)
      dumpR("idivl", $3->r, 'd');
    else
      dumpM("idivl", $3);

    if ($1->spilled)
      dumpRM("movl", REG_RAX, 'd', $1);
    else
      dump_copy("movl", REG_RAX, $1->r, 'd');

    if ($1->spilled)
      dumpRM("movl", REG_RDX, 'd', $4);
    else
      dump_copy("movl", REG_RDX, $4->r, 'd');
  },
  emit {
    rtx src1 = gen_rtx_REG(SImode, $2->r);
    rtx src2 = 1
      ? gen_rtx_REG(SImode, $3->r)
      : gen_rtx_MEM(SImode, $3->rtl);
    rtx dst1 = $1->spilled
      ? gen_rtx_MEM(SImode, $1->rtl)
      : gen_rtx_REG(SImode, $1->r);
    rtx dst2 = $4->spilled
      ? gen_rtx_MEM(SImode, $4->rtl)
      : gen_rtx_REG(SImode, $4->r);
    rtx rax  = gen_rtx_REG(SImode, REG_RAX);
    rtx rdx  = gen_rtx_REG(SImode, REG_RDX);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax, src1));
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode,
      gen_rtvec(3,
	gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(1, SImode, rax, src2)),
	gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(1, SImode, rax, src2)),
	gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst1, rax));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst2, rdx));
  };
#line 1647 "x86-64.int.py"
stmt : PARALLEL_ALL(SET_ALL(lhs64, UDIV_DI(r64, r64)),
#line 1660 "x86-64.int.py"
                          SET_ALL(lhs64, UMOD_DI(r64, r64))) [52, 8]
  supairs {
    /* suOrder2($$, $1, $2, kid, kids); */
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->r, REG_RAX);
    if (!$1->spilled)
      coalesces += attempt_coalesce(pass, $1->r, REG_RAX);
    if (!$4->spilled)
      coalesces += attempt_coalesce(pass, $4->r, REG_RDX);
  },
  build {
    /* final copy instruction */
    if ($4->spilled) {
      sparseset_set_bit(live, REG_RDX);
      add_addr(live, $4);
    }
    else
      add_copy_edges($4->r, REG_RDX, live);

    /* penultimate copy instruction */
    if ($1->spilled) {
      sparseset_set_bit(live, REG_RAX);
      add_addr(live, $1);
    }
    else
      add_copy_edges($1->r, REG_RAX, live);

    /* divide instruction */
    add_edges(REG_RAX, live);
    if (1)
      sparseset_set_bit(live, find($3->r));
    else
      add_addr(live, $3);

    /* extension instruction */
    sparseset_clear_bit(live, REG_RDX);
    add_edges(REG_RDX, live);

    /* final copy instruction */
    add_copy_edges(REG_RAX, $2->r, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
    cost_copy($2->r, REG_RAX);
    if (1)
      memorable($3->r);
    if (!$1->spilled)
      cost_copy($1->r, REG_RAX);
    if (!$4->spilled)
      cost_copy(REG_RDX, $4->r);
  },
  debug {
    dump_copy("movq", $2->r, REG_RAX, 'q');

    if (0)
      dump("xorl");
    else
      dumpRR("xorl", REG_RDX, 'q', REG_RDX, 'q');

    if (1)
      dumpR("divq", $3->r, 'q');
    else
      dumpM("divq", $3);

    if ($1->spilled)
      dumpRM("movq", REG_RAX, 'q', $1);
    else
      dump_copy("movq", REG_RAX, $1->r, 'q');

    if ($1->spilled)
      dumpRM("movq", REG_RDX, 'q', $4);
    else
      dump_copy("movq", REG_RDX, $4->r, 'q');
  },
  emit {
    rtx src1 = gen_rtx_REG(DImode, $2->r);
    rtx src2 = 1
      ? gen_rtx_REG(DImode, $3->r)
      : gen_rtx_MEM(DImode, $3->rtl);
    rtx dst1 = $1->spilled
      ? gen_rtx_MEM(DImode, $1->rtl)
      : gen_rtx_REG(DImode, $1->r);
    rtx dst2 = $4->spilled
      ? gen_rtx_MEM(DImode, $4->rtl)
      : gen_rtx_REG(DImode, $4->r);
    rtx rax  = gen_rtx_REG(DImode, REG_RAX);
    rtx rdx  = gen_rtx_REG(DImode, REG_RDX);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax, src1));
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode,
      gen_rtvec(3,
	gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, DImode, rax, src2)),
	gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(0, DImode, rax, src2)),
	gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst1, rax));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst2, rdx));
  };
#line 1647 "x86-64.int.py"
stmt : PARALLEL_ALL(SET_ALL(lhs32, UDIV_SI(r32, r32)),
#line 1660 "x86-64.int.py"
                          SET_ALL(lhs32, UMOD_SI(r32, r32))) [52, 8]
  supairs {
    /* suOrder2($$, $1, $2, kid, kids); */
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->r, REG_RAX);
    if (!$1->spilled)
      coalesces += attempt_coalesce(pass, $1->r, REG_RAX);
    if (!$4->spilled)
      coalesces += attempt_coalesce(pass, $4->r, REG_RDX);
  },
  build {
    /* final copy instruction */
    if ($4->spilled) {
      sparseset_set_bit(live, REG_RDX);
      add_addr(live, $4);
    }
    else
      add_copy_edges($4->r, REG_RDX, live);

    /* penultimate copy instruction */
    if ($1->spilled) {
      sparseset_set_bit(live, REG_RAX);
      add_addr(live, $1);
    }
    else
      add_copy_edges($1->r, REG_RAX, live);

    /* divide instruction */
    add_edges(REG_RAX, live);
    if (1)
      sparseset_set_bit(live, find($3->r));
    else
      add_addr(live, $3);

    /* extension instruction */
    sparseset_clear_bit(live, REG_RDX);
    add_edges(REG_RDX, live);

    /* final copy instruction */
    add_copy_edges(REG_RAX, $2->r, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
    cost_copy($2->r, REG_RAX);
    if (1)
      memorable($3->r);
    if (!$1->spilled)
      cost_copy($1->r, REG_RAX);
    if (!$4->spilled)
      cost_copy(REG_RDX, $4->r);
  },
  debug {
    dump_copy("movl", $2->r, REG_RAX, 'd');

    if (0)
      dump("xorl");
    else
      dumpRR("xorl", REG_RDX, 'd', REG_RDX, 'd');

    if (1)
      dumpR("divl", $3->r, 'd');
    else
      dumpM("divl", $3);

    if ($1->spilled)
      dumpRM("movl", REG_RAX, 'd', $1);
    else
      dump_copy("movl", REG_RAX, $1->r, 'd');

    if ($1->spilled)
      dumpRM("movl", REG_RDX, 'd', $4);
    else
      dump_copy("movl", REG_RDX, $4->r, 'd');
  },
  emit {
    rtx src1 = gen_rtx_REG(SImode, $2->r);
    rtx src2 = 1
      ? gen_rtx_REG(SImode, $3->r)
      : gen_rtx_MEM(SImode, $3->rtl);
    rtx dst1 = $1->spilled
      ? gen_rtx_MEM(SImode, $1->rtl)
      : gen_rtx_REG(SImode, $1->r);
    rtx dst2 = $4->spilled
      ? gen_rtx_MEM(SImode, $4->rtl)
      : gen_rtx_REG(SImode, $4->r);
    rtx rax  = gen_rtx_REG(SImode, REG_RAX);
    rtx rdx  = gen_rtx_REG(SImode, REG_RDX);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax, src1));
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode,
      gen_rtvec(3,
	gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, SImode, rax, src2)),
	gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(0, SImode, rax, src2)),
	gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst1, rax));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst2, rdx));
  };
#line 1647 "x86-64.int.py"
stmt : PARALLEL_ALL(SET_ALL(lhs64, DIV_DI(r64, MEM_DI(addr))),
#line 1660 "x86-64.int.py"
                          SET_ALL(lhs64, MOD_DI(r64, MEM_DI(addr)))) [52, 8]
  supairs {
    /* suOrder2($$, $1, $2, kid, kids); */
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->r, REG_RAX);
    if (!$1->spilled)
      coalesces += attempt_coalesce(pass, $1->r, REG_RAX);
    if (!$4->spilled)
      coalesces += attempt_coalesce(pass, $4->r, REG_RDX);
  },
  build {
    /* final copy instruction */
    if ($4->spilled) {
      sparseset_set_bit(live, REG_RDX);
      add_addr(live, $4);
    }
    else
      add_copy_edges($4->r, REG_RDX, live);

    /* penultimate copy instruction */
    if ($1->spilled) {
      sparseset_set_bit(live, REG_RAX);
      add_addr(live, $1);
    }
    else
      add_copy_edges($1->r, REG_RAX, live);

    /* divide instruction */
    add_edges(REG_RAX, live);
    if (0)
      sparseset_set_bit(live, find($3->r));
    else
      add_addr(live, $3);

    /* extension instruction */
    sparseset_clear_bit(live, REG_RDX);
    add_edges(REG_RDX, live);

    /* final copy instruction */
    add_copy_edges(REG_RAX, $2->r, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
    cost_copy($2->r, REG_RAX);
    if (0)
      memorable($3->r);
    if (!$1->spilled)
      cost_copy($1->r, REG_RAX);
    if (!$4->spilled)
      cost_copy(REG_RDX, $4->r);
  },
  debug {
    dump_copy("movq", $2->r, REG_RAX, 'q');

    if (1)
      dump("cqo");
    else
      dumpRR("cqo", REG_RDX, 'q', REG_RDX, 'q');

    if (0)
      dumpR("idivq", $3->r, 'q');
    else
      dumpM("idivq", $3);

    if ($1->spilled)
      dumpRM("movq", REG_RAX, 'q', $1);
    else
      dump_copy("movq", REG_RAX, $1->r, 'q');

    if ($1->spilled)
      dumpRM("movq", REG_RDX, 'q', $4);
    else
      dump_copy("movq", REG_RDX, $4->r, 'q');
  },
  emit {
    rtx src1 = gen_rtx_REG(DImode, $2->r);
    rtx src2 = 0
      ? gen_rtx_REG(DImode, $3->r)
      : gen_rtx_MEM(DImode, $3->rtl);
    rtx dst1 = $1->spilled
      ? gen_rtx_MEM(DImode, $1->rtl)
      : gen_rtx_REG(DImode, $1->r);
    rtx dst2 = $4->spilled
      ? gen_rtx_MEM(DImode, $4->rtl)
      : gen_rtx_REG(DImode, $4->r);
    rtx rax  = gen_rtx_REG(DImode, REG_RAX);
    rtx rdx  = gen_rtx_REG(DImode, REG_RDX);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax, src1));
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode,
      gen_rtvec(3,
	gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(1, DImode, rax, src2)),
	gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(1, DImode, rax, src2)),
	gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst1, rax));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst2, rdx));
  };
#line 1647 "x86-64.int.py"
stmt : PARALLEL_ALL(SET_ALL(lhs32, DIV_SI(r32, MEM_SI(addr))),
#line 1660 "x86-64.int.py"
                          SET_ALL(lhs32, MOD_SI(r32, MEM_SI(addr)))) [52, 8]
  supairs {
    /* suOrder2($$, $1, $2, kid, kids); */
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->r, REG_RAX);
    if (!$1->spilled)
      coalesces += attempt_coalesce(pass, $1->r, REG_RAX);
    if (!$4->spilled)
      coalesces += attempt_coalesce(pass, $4->r, REG_RDX);
  },
  build {
    /* final copy instruction */
    if ($4->spilled) {
      sparseset_set_bit(live, REG_RDX);
      add_addr(live, $4);
    }
    else
      add_copy_edges($4->r, REG_RDX, live);

    /* penultimate copy instruction */
    if ($1->spilled) {
      sparseset_set_bit(live, REG_RAX);
      add_addr(live, $1);
    }
    else
      add_copy_edges($1->r, REG_RAX, live);

    /* divide instruction */
    add_edges(REG_RAX, live);
    if (0)
      sparseset_set_bit(live, find($3->r));
    else
      add_addr(live, $3);

    /* extension instruction */
    sparseset_clear_bit(live, REG_RDX);
    add_edges(REG_RDX, live);

    /* final copy instruction */
    add_copy_edges(REG_RAX, $2->r, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
    cost_copy($2->r, REG_RAX);
    if (0)
      memorable($3->r);
    if (!$1->spilled)
      cost_copy($1->r, REG_RAX);
    if (!$4->spilled)
      cost_copy(REG_RDX, $4->r);
  },
  debug {
    dump_copy("movl", $2->r, REG_RAX, 'd');

    if (1)
      dump("cltd");
    else
      dumpRR("cltd", REG_RDX, 'd', REG_RDX, 'd');

    if (0)
      dumpR("idivl", $3->r, 'd');
    else
      dumpM("idivl", $3);

    if ($1->spilled)
      dumpRM("movl", REG_RAX, 'd', $1);
    else
      dump_copy("movl", REG_RAX, $1->r, 'd');

    if ($1->spilled)
      dumpRM("movl", REG_RDX, 'd', $4);
    else
      dump_copy("movl", REG_RDX, $4->r, 'd');
  },
  emit {
    rtx src1 = gen_rtx_REG(SImode, $2->r);
    rtx src2 = 0
      ? gen_rtx_REG(SImode, $3->r)
      : gen_rtx_MEM(SImode, $3->rtl);
    rtx dst1 = $1->spilled
      ? gen_rtx_MEM(SImode, $1->rtl)
      : gen_rtx_REG(SImode, $1->r);
    rtx dst2 = $4->spilled
      ? gen_rtx_MEM(SImode, $4->rtl)
      : gen_rtx_REG(SImode, $4->r);
    rtx rax  = gen_rtx_REG(SImode, REG_RAX);
    rtx rdx  = gen_rtx_REG(SImode, REG_RDX);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax, src1));
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode,
      gen_rtvec(3,
	gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(1, SImode, rax, src2)),
	gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(1, SImode, rax, src2)),
	gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst1, rax));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst2, rdx));
  };
#line 1647 "x86-64.int.py"
stmt : PARALLEL_ALL(SET_ALL(lhs32, DIV_SI(r32, SUBREG_SI(MEM_DI(addr), CONST_0))),
#line 1660 "x86-64.int.py"
                          SET_ALL(lhs32, MOD_SI(r32, SUBREG_SI(MEM_DI(addr), CONST_0)))) [52, 8]
  supairs {
    /* suOrder2($$, $1, $2, kid, kids); */
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->r, REG_RAX);
    if (!$1->spilled)
      coalesces += attempt_coalesce(pass, $1->r, REG_RAX);
    if (!$4->spilled)
      coalesces += attempt_coalesce(pass, $4->r, REG_RDX);
  },
  build {
    /* final copy instruction */
    if ($4->spilled) {
      sparseset_set_bit(live, REG_RDX);
      add_addr(live, $4);
    }
    else
      add_copy_edges($4->r, REG_RDX, live);

    /* penultimate copy instruction */
    if ($1->spilled) {
      sparseset_set_bit(live, REG_RAX);
      add_addr(live, $1);
    }
    else
      add_copy_edges($1->r, REG_RAX, live);

    /* divide instruction */
    add_edges(REG_RAX, live);
    if (0)
      sparseset_set_bit(live, find($3->r));
    else
      add_addr(live, $3);

    /* extension instruction */
    sparseset_clear_bit(live, REG_RDX);
    add_edges(REG_RDX, live);

    /* final copy instruction */
    add_copy_edges(REG_RAX, $2->r, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
    cost_copy($2->r, REG_RAX);
    if (0)
      memorable($3->r);
    if (!$1->spilled)
      cost_copy($1->r, REG_RAX);
    if (!$4->spilled)
      cost_copy(REG_RDX, $4->r);
  },
  debug {
    dump_copy("movl", $2->r, REG_RAX, 'd');

    if (1)
      dump("cltd");
    else
      dumpRR("cltd", REG_RDX, 'd', REG_RDX, 'd');

    if (0)
      dumpR("idivl", $3->r, 'd');
    else
      dumpM("idivl", $3);

    if ($1->spilled)
      dumpRM("movl", REG_RAX, 'd', $1);
    else
      dump_copy("movl", REG_RAX, $1->r, 'd');

    if ($1->spilled)
      dumpRM("movl", REG_RDX, 'd', $4);
    else
      dump_copy("movl", REG_RDX, $4->r, 'd');
  },
  emit {
    rtx src1 = gen_rtx_REG(SImode, $2->r);
    rtx src2 = 0
      ? gen_rtx_REG(SImode, $3->r)
      : gen_rtx_MEM(SImode, $3->rtl);
    rtx dst1 = $1->spilled
      ? gen_rtx_MEM(SImode, $1->rtl)
      : gen_rtx_REG(SImode, $1->r);
    rtx dst2 = $4->spilled
      ? gen_rtx_MEM(SImode, $4->rtl)
      : gen_rtx_REG(SImode, $4->r);
    rtx rax  = gen_rtx_REG(SImode, REG_RAX);
    rtx rdx  = gen_rtx_REG(SImode, REG_RDX);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax, src1));
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode,
      gen_rtvec(3,
	gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(1, SImode, rax, src2)),
	gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(1, SImode, rax, src2)),
	gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst1, rax));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst2, rdx));
  };
#line 1647 "x86-64.int.py"
stmt : PARALLEL_ALL(SET_ALL(lhs64, UDIV_DI(r64, MEM_DI(addr))),
#line 1660 "x86-64.int.py"
                          SET_ALL(lhs64, UMOD_DI(r64, MEM_DI(addr)))) [52, 8]
  supairs {
    /* suOrder2($$, $1, $2, kid, kids); */
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->r, REG_RAX);
    if (!$1->spilled)
      coalesces += attempt_coalesce(pass, $1->r, REG_RAX);
    if (!$4->spilled)
      coalesces += attempt_coalesce(pass, $4->r, REG_RDX);
  },
  build {
    /* final copy instruction */
    if ($4->spilled) {
      sparseset_set_bit(live, REG_RDX);
      add_addr(live, $4);
    }
    else
      add_copy_edges($4->r, REG_RDX, live);

    /* penultimate copy instruction */
    if ($1->spilled) {
      sparseset_set_bit(live, REG_RAX);
      add_addr(live, $1);
    }
    else
      add_copy_edges($1->r, REG_RAX, live);

    /* divide instruction */
    add_edges(REG_RAX, live);
    if (0)
      sparseset_set_bit(live, find($3->r));
    else
      add_addr(live, $3);

    /* extension instruction */
    sparseset_clear_bit(live, REG_RDX);
    add_edges(REG_RDX, live);

    /* final copy instruction */
    add_copy_edges(REG_RAX, $2->r, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
    cost_copy($2->r, REG_RAX);
    if (0)
      memorable($3->r);
    if (!$1->spilled)
      cost_copy($1->r, REG_RAX);
    if (!$4->spilled)
      cost_copy(REG_RDX, $4->r);
  },
  debug {
    dump_copy("movq", $2->r, REG_RAX, 'q');

    if (0)
      dump("xorl");
    else
      dumpRR("xorl", REG_RDX, 'q', REG_RDX, 'q');

    if (0)
      dumpR("divq", $3->r, 'q');
    else
      dumpM("divq", $3);

    if ($1->spilled)
      dumpRM("movq", REG_RAX, 'q', $1);
    else
      dump_copy("movq", REG_RAX, $1->r, 'q');

    if ($1->spilled)
      dumpRM("movq", REG_RDX, 'q', $4);
    else
      dump_copy("movq", REG_RDX, $4->r, 'q');
  },
  emit {
    rtx src1 = gen_rtx_REG(DImode, $2->r);
    rtx src2 = 0
      ? gen_rtx_REG(DImode, $3->r)
      : gen_rtx_MEM(DImode, $3->rtl);
    rtx dst1 = $1->spilled
      ? gen_rtx_MEM(DImode, $1->rtl)
      : gen_rtx_REG(DImode, $1->r);
    rtx dst2 = $4->spilled
      ? gen_rtx_MEM(DImode, $4->rtl)
      : gen_rtx_REG(DImode, $4->r);
    rtx rax  = gen_rtx_REG(DImode, REG_RAX);
    rtx rdx  = gen_rtx_REG(DImode, REG_RDX);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax, src1));
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode,
      gen_rtvec(3,
	gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, DImode, rax, src2)),
	gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(0, DImode, rax, src2)),
	gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst1, rax));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst2, rdx));
  };
#line 1647 "x86-64.int.py"
stmt : PARALLEL_ALL(SET_ALL(lhs32, UDIV_SI(r32, MEM_SI(addr))),
#line 1660 "x86-64.int.py"
                          SET_ALL(lhs32, UMOD_SI(r32, MEM_SI(addr)))) [52, 8]
  supairs {
    /* suOrder2($$, $1, $2, kid, kids); */
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->r, REG_RAX);
    if (!$1->spilled)
      coalesces += attempt_coalesce(pass, $1->r, REG_RAX);
    if (!$4->spilled)
      coalesces += attempt_coalesce(pass, $4->r, REG_RDX);
  },
  build {
    /* final copy instruction */
    if ($4->spilled) {
      sparseset_set_bit(live, REG_RDX);
      add_addr(live, $4);
    }
    else
      add_copy_edges($4->r, REG_RDX, live);

    /* penultimate copy instruction */
    if ($1->spilled) {
      sparseset_set_bit(live, REG_RAX);
      add_addr(live, $1);
    }
    else
      add_copy_edges($1->r, REG_RAX, live);

    /* divide instruction */
    add_edges(REG_RAX, live);
    if (0)
      sparseset_set_bit(live, find($3->r));
    else
      add_addr(live, $3);

    /* extension instruction */
    sparseset_clear_bit(live, REG_RDX);
    add_edges(REG_RDX, live);

    /* final copy instruction */
    add_copy_edges(REG_RAX, $2->r, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
    cost_copy($2->r, REG_RAX);
    if (0)
      memorable($3->r);
    if (!$1->spilled)
      cost_copy($1->r, REG_RAX);
    if (!$4->spilled)
      cost_copy(REG_RDX, $4->r);
  },
  debug {
    dump_copy("movl", $2->r, REG_RAX, 'd');

    if (0)
      dump("xorl");
    else
      dumpRR("xorl", REG_RDX, 'd', REG_RDX, 'd');

    if (0)
      dumpR("divl", $3->r, 'd');
    else
      dumpM("divl", $3);

    if ($1->spilled)
      dumpRM("movl", REG_RAX, 'd', $1);
    else
      dump_copy("movl", REG_RAX, $1->r, 'd');

    if ($1->spilled)
      dumpRM("movl", REG_RDX, 'd', $4);
    else
      dump_copy("movl", REG_RDX, $4->r, 'd');
  },
  emit {
    rtx src1 = gen_rtx_REG(SImode, $2->r);
    rtx src2 = 0
      ? gen_rtx_REG(SImode, $3->r)
      : gen_rtx_MEM(SImode, $3->rtl);
    rtx dst1 = $1->spilled
      ? gen_rtx_MEM(SImode, $1->rtl)
      : gen_rtx_REG(SImode, $1->r);
    rtx dst2 = $4->spilled
      ? gen_rtx_MEM(SImode, $4->rtl)
      : gen_rtx_REG(SImode, $4->r);
    rtx rax  = gen_rtx_REG(SImode, REG_RAX);
    rtx rdx  = gen_rtx_REG(SImode, REG_RDX);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax, src1));
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode,
      gen_rtvec(3,
	gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, SImode, rax, src2)),
	gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(0, SImode, rax, src2)),
	gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst1, rax));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst2, rdx));
  };
#line 1647 "x86-64.int.py"
stmt : PARALLEL_ALL(SET_ALL(lhs32, UDIV_SI(r32, SUBREG_SI(MEM_DI(addr), CONST_0))),
#line 1660 "x86-64.int.py"
                          SET_ALL(lhs32, UMOD_SI(r32, SUBREG_SI(MEM_DI(addr), CONST_0)))) [52, 8]
  supairs {
    /* suOrder2($$, $1, $2, kid, kids); */
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->r, REG_RAX);
    if (!$1->spilled)
      coalesces += attempt_coalesce(pass, $1->r, REG_RAX);
    if (!$4->spilled)
      coalesces += attempt_coalesce(pass, $4->r, REG_RDX);
  },
  build {
    /* final copy instruction */
    if ($4->spilled) {
      sparseset_set_bit(live, REG_RDX);
      add_addr(live, $4);
    }
    else
      add_copy_edges($4->r, REG_RDX, live);

    /* penultimate copy instruction */
    if ($1->spilled) {
      sparseset_set_bit(live, REG_RAX);
      add_addr(live, $1);
    }
    else
      add_copy_edges($1->r, REG_RAX, live);

    /* divide instruction */
    add_edges(REG_RAX, live);
    if (0)
      sparseset_set_bit(live, find($3->r));
    else
      add_addr(live, $3);

    /* extension instruction */
    sparseset_clear_bit(live, REG_RDX);
    add_edges(REG_RDX, live);

    /* final copy instruction */
    add_copy_edges(REG_RAX, $2->r, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
    cost_copy($2->r, REG_RAX);
    if (0)
      memorable($3->r);
    if (!$1->spilled)
      cost_copy($1->r, REG_RAX);
    if (!$4->spilled)
      cost_copy(REG_RDX, $4->r);
  },
  debug {
    dump_copy("movl", $2->r, REG_RAX, 'd');

    if (0)
      dump("xorl");
    else
      dumpRR("xorl", REG_RDX, 'd', REG_RDX, 'd');

    if (0)
      dumpR("divl", $3->r, 'd');
    else
      dumpM("divl", $3);

    if ($1->spilled)
      dumpRM("movl", REG_RAX, 'd', $1);
    else
      dump_copy("movl", REG_RAX, $1->r, 'd');

    if ($1->spilled)
      dumpRM("movl", REG_RDX, 'd', $4);
    else
      dump_copy("movl", REG_RDX, $4->r, 'd');
  },
  emit {
    rtx src1 = gen_rtx_REG(SImode, $2->r);
    rtx src2 = 0
      ? gen_rtx_REG(SImode, $3->r)
      : gen_rtx_MEM(SImode, $3->rtl);
    rtx dst1 = $1->spilled
      ? gen_rtx_MEM(SImode, $1->rtl)
      : gen_rtx_REG(SImode, $1->r);
    rtx dst2 = $4->spilled
      ? gen_rtx_MEM(SImode, $4->rtl)
      : gen_rtx_REG(SImode, $4->r);
    rtx rax  = gen_rtx_REG(SImode, REG_RAX);
    rtx rdx  = gen_rtx_REG(SImode, REG_RDX);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax, src1));
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode,
      gen_rtvec(3,
	gen_rtx_SET(VOIDmode, rax, gen_rtx_DIV_helper(0, SImode, rax, src2)),
	gen_rtx_SET(VOIDmode, rdx, gen_rtx_MOD_helper(0, SImode, rax, src2)),
	gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst1, rax));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst2, rdx));
  };
#line 1766 "x86-64.int.py"
stmt : PARALLEL_ALL(SET_ALL(lhs16, UDIV_HI(r16, r16)),
#line 1770 "x86-64.int.py"
		          PARALLEL_ALL(SET_ALL(lhs16, UMOD_HI(r16, r16)),
				       USE_ALL(CONST_0))) [52, 8]
  supairs {
    /* suOrder2($$, $1, $2, kid, kids); */
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->r, REG_RAX);
    if (!$1->spilled)
      coalesces += attempt_coalesce(pass, $1->r, REG_RAX);
    if (!$4->spilled)
      coalesces += attempt_coalesce(pass, $4->r, REG_RDX);
  },
  build {
    /* final copy instruction */
    if ($4->spilled) {
      sparseset_set_bit(live, REG_RDX);
      add_addr(live, $4);
    }
    else
      add_copy_edges($4->r, REG_RDX, live);

    /* penultimate copy instruction */
    if ($1->spilled) {
      sparseset_set_bit(live, REG_RAX);
      add_addr(live, $1);
    }
    else
      add_copy_edges($1->r, REG_RAX, live);

    /* divide instruction */
    add_edges(REG_RAX, live);
    sparseset_set_bit(live, find($3->r));

    /* xor instruction */
    sparseset_clear_bit(live, REG_RDX);
    add_edges(REG_RDX, live);

    /* final copy instruction */
    add_copy_edges(REG_RAX, $2->r, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
    cost_copy($2->r, REG_RAX);
    memorable($3->r);
    if (!$1->spilled)
      cost_copy($1->r, REG_RAX);
    if (!$4->spilled)
      cost_copy(REG_RDX, $4->r);
  },
  debug {
    dump_copy("movl", $2->r, REG_RAX, 'd'); /* use movw? no, movl is preferred */
    dumpRR("xorl", REG_RDX, 'd', REG_RDX, 'd'); /* use xorw? no, xorl is preferred */
    dumpR("divw", $3->r, 'w');
    dump_copy("movl", REG_RAX, $1->r, 'd'); /* use movw? no, movl is preferred */
    dump_copy("movl", REG_RDX, $4->r, 'd'); /* use movw? no, movl is preferred */
  },
  emit {
    rtx dst1 = $1->spilled
      ? gen_rtx_MEM(HImode, $1->rtl)
      : gen_rtx_REG(HImode, $1->r);
    rtx dst2 = $4->spilled
      ? gen_rtx_MEM(HImode, $4->rtl)
      : gen_rtx_REG(HImode, $4->r);

    rtx src1 = gen_rtx_REG(HImode, $2->r);
    rtx src2 = gen_rtx_REG(HImode, $3->r);
    rtx rax  = gen_rtx_REG(HImode, REG_RAX);
    rtx rdx  = gen_rtx_REG(HImode, REG_RDX);
    rtx rdxm = gen_rtx_REG(SImode, REG_RDX);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax, src1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, rdxm,
			     gen_rtx_XOR(SImode, rdxm, rdxm)));
    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode,
      gen_rtvec(4,
	gen_rtx_SET(VOIDmode, rax, gen_rtx_UDIV(HImode, rax, src2)),
	gen_rtx_SET(VOIDmode, rdx, gen_rtx_UMOD(HImode, rax, src2)),
	gen_rtx_USE(VOIDmode, rdx),
	gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG)))));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst1, rax));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst2, rdx));
  };
#line 1883 "x86-64.int.py"
r64x  : ASHIFT_DI(r64x,  r8x) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("salq", REG_RCX, 'b', $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFT(DImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1884 "x86-64.int.py"
rz32x : ASHIFT_SI(r32x,  r8x) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sall", REG_RCX, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFT(SImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1893 "x86-64.int.py"
r16x  : ASHIFT_HI(r16x,  r8x) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("salw", REG_RCX, 'b', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFT(HImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1886 "x86-64.int.py"
r8x   : ASHIFT_QI(r8x,   r8x) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("salb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1889 "x86-64.int.py"
rz16x : ASHIFT_HI(rz16x, r8x) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("salw", REG_RCX, 'b', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFT(HImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1890 "x86-64.int.py"
rz8x  : ASHIFT_QI(rz8x,  r8x) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("salb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1893 "x86-64.int.py"
r16x  : ASHIFT_HI(r16x, r8x) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sall", REG_RCX, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFT(SImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1896 "x86-64.int.py"
r64x  : ASHIFT_DI(r64x,  SUBREG_QI(r64x, CONST_0)) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("salq", REG_RCX, 'b', $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFT(DImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1897 "x86-64.int.py"
r64x  : ASHIFT_DI(r64x,  SUBREG_QI(r32x, CONST_0)) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("salq", REG_RCX, 'b', $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFT(DImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1898 "x86-64.int.py"
r64x  : ASHIFT_DI(r64x,  SUBREG_QI(r16x, CONST_0)) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("salq", REG_RCX, 'b', $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFT(DImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1900 "x86-64.int.py"
rz32x : ASHIFT_SI(r32x,  SUBREG_QI(r64x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sall", REG_RCX, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFT(SImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1901 "x86-64.int.py"
rz32x : ASHIFT_SI(r32x,  SUBREG_QI(r32x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sall", REG_RCX, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFT(SImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1902 "x86-64.int.py"
rz32x : ASHIFT_SI(r32x,  SUBREG_QI(r16x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sall", REG_RCX, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFT(SImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1922 "x86-64.int.py"
r16x  : ASHIFT_HI(r16x,  SUBREG_QI(r64x, CONST_0)) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("salw", REG_RCX, 'b', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFT(HImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1923 "x86-64.int.py"
r16x  : ASHIFT_HI(r16x,  SUBREG_QI(r32x, CONST_0)) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("salw", REG_RCX, 'b', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFT(HImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1924 "x86-64.int.py"
r16x  : ASHIFT_HI(r16x,  SUBREG_QI(r16x, CONST_0)) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("salw", REG_RCX, 'b', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFT(HImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1908 "x86-64.int.py"
r8x   : ASHIFT_QI(r8x,   SUBREG_QI(r64x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("salb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1909 "x86-64.int.py"
r8x   : ASHIFT_QI(r8x,   SUBREG_QI(r32x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("salb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1910 "x86-64.int.py"
r8x   : ASHIFT_QI(r8x,   SUBREG_QI(r16x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("salb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1913 "x86-64.int.py"
rz16x : ASHIFT_HI(rz16x, SUBREG_QI(r64x, CONST_0)) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("salw", REG_RCX, 'b', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFT(HImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1914 "x86-64.int.py"
rz16x : ASHIFT_HI(rz16x, SUBREG_QI(r32x, CONST_0)) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("salw", REG_RCX, 'b', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFT(HImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1915 "x86-64.int.py"
rz16x : ASHIFT_HI(rz16x, SUBREG_QI(r16x, CONST_0)) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("salw", REG_RCX, 'b', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFT(HImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1917 "x86-64.int.py"
rz8x  : ASHIFT_QI(rz8x,  SUBREG_QI(r64x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("salb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1918 "x86-64.int.py"
rz8x  : ASHIFT_QI(rz8x,  SUBREG_QI(r32x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("salb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1919 "x86-64.int.py"
rz8x  : ASHIFT_QI(rz8x,  SUBREG_QI(r16x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("salb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1922 "x86-64.int.py"
r16x  : ASHIFT_HI(r16x,  SUBREG_QI(r64x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sall", REG_RCX, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFT(SImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1923 "x86-64.int.py"
r16x  : ASHIFT_HI(r16x,  SUBREG_QI(r32x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sall", REG_RCX, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFT(SImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1924 "x86-64.int.py"
r16x  : ASHIFT_HI(r16x,  SUBREG_QI(r16x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sall", REG_RCX, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFT(SImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1929 "x86-64.int.py"
r64x  : ASHIFTRT_DI(r64x,  r8x) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarq", REG_RCX, 'b', $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(DImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1930 "x86-64.int.py"
rz32x : ASHIFTRT_SI(r32x,  r8x) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarl", REG_RCX, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(SImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1931 "x86-64.int.py"
r16x  : ASHIFTRT_HI(r16x,  r8x) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarw", REG_RCX, 'b', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(HImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1932 "x86-64.int.py"
r8x   : ASHIFTRT_QI(r8x,   r8x) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1935 "x86-64.int.py"
rz16x : ASHIFTRT_HI(rz16x, r8x) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarw", REG_RCX, 'b', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(HImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1936 "x86-64.int.py"
rz8x  : ASHIFTRT_QI(rz8x,  r8x) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1939 "x86-64.int.py"
rs16x : ASHIFTRT_HI(rs16x, r8x) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarl", REG_RCX, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(SImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1940 "x86-64.int.py"
rs8x  : ASHIFTRT_QI(rs8x,  r8x) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1943 "x86-64.int.py"
r64x  : ASHIFTRT_DI(r64x,  SUBREG_QI(r64x, CONST_0)) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarq", REG_RCX, 'b', $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(DImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1944 "x86-64.int.py"
r64x  : ASHIFTRT_DI(r64x,  SUBREG_QI(r32x, CONST_0)) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarq", REG_RCX, 'b', $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(DImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1945 "x86-64.int.py"
r64x  : ASHIFTRT_DI(r64x,  SUBREG_QI(r16x, CONST_0)) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarq", REG_RCX, 'b', $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(DImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1947 "x86-64.int.py"
rz32x : ASHIFTRT_SI(r32x,  SUBREG_QI(r64x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarl", REG_RCX, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(SImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1948 "x86-64.int.py"
rz32x : ASHIFTRT_SI(r32x,  SUBREG_QI(r32x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarl", REG_RCX, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(SImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1949 "x86-64.int.py"
rz32x : ASHIFTRT_SI(r32x,  SUBREG_QI(r16x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarl", REG_RCX, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(SImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1951 "x86-64.int.py"
r16x  : ASHIFTRT_HI(r16x,  SUBREG_QI(r64x, CONST_0)) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarw", REG_RCX, 'b', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(HImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1952 "x86-64.int.py"
r16x  : ASHIFTRT_HI(r16x,  SUBREG_QI(r32x, CONST_0)) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarw", REG_RCX, 'b', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(HImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1953 "x86-64.int.py"
r16x  : ASHIFTRT_HI(r16x,  SUBREG_QI(r16x, CONST_0)) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarw", REG_RCX, 'b', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(HImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1955 "x86-64.int.py"
r8x   : ASHIFTRT_QI(r8x,   SUBREG_QI(r64x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1956 "x86-64.int.py"
r8x   : ASHIFTRT_QI(r8x,   SUBREG_QI(r32x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1957 "x86-64.int.py"
r8x   : ASHIFTRT_QI(r8x,   SUBREG_QI(r16x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1960 "x86-64.int.py"
rz16x : ASHIFTRT_HI(rz16x, SUBREG_QI(r64x, CONST_0)) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarw", REG_RCX, 'b', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(HImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1961 "x86-64.int.py"
rz16x : ASHIFTRT_HI(rz16x, SUBREG_QI(r32x, CONST_0)) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarw", REG_RCX, 'b', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(HImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1962 "x86-64.int.py"
rz16x : ASHIFTRT_HI(rz16x, SUBREG_QI(r16x, CONST_0)) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarw", REG_RCX, 'b', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(HImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1964 "x86-64.int.py"
rz8x  : ASHIFTRT_QI(rz8x,  SUBREG_QI(r64x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1965 "x86-64.int.py"
rz8x  : ASHIFTRT_QI(rz8x,  SUBREG_QI(r32x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1966 "x86-64.int.py"
rz8x  : ASHIFTRT_QI(rz8x,  SUBREG_QI(r16x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1969 "x86-64.int.py"
rs16x : ASHIFTRT_HI(rs16x, SUBREG_QI(r64x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarl", REG_RCX, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(SImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1970 "x86-64.int.py"
rs16x : ASHIFTRT_HI(rs16x, SUBREG_QI(r32x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarl", REG_RCX, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(SImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1971 "x86-64.int.py"
rs16x : ASHIFTRT_HI(rs16x, SUBREG_QI(r16x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarl", REG_RCX, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(SImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1973 "x86-64.int.py"
rs8x  : ASHIFTRT_QI(rs8x,  SUBREG_QI(r64x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1974 "x86-64.int.py"
rs8x  : ASHIFTRT_QI(rs8x,  SUBREG_QI(r32x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1975 "x86-64.int.py"
rs8x  : ASHIFTRT_QI(rs8x,  SUBREG_QI(r16x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("sarb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ASHIFTRT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1979 "x86-64.int.py"
r64x  : LSHIFTRT_DI(r64x,  r8x) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("shrq", REG_RCX, 'b', $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_LSHIFTRT(DImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1980 "x86-64.int.py"
rz32x : LSHIFTRT_SI(r32x,  r8x) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("shrl", REG_RCX, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_LSHIFTRT(SImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1981 "x86-64.int.py"
r16x  : LSHIFTRT_HI(r16x,  r8x) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("shrw", REG_RCX, 'b', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_LSHIFTRT(HImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1982 "x86-64.int.py"
r8x   : LSHIFTRT_QI(r8x,   r8x) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("shrb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_LSHIFTRT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1985 "x86-64.int.py"
rz16x : LSHIFTRT_HI(rz16x, r8x) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("shrl", REG_RCX, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_LSHIFTRT(SImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1986 "x86-64.int.py"
rz8x  : LSHIFTRT_QI(rz8x,  r8x) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("shrb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_LSHIFTRT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1989 "x86-64.int.py"
r64x  : LSHIFTRT_DI(r64x,  SUBREG_QI(r64x, CONST_0)) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("shrq", REG_RCX, 'b', $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_LSHIFTRT(DImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1990 "x86-64.int.py"
r64x  : LSHIFTRT_DI(r64x,  SUBREG_QI(r32x, CONST_0)) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("shrq", REG_RCX, 'b', $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_LSHIFTRT(DImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1991 "x86-64.int.py"
r64x  : LSHIFTRT_DI(r64x,  SUBREG_QI(r16x, CONST_0)) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("shrq", REG_RCX, 'b', $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_LSHIFTRT(DImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1993 "x86-64.int.py"
rz32x : LSHIFTRT_SI(r32x,  SUBREG_QI(r64x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("shrl", REG_RCX, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_LSHIFTRT(SImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1994 "x86-64.int.py"
rz32x : LSHIFTRT_SI(r32x,  SUBREG_QI(r32x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("shrl", REG_RCX, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_LSHIFTRT(SImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1995 "x86-64.int.py"
rz32x : LSHIFTRT_SI(r32x,  SUBREG_QI(r16x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("shrl", REG_RCX, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_LSHIFTRT(SImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1997 "x86-64.int.py"
r16x  : LSHIFTRT_HI(r16x,  SUBREG_QI(r64x, CONST_0)) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("shrw", REG_RCX, 'b', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_LSHIFTRT(HImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1998 "x86-64.int.py"
r16x  : LSHIFTRT_HI(r16x,  SUBREG_QI(r32x, CONST_0)) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("shrw", REG_RCX, 'b', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_LSHIFTRT(HImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 1999 "x86-64.int.py"
r16x  : LSHIFTRT_HI(r16x,  SUBREG_QI(r16x, CONST_0)) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("shrw", REG_RCX, 'b', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_LSHIFTRT(HImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2001 "x86-64.int.py"
r8x   : LSHIFTRT_QI(r8x,   SUBREG_QI(r64x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("shrb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_LSHIFTRT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2002 "x86-64.int.py"
r8x   : LSHIFTRT_QI(r8x,   SUBREG_QI(r32x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("shrb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_LSHIFTRT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2003 "x86-64.int.py"
r8x   : LSHIFTRT_QI(r8x,   SUBREG_QI(r16x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("shrb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_LSHIFTRT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2006 "x86-64.int.py"
rz16x : LSHIFTRT_HI(rz16x, SUBREG_QI(r64x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("shrl", REG_RCX, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_LSHIFTRT(SImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2007 "x86-64.int.py"
rz16x : LSHIFTRT_HI(rz16x, SUBREG_QI(r32x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("shrl", REG_RCX, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_LSHIFTRT(SImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2008 "x86-64.int.py"
rz16x : LSHIFTRT_HI(rz16x, SUBREG_QI(r16x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("shrl", REG_RCX, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_LSHIFTRT(SImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2010 "x86-64.int.py"
rz8x  : LSHIFTRT_QI(rz8x,  SUBREG_QI(r64x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("shrb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_LSHIFTRT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2011 "x86-64.int.py"
rz8x  : LSHIFTRT_QI(rz8x,  SUBREG_QI(r32x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("shrb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_LSHIFTRT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2012 "x86-64.int.py"
rz8x  : LSHIFTRT_QI(rz8x,  SUBREG_QI(r16x, CONST_0)) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("shrb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_LSHIFTRT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2015 "x86-64.int.py"
r64x  :   ROTATE_DI(r64x,  r8x) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("rolq", REG_RCX, 'b', $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ROTATE(DImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2016 "x86-64.int.py"
r32x  :   ROTATE_SI(r32x,  r8x) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("roll", REG_RCX, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ROTATE(SImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2017 "x86-64.int.py"
r16x  :   ROTATE_HI(r16x,  r8x) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("rolw", REG_RCX, 'b', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ROTATE(HImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2018 "x86-64.int.py"
r8x   :   ROTATE_QI(r8x,   r8x) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("rolb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ROTATE(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2021 "x86-64.int.py"
r64x  : ROTATERT_DI(r64x,  r8x) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("rorq", REG_RCX, 'b', $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ROTATERT(DImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2022 "x86-64.int.py"
r32x  : ROTATERT_SI(r32x,  r8x) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("rorl", REG_RCX, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ROTATERT(SImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2023 "x86-64.int.py"
r16x  : ROTATERT_HI(r16x,  r8x) [1, 3]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("rorw", REG_RCX, 'b', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ROTATERT(HImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2024 "x86-64.int.py"
r8x   : ROTATERT_QI(r8x,   r8x) [1, 2]
#line 2028 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($1->rx);
    forgettable($2->rx);
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dump_copy("movl", $2->rx, REG_RCX, 'd');
    dumpRR("rorb", REG_RCX, 'b', $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $1->rx);
    rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    src = gen_rtx_ROTATERT(QImode, dst, gen_rtx_REG(QImode, REG_RCX));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2077 "x86-64.int.py"
r64x  : ASHIFT_DI(r64x,    imm8) [1, 3]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("salq", $2, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src = gen_rtx_ASHIFT(DImode,
			     gen_rtx_REG(DImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2078 "x86-64.int.py"
rz32x : ASHIFT_SI(r32x,    imm8) [1, 2]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("sall", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ASHIFT(SImode,
			     gen_rtx_REG(SImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2087 "x86-64.int.py"
r16x  : ASHIFT_HI(r16x,    imm8) [1, 3]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("salw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_ASHIFT(HImode,
			     gen_rtx_REG(HImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2080 "x86-64.int.py"
r8x   : ASHIFT_QI(r8x,     imm8) [1, 2]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("salb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $$->rx);
    rtx src = gen_rtx_ASHIFT(QImode,
			     gen_rtx_REG(QImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2083 "x86-64.int.py"
rz16x : ASHIFT_HI(rz16x,   imm8) [1, 3]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("salw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_ASHIFT(HImode,
			     gen_rtx_REG(HImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2084 "x86-64.int.py"
rz8x  : ASHIFT_QI(rz8x,    imm8) [1, 2]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("salb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $$->rx);
    rtx src = gen_rtx_ASHIFT(QImode,
			     gen_rtx_REG(QImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2087 "x86-64.int.py"
r16x  : ASHIFT_HI(r16x,    imm8) [1, 2]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("sall", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ASHIFT(SImode,
			     gen_rtx_REG(SImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2091 "x86-64.int.py"
r64x  : ASHIFTRT_DI(r64x,  imm8) [1, 3]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("sarq", $2, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src = gen_rtx_ASHIFTRT(DImode,
			     gen_rtx_REG(DImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2092 "x86-64.int.py"
rz32x : ASHIFTRT_SI(r32x,  imm8) [1, 2]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("sarw", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ASHIFTRT(SImode,
			     gen_rtx_REG(SImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2093 "x86-64.int.py"
r16x  : ASHIFTRT_HI(r16x,  imm8) [1, 3]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("sarw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_ASHIFTRT(HImode,
			     gen_rtx_REG(HImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2094 "x86-64.int.py"
r8x   : ASHIFTRT_QI(r8x,   imm8) [1, 2]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("sarb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $$->rx);
    rtx src = gen_rtx_ASHIFTRT(QImode,
			     gen_rtx_REG(QImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2097 "x86-64.int.py"
rz16x : ASHIFTRT_HI(rz16x, imm8) [1, 3]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("sarw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_ASHIFTRT(HImode,
			     gen_rtx_REG(HImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2098 "x86-64.int.py"
rz8x  : ASHIFTRT_QI(rz8x,  imm8) [1, 2]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("sarb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $$->rx);
    rtx src = gen_rtx_ASHIFTRT(QImode,
			     gen_rtx_REG(QImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2101 "x86-64.int.py"
rs16x : ASHIFTRT_HI(rs16x, imm8) [1, 2]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("sarl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ASHIFTRT(SImode,
			     gen_rtx_REG(SImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2102 "x86-64.int.py"
rs8x  : ASHIFTRT_QI(rs8x,  imm8) [1, 2]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("sarb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $$->rx);
    rtx src = gen_rtx_ASHIFTRT(QImode,
			     gen_rtx_REG(QImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2106 "x86-64.int.py"
r64x  : LSHIFTRT_DI(r64x,  imm8) [1, 3]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("shrq", $2, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src = gen_rtx_LSHIFTRT(DImode,
			     gen_rtx_REG(DImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2107 "x86-64.int.py"
rz32x : LSHIFTRT_SI(r32x,  imm8) [1, 2]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("shrl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_LSHIFTRT(SImode,
			     gen_rtx_REG(SImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2108 "x86-64.int.py"
r16x  : LSHIFTRT_HI(r16x,  imm8) [1, 3]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("shrw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_LSHIFTRT(HImode,
			     gen_rtx_REG(HImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2109 "x86-64.int.py"
r8x   : LSHIFTRT_QI(r8x,   imm8) [1, 2]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("shrb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $$->rx);
    rtx src = gen_rtx_LSHIFTRT(QImode,
			     gen_rtx_REG(QImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2112 "x86-64.int.py"
rz16x : LSHIFTRT_HI(rz16x, imm8) [1, 2]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("shrl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_LSHIFTRT(SImode,
			     gen_rtx_REG(SImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2113 "x86-64.int.py"
rz8x  : LSHIFTRT_QI(rz8x,  imm8) [1, 2]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("shrb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $$->rx);
    rtx src = gen_rtx_LSHIFTRT(QImode,
			     gen_rtx_REG(QImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2118 "x86-64.int.py"
r64x  :   ROTATE_DI(r64x,    imm8) [1, 3]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("rolq", $2, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src = gen_rtx_ROTATE(DImode,
			     gen_rtx_REG(DImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2119 "x86-64.int.py"
r32x  :   ROTATE_SI(r32x,    imm8) [1, 2]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("roll", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ROTATE(SImode,
			     gen_rtx_REG(SImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2120 "x86-64.int.py"
r16x  :   ROTATE_HI(r16x,    imm8) [1, 3]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("rolw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_ROTATE(HImode,
			     gen_rtx_REG(HImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2121 "x86-64.int.py"
r8x   :   ROTATE_QI(r8x,     imm8) [1, 2]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("rolb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $$->rx);
    rtx src = gen_rtx_ROTATE(QImode,
			     gen_rtx_REG(QImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2123 "x86-64.int.py"
r64x  : ROTATERT_DI(r64x,    imm8) [1, 3]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("rorq", $2, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src = gen_rtx_ROTATERT(DImode,
			     gen_rtx_REG(DImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2124 "x86-64.int.py"
r32x  : ROTATERT_SI(r32x,    imm8) [1, 2]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("rorl", $2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ROTATERT(SImode,
			     gen_rtx_REG(SImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2125 "x86-64.int.py"
r16x  : ROTATERT_HI(r16x,    imm8) [1, 3]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("rorw", $2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_ROTATERT(HImode,
			     gen_rtx_REG(HImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2126 "x86-64.int.py"
r8x   : ROTATERT_QI(r8x,     imm8) [1, 2]
#line 2130 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR("rorb", $2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $$->rx);
    rtx src = gen_rtx_ROTATERT(QImode,
			     gen_rtx_REG(QImode, $1->rx),
			     gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2170 "x86-64.int.py"
r64x  : ASHIFT_DI(r64x,    CONST_P1) [1, 3]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("salq", $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src = gen_rtx_ASHIFT(DImode,
			       gen_rtx_REG(DImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2171 "x86-64.int.py"
rz32x : ASHIFT_SI(r32x,    CONST_P1) [1, 2]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("sall", $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ASHIFT(SImode,
			       gen_rtx_REG(SImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2180 "x86-64.int.py"
r16x  : ASHIFT_HI(r16x,    CONST_P1) [1, 3]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("salw", $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_ASHIFT(HImode,
			       gen_rtx_REG(HImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2173 "x86-64.int.py"
r8x   : ASHIFT_QI(r8x,     CONST_P1) [1, 2]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("salb", $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $$->rx);
    rtx src = gen_rtx_ASHIFT(QImode,
			       gen_rtx_REG(QImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2176 "x86-64.int.py"
rz16x : ASHIFT_HI(rz16x,   CONST_P1) [1, 3]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("salw", $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_ASHIFT(HImode,
			       gen_rtx_REG(HImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2177 "x86-64.int.py"
rz8x  : ASHIFT_QI(rz8x,    CONST_P1) [1, 2]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("salb", $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $$->rx);
    rtx src = gen_rtx_ASHIFT(QImode,
			       gen_rtx_REG(QImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2180 "x86-64.int.py"
r16x  : ASHIFT_HI(r16x,    CONST_P1) [1, 2]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("sall", $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ASHIFT(SImode,
			       gen_rtx_REG(SImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2184 "x86-64.int.py"
r64x  : ASHIFTRT_DI(r64x,  CONST_P1) [1, 3]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("sarq", $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src = gen_rtx_ASHIFTRT(DImode,
			       gen_rtx_REG(DImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2185 "x86-64.int.py"
rz32x : ASHIFTRT_SI(r32x,  CONST_P1) [1, 2]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("sarl", $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ASHIFTRT(SImode,
			       gen_rtx_REG(SImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2186 "x86-64.int.py"
r16x  : ASHIFTRT_HI(r16x,  CONST_P1) [1, 3]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("sarw", $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_ASHIFTRT(HImode,
			       gen_rtx_REG(HImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2187 "x86-64.int.py"
r8x   : ASHIFTRT_QI(r8x,   CONST_P1) [1, 2]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("sarb", $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $$->rx);
    rtx src = gen_rtx_ASHIFTRT(QImode,
			       gen_rtx_REG(QImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2190 "x86-64.int.py"
rz16x : ASHIFTRT_HI(rz16x, CONST_P1) [1, 3]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("sarw", $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_ASHIFTRT(HImode,
			       gen_rtx_REG(HImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2191 "x86-64.int.py"
rz8x  : ASHIFTRT_QI(rz8x,  CONST_P1) [1, 2]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("sarb", $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $$->rx);
    rtx src = gen_rtx_ASHIFTRT(QImode,
			       gen_rtx_REG(QImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2194 "x86-64.int.py"
rs16x : ASHIFTRT_HI(rs16x, CONST_P1) [1, 2]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("sarl", $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ASHIFTRT(SImode,
			       gen_rtx_REG(SImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2195 "x86-64.int.py"
rs8x  : ASHIFTRT_QI(rs8x,  CONST_P1) [1, 2]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("sarb", $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $$->rx);
    rtx src = gen_rtx_ASHIFTRT(QImode,
			       gen_rtx_REG(QImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2199 "x86-64.int.py"
r64x  : LSHIFTRT_DI(r64x,  CONST_P1) [1, 3]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("shrq", $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src = gen_rtx_LSHIFTRT(DImode,
			       gen_rtx_REG(DImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2200 "x86-64.int.py"
rz32x : LSHIFTRT_SI(r32x,  CONST_P1) [1, 2]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("shrl", $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_LSHIFTRT(SImode,
			       gen_rtx_REG(SImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2201 "x86-64.int.py"
r16x  : LSHIFTRT_HI(r16x,  CONST_P1) [1, 3]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("shrw", $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_LSHIFTRT(HImode,
			       gen_rtx_REG(HImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2202 "x86-64.int.py"
r8x   : LSHIFTRT_QI(r8x,   CONST_P1) [1, 2]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("shrb", $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $$->rx);
    rtx src = gen_rtx_LSHIFTRT(QImode,
			       gen_rtx_REG(QImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2205 "x86-64.int.py"
rz16x : LSHIFTRT_HI(rz16x, CONST_P1) [1, 2]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("shrl", $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_LSHIFTRT(SImode,
			       gen_rtx_REG(SImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2206 "x86-64.int.py"
rz8x  : LSHIFTRT_QI(rz8x,  CONST_P1) [1, 2]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("shrb", $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $$->rx);
    rtx src = gen_rtx_LSHIFTRT(QImode,
			       gen_rtx_REG(QImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2208 "x86-64.int.py"
r64x  :   ROTATE_DI(r64x,    CONST_P1) [1, 3]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("rolq", $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src = gen_rtx_ROTATE(DImode,
			       gen_rtx_REG(DImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2209 "x86-64.int.py"
r32x  :   ROTATE_SI(r32x,    CONST_P1) [1, 2]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("roll", $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ROTATE(SImode,
			       gen_rtx_REG(SImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2210 "x86-64.int.py"
r16x  :   ROTATE_HI(r16x,    CONST_P1) [1, 3]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("rolw", $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_ROTATE(HImode,
			       gen_rtx_REG(HImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2211 "x86-64.int.py"
r8x   :   ROTATE_QI(r8x,     CONST_P1) [1, 2]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("rolb", $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $$->rx);
    rtx src = gen_rtx_ROTATE(QImode,
			       gen_rtx_REG(QImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2212 "x86-64.int.py"
r64x  : ROTATERT_DI(r64x,    CONST_P1) [1, 3]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("rorq", $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src = gen_rtx_ROTATERT(DImode,
			       gen_rtx_REG(DImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2213 "x86-64.int.py"
r32x  : ROTATERT_SI(r32x,    CONST_P1) [1, 2]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("rorl", $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ROTATERT(SImode,
			       gen_rtx_REG(SImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2214 "x86-64.int.py"
r16x  : ROTATERT_HI(r16x,    CONST_P1) [1, 3]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("rorw", $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_ROTATERT(HImode,
			       gen_rtx_REG(HImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2215 "x86-64.int.py"
r8x   : ROTATERT_QI(r8x,     CONST_P1) [1, 2]
#line 2219 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIR1("rorb", $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $$->rx);
    rtx src = gen_rtx_ROTATERT(QImode,
			       gen_rtx_REG(QImode, $1->rx),
			       GEN_INT(1));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2274 "x86-64.int.py"
r64x  : PLUS_DI(base64 | disp) [1, 2]
#line 2281 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
  },
  remat {
    unsigned r = find($1->a.base);
    if (r == REG_FP || r == REG_ARGP)
      flags |= RHS_REMAT;
    else
      flags = 0;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->a.base, true, 0, 0, $2->a.disp, $2->a.string,
      $$->rx, 'q');
  },
  emit {
    rtx src = gen_rtx_PLUS(DImode, $1->rtl, $2->rtl);
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_clobber_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "clobber", not "plain" */
  };
#line 2275 "x86-64.int.py"
rz32x : PLUS_SI(base32 | disp) [1, 1]
#line 2281 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
  },
  remat {
    unsigned r = find($1->a.base);
    if (r == REG_FP || r == REG_ARGP)
      flags |= RHS_REMAT;
    else
      flags = 0;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, 0, 0, $2->a.disp, $2->a.string,
      $$->rx, 'l');
  },
  emit {
    rtx src = gen_rtx_PLUS(SImode, $1->rtl, $2->rtl);
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_clobber_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "clobber", not "plain" */
  };
#line 2276 "x86-64.int.py"
r16x  : PLUS_HI(base16 | disp) [1, 1]
#line 2281 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
  },
  remat {
    unsigned r = find($1->a.base);
    if (r == REG_FP || r == REG_ARGP)
      flags |= RHS_REMAT;
    else
      flags = 0;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, 0, 0, $2->a.disp, $2->a.string,
      $$->rx, 'l');
  },
  emit {
    rtx src = gen_rtx_PLUS(SImode, $1->rtl, $2->rtl);
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_clobber_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "clobber", not "plain" */
  };
#line 2277 "x86-64.int.py"
r8x   : PLUS_QI(base8  | disp) [1, 1]
#line 2281 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
  },
  remat {
    unsigned r = find($1->a.base);
    if (r == REG_FP || r == REG_ARGP)
      flags |= RHS_REMAT;
    else
      flags = 0;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, 0, 0, $2->a.disp, $2->a.string,
      $$->rx, 'l');
  },
  emit {
    rtx src = gen_rtx_PLUS(SImode, $1->rtl, $2->rtl);
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_clobber_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "clobber", not "plain" */
  };
#line 2329 "x86-64.int.py"
r64x  : PLUS_DI(r64 | r64) [1, 3]
#line 2341 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->r));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    memorable($1->r);
    memorable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->r, true, $2->r, 1, 0, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src;
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src1 = gen_rtx_REG(DImode, $1->r);
    rtx src2 = gen_rtx_REG(DImode, $2->r);
    if ($1->a.base == $$->rx)
      src = gen_rtx_PLUS(DImode, src1, src2);
    else
      src = gen_rtx_PLUS(DImode, src2, src1);
    icg_emit_clobber_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "clobber", not "plain" */
  };
#line 2330 "x86-64.int.py"
rz32x : PLUS_SI(r32 | r32) [1, 2]
#line 2341 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->r));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    memorable($1->r);
    memorable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->r, true, $2->r, 1, 0, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src;
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src1 = gen_rtx_REG(SImode, $1->r);
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    if ($1->a.base == $$->rx)
      src = gen_rtx_PLUS(SImode, src1, src2);
    else
      src = gen_rtx_PLUS(SImode, src2, src1);
    icg_emit_clobber_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "clobber", not "plain" */
  };
#line 2331 "x86-64.int.py"
r16x  : PLUS_HI(r16 | r16) [1, 2]
#line 2341 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->r));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    memorable($1->r);
    memorable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->r, true, $2->r, 1, 0, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src;
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src1 = gen_rtx_REG(SImode, $1->r);
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    if ($1->a.base == $$->rx)
      src = gen_rtx_PLUS(SImode, src1, src2);
    else
      src = gen_rtx_PLUS(SImode, src2, src1);
    icg_emit_clobber_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "clobber", not "plain" */
  };
#line 2332 "x86-64.int.py"
r8x   : PLUS_QI(r8  | r8) [1, 2]
#line 2341 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->r));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    memorable($1->r);
    memorable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->r, true, $2->r, 1, 0, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src;
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src1 = gen_rtx_REG(SImode, $1->r);
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    if ($1->a.base == $$->rx)
      src = gen_rtx_PLUS(SImode, src1, src2);
    else
      src = gen_rtx_PLUS(SImode, src2, src1);
    icg_emit_clobber_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "clobber", not "plain" */
  };
#line 2334 "x86-64.int.py"
r64x  : MINUS_DI(r64, NEG_DI(r64)) [1, 3]
#line 2341 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->r));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    memorable($1->r);
    memorable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->r, true, $2->r, 1, 0, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src;
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src1 = gen_rtx_REG(DImode, $1->r);
    rtx src2 = gen_rtx_REG(DImode, $2->r);
    if ($1->a.base == $$->rx)
      src = gen_rtx_PLUS(DImode, src1, src2);
    else
      src = gen_rtx_PLUS(DImode, src2, src1);
    icg_emit_clobber_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "clobber", not "plain" */
  };
#line 2335 "x86-64.int.py"
rz32x : MINUS_SI(r32, NEG_SI(r32)) [1, 2]
#line 2341 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->r));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    memorable($1->r);
    memorable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->r, true, $2->r, 1, 0, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src;
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src1 = gen_rtx_REG(SImode, $1->r);
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    if ($1->a.base == $$->rx)
      src = gen_rtx_PLUS(SImode, src1, src2);
    else
      src = gen_rtx_PLUS(SImode, src2, src1);
    icg_emit_clobber_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "clobber", not "plain" */
  };
#line 2336 "x86-64.int.py"
r16x  : MINUS_HI(r16, NEG_HI(r16)) [1, 2]
#line 2341 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->r));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    memorable($1->r);
    memorable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->r, true, $2->r, 1, 0, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src;
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src1 = gen_rtx_REG(SImode, $1->r);
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    if ($1->a.base == $$->rx)
      src = gen_rtx_PLUS(SImode, src1, src2);
    else
      src = gen_rtx_PLUS(SImode, src2, src1);
    icg_emit_clobber_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "clobber", not "plain" */
  };
#line 2337 "x86-64.int.py"
r8x   : MINUS_QI(r8,  NEG_QI(r8)) [1, 2]
#line 2341 "x86-64.int.py"
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->r));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    memorable($1->r);
    memorable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->r, true, $2->r, 1, 0, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src;
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src1 = gen_rtx_REG(SImode, $1->r);
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    if ($1->a.base == $$->rx)
      src = gen_rtx_PLUS(SImode, src1, src2);
    else
      src = gen_rtx_PLUS(SImode, src2, src1);
    icg_emit_clobber_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "clobber", not "plain" */
  };
#line 2389 "x86-64.int.py"
r64x  : PLUS_DI(base64 | index64 | disp) [2, 2]
#line 2396 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->a.index));
  },
  remat {
    flags = 0;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->a.base, true, $2->a.index, $2->a.scale, $3->a.disp, $3->a.string,
      $$->rx, 'q');
  },
  emit {
    /*
     * for some reason, 64 bit leaq must have the gcc tree
     * built slightly differently, or the back end of gcc will
     * not be able to match it.  gen_rtx_addr will build a tree
     * from two gen_rtx_PLUS, but with a different permutation
     * than we use for the other kinds of lea instruction.
     */
    const rtx src = ('q' == 'q')
    ? gen_rtx_addr(DImode, $1->rtl, $2->rtl, $3->rtl)
    : gen_rtx_PLUS(SImode, gen_rtx_PLUS(DImode, $2->rtl, $1->rtl), $3->rtl)
    ;
    const rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2390 "x86-64.int.py"
rz32x : PLUS_SI(base32 | index32 | disp) [2, 1]
#line 2396 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->a.index));
  },
  remat {
    flags = 0;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->a.index, $2->a.scale, $3->a.disp, $3->a.string,
      $$->rx, 'l');
  },
  emit {
    /*
     * for some reason, 64 bit leaq must have the gcc tree
     * built slightly differently, or the back end of gcc will
     * not be able to match it.  gen_rtx_addr will build a tree
     * from two gen_rtx_PLUS, but with a different permutation
     * than we use for the other kinds of lea instruction.
     */
    const rtx src = ('l' == 'q')
    ? gen_rtx_addr(SImode, $1->rtl, $2->rtl, $3->rtl)
    : gen_rtx_PLUS(SImode, gen_rtx_PLUS(SImode, $2->rtl, $1->rtl), $3->rtl)
    ;
    const rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2391 "x86-64.int.py"
r16x  : PLUS_HI(base16 | index16 | disp) [2, 1]
#line 2396 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->a.index));
  },
  remat {
    flags = 0;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->a.index, $2->a.scale, $3->a.disp, $3->a.string,
      $$->rx, 'l');
  },
  emit {
    /*
     * for some reason, 64 bit leaq must have the gcc tree
     * built slightly differently, or the back end of gcc will
     * not be able to match it.  gen_rtx_addr will build a tree
     * from two gen_rtx_PLUS, but with a different permutation
     * than we use for the other kinds of lea instruction.
     */
    const rtx src = ('l' == 'q')
    ? gen_rtx_addr(SImode, $1->rtl, $2->rtl, $3->rtl)
    : gen_rtx_PLUS(SImode, gen_rtx_PLUS(SImode, $2->rtl, $1->rtl), $3->rtl)
    ;
    const rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2392 "x86-64.int.py"
r8x   : PLUS_QI(base8  | index8  | disp) [2, 1]
#line 2396 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->a.index));
  },
  remat {
    flags = 0;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->a.index, $2->a.scale, $3->a.disp, $3->a.string,
      $$->rx, 'l');
  },
  emit {
    /*
     * for some reason, 64 bit leaq must have the gcc tree
     * built slightly differently, or the back end of gcc will
     * not be able to match it.  gen_rtx_addr will build a tree
     * from two gen_rtx_PLUS, but with a different permutation
     * than we use for the other kinds of lea instruction.
     */
    const rtx src = ('l' == 'q')
    ? gen_rtx_addr(SImode, $1->rtl, $2->rtl, $3->rtl)
    : gen_rtx_PLUS(SImode, gen_rtx_PLUS(SImode, $2->rtl, $1->rtl), $3->rtl)
    ;
    const rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2450 "x86-64.int.py"
r64x  : PLUS_DI(base64 | MULT_DI(PLUS_DI(r64 | imm5)  | CONST_P8)) [2, 2]
#line 2466 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->a.base, true, $2->r, 8, $3->val*8, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src2 = gen_rtx_REG(DImode, $2->r);
    rtx src = gen_rtx_addr(DImode, $1->rtl,
			   gen_rtx_MULT(DImode, src2, GEN_INT(8)),
			   GEN_INT($3->val*8));
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2451 "x86-64.int.py"
r64x  : PLUS_DI(base64 | MULT_DI(PLUS_DI(r64 | imm29) | CONST_P8)) [2, 2]
#line 2466 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->a.base, true, $2->r, 8, $3->val*8, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src2 = gen_rtx_REG(DImode, $2->r);
    rtx src = gen_rtx_addr(DImode, $1->rtl,
			   gen_rtx_MULT(DImode, src2, GEN_INT(8)),
			   GEN_INT($3->val*8));
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2452 "x86-64.int.py"
r64x  : PLUS_DI(base64 | MULT_DI(PLUS_DI(r64 | imm6)  | CONST_P4)) [2, 2]
#line 2466 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->a.base, true, $2->r, 4, $3->val*4, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src2 = gen_rtx_REG(DImode, $2->r);
    rtx src = gen_rtx_addr(DImode, $1->rtl,
			   gen_rtx_MULT(DImode, src2, GEN_INT(4)),
			   GEN_INT($3->val*4));
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2453 "x86-64.int.py"
r64x  : PLUS_DI(base64 | MULT_DI(PLUS_DI(r64 | imm30) | CONST_P4)) [2, 2]
#line 2466 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->a.base, true, $2->r, 4, $3->val*4, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src2 = gen_rtx_REG(DImode, $2->r);
    rtx src = gen_rtx_addr(DImode, $1->rtl,
			   gen_rtx_MULT(DImode, src2, GEN_INT(4)),
			   GEN_INT($3->val*4));
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2454 "x86-64.int.py"
r64x  : PLUS_DI(base64 | MULT_DI(PLUS_DI(r64 | imm7)  | CONST_P2)) [2, 2]
#line 2466 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->a.base, true, $2->r, 2, $3->val*2, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src2 = gen_rtx_REG(DImode, $2->r);
    rtx src = gen_rtx_addr(DImode, $1->rtl,
			   gen_rtx_MULT(DImode, src2, GEN_INT(2)),
			   GEN_INT($3->val*2));
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2455 "x86-64.int.py"
r64x  : PLUS_DI(base64 | MULT_DI(PLUS_DI(r64 | imm31) | CONST_P2)) [2, 2]
#line 2466 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->a.base, true, $2->r, 2, $3->val*2, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src2 = gen_rtx_REG(DImode, $2->r);
    rtx src = gen_rtx_addr(DImode, $1->rtl,
			   gen_rtx_MULT(DImode, src2, GEN_INT(2)),
			   GEN_INT($3->val*2));
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2457 "x86-64.int.py"
r64x  : PLUS_DI(base64 | ASHIFT_DI(PLUS_DI(r64 | imm5),  CONST_P3)) [2, 2]
#line 2466 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->a.base, true, $2->r, 8, $3->val*8, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src2 = gen_rtx_REG(DImode, $2->r);
    rtx src = gen_rtx_addr(DImode, $1->rtl,
			   gen_rtx_MULT(DImode, src2, GEN_INT(8)),
			   GEN_INT($3->val*8));
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2458 "x86-64.int.py"
r64x  : PLUS_DI(base64 | ASHIFT_DI(PLUS_DI(r64 | imm29), CONST_P3)) [2, 2]
#line 2466 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->a.base, true, $2->r, 8, $3->val*8, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src2 = gen_rtx_REG(DImode, $2->r);
    rtx src = gen_rtx_addr(DImode, $1->rtl,
			   gen_rtx_MULT(DImode, src2, GEN_INT(8)),
			   GEN_INT($3->val*8));
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2459 "x86-64.int.py"
r64x  : PLUS_DI(base64 | ASHIFT_DI(PLUS_DI(r64 | imm6),  CONST_P2)) [2, 2]
#line 2466 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->a.base, true, $2->r, 4, $3->val*4, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src2 = gen_rtx_REG(DImode, $2->r);
    rtx src = gen_rtx_addr(DImode, $1->rtl,
			   gen_rtx_MULT(DImode, src2, GEN_INT(4)),
			   GEN_INT($3->val*4));
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2460 "x86-64.int.py"
r64x  : PLUS_DI(base64 | ASHIFT_DI(PLUS_DI(r64 | imm30), CONST_P2)) [2, 2]
#line 2466 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->a.base, true, $2->r, 4, $3->val*4, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src2 = gen_rtx_REG(DImode, $2->r);
    rtx src = gen_rtx_addr(DImode, $1->rtl,
			   gen_rtx_MULT(DImode, src2, GEN_INT(4)),
			   GEN_INT($3->val*4));
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2461 "x86-64.int.py"
r64x  : PLUS_DI(base64 | ASHIFT_DI(PLUS_DI(r64 | imm7),  CONST_P1)) [2, 2]
#line 2466 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->a.base, true, $2->r, 2, $3->val*2, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src2 = gen_rtx_REG(DImode, $2->r);
    rtx src = gen_rtx_addr(DImode, $1->rtl,
			   gen_rtx_MULT(DImode, src2, GEN_INT(2)),
			   GEN_INT($3->val*2));
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2462 "x86-64.int.py"
r64x  : PLUS_DI(base64 | ASHIFT_DI(PLUS_DI(r64 | imm31), CONST_P1)) [2, 2]
#line 2466 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->a.base, true, $2->r, 2, $3->val*2, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src2 = gen_rtx_REG(DImode, $2->r);
    rtx src = gen_rtx_addr(DImode, $1->rtl,
			   gen_rtx_MULT(DImode, src2, GEN_INT(2)),
			   GEN_INT($3->val*2));
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2510 "x86-64.int.py"
rz32x : PLUS_SI(base32 | MULT_SI(PLUS_SI(r32 | imm5)  | CONST_P8)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 8, $3->val*8, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(8)),
					$1->rtl),
			   GEN_INT($3->val*8));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2511 "x86-64.int.py"
rz32x : PLUS_SI(base32 | MULT_SI(PLUS_SI(r32 | imm29) | CONST_P8)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 8, $3->val*8, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(8)),
					$1->rtl),
			   GEN_INT($3->val*8));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2512 "x86-64.int.py"
r16x  : PLUS_HI(base16 | MULT_HI(PLUS_HI(r16 | imm5)  | CONST_P8)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 8, $3->val*8, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(8)),
					$1->rtl),
			   GEN_INT($3->val*8));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2513 "x86-64.int.py"
r16x  : PLUS_HI(base16 | MULT_HI(PLUS_HI(r16 | imm13) | CONST_P8)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 8, $3->val*8, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(8)),
					$1->rtl),
			   GEN_INT($3->val*8));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2514 "x86-64.int.py"
r8x   : PLUS_QI(base8  | MULT_QI(PLUS_QI(r8  | imm5)  | CONST_P8)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 8, $3->val*8, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(8)),
					$1->rtl),
			   GEN_INT($3->val*8));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2515 "x86-64.int.py"
rz32x : PLUS_SI(base32 | MULT_SI(PLUS_SI(r32 | imm6)  | CONST_P4)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 4, $3->val*4, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(4)),
					$1->rtl),
			   GEN_INT($3->val*4));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2516 "x86-64.int.py"
rz32x : PLUS_SI(base32 | MULT_SI(PLUS_SI(r32 | imm30) | CONST_P4)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 4, $3->val*4, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(4)),
					$1->rtl),
			   GEN_INT($3->val*4));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2517 "x86-64.int.py"
r16x  : PLUS_HI(base16 | MULT_HI(PLUS_HI(r16 | imm6)  | CONST_P4)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 4, $3->val*4, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(4)),
					$1->rtl),
			   GEN_INT($3->val*4));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2518 "x86-64.int.py"
r16x  : PLUS_HI(base16 | MULT_HI(PLUS_HI(r16 | imm14) | CONST_P4)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 4, $3->val*4, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(4)),
					$1->rtl),
			   GEN_INT($3->val*4));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2519 "x86-64.int.py"
r8x   : PLUS_QI(base8  | MULT_QI(PLUS_QI(r8  | imm6)  | CONST_P4)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 4, $3->val*4, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(4)),
					$1->rtl),
			   GEN_INT($3->val*4));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2520 "x86-64.int.py"
rz32x : PLUS_SI(base32 | MULT_SI(PLUS_SI(r32 | imm7)  | CONST_P2)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 2, $3->val*2, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(2)),
					$1->rtl),
			   GEN_INT($3->val*2));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2521 "x86-64.int.py"
rz32x : PLUS_SI(base32 | MULT_SI(PLUS_SI(r32 | imm31) | CONST_P2)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 2, $3->val*2, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(2)),
					$1->rtl),
			   GEN_INT($3->val*2));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2522 "x86-64.int.py"
r16x  : PLUS_HI(base16 | MULT_HI(PLUS_HI(r16 | imm7)  | CONST_P2)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 2, $3->val*2, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(2)),
					$1->rtl),
			   GEN_INT($3->val*2));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2523 "x86-64.int.py"
r16x  : PLUS_HI(base16 | MULT_HI(PLUS_HI(r16 | imm15) | CONST_P2)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 2, $3->val*2, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(2)),
					$1->rtl),
			   GEN_INT($3->val*2));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2524 "x86-64.int.py"
r8x   : PLUS_QI(base8  | MULT_QI(PLUS_QI(r8  | imm7)  | CONST_P2)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 2, $3->val*2, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(2)),
					$1->rtl),
			   GEN_INT($3->val*2));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2526 "x86-64.int.py"
rz32x : PLUS_SI(base32 | ASHIFT_SI(PLUS_SI(r32 | imm5),  CONST_P3)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 8, $3->val*8, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(8)),
					$1->rtl),
			   GEN_INT($3->val*8));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2527 "x86-64.int.py"
rz32x : PLUS_SI(base32 | ASHIFT_SI(PLUS_SI(r32 | imm29), CONST_P3)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 8, $3->val*8, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(8)),
					$1->rtl),
			   GEN_INT($3->val*8));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2528 "x86-64.int.py"
r16x  : PLUS_HI(base16 | ASHIFT_HI(PLUS_HI(r16 | imm5),  CONST_P3)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 8, $3->val*8, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(8)),
					$1->rtl),
			   GEN_INT($3->val*8));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2529 "x86-64.int.py"
r16x  : PLUS_HI(base16 | ASHIFT_HI(PLUS_HI(r16 | imm13), CONST_P3)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 8, $3->val*8, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(8)),
					$1->rtl),
			   GEN_INT($3->val*8));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2530 "x86-64.int.py"
r8x   : PLUS_QI(base8  | ASHIFT_QI(PLUS_QI(r8  | imm5),  CONST_P3)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 8, $3->val*8, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(8)),
					$1->rtl),
			   GEN_INT($3->val*8));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2531 "x86-64.int.py"
rz32x : PLUS_SI(base32 | ASHIFT_SI(PLUS_SI(r32 | imm6),  CONST_P2)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 4, $3->val*4, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(4)),
					$1->rtl),
			   GEN_INT($3->val*4));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2532 "x86-64.int.py"
rz32x : PLUS_SI(base32 | ASHIFT_SI(PLUS_SI(r32 | imm30), CONST_P2)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 4, $3->val*4, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(4)),
					$1->rtl),
			   GEN_INT($3->val*4));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2533 "x86-64.int.py"
r16x  : PLUS_HI(base16 | ASHIFT_HI(PLUS_HI(r16 | imm6),  CONST_P2)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 4, $3->val*4, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(4)),
					$1->rtl),
			   GEN_INT($3->val*4));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2534 "x86-64.int.py"
r16x  : PLUS_HI(base16 | ASHIFT_HI(PLUS_HI(r16 | imm14), CONST_P2)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 4, $3->val*4, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(4)),
					$1->rtl),
			   GEN_INT($3->val*4));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2535 "x86-64.int.py"
r8x   : PLUS_QI(base8  | ASHIFT_QI(PLUS_QI(r8  | imm6),  CONST_P2)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 4, $3->val*4, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(4)),
					$1->rtl),
			   GEN_INT($3->val*4));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2536 "x86-64.int.py"
rz32x : PLUS_SI(base32 | ASHIFT_SI(PLUS_SI(r32 | imm7),  CONST_P1)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 2, $3->val*2, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(2)),
					$1->rtl),
			   GEN_INT($3->val*2));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2537 "x86-64.int.py"
rz32x : PLUS_SI(base32 | ASHIFT_SI(PLUS_SI(r32 | imm31), CONST_P1)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 2, $3->val*2, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(2)),
					$1->rtl),
			   GEN_INT($3->val*2));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2538 "x86-64.int.py"
r16x  : PLUS_HI(base16 | ASHIFT_HI(PLUS_HI(r16 | imm7),  CONST_P1)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 2, $3->val*2, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(2)),
					$1->rtl),
			   GEN_INT($3->val*2));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2539 "x86-64.int.py"
r16x  : PLUS_HI(base16 | ASHIFT_HI(PLUS_HI(r16 | imm15), CONST_P1)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 2, $3->val*2, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(2)),
					$1->rtl),
			   GEN_INT($3->val*2));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2540 "x86-64.int.py"
r8x   : PLUS_QI(base8  | ASHIFT_QI(PLUS_QI(r8  | imm7),  CONST_P1)) [2, 1]
#line 2544 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($2->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->r, 2, $3->val*2, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $2->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(2)),
					$1->rtl),
			   GEN_INT($3->val*2));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2592 "x86-64.int.py"
r64x : PLUS_DI(base64 | imm7  |   MULT_DI(PLUS_DI(r64 | imm4)  | CONST_P8)) [2, 1]
#line 2608 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->a.base, true, $3->r, 2, $2->val + $4->val*2, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src2 = gen_rtx_REG(DImode, $3->r);
    rtx src = gen_rtx_addr(DImode, $1->rtl,
			   gen_rtx_MULT(DImode, src2, GEN_INT(2)),
			   GEN_INT($2->val + $4->val*2));
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2593 "x86-64.int.py"
r64x : PLUS_DI(base64 | imm31 |   MULT_DI(PLUS_DI(r64 | imm28) | CONST_P8)) [2, 0]
#line 2608 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->a.base, true, $3->r, 2, $2->val + $4->val*2, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src2 = gen_rtx_REG(DImode, $3->r);
    rtx src = gen_rtx_addr(DImode, $1->rtl,
			   gen_rtx_MULT(DImode, src2, GEN_INT(2)),
			   GEN_INT($2->val + $4->val*2));
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2594 "x86-64.int.py"
r64x : PLUS_DI(base64 | imm7  |   MULT_DI(PLUS_DI(r64 | imm5)  | CONST_P4)) [2, 1]
#line 2608 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->a.base, true, $3->r, 2, $2->val + $4->val*2, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src2 = gen_rtx_REG(DImode, $3->r);
    rtx src = gen_rtx_addr(DImode, $1->rtl,
			   gen_rtx_MULT(DImode, src2, GEN_INT(2)),
			   GEN_INT($2->val + $4->val*2));
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2595 "x86-64.int.py"
r64x : PLUS_DI(base64 | imm31 |   MULT_DI(PLUS_DI(r64 | imm29) | CONST_P4)) [2, 0]
#line 2608 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->a.base, true, $3->r, 2, $2->val + $4->val*2, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src2 = gen_rtx_REG(DImode, $3->r);
    rtx src = gen_rtx_addr(DImode, $1->rtl,
			   gen_rtx_MULT(DImode, src2, GEN_INT(2)),
			   GEN_INT($2->val + $4->val*2));
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2596 "x86-64.int.py"
r64x : PLUS_DI(base64 | imm7  |   MULT_DI(PLUS_DI(r64 | imm6)  | CONST_P2)) [2, 1]
#line 2608 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->a.base, true, $3->r, 2, $2->val + $4->val*2, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src2 = gen_rtx_REG(DImode, $3->r);
    rtx src = gen_rtx_addr(DImode, $1->rtl,
			   gen_rtx_MULT(DImode, src2, GEN_INT(2)),
			   GEN_INT($2->val + $4->val*2));
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2597 "x86-64.int.py"
r64x : PLUS_DI(base64 | imm31 |   MULT_DI(PLUS_DI(r64 | imm30) | CONST_P2)) [2, 0]
#line 2608 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->a.base, true, $3->r, 2, $2->val + $4->val*2, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src2 = gen_rtx_REG(DImode, $3->r);
    rtx src = gen_rtx_addr(DImode, $1->rtl,
			   gen_rtx_MULT(DImode, src2, GEN_INT(2)),
			   GEN_INT($2->val + $4->val*2));
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2599 "x86-64.int.py"
r64x : PLUS_DI(base64 | imm7  | ASHIFT_DI(PLUS_DI(r64 | imm4),  CONST_P3)) [2, 1]
#line 2608 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->a.base, true, $3->r, 2, $2->val + $4->val*2, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src2 = gen_rtx_REG(DImode, $3->r);
    rtx src = gen_rtx_addr(DImode, $1->rtl,
			   gen_rtx_MULT(DImode, src2, GEN_INT(2)),
			   GEN_INT($2->val + $4->val*2));
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2600 "x86-64.int.py"
r64x : PLUS_DI(base64 | imm31 | ASHIFT_DI(PLUS_DI(r64 | imm28), CONST_P3)) [2, 0]
#line 2608 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->a.base, true, $3->r, 2, $2->val + $4->val*2, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src2 = gen_rtx_REG(DImode, $3->r);
    rtx src = gen_rtx_addr(DImode, $1->rtl,
			   gen_rtx_MULT(DImode, src2, GEN_INT(2)),
			   GEN_INT($2->val + $4->val*2));
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2601 "x86-64.int.py"
r64x : PLUS_DI(base64 | imm7  | ASHIFT_DI(PLUS_DI(r64 | imm5),  CONST_P2)) [2, 1]
#line 2608 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->a.base, true, $3->r, 2, $2->val + $4->val*2, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src2 = gen_rtx_REG(DImode, $3->r);
    rtx src = gen_rtx_addr(DImode, $1->rtl,
			   gen_rtx_MULT(DImode, src2, GEN_INT(2)),
			   GEN_INT($2->val + $4->val*2));
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2602 "x86-64.int.py"
r64x : PLUS_DI(base64 | imm31 | ASHIFT_DI(PLUS_DI(r64 | imm29), CONST_P2)) [2, 0]
#line 2608 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->a.base, true, $3->r, 2, $2->val + $4->val*2, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src2 = gen_rtx_REG(DImode, $3->r);
    rtx src = gen_rtx_addr(DImode, $1->rtl,
			   gen_rtx_MULT(DImode, src2, GEN_INT(2)),
			   GEN_INT($2->val + $4->val*2));
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2603 "x86-64.int.py"
r64x : PLUS_DI(base64 | imm7  | ASHIFT_DI(PLUS_DI(r64 | imm6),  CONST_P1)) [2, 1]
#line 2608 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->a.base, true, $3->r, 2, $2->val + $4->val*2, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src2 = gen_rtx_REG(DImode, $3->r);
    rtx src = gen_rtx_addr(DImode, $1->rtl,
			   gen_rtx_MULT(DImode, src2, GEN_INT(2)),
			   GEN_INT($2->val + $4->val*2));
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2604 "x86-64.int.py"
r64x : PLUS_DI(base64 | imm31 | ASHIFT_DI(PLUS_DI(r64 | imm30), CONST_P1)) [2, 0]
#line 2608 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->a.base, true, $3->r, 2, $2->val + $4->val*2, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src2 = gen_rtx_REG(DImode, $3->r);
    rtx src = gen_rtx_addr(DImode, $1->rtl,
			   gen_rtx_MULT(DImode, src2, GEN_INT(2)),
			   GEN_INT($2->val + $4->val*2));
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2654 "x86-64.int.py"
rz32x : PLUS_SI(base32 | imm7  | MULT_SI(PLUS_SI(r32 | imm4)  | CONST_P8)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 8, $2->val + $4->val*8, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(8)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*8));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2655 "x86-64.int.py"
rz32x : PLUS_SI(base32 | imm31 | MULT_SI(PLUS_SI(r32 | imm28) | CONST_P8)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 8, $2->val + $4->val*8, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(8)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*8));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2656 "x86-64.int.py"
r16x  : PLUS_HI(base16 | imm7  | MULT_HI(PLUS_HI(r16 | imm5)  | CONST_P8)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 8, $2->val + $4->val*8, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(8)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*8));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2657 "x86-64.int.py"
r16x  : PLUS_HI(base16 | imm15 | MULT_HI(PLUS_HI(r16 | imm13) | CONST_P8)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 8, $2->val + $4->val*8, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(8)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*8));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2658 "x86-64.int.py"
r8x   : PLUS_QI(base8  | imm7  | MULT_QI(PLUS_QI(r8  | imm5)  | CONST_P8)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 8, $2->val + $4->val*8, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(8)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*8));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2659 "x86-64.int.py"
rz32x : PLUS_SI(base32 | imm7  | MULT_SI(PLUS_SI(r32 | imm6)  | CONST_P4)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 4, $2->val + $4->val*4, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(4)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*4));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2660 "x86-64.int.py"
rz32x : PLUS_SI(base32 | imm31 | MULT_SI(PLUS_SI(r32 | imm30) | CONST_P4)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 4, $2->val + $4->val*4, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(4)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*4));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2661 "x86-64.int.py"
r16x  : PLUS_HI(base16 | imm7  | MULT_HI(PLUS_HI(r16 | imm6)  | CONST_P4)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 4, $2->val + $4->val*4, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(4)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*4));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2662 "x86-64.int.py"
r16x  : PLUS_HI(base16 | imm15 | MULT_HI(PLUS_HI(r16 | imm14) | CONST_P4)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 4, $2->val + $4->val*4, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(4)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*4));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2663 "x86-64.int.py"
r8x   : PLUS_QI(base8  | imm7  | MULT_QI(PLUS_QI(r8  | imm6)  | CONST_P4)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 4, $2->val + $4->val*4, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(4)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*4));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2664 "x86-64.int.py"
rz32x : PLUS_SI(base32 | imm7  | MULT_SI(PLUS_SI(r32 | imm7)  | CONST_P2)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 2, $2->val + $4->val*2, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(2)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*2));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2665 "x86-64.int.py"
rz32x : PLUS_SI(base32 | imm31 | MULT_SI(PLUS_SI(r32 | imm31) | CONST_P2)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 2, $2->val + $4->val*2, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(2)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*2));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2666 "x86-64.int.py"
r16x  : PLUS_HI(base16 | imm7  | MULT_HI(PLUS_HI(r16 | imm7)  | CONST_P2)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 2, $2->val + $4->val*2, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(2)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*2));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2667 "x86-64.int.py"
r16x  : PLUS_HI(base16 | imm15 | MULT_HI(PLUS_HI(r16 | imm15) | CONST_P2)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 2, $2->val + $4->val*2, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(2)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*2));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2668 "x86-64.int.py"
r8x   : PLUS_QI(base8  | imm7  | MULT_QI(PLUS_QI(r8  | imm7)  | CONST_P2)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 2, $2->val + $4->val*2, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(2)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*2));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2670 "x86-64.int.py"
rz32x : PLUS_SI(base32 | imm7  | ASHIFT_SI(PLUS_SI(r32 | imm5),  CONST_P3)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 8, $2->val + $4->val*8, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(8)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*8));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2671 "x86-64.int.py"
rz32x : PLUS_SI(base32 | imm31 | ASHIFT_SI(PLUS_SI(r32 | imm29), CONST_P3)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 8, $2->val + $4->val*8, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(8)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*8));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2672 "x86-64.int.py"
r16x  : PLUS_HI(base16 | imm7  | ASHIFT_HI(PLUS_HI(r16 | imm5),  CONST_P3)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 8, $2->val + $4->val*8, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(8)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*8));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2673 "x86-64.int.py"
r16x  : PLUS_HI(base16 | imm15 | ASHIFT_HI(PLUS_HI(r16 | imm13), CONST_P3)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 8, $2->val + $4->val*8, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(8)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*8));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2674 "x86-64.int.py"
r8x   : PLUS_QI(base8  | imm7  | ASHIFT_QI(PLUS_QI(r8  | imm5),  CONST_P3)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 8, $2->val + $4->val*8, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(8)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*8));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2675 "x86-64.int.py"
rz32x : PLUS_SI(base32 | imm7  | ASHIFT_SI(PLUS_SI(r32 | imm6),  CONST_P2)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 4, $2->val + $4->val*4, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(4)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*4));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2676 "x86-64.int.py"
rz32x : PLUS_SI(base32 | imm31 | ASHIFT_SI(PLUS_SI(r32 | imm30), CONST_P2)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 4, $2->val + $4->val*4, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(4)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*4));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2677 "x86-64.int.py"
r16x  : PLUS_HI(base16 | imm7  | ASHIFT_HI(PLUS_HI(r16 | imm6),  CONST_P2)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 4, $2->val + $4->val*4, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(4)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*4));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2678 "x86-64.int.py"
r16x  : PLUS_HI(base16 | imm15 | ASHIFT_HI(PLUS_HI(r16 | imm14), CONST_P2)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 4, $2->val + $4->val*4, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(4)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*4));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2679 "x86-64.int.py"
r8x   : PLUS_QI(base8  | imm7  | ASHIFT_QI(PLUS_QI(r8  | imm6),  CONST_P2)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 4, $2->val + $4->val*4, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(4)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*4));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2680 "x86-64.int.py"
rz32x : PLUS_SI(base32 | imm7  | ASHIFT_SI(PLUS_SI(r32 | imm7),  CONST_P1)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 2, $2->val + $4->val*2, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(2)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*2));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2681 "x86-64.int.py"
rz32x : PLUS_SI(base32 | imm31 | ASHIFT_SI(PLUS_SI(r32 | imm31), CONST_P1)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 2, $2->val + $4->val*2, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(2)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*2));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2682 "x86-64.int.py"
r16x  : PLUS_HI(base16 | imm7  | ASHIFT_HI(PLUS_HI(r16 | imm7),  CONST_P1)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 2, $2->val + $4->val*2, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(2)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*2));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2683 "x86-64.int.py"
r16x  : PLUS_HI(base16 | imm15 | ASHIFT_HI(PLUS_HI(r16 | imm15), CONST_P1)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 2, $2->val + $4->val*2, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(2)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*2));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2684 "x86-64.int.py"
r8x   : PLUS_QI(base8  | imm7  | ASHIFT_QI(PLUS_QI(r8  | imm7),  CONST_P1)) [2, 0]
#line 2688 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $3, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($3->r));
  },
  remat {
    flags = 0;
  },
  costs {
    forgettable($3->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $3->r, 2, $2->val + $4->val*2, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src2 = gen_rtx_REG(SImode, $3->r);
    rtx src = gen_rtx_PLUS(SImode,
			   gen_rtx_PLUS(SImode,
					gen_rtx_MULT(SImode, src2, GEN_INT(2)),
					$1->rtl),
			   GEN_INT($2->val + $4->val*2));
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2737 "x86-64.int.py"
r64x  : PLUS_DI(base64 | index64) [2, 2]
#line 2744 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->a.index));
  },
  remat {
    flags = 0;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      $1->a.base, true, $2->a.index, $2->a.scale, 0, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src = 1	/* 64-bit RTL shape weirdness */
      ? gen_rtx_PLUS(DImode, $1->rtl, $2->rtl)
      : gen_rtx_PLUS(DImode, $2->rtl, $1->rtl)
    ;
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2738 "x86-64.int.py"
rz32x : PLUS_SI(base32 | index32) [2, 1]
#line 2744 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->a.index));
  },
  remat {
    flags = 0;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->a.index, $2->a.scale, 0, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src = 0	/* 64-bit RTL shape weirdness */
      ? gen_rtx_PLUS(SImode, $1->rtl, $2->rtl)
      : gen_rtx_PLUS(SImode, $2->rtl, $1->rtl)
    ;
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2739 "x86-64.int.py"
r16x  : PLUS_HI(base16 | index16) [2, 1]
#line 2744 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->a.index));
  },
  remat {
    flags = 0;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->a.index, $2->a.scale, 0, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src = 0	/* 64-bit RTL shape weirdness */
      ? gen_rtx_PLUS(SImode, $1->rtl, $2->rtl)
      : gen_rtx_PLUS(SImode, $2->rtl, $1->rtl)
    ;
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2740 "x86-64.int.py"
r8x   : PLUS_QI(base8  | index8) [2, 1]
#line 2744 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    suOrder2($$, $1, $2, kid, kids);
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.base));
    sparseset_set_bit(live, find($2->a.index));
  },
  remat {
    flags = 0;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      $1->a.base, true, $2->a.index, $2->a.scale, 0, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src = 0	/* 64-bit RTL shape weirdness */
      ? gen_rtx_PLUS(SImode, $1->rtl, $2->rtl)
      : gen_rtx_PLUS(SImode, $2->rtl, $1->rtl)
    ;
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2785 "x86-64.int.py"
r64x  : PLUS_DI(index64 | imm32) [2, 3]
#line 2792 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.index));
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      0, false, $1->a.index, $1->a.scale, $2->val, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src = gen_rtx_PLUS(DImode, $1->rtl, $2->rtl);
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2786 "x86-64.int.py"
rz32x : PLUS_SI(index32 | imm32) [2, 2]
#line 2792 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.index));
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      0, false, $1->a.index, $1->a.scale, $2->val, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src = gen_rtx_PLUS(SImode, $1->rtl, $2->rtl);
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2787 "x86-64.int.py"
r16x  : PLUS_HI(index16 | imm32) [2, 2]
#line 2792 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.index));
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      0, false, $1->a.index, $1->a.scale, $2->val, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src = gen_rtx_PLUS(SImode, $1->rtl, $2->rtl);
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2788 "x86-64.int.py"
r8x   : PLUS_QI(index8  | imm32) [2, 2]
#line 2792 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.index));
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      0, false, $1->a.index, $1->a.scale, $2->val, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src = gen_rtx_PLUS(SImode, $1->rtl, $2->rtl);
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2833 "x86-64.int.py"
r64x  : index64 [2, 7]
#line 2840 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.index));
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leaq",
      0, false, $1->a.index, $1->a.scale, 0, NULL,
      $$->rx, 'q');
  },
  emit {
    rtx src = $1->rtl;
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2834 "x86-64.int.py"
rz32x : index32 [2, 6]
#line 2840 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.index));
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      0, false, $1->a.index, $1->a.scale, 0, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src = $1->rtl;
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2835 "x86-64.int.py"
r16x  : index16 [2, 6]
#line 2840 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.index));
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      0, false, $1->a.index, $1->a.scale, 0, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src = $1->rtl;
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2836 "x86-64.int.py"
r8x   : index8 [2, 6]
#line 2840 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    add_edges(rd, live);
    sparseset_clear_bit(live, rd);
    sparseset_set_bit(live, find($1->a.index));
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dumpMbidR("leal",
      0, false, $1->a.index, $1->a.scale, 0, NULL,
      $$->rx, 'l');
  },
  emit {
    rtx src = $1->rtl;
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain_tagged(gen_rtx_SET(VOIDmode, dst, src), __FILE__, __LINE__);
    /* the above line must be "plain", not "clobber" */
  };
#line 2887 "x86-64.int.py"
r64x  : SIGN_EXTEND_DI(r32) [1, 3]
#line 2911 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_REG(SImode, $1->r);
    else
      src = gen_rtx_SIGN_EXTEND(DImode, gen_rtx_REG(SImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  },
  debug {
    dumpRR("movslq", $1->r, 'l', $$->rx, 'q');
  };
#line 2888 "x86-64.int.py"
r64x  : SIGN_EXTEND_DI(r16) [1, 4]
#line 2911 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_REG(HImode, $1->r);
    else
      src = gen_rtx_SIGN_EXTEND(DImode, gen_rtx_REG(HImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  },
  debug {
    dumpRR("movswq", $1->r, 'w', $$->rx, 'q');
  };
#line 2889 "x86-64.int.py"
r64x  : SIGN_EXTEND_DI(r8) [1, 4]
#line 2911 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_REG(QImode, $1->r);
    else
      src = gen_rtx_SIGN_EXTEND(DImode, gen_rtx_REG(QImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  },
  debug {
    dumpRR("movsbq", $1->r, 'b', $$->rx, 'q');
  };
#line 2890 "x86-64.int.py"
rz32x : SIGN_EXTEND_SI(r16) [1, 3]
#line 2911 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_REG(HImode, $1->r);
    else
      src = gen_rtx_SIGN_EXTEND(SImode, gen_rtx_REG(HImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  },
  debug {
    dumpRR("movswl", $1->r, 'w', $$->rx, 'l');
  };
#line 2891 "x86-64.int.py"
rz32x : SIGN_EXTEND_SI(r8) [1, 3]
#line 2911 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_REG(QImode, $1->r);
    else
      src = gen_rtx_SIGN_EXTEND(SImode, gen_rtx_REG(QImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  },
  debug {
    dumpRR("movsbl", $1->r, 'b', $$->rx, 'l');
  };
#line 2892 "x86-64.int.py"
r16x  : SIGN_EXTEND_HI(r8) [1, 4]
#line 2911 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_REG(QImode, $1->r);
    else
      src = gen_rtx_SIGN_EXTEND(HImode, gen_rtx_REG(QImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  },
  debug {
    dumpRR("movsbw", $1->r, 'b', $$->rx, 'w');
  };
#line 2895 "x86-64.int.py"
rs16x : SIGN_EXTEND_HI(r8) [1, 3]
#line 2911 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_REG(QImode, $1->r);
    else
      src = gen_rtx_SIGN_EXTEND(SImode, gen_rtx_REG(QImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  },
  debug {
    dumpRR("movsbl", $1->r, 'b', $$->rx, 'l');
  };
#line 2899 "x86-64.int.py"
r64x  : ZERO_EXTEND_DI(r32) [1, 2]
#line 2911 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src;
    if (1)
      src = gen_rtx_REG(SImode, $1->r);
    else
      src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_REG(SImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  },
  debug {
    dumpRR("movl", $1->r, 'l', $$->rx, 'l');
  };
#line 2900 "x86-64.int.py"
r64x  : ZERO_EXTEND_DI(r16) [1, 4]
#line 2911 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_REG(HImode, $1->r);
    else
      src = gen_rtx_ZERO_EXTEND(DImode, gen_rtx_REG(HImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  },
  debug {
    dumpRR("movzwq", $1->r, 'w', $$->rx, 'q');
  };
#line 2901 "x86-64.int.py"
r64x  : ZERO_EXTEND_DI(r8) [1, 4]
#line 2911 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_REG(QImode, $1->r);
    else
      src = gen_rtx_ZERO_EXTEND(DImode, gen_rtx_REG(QImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  },
  debug {
    dumpRR("movzbq", $1->r, 'b', $$->rx, 'q');
  };
#line 2902 "x86-64.int.py"
rz32x : ZERO_EXTEND_SI(r16) [1, 3]
#line 2911 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_REG(HImode, $1->r);
    else
      src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_REG(HImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  },
  debug {
    dumpRR("movzwl", $1->r, 'w', $$->rx, 'l');
  };
#line 2903 "x86-64.int.py"
rz32x : ZERO_EXTEND_SI(r8) [1, 3]
#line 2911 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_REG(QImode, $1->r);
    else
      src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_REG(QImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  },
  debug {
    dumpRR("movzbl", $1->r, 'b', $$->rx, 'l');
  };
#line 2904 "x86-64.int.py"
r16x  : ZERO_EXTEND_HI(r8) [1, 4]
#line 2911 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_REG(QImode, $1->r);
    else
      src = gen_rtx_ZERO_EXTEND(HImode, gen_rtx_REG(QImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  },
  debug {
    dumpRR("movzbw", $1->r, 'b', $$->rx, 'w');
  };
#line 2907 "x86-64.int.py"
rz16x : ZERO_EXTEND_HI(r8) [1, 3]
#line 2911 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_REG(QImode, $1->r);
    else
      src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_REG(QImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  },
  debug {
    dumpRR("movzbl", $1->r, 'b', $$->rx, 'l');
  };
#line 2965 "x86-64.int.py"
r64x  : SIGN_EXTEND_DI(MEM_SI(addr)) [4, 2]
#line 3008 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movslq", $1, $$->rx, 'q');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_MEM(SImode, $1->rtl);
    else
      src = gen_rtx_SIGN_EXTEND(DImode, gen_rtx_MEM(SImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2966 "x86-64.int.py"
r64x  : SIGN_EXTEND_DI(MEM_HI(addr)) [4, 3]
#line 3008 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movswq", $1, $$->rx, 'q');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_MEM(HImode, $1->rtl);
    else
      src = gen_rtx_SIGN_EXTEND(DImode, gen_rtx_MEM(HImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2967 "x86-64.int.py"
r64x  : SIGN_EXTEND_DI(MEM_QI(addr)) [4, 3]
#line 3008 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movsbq", $1, $$->rx, 'q');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_MEM(QImode, $1->rtl);
    else
      src = gen_rtx_SIGN_EXTEND(DImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2968 "x86-64.int.py"
rz32x : SIGN_EXTEND_SI(MEM_HI(addr)) [4, 2]
#line 3008 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movswl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_MEM(HImode, $1->rtl);
    else
      src = gen_rtx_SIGN_EXTEND(SImode, gen_rtx_MEM(HImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2969 "x86-64.int.py"
rz32x : SIGN_EXTEND_SI(MEM_QI(addr)) [4, 2]
#line 3008 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movsbl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_MEM(QImode, $1->rtl);
    else
      src = gen_rtx_SIGN_EXTEND(SImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2970 "x86-64.int.py"
r16x  : SIGN_EXTEND_HI(MEM_QI(addr)) [4, 3]
#line 3008 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movsbw", $1, $$->rx, 'w');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_MEM(QImode, $1->rtl);
    else
      src = gen_rtx_SIGN_EXTEND(HImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2973 "x86-64.int.py"
rs16x : SIGN_EXTEND_HI(MEM_QI(addr)) [4, 2]
#line 3008 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movsbl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_MEM(QImode, $1->rtl);
    else
      src = gen_rtx_SIGN_EXTEND(SImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2977 "x86-64.int.py"
r64x  : ZERO_EXTEND_DI(MEM_SI(addr)) [4, 1]
#line 3008 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src;
    if (1)
      src = gen_rtx_MEM(SImode, $1->rtl);
    else
      src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_MEM(SImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2978 "x86-64.int.py"
r64x  : ZERO_EXTEND_DI(MEM_HI(addr)) [4, 3]
#line 3008 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movzwq", $1, $$->rx, 'q');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_MEM(HImode, $1->rtl);
    else
      src = gen_rtx_ZERO_EXTEND(DImode, gen_rtx_MEM(HImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2979 "x86-64.int.py"
r64x  : ZERO_EXTEND_DI(MEM_QI(addr)) [4, 3]
#line 3008 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movzbq", $1, $$->rx, 'q');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_MEM(QImode, $1->rtl);
    else
      src = gen_rtx_ZERO_EXTEND(DImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2980 "x86-64.int.py"
rz32x : ZERO_EXTEND_SI(MEM_HI(addr)) [4, 2]
#line 3008 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movzwl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_MEM(HImode, $1->rtl);
    else
      src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_MEM(HImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2981 "x86-64.int.py"
rz32x : ZERO_EXTEND_SI(MEM_QI(addr)) [4, 2]
#line 3008 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movzbl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_MEM(QImode, $1->rtl);
    else
      src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2982 "x86-64.int.py"
r16x  : ZERO_EXTEND_HI(MEM_QI(addr)) [4, 3]
#line 3008 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movzbw", $1, $$->rx, 'w');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_MEM(QImode, $1->rtl);
    else
      src = gen_rtx_ZERO_EXTEND(HImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2985 "x86-64.int.py"
rz16x : ZERO_EXTEND_HI(MEM_QI(addr)) [4, 2]
#line 3008 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movzbl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_MEM(QImode, $1->rtl);
    else
      src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2989 "x86-64.int.py"
rs16x : MEM_HI(addr) [4, 2]
#line 3008 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movswl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_MEM(HImode, $1->rtl);
    else
      src = gen_rtx_SIGN_EXTEND(SImode, gen_rtx_MEM(HImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2990 "x86-64.int.py"
rs8x  : MEM_QI(addr) [4, 2]
#line 3008 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movsbl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_MEM(QImode, $1->rtl);
    else
      src = gen_rtx_SIGN_EXTEND(SImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2991 "x86-64.int.py"
rs16x : SUBREG_HI(MEM_DI(addr), CONST_0) [4, 2]
#line 3008 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movswl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_MEM(HImode, $1->rtl);
    else
      src = gen_rtx_SIGN_EXTEND(SImode, gen_rtx_MEM(HImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2992 "x86-64.int.py"
rs16x : SUBREG_HI(MEM_SI(addr), CONST_0) [4, 2]
#line 3008 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movswl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_MEM(HImode, $1->rtl);
    else
      src = gen_rtx_SIGN_EXTEND(SImode, gen_rtx_MEM(HImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2993 "x86-64.int.py"
rs8x  : SUBREG_QI(MEM_DI(addr), CONST_0) [4, 2]
#line 3008 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movsbl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_MEM(QImode, $1->rtl);
    else
      src = gen_rtx_SIGN_EXTEND(SImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2994 "x86-64.int.py"
rs8x  : SUBREG_QI(MEM_SI(addr), CONST_0) [4, 2]
#line 3008 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movsbl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_MEM(QImode, $1->rtl);
    else
      src = gen_rtx_SIGN_EXTEND(SImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2995 "x86-64.int.py"
rs8x  : SUBREG_QI(MEM_HI(addr), CONST_0) [4, 2]
#line 3008 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movsbl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_MEM(QImode, $1->rtl);
    else
      src = gen_rtx_SIGN_EXTEND(SImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2998 "x86-64.int.py"
rz16x : MEM_HI(addr) [4, 2]
#line 3008 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movzwl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_MEM(HImode, $1->rtl);
    else
      src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_MEM(HImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 2999 "x86-64.int.py"
rz8x  : MEM_QI(addr) [4, 2]
#line 3008 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movzbl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_MEM(QImode, $1->rtl);
    else
      src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3000 "x86-64.int.py"
rz16x : SUBREG_HI(MEM_DI(addr), CONST_0) [4, 2]
#line 3008 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movzwl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_MEM(HImode, $1->rtl);
    else
      src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_MEM(HImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3001 "x86-64.int.py"
rz16x : SUBREG_HI(MEM_SI(addr), CONST_0) [4, 2]
#line 3008 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movzwl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_MEM(HImode, $1->rtl);
    else
      src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_MEM(HImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3002 "x86-64.int.py"
rz8x  : SUBREG_QI(MEM_DI(addr), CONST_0) [4, 2]
#line 3008 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movzbl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_MEM(QImode, $1->rtl);
    else
      src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3003 "x86-64.int.py"
rz8x  : SUBREG_QI(MEM_SI(addr), CONST_0) [4, 2]
#line 3008 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movzbl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_MEM(QImode, $1->rtl);
    else
      src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3004 "x86-64.int.py"
rz8x  : SUBREG_QI(MEM_HI(addr), CONST_0) [4, 2]
#line 3008 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movzbl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src;
    if (0)
      src = gen_rtx_MEM(QImode, $1->rtl);
    else
      src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3061 "x86-64.int.py"
r64x  :                  MEM_DI(addr) [3, 2]
#line 3079 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movq", $1, $$->rx, 'q');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    /* TODO: handle BSF and BSR in the rtx IL, perhaps as asm */
    const rtx src = gen_rtx_MEM(DImode, $1->rtl);
    const rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3062 "x86-64.int.py"
rz32x :                  MEM_SI(addr) [3, 1]
#line 3079 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    /* TODO: handle BSF and BSR in the rtx IL, perhaps as asm */
    const rtx src = gen_rtx_MEM(SImode, $1->rtl);
    const rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3063 "x86-64.int.py"
rz32x :        SUBREG_SI(MEM_DI(addr), CONST_0) [3, 1]
#line 3079 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    /* TODO: handle BSF and BSR in the rtx IL, perhaps as asm */
    const rtx src = gen_rtx_MEM(SImode, $1->rtl);
    const rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3065 "x86-64.int.py"
r64x  : BSF_DI(          MEM_DI(addr)) [3, 2]
#line 3079 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("bsfq", $1, $$->rx, 'q');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    /* TODO: handle BSF and BSR in the rtx IL, perhaps as asm */
    const rtx src = gen_rtx_MEM(DImode, $1->rtl);
    const rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3066 "x86-64.int.py"
rz32x : BSF_SI(          MEM_SI(addr)) [3, 1]
#line 3079 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("bsfl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    /* TODO: handle BSF and BSR in the rtx IL, perhaps as asm */
    const rtx src = gen_rtx_MEM(SImode, $1->rtl);
    const rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3067 "x86-64.int.py"
rz32x : BSF_SI(SUBREG_SI(MEM_DI(addr), CONST_0)) [3, 1]
#line 3079 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("bsfl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    /* TODO: handle BSF and BSR in the rtx IL, perhaps as asm */
    const rtx src = gen_rtx_MEM(SImode, $1->rtl);
    const rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3069 "x86-64.int.py"
r64x  : BSR_DI(          MEM_DI(addr)) [3, 2]
#line 3079 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("bsrq", $1, $$->rx, 'q');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    /* TODO: handle BSF and BSR in the rtx IL, perhaps as asm */
    const rtx src = gen_rtx_MEM(DImode, $1->rtl);
    const rtx dst = gen_rtx_REG(DImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3070 "x86-64.int.py"
rz32x : BSR_SI(          MEM_SI(addr)) [3, 1]
#line 3079 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("bsrl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    /* TODO: handle BSF and BSR in the rtx IL, perhaps as asm */
    const rtx src = gen_rtx_MEM(SImode, $1->rtl);
    const rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3071 "x86-64.int.py"
rz32x : BSR_SI(SUBREG_SI(MEM_DI(addr), CONST_0)) [3, 1]
#line 3079 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("bsrl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    /* TODO: handle BSF and BSR in the rtx IL, perhaps as asm */
    const rtx src = gen_rtx_MEM(SImode, $1->rtl);
    const rtx dst = gen_rtx_REG(SImode, $$->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3127 "x86-64.int.py"
rcc : MEM_NEG_DI(MEM_DI(addr)) [4, 2]
#line 3139 "x86-64.int.py"
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("negq", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_NEG(DImode,
	mem	/* NOTE: dag */
      )
    ));
  };
#line 3128 "x86-64.int.py"
rcc : MEM_NEG_SI(MEM_SI(addr)) [4, 1]
#line 3139 "x86-64.int.py"
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("negl", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_NEG(SImode,
	mem	/* NOTE: dag */
      )
    ));
  };
#line 3129 "x86-64.int.py"
rcc : MEM_NEG_HI(MEM_HI(addr)) [4, 2]
#line 3139 "x86-64.int.py"
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("negw", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_NEG(HImode,
	mem	/* NOTE: dag */
      )
    ));
  };
#line 3130 "x86-64.int.py"
rcc : MEM_NEG_QI(MEM_QI(addr)) [4, 1]
#line 3139 "x86-64.int.py"
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("negb", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_NEG(QImode,
	mem	/* NOTE: dag */
      )
    ));
  };
#line 3132 "x86-64.int.py"
nocc : MEM_NOT_DI(MEM_DI(addr)) [4, 2]
#line 3139 "x86-64.int.py"
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("notq", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (1 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_NOT(DImode,
	mem	/* NOTE: dag */
      )
    ));
  };
#line 3133 "x86-64.int.py"
nocc : MEM_NOT_SI(MEM_SI(addr)) [4, 1]
#line 3139 "x86-64.int.py"
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("notl", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (1 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_NOT(SImode,
	mem	/* NOTE: dag */
      )
    ));
  };
#line 3134 "x86-64.int.py"
nocc : MEM_NOT_HI(MEM_HI(addr)) [4, 2]
#line 3139 "x86-64.int.py"
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("notw", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (1 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_NOT(HImode,
	mem	/* NOTE: dag */
      )
    ));
  };
#line 3135 "x86-64.int.py"
nocc : MEM_NOT_QI(MEM_QI(addr)) [4, 1]
#line 3139 "x86-64.int.py"
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("notb", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    (1 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_NOT(QImode,
	mem	/* NOTE: dag */
      )
    ));
  };
#line 3162 "x86-64.int.py"
rcc : MEM_PLUS_DI(MEM_DI(addr),  NEG_DI(r64)) [4, 2]
#line 3199 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->r);
  },
  build {
    sparseset_set_bit(live, find($2->r));
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpRM("subq", $2->r, 'q', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_MINUS(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(DImode, $2->r)
      )
    ));
  };
#line 3163 "x86-64.int.py"
rcc : MEM_PLUS_SI(MEM_SI(addr),  NEG_DI(r32)) [4, 1]
#line 3199 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->r);
  },
  build {
    sparseset_set_bit(live, find($2->r));
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpRM("subl", $2->r, 'l', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_MINUS(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(SImode, $2->r)
      )
    ));
  };
#line 3164 "x86-64.int.py"
rcc : MEM_PLUS_HI(MEM_HI(addr),  NEG_DI(r16)) [4, 2]
#line 3199 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->r);
  },
  build {
    sparseset_set_bit(live, find($2->r));
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpRM("subw", $2->r, 'w', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_MINUS(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(HImode, $2->r)
      )
    ));
  };
#line 3165 "x86-64.int.py"
rcc : MEM_PLUS_QI(MEM_QI(addr),  NEG_DI(r8)) [4, 1]
#line 3199 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->r);
  },
  build {
    sparseset_set_bit(live, find($2->r));
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpRM("subb", $2->r, 'b', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_MINUS(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, $2->r)
      )
    ));
  };
#line 3167 "x86-64.int.py"
rcc : MEM_MINUS_DI(MEM_DI(addr), NEG_DI(r64)) [4, 2]
#line 3199 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->r);
  },
  build {
    sparseset_set_bit(live, find($2->r));
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpRM("addq", $2->r, 'q', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_PLUS(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(DImode, $2->r)
      )
    ));
  };
#line 3168 "x86-64.int.py"
rcc : MEM_MINUS_SI(MEM_SI(addr), NEG_DI(r32)) [4, 1]
#line 3199 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->r);
  },
  build {
    sparseset_set_bit(live, find($2->r));
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpRM("addl", $2->r, 'l', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_PLUS(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(SImode, $2->r)
      )
    ));
  };
#line 3169 "x86-64.int.py"
rcc : MEM_MINUS_HI(MEM_HI(addr), NEG_DI(r16)) [4, 2]
#line 3199 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->r);
  },
  build {
    sparseset_set_bit(live, find($2->r));
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpRM("addw", $2->r, 'w', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_PLUS(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(HImode, $2->r)
      )
    ));
  };
#line 3170 "x86-64.int.py"
rcc : MEM_MINUS_QI(MEM_QI(addr), NEG_DI(r8)) [4, 1]
#line 3199 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->r);
  },
  build {
    sparseset_set_bit(live, find($2->r));
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpRM("addb", $2->r, 'b', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_PLUS(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, $2->r)
      )
    ));
  };
#line 3172 "x86-64.int.py"
rcc : MEM_IOR_DI     (MEM_DI(addr), r64) [4, 2]
#line 3199 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->r);
  },
  build {
    sparseset_set_bit(live, find($2->r));
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpRM("orq", $2->r, 'q', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_IOR(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(DImode, $2->r)
      )
    ));
  };
#line 3173 "x86-64.int.py"
rcc : MEM_IOR_SI     (MEM_SI(addr), r32) [4, 1]
#line 3199 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->r);
  },
  build {
    sparseset_set_bit(live, find($2->r));
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpRM("orl", $2->r, 'l', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_IOR(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(SImode, $2->r)
      )
    ));
  };
#line 3174 "x86-64.int.py"
rcc : MEM_IOR_HI     (MEM_HI(addr), r16) [4, 2]
#line 3199 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->r);
  },
  build {
    sparseset_set_bit(live, find($2->r));
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpRM("orw", $2->r, 'w', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_IOR(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(HImode, $2->r)
      )
    ));
  };
#line 3175 "x86-64.int.py"
rcc : MEM_IOR_QI     (MEM_QI(addr), r8) [4, 1]
#line 3199 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->r);
  },
  build {
    sparseset_set_bit(live, find($2->r));
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpRM("orb", $2->r, 'b', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_IOR(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, $2->r)
      )
    ));
  };
#line 3177 "x86-64.int.py"
rcc : MEM_XOR_DI     (MEM_DI(addr), r64) [4, 2]
#line 3199 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->r);
  },
  build {
    sparseset_set_bit(live, find($2->r));
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpRM("xorq", $2->r, 'q', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_XOR(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(DImode, $2->r)
      )
    ));
  };
#line 3178 "x86-64.int.py"
rcc : MEM_XOR_SI     (MEM_SI(addr), r32) [4, 1]
#line 3199 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->r);
  },
  build {
    sparseset_set_bit(live, find($2->r));
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpRM("xorl", $2->r, 'l', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_XOR(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(SImode, $2->r)
      )
    ));
  };
#line 3179 "x86-64.int.py"
rcc : MEM_XOR_HI     (MEM_HI(addr), r16) [4, 2]
#line 3199 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->r);
  },
  build {
    sparseset_set_bit(live, find($2->r));
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpRM("xorw", $2->r, 'w', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_XOR(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(HImode, $2->r)
      )
    ));
  };
#line 3180 "x86-64.int.py"
rcc : MEM_XOR_QI     (MEM_QI(addr), r8) [4, 1]
#line 3199 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->r);
  },
  build {
    sparseset_set_bit(live, find($2->r));
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpRM("xorb", $2->r, 'b', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_XOR(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, $2->r)
      )
    ));
  };
#line 3182 "x86-64.int.py"
rcc : MEM_PLUS_DI    (MEM_DI(addr), r64) [4, 2]
#line 3199 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->r);
  },
  build {
    sparseset_set_bit(live, find($2->r));
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpRM("addq", $2->r, 'q', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_PLUS(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(DImode, $2->r)
      )
    ));
  };
#line 3183 "x86-64.int.py"
rcc : MEM_PLUS_SI    (MEM_SI(addr), r32) [4, 1]
#line 3199 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->r);
  },
  build {
    sparseset_set_bit(live, find($2->r));
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpRM("addl", $2->r, 'l', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_PLUS(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(SImode, $2->r)
      )
    ));
  };
#line 3184 "x86-64.int.py"
rcc : MEM_PLUS_HI    (MEM_HI(addr), r16) [4, 2]
#line 3199 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->r);
  },
  build {
    sparseset_set_bit(live, find($2->r));
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpRM("addw", $2->r, 'w', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_PLUS(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(HImode, $2->r)
      )
    ));
  };
#line 3185 "x86-64.int.py"
rcc : MEM_PLUS_QI    (MEM_QI(addr), r8) [4, 1]
#line 3199 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->r);
  },
  build {
    sparseset_set_bit(live, find($2->r));
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpRM("addb", $2->r, 'b', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_PLUS(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, $2->r)
      )
    ));
  };
#line 3187 "x86-64.int.py"
rcc : MEM_MINUS_DI   (MEM_DI(addr), r64) [4, 2]
#line 3199 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->r);
  },
  build {
    sparseset_set_bit(live, find($2->r));
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpRM("subq", $2->r, 'q', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_MINUS(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(DImode, $2->r)
      )
    ));
  };
#line 3188 "x86-64.int.py"
rcc : MEM_MINUS_SI   (MEM_SI(addr), r32) [4, 1]
#line 3199 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->r);
  },
  build {
    sparseset_set_bit(live, find($2->r));
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpRM("subl", $2->r, 'l', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_MINUS(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(SImode, $2->r)
      )
    ));
  };
#line 3189 "x86-64.int.py"
rcc : MEM_MINUS_HI   (MEM_HI(addr), r16) [4, 2]
#line 3199 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->r);
  },
  build {
    sparseset_set_bit(live, find($2->r));
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpRM("subw", $2->r, 'w', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_MINUS(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(HImode, $2->r)
      )
    ));
  };
#line 3190 "x86-64.int.py"
rcc : MEM_MINUS_QI   (MEM_QI(addr), r8) [4, 1]
#line 3199 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->r);
  },
  build {
    sparseset_set_bit(live, find($2->r));
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpRM("subb", $2->r, 'b', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_MINUS(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, $2->r)
      )
    ));
  };
#line 3192 "x86-64.int.py"
rcc : MEM_AND_DI     (MEM_DI(addr), r64) [4, 2]
#line 3199 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->r);
  },
  build {
    sparseset_set_bit(live, find($2->r));
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpRM("andq", $2->r, 'q', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_AND(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(DImode, $2->r)
      )
    ));
  };
#line 3193 "x86-64.int.py"
rcc : MEM_AND_SI     (MEM_SI(addr), r32) [4, 1]
#line 3199 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->r);
  },
  build {
    sparseset_set_bit(live, find($2->r));
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpRM("andl", $2->r, 'l', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_AND(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(SImode, $2->r)
      )
    ));
  };
#line 3194 "x86-64.int.py"
rcc : MEM_AND_HI     (MEM_HI(addr), r16) [4, 2]
#line 3199 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->r);
  },
  build {
    sparseset_set_bit(live, find($2->r));
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpRM("andw", $2->r, 'w', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_AND(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(HImode, $2->r)
      )
    ));
  };
#line 3195 "x86-64.int.py"
rcc : MEM_AND_QI     (MEM_QI(addr), r8) [4, 1]
#line 3199 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->r);
  },
  build {
    sparseset_set_bit(live, find($2->r));
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpRM("andb", $2->r, 'b', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_AND(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, $2->r)
      )
    ));
  };
#line 3250 "x86-64.int.py"
rcc : MEM_ASHIFT_DI  (MEM_DI(addr), r8x) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("salq", $2->rx, 'q', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFT(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3251 "x86-64.int.py"
rcc : MEM_ASHIFT_SI  (MEM_SI(addr), r8x) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("sall", $2->rx, 'l', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFT(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3252 "x86-64.int.py"
rcc : MEM_ASHIFT_HI  (MEM_HI(addr), r8x) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("salw", $2->rx, 'w', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFT(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3253 "x86-64.int.py"
rcc : MEM_ASHIFT_QI  (MEM_QI(addr), r8x) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("salb", $2->rx, 'b', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFT(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3255 "x86-64.int.py"
rcc : MEM_ROTATE_DI  (MEM_DI(addr), r8x) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("rolq", $2->rx, 'q', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATE(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3256 "x86-64.int.py"
rcc : MEM_ROTATE_SI  (MEM_SI(addr), r8x) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("roll", $2->rx, 'l', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATE(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3257 "x86-64.int.py"
rcc : MEM_ROTATE_HI  (MEM_HI(addr), r8x) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("rolw", $2->rx, 'w', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATE(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3258 "x86-64.int.py"
rcc : MEM_ROTATE_QI  (MEM_QI(addr), r8x) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("rolb", $2->rx, 'b', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATE(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3260 "x86-64.int.py"
rcc : MEM_ASHIFTRT_DI(MEM_DI(addr), r8x) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("sarq", $2->rx, 'q', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFTRT(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3261 "x86-64.int.py"
rcc : MEM_ASHIFTRT_SI(MEM_SI(addr), r8x) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("sarl", $2->rx, 'l', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFTRT(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3262 "x86-64.int.py"
rcc : MEM_ASHIFTRT_HI(MEM_HI(addr), r8x) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("sarw", $2->rx, 'w', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFTRT(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3263 "x86-64.int.py"
rcc : MEM_ASHIFTRT_QI(MEM_QI(addr), r8x) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("sarb", $2->rx, 'b', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFTRT(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3265 "x86-64.int.py"
rcc : MEM_LSHIFTRT_DI(MEM_DI(addr), r8x) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("shrq", $2->rx, 'q', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_LSHIFTRT(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3266 "x86-64.int.py"
rcc : MEM_LSHIFTRT_SI(MEM_SI(addr), r8x) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("shrl", $2->rx, 'l', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_LSHIFTRT(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3267 "x86-64.int.py"
rcc : MEM_LSHIFTRT_HI(MEM_HI(addr), r8x) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("shrw", $2->rx, 'w', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_LSHIFTRT(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3268 "x86-64.int.py"
rcc : MEM_LSHIFTRT_QI(MEM_QI(addr), r8x) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("shrb", $2->rx, 'b', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_LSHIFTRT(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3270 "x86-64.int.py"
rcc : MEM_ROTATERT_DI(MEM_DI(addr), r8x) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("rorq", $2->rx, 'q', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATERT(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3271 "x86-64.int.py"
rcc : MEM_ROTATERT_SI(MEM_SI(addr), r8x) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("rorl", $2->rx, 'l', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATERT(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3272 "x86-64.int.py"
rcc : MEM_ROTATERT_HI(MEM_HI(addr), r8x) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("rorw", $2->rx, 'w', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATERT(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3273 "x86-64.int.py"
rcc : MEM_ROTATERT_QI(MEM_QI(addr), r8x) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("rorb", $2->rx, 'b', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATERT(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3276 "x86-64.int.py"
rcc : MEM_ASHIFT_DI  (MEM_DI(addr), SUBREG_QI(r64x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("salq", $2->rx, 'q', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFT(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3277 "x86-64.int.py"
rcc : MEM_ASHIFT_SI  (MEM_SI(addr), SUBREG_QI(r64x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("sall", $2->rx, 'l', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFT(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3278 "x86-64.int.py"
rcc : MEM_ASHIFT_HI  (MEM_HI(addr), SUBREG_QI(r64x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("salw", $2->rx, 'w', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFT(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3279 "x86-64.int.py"
rcc : MEM_ASHIFT_QI  (MEM_QI(addr), SUBREG_QI(r64x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("salb", $2->rx, 'b', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFT(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3281 "x86-64.int.py"
rcc : MEM_ROTATE_DI  (MEM_DI(addr), SUBREG_QI(r64x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("rolq", $2->rx, 'q', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATE(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3282 "x86-64.int.py"
rcc : MEM_ROTATE_SI  (MEM_SI(addr), SUBREG_QI(r64x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("roll", $2->rx, 'l', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATE(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3283 "x86-64.int.py"
rcc : MEM_ROTATE_HI  (MEM_HI(addr), SUBREG_QI(r64x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("rolw", $2->rx, 'w', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATE(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3284 "x86-64.int.py"
rcc : MEM_ROTATE_QI  (MEM_QI(addr), SUBREG_QI(r64x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("rolb", $2->rx, 'b', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATE(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3286 "x86-64.int.py"
rcc : MEM_ASHIFTRT_DI(MEM_DI(addr), SUBREG_QI(r64x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("sarq", $2->rx, 'q', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFTRT(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3287 "x86-64.int.py"
rcc : MEM_ASHIFTRT_SI(MEM_SI(addr), SUBREG_QI(r64x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("sarl", $2->rx, 'l', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFTRT(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3288 "x86-64.int.py"
rcc : MEM_ASHIFTRT_HI(MEM_HI(addr), SUBREG_QI(r64x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("sarw", $2->rx, 'w', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFTRT(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3289 "x86-64.int.py"
rcc : MEM_ASHIFTRT_QI(MEM_QI(addr), SUBREG_QI(r64x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("sarb", $2->rx, 'b', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFTRT(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3291 "x86-64.int.py"
rcc : MEM_LSHIFTRT_DI(MEM_DI(addr), SUBREG_QI(r64x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("shrq", $2->rx, 'q', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_LSHIFTRT(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3292 "x86-64.int.py"
rcc : MEM_LSHIFTRT_SI(MEM_SI(addr), SUBREG_QI(r64x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("shrl", $2->rx, 'l', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_LSHIFTRT(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3293 "x86-64.int.py"
rcc : MEM_LSHIFTRT_HI(MEM_HI(addr), SUBREG_QI(r64x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("shrw", $2->rx, 'w', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_LSHIFTRT(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3294 "x86-64.int.py"
rcc : MEM_LSHIFTRT_QI(MEM_QI(addr), SUBREG_QI(r64x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("shrb", $2->rx, 'b', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_LSHIFTRT(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3296 "x86-64.int.py"
rcc : MEM_ROTATERT_DI(MEM_DI(addr), SUBREG_QI(r64x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("rorq", $2->rx, 'q', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATERT(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3297 "x86-64.int.py"
rcc : MEM_ROTATERT_SI(MEM_SI(addr), SUBREG_QI(r64x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("rorl", $2->rx, 'l', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATERT(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3298 "x86-64.int.py"
rcc : MEM_ROTATERT_HI(MEM_HI(addr), SUBREG_QI(r64x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("rorw", $2->rx, 'w', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATERT(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3299 "x86-64.int.py"
rcc : MEM_ROTATERT_QI(MEM_QI(addr), SUBREG_QI(r64x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("rorb", $2->rx, 'b', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATERT(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3302 "x86-64.int.py"
rcc : MEM_ASHIFT_DI  (MEM_DI(addr), SUBREG_QI(r32x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("salq", $2->rx, 'q', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFT(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3303 "x86-64.int.py"
rcc : MEM_ASHIFT_SI  (MEM_SI(addr), SUBREG_QI(r32x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("sall", $2->rx, 'l', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFT(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3304 "x86-64.int.py"
rcc : MEM_ASHIFT_HI  (MEM_HI(addr), SUBREG_QI(r32x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("salw", $2->rx, 'w', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFT(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3305 "x86-64.int.py"
rcc : MEM_ASHIFT_QI  (MEM_QI(addr), SUBREG_QI(r32x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("salb", $2->rx, 'b', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFT(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3307 "x86-64.int.py"
rcc : MEM_ROTATE_DI  (MEM_DI(addr), SUBREG_QI(r32x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("rolq", $2->rx, 'q', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATE(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3308 "x86-64.int.py"
rcc : MEM_ROTATE_SI  (MEM_SI(addr), SUBREG_QI(r32x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("roll", $2->rx, 'l', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATE(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3309 "x86-64.int.py"
rcc : MEM_ROTATE_HI  (MEM_HI(addr), SUBREG_QI(r32x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("rolw", $2->rx, 'w', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATE(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3310 "x86-64.int.py"
rcc : MEM_ROTATE_QI  (MEM_QI(addr), SUBREG_QI(r32x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("rolb", $2->rx, 'b', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATE(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3312 "x86-64.int.py"
rcc : MEM_ASHIFTRT_DI(MEM_DI(addr), SUBREG_QI(r32x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("sarq", $2->rx, 'q', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFTRT(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3313 "x86-64.int.py"
rcc : MEM_ASHIFTRT_SI(MEM_SI(addr), SUBREG_QI(r32x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("sarl", $2->rx, 'l', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFTRT(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3314 "x86-64.int.py"
rcc : MEM_ASHIFTRT_HI(MEM_HI(addr), SUBREG_QI(r32x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("sarw", $2->rx, 'w', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFTRT(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3315 "x86-64.int.py"
rcc : MEM_ASHIFTRT_QI(MEM_QI(addr), SUBREG_QI(r32x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("sarb", $2->rx, 'b', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFTRT(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3317 "x86-64.int.py"
rcc : MEM_LSHIFTRT_DI(MEM_DI(addr), SUBREG_QI(r32x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("shrq", $2->rx, 'q', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_LSHIFTRT(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3318 "x86-64.int.py"
rcc : MEM_LSHIFTRT_SI(MEM_SI(addr), SUBREG_QI(r32x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("shrl", $2->rx, 'l', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_LSHIFTRT(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3319 "x86-64.int.py"
rcc : MEM_LSHIFTRT_HI(MEM_HI(addr), SUBREG_QI(r32x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("shrw", $2->rx, 'w', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_LSHIFTRT(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3320 "x86-64.int.py"
rcc : MEM_LSHIFTRT_QI(MEM_QI(addr), SUBREG_QI(r32x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("shrb", $2->rx, 'b', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_LSHIFTRT(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3322 "x86-64.int.py"
rcc : MEM_ROTATERT_DI(MEM_DI(addr), SUBREG_QI(r32x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("rorq", $2->rx, 'q', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATERT(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3323 "x86-64.int.py"
rcc : MEM_ROTATERT_SI(MEM_SI(addr), SUBREG_QI(r32x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("rorl", $2->rx, 'l', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATERT(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3324 "x86-64.int.py"
rcc : MEM_ROTATERT_HI(MEM_HI(addr), SUBREG_QI(r32x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("rorw", $2->rx, 'w', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATERT(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3325 "x86-64.int.py"
rcc : MEM_ROTATERT_QI(MEM_QI(addr), SUBREG_QI(r32x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("rorb", $2->rx, 'b', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATERT(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3328 "x86-64.int.py"
rcc : MEM_ASHIFT_DI  (MEM_DI(addr), SUBREG_QI(r16x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("salq", $2->rx, 'q', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFT(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3329 "x86-64.int.py"
rcc : MEM_ASHIFT_SI  (MEM_SI(addr), SUBREG_QI(r16x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("sall", $2->rx, 'l', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFT(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3330 "x86-64.int.py"
rcc : MEM_ASHIFT_HI  (MEM_HI(addr), SUBREG_QI(r16x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("salw", $2->rx, 'w', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFT(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3331 "x86-64.int.py"
rcc : MEM_ASHIFT_QI  (MEM_QI(addr), SUBREG_QI(r16x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("salb", $2->rx, 'b', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFT(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3333 "x86-64.int.py"
rcc : MEM_ROTATE_DI  (MEM_DI(addr), SUBREG_QI(r16x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("rolq", $2->rx, 'q', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATE(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3334 "x86-64.int.py"
rcc : MEM_ROTATE_SI  (MEM_SI(addr), SUBREG_QI(r16x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("roll", $2->rx, 'l', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATE(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3335 "x86-64.int.py"
rcc : MEM_ROTATE_HI  (MEM_HI(addr), SUBREG_QI(r16x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("rolw", $2->rx, 'w', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATE(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3336 "x86-64.int.py"
rcc : MEM_ROTATE_QI  (MEM_QI(addr), SUBREG_QI(r16x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("rolb", $2->rx, 'b', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATE(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3338 "x86-64.int.py"
rcc : MEM_ASHIFTRT_DI(MEM_DI(addr), SUBREG_QI(r16x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("sarq", $2->rx, 'q', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFTRT(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3339 "x86-64.int.py"
rcc : MEM_ASHIFTRT_SI(MEM_SI(addr), SUBREG_QI(r16x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("sarl", $2->rx, 'l', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFTRT(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3340 "x86-64.int.py"
rcc : MEM_ASHIFTRT_HI(MEM_HI(addr), SUBREG_QI(r16x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("sarw", $2->rx, 'w', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFTRT(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3341 "x86-64.int.py"
rcc : MEM_ASHIFTRT_QI(MEM_QI(addr), SUBREG_QI(r16x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("sarb", $2->rx, 'b', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFTRT(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3343 "x86-64.int.py"
rcc : MEM_LSHIFTRT_DI(MEM_DI(addr), SUBREG_QI(r16x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("shrq", $2->rx, 'q', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_LSHIFTRT(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3344 "x86-64.int.py"
rcc : MEM_LSHIFTRT_SI(MEM_SI(addr), SUBREG_QI(r16x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("shrl", $2->rx, 'l', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_LSHIFTRT(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3345 "x86-64.int.py"
rcc : MEM_LSHIFTRT_HI(MEM_HI(addr), SUBREG_QI(r16x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("shrw", $2->rx, 'w', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_LSHIFTRT(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3346 "x86-64.int.py"
rcc : MEM_LSHIFTRT_QI(MEM_QI(addr), SUBREG_QI(r16x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("shrb", $2->rx, 'b', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_LSHIFTRT(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3348 "x86-64.int.py"
rcc : MEM_ROTATERT_DI(MEM_DI(addr), SUBREG_QI(r16x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("rorq", $2->rx, 'q', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATERT(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3349 "x86-64.int.py"
rcc : MEM_ROTATERT_SI(MEM_SI(addr), SUBREG_QI(r16x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("rorl", $2->rx, 'l', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATERT(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3350 "x86-64.int.py"
rcc : MEM_ROTATERT_HI(MEM_HI(addr), SUBREG_QI(r16x, CONST_0)) [4, 2]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("rorw", $2->rx, 'w', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATERT(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3351 "x86-64.int.py"
rcc : MEM_ROTATERT_QI(MEM_QI(addr), SUBREG_QI(r16x, CONST_0)) [4, 1]
#line 3355 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $2->rx, REG_RCX);
  },
  build {
    add_addr(live, $1);
    add_copy_edges(REG_RCX, $2->rx, live);
  },
  remat {
    flags = 0;
  },
  costs {
    /*
     * the src register can not be directly replaced
     * with a spill memory reference, so this is "forgettable".
     */
    forgettable($2->rx);	/* must be in a register */
    cost_copy(REG_RCX, $2->rx);
  },
  debug {
    dumpRM("rorb", $2->rx, 'b', $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    const rtx rcx = gen_rtx_REG(SImode, REG_RCX);
    const rtx src = gen_rtx_REG(SImode, $2->rx);
    icg_emit_plain(gen_rtx_SET(VOIDmode, rcx, src));
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATERT(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_REG(QImode, REG_RCX)
      )
    ));
  };
#line 3397 "x86-64.int.py"
rcc  : MEM_PLUS_DI(MEM_DI(addr),     imm32) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("addq", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_PLUS(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3398 "x86-64.int.py"
rcc  : MEM_PLUS_SI(MEM_SI(addr),     imm32) [4, 2]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("addl", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_PLUS(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3399 "x86-64.int.py"
rcc  : MEM_PLUS_HI(MEM_HI(addr),     imm16) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("addw", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_PLUS(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3400 "x86-64.int.py"
rcc  : MEM_PLUS_QI(MEM_QI(addr),     imm8) [4, 2]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("addb", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_PLUS(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3401 "x86-64.int.py"
rcc  : MEM_PLUS_DI(MEM_DI(addr),     imm8) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("addq", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_PLUS(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3402 "x86-64.int.py"
rcc  : MEM_PLUS_SI(MEM_SI(addr),     imm8) [4, 2]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("addl", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_PLUS(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3403 "x86-64.int.py"
rcc  : MEM_PLUS_HI(MEM_HI(addr),     imm8) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("addw", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_PLUS(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3405 "x86-64.int.py"
rcc  : MEM_MINUS_DI(MEM_DI(addr),    imm32) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("subq", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_MINUS(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3406 "x86-64.int.py"
rcc  : MEM_MINUS_SI(MEM_SI(addr),    imm32) [4, 2]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("subl", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_MINUS(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3407 "x86-64.int.py"
rcc  : MEM_MINUS_HI(MEM_HI(addr),    imm16) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("subw", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_MINUS(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3408 "x86-64.int.py"
rcc  : MEM_MINUS_QI(MEM_QI(addr),    imm8) [4, 2]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("subb", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_MINUS(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3409 "x86-64.int.py"
rcc  : MEM_MINUS_DI(MEM_DI(addr),    imm8) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("subq", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_MINUS(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3410 "x86-64.int.py"
rcc  : MEM_MINUS_SI(MEM_SI(addr),    imm8) [4, 2]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("subl", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_MINUS(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3411 "x86-64.int.py"
rcc  : MEM_MINUS_HI(MEM_HI(addr),    imm8) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("subw", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_MINUS(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3413 "x86-64.int.py"
rcc  : MEM_AND_DI(MEM_DI(addr),      imm32) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("andq", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_AND(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3414 "x86-64.int.py"
rcc  : MEM_AND_SI(MEM_SI(addr),      imm32) [4, 2]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("andl", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_AND(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3415 "x86-64.int.py"
rcc  : MEM_AND_HI(MEM_HI(addr),      imm16) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("andw", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_AND(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3416 "x86-64.int.py"
rcc  : MEM_AND_QI(MEM_QI(addr),      imm8) [4, 2]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("andb", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_AND(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3417 "x86-64.int.py"
rcc  : MEM_AND_DI(MEM_DI(addr),      imm8) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("andq", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_AND(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3418 "x86-64.int.py"
rcc  : MEM_AND_SI(MEM_SI(addr),      imm8) [4, 2]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("andl", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_AND(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3419 "x86-64.int.py"
rcc  : MEM_AND_HI(MEM_HI(addr),      imm8) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("andw", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_AND(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3421 "x86-64.int.py"
rcc  : MEM_IOR_DI(MEM_DI(addr),      imm32) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("orq", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_IOR(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3422 "x86-64.int.py"
rcc  : MEM_IOR_SI(MEM_SI(addr),      imm32) [4, 2]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("orl", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_IOR(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3423 "x86-64.int.py"
rcc  : MEM_IOR_HI(MEM_HI(addr),      imm16) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("orw", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_IOR(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3424 "x86-64.int.py"
rcc  : MEM_IOR_QI(MEM_QI(addr),      imm8) [4, 2]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("orb", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_IOR(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3425 "x86-64.int.py"
rcc  : MEM_IOR_DI(MEM_DI(addr),      imm8) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("orq", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_IOR(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3426 "x86-64.int.py"
rcc  : MEM_IOR_SI(MEM_SI(addr),      imm8) [4, 2]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("orl", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_IOR(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3427 "x86-64.int.py"
rcc  : MEM_IOR_HI(MEM_HI(addr),      imm8) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("orw", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_IOR(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3429 "x86-64.int.py"
rcc  : MEM_XOR_DI(MEM_DI(addr),      imm32) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("xorq", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_XOR(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3430 "x86-64.int.py"
rcc  : MEM_XOR_SI(MEM_SI(addr),      imm32) [4, 2]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("xorl", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_XOR(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3431 "x86-64.int.py"
rcc  : MEM_XOR_HI(MEM_HI(addr),      imm16) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("xorw", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_XOR(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3432 "x86-64.int.py"
rcc  : MEM_XOR_QI(MEM_QI(addr),      imm8) [4, 2]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("xorb", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_XOR(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3433 "x86-64.int.py"
rcc  : MEM_XOR_DI(MEM_DI(addr),      imm8) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("xorq", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_XOR(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3434 "x86-64.int.py"
rcc  : MEM_XOR_SI(MEM_SI(addr),      imm8) [4, 2]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("xorl", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_XOR(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3435 "x86-64.int.py"
rcc  : MEM_XOR_HI(MEM_HI(addr),      imm8) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("xorw", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_XOR(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3444 "x86-64.int.py"
rcc : MEM_ASHIFT_DI(MEM_DI(addr),   imm8) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("salq", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFT(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3445 "x86-64.int.py"
rcc : MEM_ASHIFT_SI(MEM_SI(addr),   imm8) [4, 2]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("sall", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFT(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3446 "x86-64.int.py"
rcc : MEM_ASHIFT_HI(MEM_HI(addr),   imm8) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("salw", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFT(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3447 "x86-64.int.py"
rcc : MEM_ASHIFT_QI(MEM_QI(addr),   imm8) [4, 2]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("salb", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFT(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3449 "x86-64.int.py"
rcc : MEM_ROTATE_DI(MEM_DI(addr),   imm8) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("rolq", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATE(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3450 "x86-64.int.py"
rcc : MEM_ROTATE_SI(MEM_SI(addr),   imm8) [4, 2]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("roll", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATE(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3451 "x86-64.int.py"
rcc : MEM_ROTATE_HI(MEM_HI(addr),   imm8) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("rolw", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATE(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3452 "x86-64.int.py"
rcc : MEM_ROTATE_QI(MEM_QI(addr),   imm8) [4, 2]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("rolb", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATE(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3454 "x86-64.int.py"
rcc : MEM_LSHIFTRT_DI(MEM_DI(addr), imm8) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("shrq", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_LSHIFTRT(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3455 "x86-64.int.py"
rcc : MEM_LSHIFTRT_SI(MEM_SI(addr), imm8) [4, 2]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("shrl", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_LSHIFTRT(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3456 "x86-64.int.py"
rcc : MEM_LSHIFTRT_HI(MEM_HI(addr), imm8) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("shrw", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_LSHIFTRT(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3457 "x86-64.int.py"
rcc : MEM_LSHIFTRT_QI(MEM_QI(addr), imm8) [4, 2]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("shrb", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_LSHIFTRT(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3459 "x86-64.int.py"
rcc : MEM_ASHIFTRT_DI(MEM_DI(addr), imm8) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("sarq", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFTRT(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3460 "x86-64.int.py"
rcc : MEM_ASHIFTRT_SI(MEM_SI(addr), imm8) [4, 2]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("sarl", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFTRT(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3461 "x86-64.int.py"
rcc : MEM_ASHIFTRT_HI(MEM_HI(addr), imm8) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("sarw", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFTRT(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3462 "x86-64.int.py"
rcc : MEM_ASHIFTRT_QI(MEM_QI(addr), imm8) [4, 2]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("sarb", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFTRT(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3464 "x86-64.int.py"
rcc : MEM_ROTATERT_DI(MEM_DI(addr), imm8) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("rorq", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATERT(DImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3465 "x86-64.int.py"
rcc : MEM_ROTATERT_SI(MEM_SI(addr), imm8) [4, 2]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("rorl", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATERT(SImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3466 "x86-64.int.py"
rcc : MEM_ROTATERT_HI(MEM_HI(addr), imm8) [4, 3]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("rorw", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATERT(HImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3467 "x86-64.int.py"
rcc : MEM_ROTATERT_QI(MEM_QI(addr), imm8) [4, 2]
#line 3471 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpIM("rorb", $2, $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATERT(QImode,
	mem,	/* NOTE: dag */
	gen_rtx_imm_constant($2->val, $2->a.string, $2->rtl)
      )
    ));
  };
#line 3503 "x86-64.int.py"
rcc  : MEM_PLUS_DI(MEM_DI(addr),     CONST_P1) [4, 3]
#line 3525 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("incq", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_PLUS(DImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3504 "x86-64.int.py"
rcc  : MEM_PLUS_SI(MEM_SI(addr),     CONST_P1) [4, 2]
#line 3525 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("incl", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_PLUS(SImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3505 "x86-64.int.py"
rcc  : MEM_PLUS_HI(MEM_HI(addr),     CONST_P1) [4, 3]
#line 3525 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("incw", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_PLUS(HImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3506 "x86-64.int.py"
rcc  : MEM_PLUS_QI(MEM_QI(addr),     CONST_P1) [4, 2]
#line 3525 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("incb", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_PLUS(QImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3508 "x86-64.int.py"
rcc  : MEM_PLUS_DI(MEM_DI(addr),     CONST_N1) [4, 3]
#line 3525 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("decq", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_MINUS(DImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3509 "x86-64.int.py"
rcc  : MEM_PLUS_SI(MEM_SI(addr),     CONST_N1) [4, 2]
#line 3525 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("decl", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_MINUS(SImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3510 "x86-64.int.py"
rcc  : MEM_PLUS_HI(MEM_HI(addr),     CONST_N1) [4, 3]
#line 3525 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("decw", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_MINUS(HImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3511 "x86-64.int.py"
rcc  : MEM_PLUS_QI(MEM_QI(addr),     CONST_N1) [4, 2]
#line 3525 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("decb", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_MINUS(QImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3513 "x86-64.int.py"
rcc  : MEM_MINUS_DI(MEM_DI(addr),    CONST_P1) [4, 3]
#line 3525 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("decq", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_MINUS(DImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3514 "x86-64.int.py"
rcc  : MEM_MINUS_SI(MEM_SI(addr),    CONST_P1) [4, 2]
#line 3525 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("decl", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_MINUS(SImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3515 "x86-64.int.py"
rcc  : MEM_MINUS_HI(MEM_HI(addr),    CONST_P1) [4, 3]
#line 3525 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("decw", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_MINUS(HImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3516 "x86-64.int.py"
rcc  : MEM_MINUS_QI(MEM_QI(addr),    CONST_P1) [4, 2]
#line 3525 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("decb", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_MINUS(QImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3518 "x86-64.int.py"
rcc  : MEM_MINUS_DI(MEM_DI(addr),    CONST_N1) [4, 3]
#line 3525 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("incq", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_PLUS(DImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3519 "x86-64.int.py"
rcc  : MEM_MINUS_SI(MEM_SI(addr),    CONST_N1) [4, 2]
#line 3525 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("incl", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_PLUS(SImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3520 "x86-64.int.py"
rcc  : MEM_MINUS_HI(MEM_HI(addr),    CONST_N1) [4, 3]
#line 3525 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("incw", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_PLUS(HImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3521 "x86-64.int.py"
rcc  : MEM_MINUS_QI(MEM_QI(addr),    CONST_N1) [4, 2]
#line 3525 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("incb", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_PLUS(QImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3559 "x86-64.int.py"
rcc : MEM_ASHIFT_DI(MEM_DI(addr),   CONST_P1) [4, 3]
#line 3586 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("salq", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFT(DImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3560 "x86-64.int.py"
rcc : MEM_ASHIFT_SI(MEM_SI(addr),   CONST_P1) [4, 2]
#line 3586 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("sall", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFT(SImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3561 "x86-64.int.py"
rcc : MEM_ASHIFT_HI(MEM_HI(addr),   CONST_P1) [4, 3]
#line 3586 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("salw", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFT(HImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3562 "x86-64.int.py"
rcc : MEM_ASHIFT_QI(MEM_QI(addr),   CONST_P1) [4, 2]
#line 3586 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("salb", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFT(QImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3564 "x86-64.int.py"
rcc : MEM_ROTATE_DI(MEM_DI(addr),   CONST_P1) [4, 3]
#line 3586 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("rolq", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATE(DImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3565 "x86-64.int.py"
rcc : MEM_ROTATE_SI(MEM_SI(addr),   CONST_P1) [4, 2]
#line 3586 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("roll", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATE(SImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3566 "x86-64.int.py"
rcc : MEM_ROTATE_HI(MEM_HI(addr),   CONST_P1) [4, 3]
#line 3586 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("rolw", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATE(HImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3567 "x86-64.int.py"
rcc : MEM_ROTATE_QI(MEM_QI(addr),   CONST_P1) [4, 2]
#line 3586 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("rolb", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATE(QImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3569 "x86-64.int.py"
rcc : MEM_LSHIFTRT_DI(MEM_DI(addr), CONST_P1) [4, 3]
#line 3586 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("shrq", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_LSHIFTRT(DImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3570 "x86-64.int.py"
rcc : MEM_LSHIFTRT_SI(MEM_SI(addr), CONST_P1) [4, 2]
#line 3586 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("shrl", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_LSHIFTRT(SImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3571 "x86-64.int.py"
rcc : MEM_LSHIFTRT_HI(MEM_HI(addr), CONST_P1) [4, 3]
#line 3586 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("shrw", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_LSHIFTRT(HImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3572 "x86-64.int.py"
rcc : MEM_LSHIFTRT_QI(MEM_QI(addr), CONST_P1) [4, 2]
#line 3586 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("shrb", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_LSHIFTRT(QImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3574 "x86-64.int.py"
rcc : MEM_ASHIFTRT_DI(MEM_DI(addr), CONST_P1) [4, 3]
#line 3586 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("sarq", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFTRT(DImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3575 "x86-64.int.py"
rcc : MEM_ASHIFTRT_SI(MEM_SI(addr), CONST_P1) [4, 2]
#line 3586 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("sarl", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFTRT(SImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3576 "x86-64.int.py"
rcc : MEM_ASHIFTRT_HI(MEM_HI(addr), CONST_P1) [4, 3]
#line 3586 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("sarw", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFTRT(HImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3577 "x86-64.int.py"
rcc : MEM_ASHIFTRT_QI(MEM_QI(addr), CONST_P1) [4, 2]
#line 3586 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("sarb", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ASHIFTRT(QImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3579 "x86-64.int.py"
rcc : MEM_ROTATERT_DI(MEM_DI(addr), CONST_P1) [4, 3]
#line 3586 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("sarq", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(DImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATERT(DImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3580 "x86-64.int.py"
rcc : MEM_ROTATERT_SI(MEM_SI(addr), CONST_P1) [4, 2]
#line 3586 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("sarl", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(SImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATERT(SImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3581 "x86-64.int.py"
rcc : MEM_ROTATERT_HI(MEM_HI(addr), CONST_P1) [4, 3]
#line 3586 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("sarw", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(HImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATERT(HImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3582 "x86-64.int.py"
rcc : MEM_ROTATERT_QI(MEM_QI(addr), CONST_P1) [4, 2]
#line 3586 "x86-64.int.py"
  supairs {
    /*TODO*/
  },
  build {
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpM("sarb", $1);
  },
  emit {
    const rtx mem = gen_rtx_MEM(QImode, $1->rtl);
    (0 ? icg_emit_plain : icg_emit_clobber)(gen_rtx_SET(VOIDmode,
      mem,	/* NOTE: dag */
      gen_rtx_ROTATERT(QImode,
	mem,	/* NOTE: dag */
	GEN_INT(1)
      )
    ));
  };
#line 3616 "x86-64.int.py"
stmt : nocc [100, 100]
#line 3620 "x86-64.int.py"
  ;
#line 3617 "x86-64.int.py"
stmt : rcc [100, 100]
#line 3620 "x86-64.int.py"
  ;
#line 3648 "x86-64.int.py"
r64x  : TRUNCATE_DI(LSHIFTRT_TI(MULT_TI(ZERO_EXTEND_TI(r64x) | ZERO_EXTEND_TI(r64)), CONST8P)) [4, 4]
#line 3663 "x86-64.int.py"
  supairs {
    if (1) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RDX);
  },
  build {
    if ('q' != 'b') {
      add_copy_edges($$->rx, REG_RDX, live);
    }
    if (1) {
      sparseset_set_bit(live, find($2->r));
    } else {
      add_addr(live, $2);
    }
    if ('q' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);	/* RDX is always killed on 64,32,16 bit variants */
    }
    add_copy_edges(REG_RAX, $1->rx, live);	/* we want these to coalesce */
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy(REG_RAX, $1->rx);
    if (1) {
      memorable($1->rx);
      memorable($2->r);
    }
    else
      forgettable($1->rx);
    cost_copy(REG_RDX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movq", $1->rx, REG_RAX, 'q');
    if (1)
      dumpR("mulq", $2->r, 'q');
    else
      dumpM("mulq", $2);
    dump_copy("movq", REG_RDX, $$->rx, 'q');
  },
  emit {
    rtx dst  = gen_rtx_REG(DImode, $$->rx);
    rtx src1 = gen_rtx_REG(DImode, $1->rx);
    rtx src2 = 1
      ? gen_rtx_REG(DImode, $2->r)
      : gen_rtx_MEM(DImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(DImode, REG_RAX);
    rtx rdx = ('q' != 'b') ? gen_rtx_REG(DImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * unsigned multiply modifes the OF and CF flags,
     * so we must use icg_emit_clobber (gen_rtx_CLOBBER)
     */
    parset = gen_rtvec(3,
      gen_rtx_SET(VOIDmode,
	rdx,	/* value comes back in rdx, no shifts needed */
	gen_rtx_TRUNCATE(DImode,
	  gen_rtx_LSHIFTRT(TImode,
	    gen_rtx_MULT(TImode,
	      0
		? gen_rtx_SIGN_EXTEND(TImode, rax)
		: gen_rtx_ZERO_EXTEND(TImode, rax),
	      0
	        ?  gen_rtx_SIGN_EXTEND(TImode, src2)
	        :  gen_rtx_ZERO_EXTEND(TImode, src2)
	      ),
	    gen_rtx_CONST_INT(QImode, 64)
	))),
      gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(DImode, REG_RAX)),	/* perhaps clobber the scratch reg? */
      gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG))
    );

    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RDX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 3650 "x86-64.int.py"
r64x  : TRUNCATE_DI(LSHIFTRT_TI(MULT_TI(ZERO_EXTEND_TI(r64x) | ZERO_EXTEND_TI(MEM_QI(addr))), CONST8P)) [7, 2]
#line 3663 "x86-64.int.py"
  supairs {
    if (0) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RDX);
  },
  build {
    if ('q' != 'b') {
      add_copy_edges($$->rx, REG_RDX, live);
    }
    if (0) {
      sparseset_set_bit(live, find($2->r));
    } else {
      add_addr(live, $2);
    }
    if ('q' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);	/* RDX is always killed on 64,32,16 bit variants */
    }
    add_copy_edges(REG_RAX, $1->rx, live);	/* we want these to coalesce */
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy(REG_RAX, $1->rx);
    if (0) {
      memorable($1->rx);
      memorable($2->r);
    }
    else
      forgettable($1->rx);
    cost_copy(REG_RDX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movq", $1->rx, REG_RAX, 'q');
    if (0)
      dumpR("mulq", $2->r, 'q');
    else
      dumpM("mulq", $2);
    dump_copy("movq", REG_RDX, $$->rx, 'q');
  },
  emit {
    rtx dst  = gen_rtx_REG(DImode, $$->rx);
    rtx src1 = gen_rtx_REG(DImode, $1->rx);
    rtx src2 = 0
      ? gen_rtx_REG(DImode, $2->r)
      : gen_rtx_MEM(DImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(DImode, REG_RAX);
    rtx rdx = ('q' != 'b') ? gen_rtx_REG(DImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * unsigned multiply modifes the OF and CF flags,
     * so we must use icg_emit_clobber (gen_rtx_CLOBBER)
     */
    parset = gen_rtvec(3,
      gen_rtx_SET(VOIDmode,
	rdx,	/* value comes back in rdx, no shifts needed */
	gen_rtx_TRUNCATE(DImode,
	  gen_rtx_LSHIFTRT(TImode,
	    gen_rtx_MULT(TImode,
	      0
		? gen_rtx_SIGN_EXTEND(TImode, rax)
		: gen_rtx_ZERO_EXTEND(TImode, rax),
	      0
	        ?  gen_rtx_SIGN_EXTEND(TImode, src2)
	        :  gen_rtx_ZERO_EXTEND(TImode, src2)
	      ),
	    gen_rtx_CONST_INT(QImode, 64)
	))),
      gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(DImode, REG_RAX)),	/* perhaps clobber the scratch reg? */
      gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG))
    );

    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RDX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 3657 "x86-64.int.py"
r64x  : TRUNCATE_DI(LSHIFTRT_TI(MULT_TI(SIGN_EXTEND_TI(r64x) | SIGN_EXTEND_TI(r64)), CONST8P)) [4, 4]
#line 3663 "x86-64.int.py"
  supairs {
    if (1) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RDX);
  },
  build {
    if ('q' != 'b') {
      add_copy_edges($$->rx, REG_RDX, live);
    }
    if (1) {
      sparseset_set_bit(live, find($2->r));
    } else {
      add_addr(live, $2);
    }
    if ('q' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);	/* RDX is always killed on 64,32,16 bit variants */
    }
    add_copy_edges(REG_RAX, $1->rx, live);	/* we want these to coalesce */
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy(REG_RAX, $1->rx);
    if (1) {
      memorable($1->rx);
      memorable($2->r);
    }
    else
      forgettable($1->rx);
    cost_copy(REG_RDX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movq", $1->rx, REG_RAX, 'q');
    if (1)
      dumpR("imulq", $2->r, 'q');
    else
      dumpM("imulq", $2);
    dump_copy("movq", REG_RDX, $$->rx, 'q');
  },
  emit {
    rtx dst  = gen_rtx_REG(DImode, $$->rx);
    rtx src1 = gen_rtx_REG(DImode, $1->rx);
    rtx src2 = 1
      ? gen_rtx_REG(DImode, $2->r)
      : gen_rtx_MEM(DImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(DImode, REG_RAX);
    rtx rdx = ('q' != 'b') ? gen_rtx_REG(DImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * unsigned multiply modifes the OF and CF flags,
     * so we must use icg_emit_clobber (gen_rtx_CLOBBER)
     */
    parset = gen_rtvec(3,
      gen_rtx_SET(VOIDmode,
	rdx,	/* value comes back in rdx, no shifts needed */
	gen_rtx_TRUNCATE(DImode,
	  gen_rtx_LSHIFTRT(TImode,
	    gen_rtx_MULT(TImode,
	      1
		? gen_rtx_SIGN_EXTEND(TImode, rax)
		: gen_rtx_ZERO_EXTEND(TImode, rax),
	      1
	        ?  gen_rtx_SIGN_EXTEND(TImode, src2)
	        :  gen_rtx_ZERO_EXTEND(TImode, src2)
	      ),
	    gen_rtx_CONST_INT(QImode, 64)
	))),
      gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(DImode, REG_RAX)),	/* perhaps clobber the scratch reg? */
      gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG))
    );

    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RDX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 3659 "x86-64.int.py"
r64x  : TRUNCATE_DI(LSHIFTRT_TI(MULT_TI(SIGN_EXTEND_TI(r64x) | SIGN_EXTEND_TI(MEM_QI(addr))), CONST8P)) [7, 2]
#line 3663 "x86-64.int.py"
  supairs {
    if (0) {
      suOrder2($$, $1, $2, kid, kids);
    } else {
      suOrder2($$, $1, $2, kid, kids);
    }
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  coalesce {
    coalesces += attempt_coalesce(pass, $1->rx, REG_RAX);
    coalesces += attempt_coalesce(pass, $$->rx, REG_RDX);
  },
  build {
    if ('q' != 'b') {
      add_copy_edges($$->rx, REG_RDX, live);
    }
    if (0) {
      sparseset_set_bit(live, find($2->r));
    } else {
      add_addr(live, $2);
    }
    if ('q' != 'b') {
      sparseset_clear_bit(live, REG_RDX);
      add_edges(REG_RDX, live);	/* RDX is always killed on 64,32,16 bit variants */
    }
    add_copy_edges(REG_RAX, $1->rx, live);	/* we want these to coalesce */
  },
  remat {
    flags = 0;
  },
  costs {
    cost_copy(REG_RAX, $1->rx);
    if (0) {
      memorable($1->rx);
      memorable($2->r);
    }
    else
      forgettable($1->rx);
    cost_copy(REG_RDX, $$->rx);
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  debug {
    dump_copy("movq", $1->rx, REG_RAX, 'q');
    if (0)
      dumpR("imulq", $2->r, 'q');
    else
      dumpM("imulq", $2);
    dump_copy("movq", REG_RDX, $$->rx, 'q');
  },
  emit {
    rtx dst  = gen_rtx_REG(DImode, $$->rx);
    rtx src1 = gen_rtx_REG(DImode, $1->rx);
    rtx src2 = 0
      ? gen_rtx_REG(DImode, $2->r)
      : gen_rtx_MEM(DImode, $2->rtl);
    /*
     * TODO: raxm, which is the wider mode
     * TODO: rdxm, which is the wider mode
     */
    rtx rax = gen_rtx_REG(DImode, REG_RAX);
    rtx rdx = ('q' != 'b') ? gen_rtx_REG(DImode, REG_RDX) : 0;
    rtvec parset = 0;
    icg_emit_plain(gen_rtx_SET(VOIDmode, rax/*raxm?*/, src1));
    /*
     * unsigned multiply modifes the OF and CF flags,
     * so we must use icg_emit_clobber (gen_rtx_CLOBBER)
     */
    parset = gen_rtvec(3,
      gen_rtx_SET(VOIDmode,
	rdx,	/* value comes back in rdx, no shifts needed */
	gen_rtx_TRUNCATE(DImode,
	  gen_rtx_LSHIFTRT(TImode,
	    gen_rtx_MULT(TImode,
	      1
		? gen_rtx_SIGN_EXTEND(TImode, rax)
		: gen_rtx_ZERO_EXTEND(TImode, rax),
	      1
	        ?  gen_rtx_SIGN_EXTEND(TImode, src2)
	        :  gen_rtx_ZERO_EXTEND(TImode, src2)
	      ),
	    gen_rtx_CONST_INT(QImode, 64)
	))),
      gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(DImode, REG_RAX)),	/* perhaps clobber the scratch reg? */
      gen_rtx_CLOBBER(VOIDmode, gen_rtx_REG(CCmode, FLAGS_REG))
    );

    icg_emit_plain(gen_rtx_PARALLEL(VOIDmode, parset));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, (REG_RDX == REG_RAX) ? rax/*raxm?*/ : rdx/*rdxm*/));
  };
#line 3777 "x86-64.int.py"
r64x  : CLZ_DI(r64) [4, 3]
#line 3792 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;            /* think about these */
    $$->freed = $1->freed;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    forgettable($1->r);
  },
  debug {
    dumpRR("lzcntq", $1->r, 'q', $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src = gen_rtx_CLZ(DImode,
      gen_rtx_REG(DImode, $1->r)
    );
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3778 "x86-64.int.py"
rz32x : CLZ_SI(r32) [3, 2]
#line 3792 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;            /* think about these */
    $$->freed = $1->freed;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    forgettable($1->r);
  },
  debug {
    dumpRR("lzcntl", $1->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_CLZ(SImode,
      gen_rtx_REG(SImode, $1->r)
    );
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3779 "x86-64.int.py"
r16x  : CLZ_HI(r16) [4, 3]
#line 3792 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;            /* think about these */
    $$->freed = $1->freed;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    forgettable($1->r);
  },
  debug {
    dumpRR("lzcntw", $1->r, 'w', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_CLZ(HImode,
      gen_rtx_REG(HImode, $1->r)
    );
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3781 "x86-64.int.py"
r64x  : PLUS_DI(CONST_P63, NEG_DI(CLZ_DI(r64))) [4, 3]
#line 3792 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;            /* think about these */
    $$->freed = $1->freed;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    forgettable($1->r);
  },
  debug {
    dumpRR("bsrq", $1->r, 'q', $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src = gen_rtx_BSR_DI(DImode,
      gen_rtx_REG(DImode, $1->r)
    );
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3782 "x86-64.int.py"
rz32x : PLUS_DI(CONST_P31, NEG_DI(CLZ_SI(r32))) [3, 2]
#line 3792 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;            /* think about these */
    $$->freed = $1->freed;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    forgettable($1->r);
  },
  debug {
    dumpRR("bsrl", $1->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_BSR_SI(SImode,
      gen_rtx_REG(SImode, $1->r)
    );
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3783 "x86-64.int.py"
r16x  : PLUS_DI(CONST_P15, NEG_DI(CLZ_HI(r16))) [4, 3]
#line 3792 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;            /* think about these */
    $$->freed = $1->freed;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    forgettable($1->r);
  },
  debug {
    dumpRR("bsrw", $1->r, 'w', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_BSR_HI(HImode,
      gen_rtx_REG(HImode, $1->r)
    );
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3786 "x86-64.int.py"
r64x  : POPCOUNT_DI(r64) [4, 3]
#line 3792 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;            /* think about these */
    $$->freed = $1->freed;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    forgettable($1->r);
  },
  debug {
    dumpRR("popcntq", $1->r, 'q', $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src = gen_rtx_POPCOUNT(DImode,
      gen_rtx_REG(DImode, $1->r)
    );
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3787 "x86-64.int.py"
rz32x : POPCOUNT_SI(r32) [3, 2]
#line 3792 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;            /* think about these */
    $$->freed = $1->freed;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    forgettable($1->r);
  },
  debug {
    dumpRR("popcntl", $1->r, 'l', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_POPCOUNT(SImode,
      gen_rtx_REG(SImode, $1->r)
    );
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3788 "x86-64.int.py"
r16x  : POPCOUNT_HI(r16) [4, 3]
#line 3792 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;            /* think about these */
    $$->freed = $1->freed;
  },
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    forgettable($1->r);
  },
  debug {
    dumpRR("popcntw", $1->r, 'w', $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_POPCOUNT(HImode,
      gen_rtx_REG(HImode, $1->r)
    );
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3828 "x86-64.int.py"
stmt  :  PREFETCH_DI(addr, imm32) [3, 2]
#line 3831 "x86-64.int.py"
  build {
    add_addr(live, $1);
  },
  debug {
    dumpM("prefetchnta", $1);
  },
  emit {
    const int k1 = $2->val/10;
    const int k2 = $2->val%10;
    icg_emit_plain(gen_rtx_PREFETCH(DImode, $1->rtl, GEN_INT(k1), GEN_INT(k2)));
  };
#line 3860 "x86-64.int.py"
ccr64x  : ASHIFT_DI(LSHIFTRT_DI(r64x, CONST_P1), CONST_P1) [1, 8]
#line 3885 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("andq", -2, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src = gen_rtx_AND(DImode,
			       gen_rtx_REG(DImode, $1->rx),
			       GEN_INT(-2));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3861 "x86-64.int.py"
ccr64x  : ASHIFT_DI(LSHIFTRT_DI(r64x, CONST_P2), CONST_P2) [1, 8]
#line 3885 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("andq", -4, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src = gen_rtx_AND(DImode,
			       gen_rtx_REG(DImode, $1->rx),
			       GEN_INT(-4));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3862 "x86-64.int.py"
ccr64x  : ASHIFT_DI(LSHIFTRT_DI(r64x, CONST_P3), CONST_P3) [1, 8]
#line 3885 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("andq", -8, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src = gen_rtx_AND(DImode,
			       gen_rtx_REG(DImode, $1->rx),
			       GEN_INT(-8));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3863 "x86-64.int.py"
ccr64x  : ASHIFT_DI(LSHIFTRT_DI(r64x, CONST_P4), CONST_P4) [1, 8]
#line 3885 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("andq", -16, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src = gen_rtx_AND(DImode,
			       gen_rtx_REG(DImode, $1->rx),
			       GEN_INT(-16));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3864 "x86-64.int.py"
ccr64x  : ASHIFT_DI(LSHIFTRT_DI(r64x, CONST_P8), CONST_P8) [1, 8]
#line 3885 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("andq", -256, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src = gen_rtx_AND(DImode,
			       gen_rtx_REG(DImode, $1->rx),
			       GEN_INT(-256));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3866 "x86-64.int.py"
ccrz32x : ASHIFT_SI(LSHIFTRT_SI(r32x, CONST_P1), CONST_P1) [1, 7]
#line 3885 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("andl", -2, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_AND(SImode,
			       gen_rtx_REG(SImode, $1->rx),
			       GEN_INT(-2));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3867 "x86-64.int.py"
ccrz32x : ASHIFT_SI(LSHIFTRT_SI(r32x, CONST_P2), CONST_P2) [1, 7]
#line 3885 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("andl", -4, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_AND(SImode,
			       gen_rtx_REG(SImode, $1->rx),
			       GEN_INT(-4));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3868 "x86-64.int.py"
ccrz32x : ASHIFT_SI(LSHIFTRT_SI(r32x, CONST_P3), CONST_P3) [1, 7]
#line 3885 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("andl", -8, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_AND(SImode,
			       gen_rtx_REG(SImode, $1->rx),
			       GEN_INT(-8));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3869 "x86-64.int.py"
ccrz32x : ASHIFT_SI(LSHIFTRT_SI(r32x, CONST_P4), CONST_P4) [1, 7]
#line 3885 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("andl", -16, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_AND(SImode,
			       gen_rtx_REG(SImode, $1->rx),
			       GEN_INT(-16));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3870 "x86-64.int.py"
ccrz32x : ASHIFT_SI(LSHIFTRT_SI(r32x, CONST_P8), CONST_P8) [1, 7]
#line 3885 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("andl", -256, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_AND(SImode,
			       gen_rtx_REG(SImode, $1->rx),
			       GEN_INT(-256));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3872 "x86-64.int.py"
ccr16x  : ASHIFT_HI(LSHIFTRT_HI(r16x, CONST_P1), CONST_P1) [1, 8]
#line 3885 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("andw", -2, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_AND(HImode,
			       gen_rtx_REG(HImode, $1->rx),
			       GEN_INT(-2));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3873 "x86-64.int.py"
ccr16x  : ASHIFT_HI(LSHIFTRT_HI(r16x, CONST_P2), CONST_P2) [1, 8]
#line 3885 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("andw", -4, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_AND(HImode,
			       gen_rtx_REG(HImode, $1->rx),
			       GEN_INT(-4));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3874 "x86-64.int.py"
ccr16x  : ASHIFT_HI(LSHIFTRT_HI(r16x, CONST_P3), CONST_P3) [1, 8]
#line 3885 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("andw", -8, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_AND(HImode,
			       gen_rtx_REG(HImode, $1->rx),
			       GEN_INT(-8));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3875 "x86-64.int.py"
ccr16x  : ASHIFT_HI(LSHIFTRT_HI(r16x, CONST_P4), CONST_P4) [1, 8]
#line 3885 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("andw", -16, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_AND(HImode,
			       gen_rtx_REG(HImode, $1->rx),
			       GEN_INT(-16));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3876 "x86-64.int.py"
ccr16x  : ASHIFT_HI(LSHIFTRT_HI(r16x, CONST_P8), CONST_P8) [1, 8]
#line 3885 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("andw", -256, $$->rx, 'w');
  },
  emit {
    rtx dst = gen_rtx_REG(HImode, $$->rx);
    rtx src = gen_rtx_AND(HImode,
			       gen_rtx_REG(HImode, $1->rx),
			       GEN_INT(-256));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3878 "x86-64.int.py"
ccr8x   : ASHIFT_QI(LSHIFTRT_QI(r8x,  CONST_P1), CONST_P1) [1, 7]
#line 3885 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("andb", -2, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $$->rx);
    rtx src = gen_rtx_AND(QImode,
			       gen_rtx_REG(QImode, $1->rx),
			       GEN_INT(-2));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3879 "x86-64.int.py"
ccr8x   : ASHIFT_QI(LSHIFTRT_QI(r8x,  CONST_P2), CONST_P2) [1, 7]
#line 3885 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("andb", -4, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $$->rx);
    rtx src = gen_rtx_AND(QImode,
			       gen_rtx_REG(QImode, $1->rx),
			       GEN_INT(-4));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3880 "x86-64.int.py"
ccr8x   : ASHIFT_QI(LSHIFTRT_QI(r8x,  CONST_P3), CONST_P3) [1, 7]
#line 3885 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("andb", -8, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $$->rx);
    rtx src = gen_rtx_AND(QImode,
			       gen_rtx_REG(QImode, $1->rx),
			       GEN_INT(-8));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3881 "x86-64.int.py"
ccr8x   : ASHIFT_QI(LSHIFTRT_QI(r8x,  CONST_P4), CONST_P4) [1, 7]
#line 3885 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("andb", -16, $$->rx, 'b');
  },
  emit {
    rtx dst = gen_rtx_REG(QImode, $$->rx);
    rtx src = gen_rtx_AND(QImode,
			       gen_rtx_REG(QImode, $1->rx),
			       GEN_INT(-16));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3923 "x86-64.int.py"
r64x : ASHIFT_DI(ZERO_EXTEND_DI(r32x), CONST_P32) [1, 4]
#line 3939 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("shlq", 32, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src = gen_rtx_ASHIFT(DImode,
                             gen_rtx_REG(DImode, $1->rx),
			     GEN_INT(32));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3924 "x86-64.int.py"
r64x : ASHIFT_DI(ZERO_EXTEND_DI(r16x), CONST_P48) [1, 4]
#line 3939 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("shlq", 48, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src = gen_rtx_ASHIFT(DImode,
                             gen_rtx_REG(DImode, $1->rx),
			     GEN_INT(48));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3925 "x86-64.int.py"
r64x : ASHIFT_DI(ZERO_EXTEND_DI(r8x),  CONST_P56) [1, 4]
#line 3939 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("shlq", 56, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src = gen_rtx_ASHIFT(DImode,
                             gen_rtx_REG(DImode, $1->rx),
			     GEN_INT(56));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3926 "x86-64.int.py"
r32x : ASHIFT_SI(ZERO_EXTEND_SI(r16x), CONST_P16) [1, 3]
#line 3939 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("shll", 16, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ASHIFT(SImode,
                             gen_rtx_REG(SImode, $1->rx),
			     GEN_INT(16));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3927 "x86-64.int.py"
r32x : ASHIFT_SI(ZERO_EXTEND_SI(r8x),  CONST_P24) [1, 3]
#line 3939 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("shll", 24, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ASHIFT(SImode,
                             gen_rtx_REG(SImode, $1->rx),
			     GEN_INT(24));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3928 "x86-64.int.py"
r16x : ASHIFT_HI(ZERO_EXTEND_HI(r8x),  CONST_P8) [1, 3]
#line 3939 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("shll", 8, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ASHIFT(SImode,
                             gen_rtx_REG(SImode, $1->rx),
			     GEN_INT(8));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3930 "x86-64.int.py"
r64x : ASHIFT_DI(SIGN_EXTEND_DI(r32x), CONST_P32) [1, 4]
#line 3939 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("shlq", 32, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src = gen_rtx_ASHIFT(DImode,
                             gen_rtx_REG(DImode, $1->rx),
			     GEN_INT(32));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3931 "x86-64.int.py"
r64x : ASHIFT_DI(SIGN_EXTEND_DI(r16x), CONST_P48) [1, 4]
#line 3939 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("shlq", 48, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src = gen_rtx_ASHIFT(DImode,
                             gen_rtx_REG(DImode, $1->rx),
			     GEN_INT(48));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3932 "x86-64.int.py"
r64x : ASHIFT_DI(SIGN_EXTEND_DI(r8x),  CONST_P56) [1, 4]
#line 3939 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("shlq", 56, $$->rx, 'q');
  },
  emit {
    rtx dst = gen_rtx_REG(DImode, $$->rx);
    rtx src = gen_rtx_ASHIFT(DImode,
                             gen_rtx_REG(DImode, $1->rx),
			     GEN_INT(56));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3933 "x86-64.int.py"
r32x : ASHIFT_SI(SIGN_EXTEND_SI(r16x), CONST_P16) [1, 3]
#line 3939 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("shll", 16, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ASHIFT(SImode,
                             gen_rtx_REG(SImode, $1->rx),
			     GEN_INT(16));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3934 "x86-64.int.py"
r32x : ASHIFT_SI(SIGN_EXTEND_SI(r8x),  CONST_P24) [1, 3]
#line 3939 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("shll", 24, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ASHIFT(SImode,
                             gen_rtx_REG(SImode, $1->rx),
			     GEN_INT(24));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3935 "x86-64.int.py"
r16x : ASHIFT_HI(SIGN_EXTEND_HI(r8x),  CONST_P8) [1, 3]
#line 3939 "x86-64.int.py"
  supairs {
    $$->extra = $1->extra;
    $$->freed = $1->freed;
  },
  names {
    $$->rx = $1->rx;
  },
  final {
    $$->rx = $1->rx;
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_set_bit(live, rd);
    add_edges(rd, live);
  },
  costs {
    forgettable($1->rx);
  },
  debug {
    dumpIRn("shll", 8, $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ASHIFT(SImode,
                             gen_rtx_REG(SImode, $1->rx),
			     GEN_INT(8));
    icg_emit_clobber(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3978 "x86-64.int.py"
r64x  : AND_DI(               r64  | CONST_P255) [1, 3]
#line 3998 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  debug {
    dumpRR("movzbl", $1->r, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_REG(QImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3979 "x86-64.int.py"
r64x  : AND_DI(ZERO_EXTEND_DI(r32) | CONST_P255) [1, 3]
#line 3998 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  debug {
    dumpRR("movzbl", $1->r, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_REG(QImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3980 "x86-64.int.py"
r64x  : AND_DI(SIGN_EXTEND_DI(r32) | CONST_P255) [1, 3]
#line 3998 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  debug {
    dumpRR("movzbl", $1->r, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_REG(QImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3981 "x86-64.int.py"
r64x  : AND_DI(ZERO_EXTEND_DI(r16) | CONST_P255) [1, 3]
#line 3998 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  debug {
    dumpRR("movzbl", $1->r, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_REG(QImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3982 "x86-64.int.py"
r64x  : AND_DI(SIGN_EXTEND_DI(r16) | CONST_P255) [1, 3]
#line 3998 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  debug {
    dumpRR("movzbl", $1->r, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_REG(QImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3983 "x86-64.int.py"
r64x  : AND_DI(ZERO_EXTEND_DI(r8)  | CONST_P255) [1, 3]
#line 3998 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  debug {
    dumpRR("movzbl", $1->r, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_REG(QImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3984 "x86-64.int.py"
r64x  : AND_DI(SIGN_EXTEND_DI(r8)  | CONST_P255) [1, 3]
#line 3998 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  debug {
    dumpRR("movzbl", $1->r, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_REG(QImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3986 "x86-64.int.py"
rz32x : AND_SI(               r32  | CONST_P255) [1, 3]
#line 3998 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  debug {
    dumpRR("movzbl", $1->r, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_REG(QImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3987 "x86-64.int.py"
rz32x : AND_SI(ZERO_EXTEND_SI(r16) | CONST_P255) [1, 3]
#line 3998 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  debug {
    dumpRR("movzbl", $1->r, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_REG(QImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3988 "x86-64.int.py"
rz32x : AND_SI(SIGN_EXTEND_SI(r16) | CONST_P255) [1, 3]
#line 3998 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  debug {
    dumpRR("movzbl", $1->r, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_REG(QImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3989 "x86-64.int.py"
rz32x : AND_SI(ZERO_EXTEND_SI(r8)  | CONST_P255) [1, 3]
#line 3998 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  debug {
    dumpRR("movzbl", $1->r, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_REG(QImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3990 "x86-64.int.py"
rz32x : AND_SI(SIGN_EXTEND_SI(r8)  | CONST_P255) [1, 3]
#line 3998 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  debug {
    dumpRR("movzbl", $1->r, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_REG(QImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3992 "x86-64.int.py"
rz16x : AND_HI(               r16  | CONST_P255) [1, 3]
#line 3998 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  debug {
    dumpRR("movzbl", $1->r, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_REG(QImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3993 "x86-64.int.py"
rz16x : AND_HI(ZERO_EXTEND_HI(r8)  | CONST_P255) [1, 3]
#line 3998 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  debug {
    dumpRR("movzbl", $1->r, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_REG(QImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 3994 "x86-64.int.py"
rz16x : AND_HI(SIGN_EXTEND_HI(r8)  | CONST_P255) [1, 3]
#line 3998 "x86-64.int.py"
  supairs {
    if ($$->freed > 0)
      $$->freed--;
    else
      $$->extra++;
  },
  names {
    $$->rx = new_reg();
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  build {
    add_edges(find($$->rx), live);
    sparseset_clear_bit(live, find($$->rx));
    sparseset_set_bit(live, find($1->r));
  },
  costs {
    memorable($1->r);
  },
  debug {
    dumpRR("movzbl", $1->r, 'b', $$->rx, 'l');
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_REG(QImode, $1->r));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 4035 "x86-64.int.py"
r64x  : AND_DI(               MEM_DI(addr)  | CONST_P255) [4, 2]
#line 4055 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movzbl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 4036 "x86-64.int.py"
r64x  : AND_DI(ZERO_EXTEND_DI(MEM_SI(addr)) | CONST_P255) [4, 2]
#line 4055 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movzbl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 4037 "x86-64.int.py"
r64x  : AND_DI(SIGN_EXTEND_DI(MEM_SI(addr)) | CONST_P255) [4, 2]
#line 4055 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movzbl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 4038 "x86-64.int.py"
r64x  : AND_DI(ZERO_EXTEND_DI(MEM_HI(addr)) | CONST_P255) [4, 2]
#line 4055 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movzbl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 4039 "x86-64.int.py"
r64x  : AND_DI(SIGN_EXTEND_DI(MEM_HI(addr)) | CONST_P255) [4, 2]
#line 4055 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movzbl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 4040 "x86-64.int.py"
r64x  : AND_DI(ZERO_EXTEND_DI(MEM_QI(addr)) | CONST_P255) [4, 2]
#line 4055 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movzbl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 4041 "x86-64.int.py"
r64x  : AND_DI(SIGN_EXTEND_DI(MEM_QI(addr)) | CONST_P255) [4, 2]
#line 4055 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movzbl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 4043 "x86-64.int.py"
rz32x : AND_SI(               MEM_SI(addr)  | CONST_P255) [4, 2]
#line 4055 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movzbl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 4044 "x86-64.int.py"
rz32x : AND_SI(ZERO_EXTEND_DI(MEM_HI(addr)) | CONST_P255) [4, 2]
#line 4055 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movzbl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 4045 "x86-64.int.py"
rz32x : AND_SI(SIGN_EXTEND_DI(MEM_HI(addr)) | CONST_P255) [4, 2]
#line 4055 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movzbl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 4046 "x86-64.int.py"
rz32x : AND_SI(ZERO_EXTEND_DI(MEM_QI(addr)) | CONST_P255) [4, 2]
#line 4055 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movzbl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 4047 "x86-64.int.py"
rz32x : AND_SI(SIGN_EXTEND_DI(MEM_QI(addr)) | CONST_P255) [4, 2]
#line 4055 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movzbl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 4049 "x86-64.int.py"
rz16x : AND_HI(               MEM_HI(addr)  | CONST_P255) [4, 2]
#line 4055 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movzbl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 4050 "x86-64.int.py"
rz16x : AND_HI(ZERO_EXTEND_DI(MEM_QI(addr)) | CONST_P255) [4, 2]
#line 4055 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movzbl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
#line 4051 "x86-64.int.py"
rz16x : AND_HI(SIGN_EXTEND_DI(MEM_QI(addr)) | CONST_P255) [4, 2]
#line 4055 "x86-64.int.py"
  names {
    $$->rx = new_reg();
  },
  kinds {
    icg_reg_vector[$$->rx].kind = INT_REGISTER;
  },
  supairs {
    if ($1->freed > 0) {
      $$->extra = $1->extra;
      $$->freed = $1->freed - 1;
    }
    else {
      $$->extra = $1->extra + 1;
      $$->freed = 0;
    }
  },
  build {
    unsigned rd = find($$->rx);
    sparseset_clear_bit(live, rd);
    add_edges(rd, live);
    add_addr(live, $1);
  },
  remat {
    flags = 0;
  },
  debug {
    dumpMR("movzbl", $1, $$->rx, 'l');
  },
  final {
    $$->rx = icg_reg_vector[find($$->rx)].color;
  },
  emit {
    rtx dst = gen_rtx_REG(SImode, $$->rx);
    rtx src = gen_rtx_ZERO_EXTEND(SImode, gen_rtx_MEM(QImode, $1->rtl));
    icg_emit_plain(gen_rtx_SET(VOIDmode, dst, src));
  };
