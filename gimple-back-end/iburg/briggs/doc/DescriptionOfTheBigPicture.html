<h1><a name="The_Big_Picture_Described"> </a> The Big Picture Described </h1>
<p>
   <img src="icg.jpg" alt="icg.jpg" height="538" width="840">
</p><p>
The input is <em>loose</em> RTL from gcc, siphoned off just before gcc's register allocator.
The output is <em>strict</em> RTL, fed back into gcc just after gcc's reload phase.
</p><p>
Everything in black is intended to be machine independent (someday).
Thus, the only machine-dependent portion is the grammar specification.
The proportions of things in the picture are misleading though, 
since the grammar specification is quite large.
</p><p>
</p><h2><a name="Build_Time"> </a> Build Time </h2>
<p>
The dashed lines are intended to indicate processing that happens when the compiler is being built.
</p><ul>
<li> The grammar specification is machine dependent. It specifies how
different combinations of RTL are to be handled by the many parts of
the code generator.
</li>
<li> There's a preprocessor for plug, written by Robert Henry in
Python. It supports named attributes, does some checking, and enables a
lot more compression of the spec.
</li>
<li> <a href="BurgProcessor.html" target="_top">Plug</a> is mostly a preprocessor for <a href="http://wiki.corp.google.com/twiki/pub/Main/NewCodeGenForGCC/iburg.pdf" target="_top">iburg</a>.
In addition, plug splits of pieces of the grammar specification,
feeding them into include files to be included as part of the source
for the various phases of the code generator. In all cases, the
generated include files are simply long sequences of case arms, where
the case selection is controlled by a tree walk of the IL and the state
generated by iburg.
</li>
<li> <a href="http://wiki.corp.google.com/twiki/pub/Main/NewCodeGenForGCC/iburg.pdf" target="_top">iburg</a> is a tool written by Dave Hanson, a fellow Googler, back when he was just a kid.  
</li>
</ul>
<p>
</p><h2><a name="Compile_Time"> </a> Compile Time </h2>
<p>
Solid lines indicate phases that run during compile time.
There are three preliminary phases:
</p><ul>
<li> <em>foward prop</em> does a form of forward propagation within
basic blocks to build large expression trees. The RTL coming into the
allocator is made up of many, very small expression trees, basically
one tree per instruction. We prefer maximal trees, to give iburg and
the SU-numbering as much scope as possible. Trees that define a single
register with a single use are combine with the tree that uses the
register. Note that we run <em>forward prop</em> twice, because <em>find updates</em> can expose new opportunities.
</li>
<li> <em>side tree</em> constructs an icg-private version of each rtl
expression using our own data structures. We chose to do this for our
prototype, to allow us to easily add and delete fields without
affecting the rest of gcc's passes.
</li>
<li> <em>SSA</em> finds the live ranges by converting to SSA form, then unioning together all the names that reach phi nodes.
</li>
<li> <em>find updates</em> studies expression trees, looking for
opportunities to rewrite them with explicit update operation
(add-to-memory, etc). Note that we run this phase in two places:
initially and just after adding spill code.
</li>
</ul>
<p>The bulk of the code generator is in the form of a large loop that
repeatedly does instruction selection and attempts register allocation
until no additional spill code is required. Many of these phases work
over expression trees. Initially all expression trees are examined. As
spill code is added, the modified trees are marked <em>dirty</em>
and later passes will only examine the dirty trees. Generally, the
phases dealing with register allocation are global and must examine all
expression trees, dirty or not.
</p><ul>
<li> <em>reassoc</em> examines each dirty expression tree, computing <a href="ExtendedSUNumbering.html" target="_top">SU pairs</a> and reassociating to minimize register usage. This won't do a perfect job because we haven't yet done instruction selection.
</li>
<li> <em>select</em> does the labeling phase of iburg, walking over
dirty expression trees and computing the best cover. The result for
each subtree is stored in the <em>state_label</em> field. The value here is not examined directly; instead, it's referred to by iburg code when doing the various reduce passes.
</li>
<li> <em>names</em> walks over all expression trees, propagating
register names up from the leaves to interior nodes, adding new
register names when required. Also propagates the various parts of
addressing modes (base, index, displacement).
</li>
<li> <em>Sethi Ullman</em> examines each dirty expression tree, computing <a href="ExtendedSUNumbering.html" target="_top">SU pairs</a>
and choosing a preferred order of evaluation. This time, we've
completed instruction selection, so the SU pairs are accurate, though
we're not able to reassociate.
</li>
<li> <em>bit matrix</em> walks over all the expression trees, building
the bit matrix representation of the interference graph and computing
the degree of each live range.
</li>
<li> <em>build AVs</em> uses the computed degree and allocates
adjacency vectors for each live range, then walks over all the
expression trees, filling in the adjacency vectors.
</li>
<li> <em>coalesce</em> attempts to coalesce live ranges connected by a
copy. If any live ranges are coalesced, we need to recompute the
adjacency vectors. Additional coalescing opportunities may be exposed
whenever a coalesce is performed, so we iterate until no more changes
are found.
</li>
<li> <em>spill costs</em> walks over all expression trees, computing
spill costs for all the live ranges. Note that we divide the set of
live ranges into three parts: the machine registers, the SSA names, and
the interior live ranges. Each interior live range appears inside a
single expression tree and may not be spilled (has an infinite spill
cost).
</li>
<li> <em>color</em> tries to color the live ranges following the scheme
in Preston's thesis. If some live ranges can't be colored, then we'll
need to introduce spill code.
</li>
<li> <em>spill code</em> does a pretty simplistic job of introducing
spill code. If a spilled live range is referenced by an expression
tree, the tree is rewritten to reference memory and is marked as dirty.
Similarly, if the tree defines a spilled live range, the tree is
rewritten to store to memory and the tree is marked as dirty.
</li>
</ul>
<p>
There are a couple of final phases:
</p><ul>
<li> <em>final</em> (not shown, but runs right before emit). Propagates
the final register names/colors up the expression trees. Should perhaps
be replaced by a lookup during <em>emit</em>.
</li>
<li> <em>emit</em> makes calls into existing gcc infrastructure to
generate rtl for the new instructions and registers chosen during icg's
code generation. This was very tedious to write and is probably quite
brittle.
</li>
</ul>
<p>
There's another phase, <em>debug</em>, that dumps an assembly language version of the routine to dump_file. It can be run anytime after <em>names</em>.
