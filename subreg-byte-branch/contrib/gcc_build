#! /bin/sh

########################################################################
#
# File:   gcc_build
# Author: Mark Mitchell
# Date:   07/10/2000
#
# Contents:
#   Script to automatically download and build GCC.
#
# Copyright (c) 2000 Free Software Foundation.
#
# This file is part of GNU CC.
#
# GNU CC is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# GNU CC is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GNU CC; see the file COPYING.  If not, write to
# the Free Software Foundation, 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.
#
########################################################################

########################################################################
# Notes
########################################################################

# If you are using password-based CVS, you must manually log in, and
# not log out from, the CVS server before running this script.

########################################################################
# Functions
########################################################################

# Issue the error message given by $1 and exit with a non-zero
# exit code.

error() {
    echo "gcc_build: error: $1"
    exit 1
}

# Issue a usage message explaining how to use this script.

usage() {
cat <<EOF
gcc_build        [-c configure_options] 
		 [-d destination_directory]
		 [-m make_options]
		 [-u username]
		 [-p protocol]
		 [-t tarfile]
		 [build]
		 [checkout]
		 [export]
		 [install]
		 [test]
		 [update]
EOF
    exit 1
}

# Change to the directory given by $1.

changedir() {
    cd $1 || \
	error "Could not change directory to $1"
}

# Set up CVS environment variables

cvs_setup() {
    CVSROOT=":${CVS_PROTOCOL}:${CVS_USERNAME}@"
    CVSROOT="${CVSROOT}${CVS_SERVER}:${CVS_REPOSITORY}"
    export CVSROOT
}

# Checkout a fresh copy of the GCC build tree.

checkout_gcc() {
    # Tell CVS where to find everything.
    cvs_setup

    # If the destination already exists, don't risk destroying it.
    test -e ${DESTINATION} && \
	error "${DESTINATION} already exists"

    # CVS doesn't allow an absolute path for the destination directory.
    DESTINATION_PARENT=`dirname ${DESTINATION}`
    test -d ${DESTINATION_PARENT} || \
	error "${DESTINATION_PARENT} is not a directory"
    changedir ${DESTINATION_PARENT}

    # Checkout the tree
    cvs -z 9 co -d `basename ${DESTINATION}` gcc || \
	error "Could not check out GCC"
}

# Update GCC.

update_gcc() {
    # Tell CVS where to find everything
    cvs_setup

    # If the destination does not already exist, complain.
    test -d ${DESTINATION} || \
	error "{$DESTINATION} does not exist"
    # Enter the destination directory.
    changedir ${DESTINATION}

    # Update the tree
    ./contrib/gcc_update || \
	error "Could not update GCC"
}

# Build GCC.

build_gcc() {
    # Go to the source directory.
    changedir ${DESTINATION}

    # Remove the object directory.
    rm -rf ${OBJDIR}
    # Create it again.
    mkdir ${OBJDIR} || \
	error "Could not create ${OBJDIR}"
    # Enter it.
    changedir ${OBJDIR}

    # Configure the tree.
    (eval ${DESTINATION}/configure ${CONFIGURE_OPTIONS} | 
        tee -a ${LOGFILE}) 2>&1 || \
	error "Could not configure the compiler"

    # Bootstrap the compiler
    (eval make ${MAKE_OPTIONS} bootstrap |
	tee -a ${LOGFILE}) 2>&1 || \
	error "Could not build the compiler"
}

# Test GCC.

test_gcc() {
    # Go to the source directory.
    changedir ${DESTINATION}
    # Go to the object directory.
    changedir ${OBJDIR}

    echo "Running tests...  This will take a while."
    (make -k check | tee -a ${LOGFILE}) 2>&1
    (${DESTINATION}/contrib/test_summary | tee -a ${LOGFILE})
}

# Export the GCC source tree.

export_gcc() {
    # Go to the source directory.
    changedir ${DESTINATION}
    # Go up one level.
    changedir ..
    # Build a tarbal off the source directory.
    tar czf ${TARFILE} \
	--exclude=${OBJDIR} \
	--exclude=CVS \
	--exclude='.#*' \
	--exclude='*~' \
	`basename ${DESTINATION}`
}

# Install GCC.

install_gcc() {
    # Go to the source directory.
    changedir ${DESTINATION}
    # Go to the object directory.
    changedir ${OBJDIR}

    make install > ${LOGFILE} 2>&1 || \
	error "Installation failed"
}

########################################################################
# Initialization
########################################################################

# The CVS server containing the GCC repository.
CVS_SERVER="gcc.gnu.org"
# The path to the repository on that server.
CVS_REPOSITORY="/cvs/gcc"
# The CVS protocol to use.
CVS_PROTOCOL="pserver"
# The username to use when connecting to the server.
CVS_USERNAME="anoncvs"

# The directory where the checked out GCC will be placed.
DESTINATION="${HOME}/dev/gcc"
# The relative path from the top of the source tree to the 
# object directory.
OBJDIR="objdir"

# The file where information will be logged.
LOGFILE=${HOME}/build-gcc.$$.log
# The file where the tarred up sources will be placed.
TARFILE="${HOME}/dev/gcc.tgz"

# Options to pass to configure.
CONFIGURE_OPTIONS=
# Options to pass to make.
MAKE_OPTIONS=

# Modes of operation
BUILD=0
CHECKOUT=0
EXPORT=0
INSTALL=0
TEST=0
UPDATE=0

########################################################################
# Main Program
########################################################################

# Parse the options.
while getopts "c:d:m:t:" ARG; do
    case $ARG in
    c)    CONFIGURE_OPTIONS="${OPTARG}";;
    d)    DESTINATION="${OPTARG}";;
    m)    MAKE_OPTIONS="${OPTARG}";;
    u)    CVS_USERNAME="${OPTARG}";;
    p)    CVS_PROTOCOL="${OPTARG}";;
    t)    CVS_TARGFILE="${OPTARG}";;
    \?)   usage;;
    esac
done
shift `expr ${OPTIND} - 1`

# Handle the major modes.
while [ $# -ne 0 ]; do
    case $1 in
    build)    BUILD=1;;
    checkout) CHECKOUT=1;;
    export)   EXPORT=1;;
    install)  INSTALL=1;;
    test)     TEST=1;;
    update)   UPDATE=1;;
    *)        usage;;
    esac
    shift
done

# Check the arguments for sanity.
if [ ${CHECKOUT} -ne 0 ] && [ ${UPDATE} -ne 0 ]; then
    error "Cannot checkout and update simultaneously"
fi

# Remove any old logfiles.
rm -f ${LOGFILE}
# Tell the user where to find the logfile.
echo "gcc_build: The logfile for this run is ${LOGFILE}"

# Checkout the tree.
if [ ${CHECKOUT} -ne 0 ]; then
    checkout_gcc
elif [ ${UPDATE} -ne 0 ]; then
    update_gcc
fi

# Build the compiler.
if [ ${BUILD} -ne 0 ]; then
    build_gcc
fi

# Test the compiler
if [ ${TEST} -ne 0 ]; then
    test_gcc
fi

# Install the compiler.
if [ ${INSTALL} -ne 0 ]; then
    install_gcc
fi

# Export the sources
if [ ${EXPORT} -ne 0 ]; then
    export_gcc
fi
