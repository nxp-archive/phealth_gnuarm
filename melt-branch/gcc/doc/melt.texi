@c Copyright (c) 2008 Free Software Foundation, Inc.
@c Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@c ---------------------------------------------------------------------
@c  MELT
@c ---------------------------------------------------------------------

@node MELT
@chapter MELT: Middle End Lisp Translator
@cindex MELT
@cindex Middle End Lisp Translator


The MELT branch introduces a Lisp dialect to express middle-end analysers. 
This chapter describes the dialect and how to use it.
A working knowledge of Scheme or Lisp is presupposed.

MELT was formerly known as Basilys, hence many functions or variables
have basilys in their name, and the conventional file extensions for
MELT source files is @code{.bysl}

See the @uref{http://gcc.gnu.org/wiki/MiddleEndLispTranslator,,MELT wiki page}

@menu
* MELT Prerequisites and Deficiencies::       Prerequisites and topics not yet covered in this MELT chapter.
* MELT overview::                             An overview of MELT.
* Building the MELT branch::                  configuration and building requirements and instructions for MELT.
* Invoking MELT::                             Invoking MELT.
* Tutorial about MELT::                       Tutorial describing MELT.
* Reference on MELT::                         MELT language reference.
@end menu

@c ----------------------------------------------------------------
@c MELT Prerequisites and Deficiencies
@c ----------------------------------------------------------------

@node MELT Prerequisites and Deficiencies
@section MELT Prerequisites and Deficiencies

A working knowledge of Scheme or Lisp is presupposed.

This chapter is incomplete.

@c ----------------------------------------------------------------
@c MELT Overview
@c ----------------------------------------------------------------

@node MELT overview
@section MELT overview
@cindex MELT overview

Any MELT enabling compilation is really a long lasting compilation. It
is supposed that you use a powerful workstation (or laptop) with
enough memory (at least 4Gigabytes of RAM is receommended on a 64 bits
machine like x86-64), and that the MELT-enabled compilation will run a
lot slower than a simple @code{gcc -O1} compilation (hopefully doing
some useful stuff). Notice that a MELT compilation actually generates
C code, compile it (using another GCC compilation process) to a
dynamically loadable library, and load its into the MELT compilation
process.

@c some sentences copied from the Wiki page. I (Basile) wrote all of them.

The MELT branch contains several (related) stuff. Everything can be
enabled or disabled at GCC configure time or at GCC run time:

@enumerate

@item a compiler probe, which enable an advanced user to display some of
the compilers internals data (but not to change them or change the
GCC compiler's behavior.

@item a Lisp dialect compiled into C code, with which one can code
sophisticated or prototypical middle end passes.

@item a runtime which extends the GCC infrastructure to support the
previous items, in particular a generational copying garbage
collector well suited for the lisp dialect above, which is build
above the existing GGC (which deals with old values).

@end enumerate

MELT is bootstrapped, in the sense that the translation from the MELT
dialect to C is coded in MELT (hence the MELT generated C code is
available from the source code).

The generated C code is including only one file @code{run-basilys.h}
which includes many GCC include files internal to the compiler. It is
compiled into a dynamic library by a shell script
@code{*melt-cc-script*} which invokes the host GCC with appropriate
flags.

MELT obviously need that the binary (dynamic libraries @code{warm*.so})
for the MELT translator are already available. More generally, it uses
several kind of files:

@enumerate

@item the script used to compile generated C files info dynamically loadable stuff.
This script may be invoked by MELT GCC. In common cases, the first
argument to the script is the MELT generated input @code{*.c} file and
the second argument is the MELT loaded output @code{*.so} dynamic
library.

@item an include directory (passed by @code{-I} to the compiler) 
containing all the useful GCC headers. This directory is only written by
the installation procedure.

@item a permanent generated C code directory which contains some essential files, in particular the C form of the MELT translated.
 
@end enumerate


@c =======================================================================
@node Building the MELT branch
@section Building the MELT branch
@cindex Building the MELT branch

The MELT branch has to be configured appropriately to enable MELT. If
MELT is disabled at configure time, the MELT branch is essentially the
GCC trunk. Enabling MELT means passing the @code{-with-ppl --with-ltdl
--enable-compiler-probe --enable-basilysmelt} flags to the toplevel
@code{configure}.

Actually, there are two different features enabled: the compiler probe
and MELT. In practice, you'll need both.

To compile the MELT branch, you need the libtool dynamic loader and
the Parma Polyhedra Library. The libtool dynamic loader wraps the
dynamic library loading functions like @code{dlopen} or @code{dlsym};
it is part of @uref{http://www.gnu.org/software/libtool,,libtool}
(version 2.x). The Parma Polyhedra Library (PPL) is a free library
available @uref{http://www.cs.unipr.it/ppl/,,here}, it is a C++
library (GPLv3 licensed) handling lattices like intervals etc. Also,
the host compiler (the compiler which compiles the source code of
GCC), also used to compile MELT generated C code during MELT enabled
@code{gcc} execution, should be some version of @code{gcc} (preferably
a 4.x version at least).

Note that currently MELT is only compiled on Linux machines.

@c =======================================================================
@node Invoking MELT
@section Invoking MELT
@cindex Invoking MELT

Without any MELT specific program flags, the MELT variant of gcc
behave as the trunk. So to get or use MELT features, you need to pass
some special flags. Most of these flags are starting with
@code{-fbasilys}. They for the middle-end of GCC so are common for
every source language (ie @code{gcc}, @code{g++} ... commands) and
target.

MELT is usually invoked while compiling a (C, C++, ...) source file
but may occasionnally be invoked without compiling any source input to
perform tasks which are not related to a particular GCC input source
file. In particular, the translation of a MELT file @code{foo.bysl}
into C code @code{foo.c} is done with a special invocation like
@code{gcc -fbasilys=compilefile
-fbasilys-arg=foo.bysl -fbasilys-secondarg=foo.c} (possibly with other
options like some appropriate @code{-fbasilys-init=}). In other words,
the MELT translator to C @emph{is not} a gcc front-end.

The table below lists all MELT specific options, in alphabetical order.

@table @gcctabopt
@item -fbasilys=
@gccoptlist{-fbasilys=}
@opindex fbasilys
This flag (without argument) is required for every MELT enabled
compilation. If it is not given, no MELT specific processing is done.
If given, this gives the command to be executed before any MELT
passes. It uses the @code{:sysdata_cmd_fundict} field of
@code{INITIAL_SYSTEM_DATA} internal object of MELT to determine the
MELT function applied to execute the command. If this application
returns nil, no GCC compilation occur (i.e. no @code{*.c} or
@code{*.cc} etc... source file is read). Hence, some commands may be
used for their side-effects. In particular, the compilation of MELT
lisp source file @code{*.bysl} into C code @code{*.c} is done this
way.

@item -fbasilys-arg=
@gccoptlist{-fbasilys-arg=}
@opindex fbasilys-arg=
This gives the first argument string to MELT. It is incompatible with
the @code{-fbasilys-arglist=} option.

@item -fbasilys-arglist=
@gccoptlist{-fbasilys-arglist=}
@opindex fbasilys-arglist=
This gives the first argument list of strings to MELT. It is
incompatible with the @code{-fbasilys-arg=} option. The string program
argument is split into a list of strings using the comma
separator. For example, @code{-fbasilys-arglist=1,BB,3} makes a
three-element list argument with first string @code{1}, second string
@code{BB} and third string @code{3}. There is no way to give a
string subargument containing a comma.


@item -fbasilys-compile-script=
@gccoptlist{-fbasilys-compile-script=}
@opindex fbasilys-compile-script=
This sets the compile script (default is @code{melt-compile-script}
somewhere inside GCC files) used to compile MELT generated C code into
dynamically loaded stuff. The script is usually invoked by GCC with
two arguments: the C file generated by MELT and the dynamic library
(e.g. a @code{*.so} or @code{*.la}) to be generated by the
script. Notice that MELT generates huge C files (containing, in
addition of a routine for each MELT function, a very big
initialization routine), so it is recommended to avoid compiling these
generated files with @code{-O3}.

@item -fbasilys-debug
@gccoptlist{-fbasilys-debug}
@opindex fbasilys-debug
This flag has no argument and asks for lot of debugging output. It is
only useful to debug MELT and is unrelated to the @code{-g} flag
asking GCC to output debug information.

@item -fbasilys-debugskip=
@gccoptlist{-fbasilys-debugskip=}
@opindex fbasilys-debugskip=
This flag (only useful with @code{-fbasilys-debug}) has an integer
argument. When @code{-fbasilys-debug} is given with
@code{-fbasilys-debugskip=1000} the first thousand debug messages are
skipped, so are not printed.

@item -fbasilys-gensrcdir=
@gccoptlist{-fbasilys-gensrcdir=}
@opindex fbasilys-gensrcdir=
This flag sets the directory containing MELT generated C files.

@item -fbasilys-gdbmstate=
@gccoptlist{-fbasilys-gdbmstate=}
@opindex fbasilys-gdbmstate=
This flag sets the GDBM indexed file containing global state. It
should always be specified when needed, because there is no default.

@item -fbasilys-init=
@gccoptlist{-fbasilys-init=}
@opindex fbasilys-init=
This flag sets the initial MELT modules. They are separated by
semi-colons or (on Unix only) colons. So @code{-fbasilys-init=foo:bar}
or @code{'-fbasilys-init=foo;bar'} (quotes are useful for the shell
running GCC) load first the @code{foo} module and then the @code{bar}
module. A module starting with an at sign @code{@@} is handled as a
module list file. The @code{.modlis} extension is added, and then a
file is seeked by that name. This file is read line by line (with
empty or blank lines skipped, and comment lines starting with an hash
@code{#} skipped). Each line is the name of a module do be load in
sequence. For example, @code{-fbasilys-init=@@mylist:bar} with a file
@file{mylist.modlis} containing
@example
# file mylist.modlis ; just a comment
alpha
beta
@end example
would have the same effect as @code{-fbasilys-init=alpha:beta:bar}. 
Notice that modules are seeked in several directories.

@item -fbasilys-tempdir=
@gccoptlist{-fbasilys-tempdir=}
@opindex fbasilys-tempdir=
@end table
This flags sets the temporary MELT directory. If specified it is not
cleaned. If it does not exist, it is mkdir-ed and cleaned. Avoid
setting it to a non-empty directory.




@c =======================================================================
@node Tutorial about MELT
@section Tutorial about MELT
@cindex Tutorial about MELT

This section has to be written.

As in all Lisps, parenthesis are important, so @code{a} and @code{(a)}
do not mean the same thing. The first stuff after an opening
parenthesis has usually an operator or syntactic keyword role.

MELT is a Lisp dialect translated into (unreadable, or at least
unfriendly) C code. Some MELT constructs are related to this C
translatability.


@menu
* Reserved MELT syntax and symbols::
* Primitives in MELT::
@end menu

@node Reserved MELT syntax and symbols
@subsection Reserved MELT syntax and symbols

The following symbols have specific MELT meaning. Use them only as
described here and avoid redefining them.
@code{and assert_msg comment compile_warning cond cppif
current_module_environment_container debug_msg defciterator defclass
definstance defprimitive defselector defun exit export_class
export_macro export_values fetch_predefined forever if lambda let
make_instance match multicall or parent_module_environment progn quote
redefinition_handling return setq store_predefined unsafe_get_field
unsafe_put_fields update_current_module_environment_container}

Also avoid symbols starting with @code{def}.

@node Primitives in MELT
@subsection Primitives in MELT

To be written.

@c =======================================================================

@node Reference on MELT
@section Reference on MELT
@cindex Reference on MELT

@menu
* Lexical MELT conventions::
* Main MELT syntax::
@end menu

@node Lexical MELT conventions
@subsection Lexical MELT conventions

It is recommended to edit MELT files with a Lisp-aware editor
(e.g. the GNU emacs Lisp mode).

As in Lisp dialects:

@itemize @bullet

@item parenthesis 
are essential and should be matched. It is an error to add extra right
parenthesis.

@item brackets 
are like parenthesis but should be matched (but you probably don't
want to use them). @code{[a b]} is the same as @code{(a b)} but botn
@code{[a b)} and @code{(a b]} are incorrect.

@item comments 
start with a semicolon (@code{;}) to the end of the line. This is the
prefered way to put comments in MELT file.

@item block comments 
start with hash-bar (@code{#|}), may take several lines, and end with
bar-hash (@code{|#}). Don't nest block comments.

@item space 
characters are token sepators, but indentation does not matter (we
strongly recommend the MELT code to be properly indented, e.g. using
Emacs Lisp mode, for readability purposes).

@item case 
is insensitive; words, i.e. identifiers and keywords are all converted
to uppercases.

@item strings 
are denoted like in C between double quotes, with backslashes escaping
(eg double-backslash @code{\\} to represent a single backslash,
backslash doublequote @code{\"} to represent a doublequote, backslash t
@code{\t} for a tab, , and @code{\xfe} to represent the character
coded 0xfe in hex, etc. In addition, a backslash-leftbrace @code{ \@{
} read verbatim all characters up to the first rightbrace @code{ @}
}. A string with the last doublequote followed by an underscore like
@code{"do that"_} is localized using the @code{gettext} host system
function; this could be useful for some user messages (to be
translated to other languages like french).

@item symbols
 (i.e. identifiers) are case insensitive and may contain non
alphanumerical characters like @code{_+-*/<>=!?:%~&@@$}. It is advised
to use these special characters sparingly. Symbols cannot start with
any of @code{?%}. Because symbols are related to their C translation,
is advised to avoid digits after underscores in symbols like
@code{x_12} and to have each symbol contain at least one letter
(e.g. use @code{<i} instead of @code{<}).

@item the quote character 
@code{'} is special. @code{'x} is parsed the same as @code{(quote x)}.

@item the backquote character 
@code{`} is special. @code{`x} means the same as @code{(backquote x)}

@item the comma character 
@code{,} is special. So @code{,x} means @code{(comma x)} and @code{,(a
b)} is @code{(comma (a b))}

@item the question mark chararacter 
@code{?} is special when is is the first of a token (it may appear
inside a symbol otherwise). For instance, @code{?x} means
@code{(question x)} but @code{x?} is a symbol of two characters. So
@code{?y?} is bad taste but means @code{(question y?)}

@item the hash character 
@code{#} is special. In particular, @code{#|} starts multiline
comments; @code{#\space} is the integer code of the space character;
@code{#b10} is a binary number (i.e. two), @code{#o12} is octal (ie
ten), @code{#xffff} is hexadecimal number (ie 65535).

@item braces 
@code{@{} and @code{@}} are special.


@item numbers
are integers in decimal like @code{-123} or @code{+22} or
@code{33}. Notice that @code{1.2} is illegal; it is not a floating
point number.

@item colons 
(i.e. @code{:}) starts constant (lisp-like) keywords which always evaluate to themselves.

@end itemize

Contrarily to some or most other Lisp dialects:

@itemize @minus

@item don't use the dot 
for cons-ing, e.g. @code{(a b . c)} is not legal.

@item strings 
may contain escaped braces with special verbatim-like meaning.

@item a string 
whose ending doublequote is immediately followed by an underscore
(e.g. @code{"example of international"_}) is localized by calling
@code{gettext} at read time.

@end itemize


@c =======================================================================

@node Main MELT syntax
@subsection Main MELT syntax.

We list each key symbol in alphabetical order and provide a short
derscription. Familiarity with some Lisp or Scheme dialect is
required.

@menu
* MELT formal arguments::
* MELT syntax constructs::
@end menu

@node MELT formal arguments
@subsubsection MELT formal arguments

A formal argument list is a possibly empty list (between
parenthesis). This list contains either ctype keywords or formal
names. A ctype keyword apply to all further formals (until another
ctype keyword, or end of formal arguments list. Ctypes have a keyword
and are each described by a predefined instance (of
@code{CLASS_CTYPE}) with a name conventionnally starting with
@code{ctype_}.
@cindex ctype MELT keyword
[Expert: to add a new ctype, define a predefined in
@file{gcc/basilys.h} and an instance in @file{warmelt-first.bysl}
using @code{install_ctype_descr}, then regenerate all the
@file{gcc/warmelt-*.c} files]

Here are the list of ctype-s.
@itemize
@item @code{:value} (ctype instance @code{ctype_value})
This ctype is for MELT [boxed] values. It is the default ctype of arguments.

@item @code{:long} (ctype instance @code{ctype_long})
This ctype is for unboxed long integers; it is also used for conditions and tests.

@item @code{:tree} (ctype instance @code{ctype_tree})
This ctype is for GCC @code{tree} raw pointers, as in @file{gcc/tree.h}.

@item @code{:gimple} (ctype instance @code{ctype_gimple})
This ctype is for GCC @code{gimple} raw tuple pointers, as in @file{gcc/gimple.h}.

@item @code{:gimpleseq}  (ctype instance @code{ctype_gimple})
This ctype is for GCC @code{gimple_seq} raw pointers, representing
sequences of gimple instructions, as in @file{gcc/gimple.h}

@item @code{:basicblock}  (ctype instance @code{ctype_basicblock})
This ctype is for GCC @code{basic_block} raw pointers, representing
basic blocks, as in @file{gcc/basic-block.h}

@item @code{:edge}  (ctype instance @code{ctype_edge})
This ctype is for GCC @code{edge} raw pointers, representing edges of
the control flow graph, as in @file{gcc/basic-block.h}

@item @code{:void}  (ctype instance @code{ctype_void})
This ctype is the same as C @code{void} type. It should not be the
type of formal arguments, but of results (e.g. primitive results).

@item @code{:cstring} (ctype instance @code{ctype_cstring})
This ctpe is only for constant strings (like @code{const char[]} in C).

@end itemize

MELT formal arguments appear in @code{lambda defun defprimitive
defciterator multicall} forms. The first argument of (@code{defun
lambda multicall}) should -if given- be a @code{:value}. Ctype-s also
appear in @code{let} bindings.


@node MELT syntax constructs
@subsubsection MELT syntax constructs

The table below gives MELT syntax constructs.

@table @code

@item and
@cindex @code{and} MELT syntax
@code{(and @var{e1} @var{e2} @var{e3})} is (like in all Lisps) used
for sequential conjunction; it is the same as @code{(if @var{e1} (if
@var{e2} @var{e3}))}.

@item assert_msg
@cindex @code{assert_msg} MELT syntax
@cindex @code{assert_failed} MELT primitive
@code{(assert_msg @var{msg} @var{check})} aborts when @var{check} is
false (using the @code{assert_failed} primitive, giving the source file
position) and displays the given @var{msg}, when GCC is built for
debugging with @code{ENABLE_CHECK}. If GCC is not built for debugging,
neither operand is used. The entire @code{assert_msg} expression
evaluates to nil.

@item comment
@cindex @code{comment} MELT syntax
@code{(comment @var{msg})} evaluates to nil and output the @var{msg}
as a C comment in the C translation. Don't use @code{*/} or @code{*/}
in @var{msg}. When a @code{comment} appears at the beginning of a MELT
compilation unit, it appears at the beginning of the generated C file;
this is useful for making copyright notices appear both in the MELT
source file and the generated C code.

@item compile_warning
@cindex @code{compile_warning} MELT syntax
@code{(compile_warning @var{msg} @var{exp})} evaluates like @var{exp} but also
emits a message at MELT compilation time. Intended use is similar to
@code{#warning} in C.

@item cond
@cindex @code{cond} MELT syntax
@code{(cond @var{condition1} @var{condition2} @var{...})} is -like in
all Lisps- a conditional evaluation. Each condition is
@code{(@var{test} @var{then1} @var{then2} @var{...} @var{thenk})} so
the @var{test} is evaluated. If it is true, all the @var{then}s are
evaluated in sequence, and the last is the result of the whole
@code{cond} expression. The last condition can be @code{(:else
@var{else1} @var{...} @var{elsek})}; if no previous test succeeded,
all the @var{else}s are sequentially evaluated, and the last of them
is the whole @code{cond} result. Notice that @code{(cond (@var{test1}
@var{then1}) (@var{test2} @var{then2a} @var{then2b}) (:else
@var{else1} @var{else2} @var{else3}))} is the same as @code{(if
@var{test1} @var{then1} (if @var{test2} (progn @var{then2a}
@var{then2b}) (progn @var{else1} @var{else2})))}.

@item cppif
@cindex @code{cppif} MELT syntax
[for experts] @code{(cppif @var{name} @var{then-cpp} @var{else-cpp})} is translated
using a C directive @code{#if @var{name}} to the translation of
@var{then-cpp} or @var{else-cpp}.

@item current_module_environment_container
@cindex @code{current_module_environment_container} MELT syntax
[for experts] @code{(current_module_environment_container)} evaluates
to an object of @code{CLASS_CONTAINER} containing the current module
environment.

@item debug_msg
@cindex @code{debug_msg} MELT syntax
@code{(debug_msg @var{expv} @var{msg} @var{[count]})} -where the
@var{[count]} expression is usually ommitted- is useful for debugging
ouput of the value of @var{expv} (with the @code{-fbasilys-debug}
program option) to output, using the @code{debug_msg_fun}
function. The entire @code{debug_msg} expression is somehow equivalent
to @code{(cppif ENABLE_CHECKING (debug_msg_fun @var{expv msg count
filename lineno}) ())} and evaluates to nil.

@item defciterator
@cindex @code{defciterator} MELT syntax
The form @code{(defciterator @var{iter-name} @var{start-formals}
@var{state-symbol} @var{local-formals} @var{before-expansion}
@var{after-expansion})} defines a C-iterator named
@var{iter-name}. The @var{start-formals} is a [binding] list of formal
arguments [given to the C-iterator].  The @var{state-symbol} is usable
in the expansions, where it is expanded to a unique C identifier. The
@var{local-formals} is a [binding] list of variables local to the
expanded block. The @var{before-expansion} and @var{after-expansion}
are lists of items like strings (appearing as is in the C expansion)
or symbols (either from the start formals, or the local formals, or
the state symbol).

@item defclass
@cindex @code{defclass} MELT syntax
The form @code{(defclass @var{class-name} [:predef @var{predefined}]
[:super @var{superclass-name}] :fields @var{fields-list})} defines a
class named @var{class-name} of super-class named
@var{superclass-name} with the given @var{fields-list} (a list of
field names) and an optional @var{predefined} name (for predefined
classes [giving a @var{predefined} is for experts]).

@item definstance
@cindex @code{definstance} MELT syntax
The form @code{(definstance @var{instance-name} @var{class-name}
[:predef @var{predefined}] [:obj_num @var{object-number}]
@var{:field-name} @var{field-value} @var{...})} statically defines an
instance of name @var{instance-name} of the class
@var{class-name}. [expert usage: a @var{predefined} name and an
@var{object-number} may also be given].

@item defprimitive
@cindex @code{defprimitive} MELT syntax
The form @code{(defprimitive @var{primitive-name}
@var{formals-arglist} @var{ctype} @var{expansion} @var{...})}
statically defines a C primitive named @var{primitive-name} of a given
@var{formals-list} and given return @var{ctype}. The @var{expansion}-s
are either strings or formal names.

@item defselector
@cindex @code{defselector} MELT syntax
The form @code{(defprimitive @var{selector-name} @var{selector-class}
@var{:field-name} @var{field-value} @var{...})} defines a
selector. Usually @var{selector-class} is @code{CLASS_SELECTOR}, and
no other @var{field}s are given. Once a name is bound to a selector,
every further occurrence of that name in operator position is
considered as a message invocation.

@item defun
@cindex @code{defun} MELT syntax
The form @code{(defun @var{function-name} @var{formals-list}
@var{body} @var{...})} define a function named
@code{function-name}. The ctype of the first (if any) formal argument
(in the @var{formals-list}) should be a @code{:value}. The
@code{function-name} can appear in the given @var{body} (for
recursion).

@item exit
@cindex @code{exit} MELT syntax
The form @code{(exit @var{loop-label} @var{expr} @var{...})}, only
used inside @code{forever} loops, causes the lexically enclosing
@code{forever} loop named by @var{loop-label} to be exited, after
evaluation of the @var{expr}s. The last such value (or nil if no
@var{expr} is given) is the result returned by the @code{forever}
loop. @code{exit} forms are similar to Ada's @code{exit} or C
@code{break} (not to @code{longjmp}). The @code{exit} should be local
to the containing procedure: it cannot jump across @code{lambda}s.

@item export_class
@cindex @code{export_class} MELT syntax
The form @code{(export_class @var{class-name} @var{...})} export all
the given @var{class-name}s and their fields.

@item export_macro
@cindex @code{export_macro} MELT syntax
[For experts] The form @code{(export_macro @var{macro-symbol}
@var{expander})} exports a macro binding for the given
@var{macro-symbol} with the @var{expander} function (which takes as
arguments the source expression (of @code{CLASS_SEXPR}), the
environment (of @code{CLASS_ENVIRONMENT}), the expander produces an
instance of a subclass of @code{CLASS_SRC}. The macro
@code{macro-symbol} is defined in the environment exported by the
current module, so is available in other modules only.

@item export_values
@cindex @code{export_values} MELT syntax
The form @code{(export_values @var{exported-name} @var{...})} export
all the names, as values, given as arguments.

@item fetch_predefined
@cindex @code{fetch_predefined} MELT syntax
[For experts] @code{(fetch_predefined @var{predefined-name-or-number})}

@item forever
@cindex @code{forever} MELT syntax
@code{(forever @var{label-name} @var{body} @var{...})}  when
evaluated, the bodies are evaluated in sequence, and indefinitely
re-evaluated again. The only way of getting out from a @code{forever}
loop is with @code{exit} (using the given @var{label-name}, lexically
inside the body) or @code{return}

@item if
@item lambda
@item let
@item make_instance
@item match
@item multicall
@item or
@item parent_module_environment
@item progn
@item quote
@item redefinition_handling
@item return
@item setq
@item store_predefined
@item unsafe_get_field
@item unsafe_put_fields
@item update_current_module_environment_container

@end table
@c =======================================================================
