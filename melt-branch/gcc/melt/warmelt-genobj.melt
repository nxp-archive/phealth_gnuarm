;; File warmelt-genobj.melt -*- Lisp -*-
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(comment "
    Copyright 2008, 2009 Free Software Foundation, Inc.
    Contributed by Basile Starynkevitch <basile@starynkevitch.net>

    This file is part of GCC.

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
")

;; the copyright notice above apply both to warmelt-genobj.melt and 
;; to the generated file  warmelt-genobj*.c

;;    This file is the fifth part of a bootstrapping compiler for the
;;    MELT lisp dialect, compiler which should be able to
;;    compile itself (into generated C file[s])
;;    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;; value like objects
(defclass class_objvalue
  :super class_objcode
  :fields ( obv_type			;the ctype
	    ))


;;; pure values are side-effect free
(defclass class_objpurevalue
  :super class_objvalue
  :fields ())

;; object local variable
;;;; disposed local variables can be reused.
(defclass class_objlocv
  :super class_objpurevalue
  :fields (obl_off			;offset in frame
	   obl_proc			;containing procedure or nil if disposed
	   obl_cname			;symbolic cname string
	   ))


;; closed occurrence
(defclass class_objcloccv
  :super class_objpurevalue
  :fields (obc_off			;offset in closure
	   obc_proc			;containing procedure
	   obc_name			;symbolic name
	   ))


;; constant [closed] occurrence
(defclass class_objconstv
  :super class_objcloccv
  :fields (
	   ))

;; predefined object
(defclass class_objpredef
  :super class_objpurevalue
  :fields (obpredef
	   ))

;; nil
(defclass class_objnil
  :super class_objpurevalue
  :fields ())

;; initial element 
(defclass class_objinitelem
  :super class_objpurevalue
  :fields (oie_cname 			;symbolic cname string - fieldname in cdat
	   oie_data			;normal data
	   oie_discr			;compiled discriminant
	   oie_locvar			;initial routine's local variable
	   ;; the size, if any is the obj_num
	   ))

;;; initial object - see MELT_OBJECT_STRUCT in melt-runtime.h
(defclass class_objinitobject
  :super class_objinitelem
  :fields (
	   oio_predef			;the predef name or number to contain this object
	   ))


;;; initial multiple - see MELT_MULTIPLE_STRUCT in melt-runtime.h
(defclass class_objinitmultiple
  :super class_objinitelem
  :fields (
	   ;; we may need to tuple of compiled values for accessing
	   ;; the nth at compilation time in compilobj_nrep_multacc
	   oim_tupval			;tuple of compiled values
	   ))

;;; initial closure - see MELT_CLOSURE_STRUCT in melt-runtime.h
(defclass class_objinitclosure 
  :super  class_objinitelem
  :fields (
	   ))

;;; initial routine - see  MELT_ROUTINE_STRUCT in melt-runtime.h
(defclass class_objinitroutine
  :super class_objinitelem
  :fields (
	   oir_procroutine		;the procroutine associated
	   ))

;;; initial string - see MELT_STRING_STRUCT in melt-runtime.h
(defclass class_objinitstring
  :super class_objinitelem
  :fields (
	   ))


;; expanded value
(defclass class_objexpv
  :super class_objvalue
  :fields (obx_cont
	   ))

;; expanded value with location 
(defclass class_objlocatedexpv
  :super class_objexpv
  :fields (obcx_loc			;optional location
	   ))

;;;; instructions
(defclass class_objinstr
  :super class_objcode
  :fields (obi_loc			;src location
	   ))

(defclass class_objcommentinstr		;just a comment, useful only for debugging our generator
  :super class_objinstr
  :fields (obci_comment
	   ))


;;;; instructions with a list of destinations (computes, calls, sends, etc...)
(defclass class_objdestinstr
  :super class_objinstr
  :fields (obdi_destlist		;a list of destination lovations
	   ))

;;; compute instruction
(defclass class_objcompute
  :super class_objdestinstr
  :fields (obcpt_expr			;expression list or object or tuple
	   ))

;; get argument instruction
(defclass class_objgetarg
  :super class_objinstr
  :fields (obarg_obloc			;objlocation
	   obarg_bind			;formal binding
	   ))


;; put extra result instruction
(defclass class_objputxtraresult
  :super class_objinstr
  :fields (obxres_rank 			;boxed rank
	   obxres_obloc			;objlocation
	   ))

;; final return
(defclass class_objfinalreturn
  :super class_objinstr
  :fields (				;no argument
	   ))

;; clear instruction
(defclass class_objclear
  :super class_objinstr
  :fields (oclr_vloc			;varlocation to clear
	   ))



;; block instruction
(defclass class_objblock
  :super class_objinstr
  :fields ( oblo_bodyl			;body list
	    oblo_epil			;epilogue list
	    ))

;; a block with a comment string appearing in the generated code
(defclass class_objcommentedblock
  :super class_objblock
  :fields ( ocomblo_comment		;the comment string
	    ))


;; a block for compiling matches. We need to redistribute put_objdest
;; inside appropriately
(defclass class_objmultiblock
  :super class_objblock
  :fields (omulblo_subcomp		;the tuple of subcomponents
					;into which redistribute
					;destination
	   ))

;; unique label instr
(defclass class_objlabelinstr
  :super class_objinstr
  :fields (oblab_prefix			;unique prefix string
	   oblab_rank			;additional rank
	   ))

;; unconditional goto label
(defclass class_objgotoinstr
  :super class_objinstr
  :fields (obgoto_prefix		;unique prefix string
	   obgoto_rank			;additional rank
	   ))

;; looping block
(defclass class_objloop
  :super class_objblock		 ;the body is looped, not the epilogue
  :fields (obloop_label		 ;cloned symbol
	   obloop_resv		 ;the result of the loop
	   ))

;; exit a loop
(defclass class_objexit
  :super class_objinstr
  :fields (obexit_label			;cloned symbol for goto destination
	   ))

;; citeration block
(defclass class_objciterblock
  :super class_objblock
  :fields (obciter_citer
	   obciter_before
	   obciter_after
	   ))

;; conditional instruction
(defclass class_objcond
  :super class_objinstr
  :fields (obcond_test
	   obcond_then
	   obcond_else
	   ))

;; preprocessor conditional instruction
(defclass class_objcppif
  :super class_objinstr
  :fields (obifp_cond
	   obifp_then
	   obifp_else
	   ))


;;; keyword & symbol intern instruction
(defclass class_objinterncommon
  :super class_objinstr
  :fields (obintern_iobj			;the objinitobject for
					;the symbol or keyword
	   ))

(defclass class_objinternsymbol
  :super class_objinterncommon
  :fields (
	   ))

(defclass class_objinternkeyword
  :super class_objinterncommon
  :fields (
	   ))

;;; keyword & symbol getnamed instruction
(defclass class_objgetnamedcommon
  :super class_objinstr
  :fields (obgnamed_iobj		;the objinitobject for the
					;symbol or keyword
	   ))

(defclass class_objgetnamedsymbol
  :super class_objgetnamedcommon
  :fields (
	   ))

(defclass class_objgetnamedkeyword
  :super class_objgetnamedcommon
  :fields (
	   ))

;;; apply instruction
(defclass class_objapply
  :super class_objdestinstr
  :fields (obapp_clos			;closure to be applied
	   obapp_args			;argument tuple
	   ))

;;; multiapply instruction
(defclass class_objmultiapply
  :super class_objapply
  :fields (obmultapp_xres		;extraresult tuple
	   ))

;;; message send instruction
(defclass class_objmsend
  :super class_objdestinstr
  :fields (obmsnd_sel			;selector object (compiled)
	   obmsnd_recv			;message reciever (compiled)
	   obmsnd_args 			;argument tuple (compiled)
	   ))

;;; multisend instruction
(defclass class_objmultimsend
  :super class_objmsend
  :fields (obmultsnd_xres		;extraresult tuple
	   ))

;; raw object allocation instruction
(defclass class_objrawallocobj
  :super class_objdestinstr
  :fields (
	   obrallobj_class		;the class data
	   obrallobj_len		;the boxed integer length
	   obrallobj_classname		;the class name
	   ))


;; new closure allocation
(defclass class_objnewclosure
  :super class_objdestinstr
  :fields (obnclo_discr		     ;the discriminant
	   obnclo_rout		     ;the routine
	   obnclo_len		     ;the boxed integer length
	   ))

;; put a component inside a tuple
(defclass class_objputuple
  :super class_objinstr
  :fields (oputu_tupled			;the tuple data
	   oputu_offset			;numerical offset
	   oputu_value			;the new value
	   ))

;; put a slot inside an object
(defclass class_objputslot
  :super class_objinstr
  :fields ( oslot_odata			;the object data to put
	    oslot_offset		;numerical offset
	    oslot_field			;the [optional] field 
	    oslot_value			;the new value
	    ))


;; get a slot from an object
(defclass class_objgetslot
  :super class_objdestinstr
  :fields (ogetsl_obj		   ;the object to get from
	   ogetsl_field		   ;the fieldname
	   ))

;; put the routine inside a closure
(defclass class_objputclosurout
  :super class_objinstr
  :fields (opclor_clos			;the closure data
	   opclor_rout			;the routine data
	   ))

;; put a closed value inside a closure
(defclass class_objputclosedv
  :super class_objinstr
  :fields (opclov_clos			;the closure data or local
	   opclov_off 			;the boxed offset
	   opclov_cval			;the closed value
	   ))

;; likewise, but check that the closed value is notnull
(defclass class_objputclosednotnullv
  :super class_objputclosedv
  :fields (
	   ))

;; put a constant value inside a routine
(defclass class_objputroutconst
  :super class_objinstr
  :fields (oprconst_rout	 ;the routine data
	   oprconst_off		 ;the boxed offset
	   oprconst_cval	 ;the constant value
	   ))

;; likewise, but check that the constant is notnull
(defclass class_objputroutconstnotnull
  :super class_objputroutconst
  :fields (
	   ))

;; touch a value, with a tiny comment
(defclass class_objtouch
  :super class_objinstr
  :fields (otouch_val
	   otouch_comment
	   ))

;; set a predef
(defclass class_objsetpredef
  :super class_objinstr
  :fields ( ospr_object			;the object 
	    ospr_predef			;its predef rank
	    ))


;;; routines
(defclass class_routineobj
  :super class_named
  :fields (obrout_proc			;the associated procedure
	   obrout_body			;the body (a list)
	   obrout_nbval			;the boxed number of value pointers
	   obrout_nblong		;the boxed number of longs
	   obrout_others		;the list of other (nonvalue,
					;nonlongs) locals (usually C
					;pointers like tree-s,
					;cstrings, ...)
	   obrout_retval		;the main return value
	   obrout_cntciter		;the boxed counter of citerations
	   ))

;; procedure routine
(defclass class_procroutineobj
  :super class_routineobj
  :fields (oprout_getargs		;the get arguments tuple of instructions
	   oprout_loc			;the source location
	   oprout_funam			;function name
	   ))

;; initial routine
(defclass class_initialroutineobj
  :super class_routineobj
  :fields (
	   oirout_data			;the tuple of initial data
	   oirout_prolog       ;the prologue (list of instr) before filling the data. Imports should go here!
	   oirout_fill			;the fill of the data (a list of instr)
	   ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; export the above classes
(export_class				;alphabetical order
 class_initialroutineobj
 class_objapply
 class_objblock
 class_objciterblock
 class_objclear
 class_objcloccv
 class_objcommentedblock
 class_objcommentinstr
 class_objcompute
 class_objcond
 class_objconstv
 class_objcppif
 class_objdestinstr
 class_objexit
 class_objexpv
 class_objfinalreturn
 class_objgetarg
 class_objgetnamedcommon
 class_objgetnamedkeyword
 class_objgetnamedsymbol
 class_objgetslot
 class_objgotoinstr
 class_objinitclosure
 class_objinitelem
 class_objinitmultiple
 class_objinitobject
 class_objinitroutine
 class_objinitstring
 class_objinstr
 class_objinterncommon
 class_objinternkeyword
 class_objinternsymbol
 class_objlabelinstr
 class_objlocatedexpv
 class_objlocv
 class_objloop
 class_objmsend
 class_objmultiapply
 class_objmultiblock
 class_objmultimsend
 class_objnewclosure
 class_objnil
 class_objpredef
 class_objpurevalue
 class_objputclosednotnullv
 class_objputclosedv
 class_objputclosurout
 class_objputroutconst
 class_objputroutconstnotnull
 class_objputslot
 class_objputuple
 class_objputxtraresult
 class_objrawallocobj
 class_objsetpredef
 class_objtouch
 class_objvalue
 class_procroutineobj
 class_routineobj
 )					;end export_class

;;;; selector to generate the declaration of an initial
;;; reciever some objinielem
;;; argument strbuf
(defselector output_c_declinit class_selector
  )
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; selector to put a destination into an objcode
;;; reciever: the objcode
;;; argument: the destination value
;;; result: the (modified) recieving objcode or its replacement
(defselector put_objdest class_selector
  )

;;; selector to generate the c code for an object
;;; reciever: the object to output
;;; arguments: 
;;;; * DECLBUF the stringbuffer for the declarations
;;;; * IMPLBUF the stringbuffer for implementations
;;;; * DEPTH an unboxed integer for indentation...
;;; result is not used

(defselector output_c_code class_selector
  )

;;;; selector to generate the initial fill of some objinit
;;; reciever some objinitelem
;;; argument a stringbuffer
(defselector output_c_initfill class_selector
  )

;;;; selector to generate the predef fill of some objinit
;;; reciever some objinitelem
;;; argument a stringbuffer
(defselector output_c_initpredef class_selector
  )

(export_values
 output_c_code
 output_c_declinit
 output_c_initfill
 output_c_initpredef 
 put_objdest
 )

;; a catchall method for nrep-s (normal representations) each should
;; be separately compiled with its own method so this should never be
;; called
(defun compilobj_catchall_nrep (recv gcx)
  (debug_msg gcx "class_rep compile_obj gcx")
  (displaydebugmsg recv "class_rep compile_obj recv")
  (outcstring_err "* compilobj unimplemented reciever class ")
  (let ( (discr (discrim recv)) ) (outstr_err (unsafe_get_field :named_name discr)))
  (outnewline_err)
  (assert_msg "@@compile_obj should be implemented in nrep-s subclasses" ())
  )
(install_method class_nrep compile_obj compilobj_catchall_nrep)

(defun putobjdest_catchall_objcode (recv desto)
  (debug_msg recv "putobjdest_catchall_objcode recv@@  " )
  (debug_msg desto "putobjdest_catchall_objcode desto@@  " )
  (outcstring_err "* putobjdest unimplemented reciever class ")
  (let ( (discr (discrim recv)) ) (outstr_err (unsafe_get_field :named_name discr)))
  (outnewline_err)
  (assert_msg "@@ unexpected catchall putobjdest objcod" ()))
(install_method class_objcode put_objdest putobjdest_catchall_objcode)


(defun putobjdest_catchall_anydiscr (recv desto)
  (debug_msg recv "putobjdest_catchall_anydiscr recv@@  " )
  (debug_msg desto "putobjdest_catchall_anydiscr desto@@  " )
  (outcstring_err "* putobjdest unimplemented reciever discriminant ")
  (let ( (discr (discrim recv)) ) 
    (outstr_err (unsafe_get_field :named_name discr)))
  (outnewline_err)
  (assert_msg "@@ unexpected catchall putobjdest anydiscr" ()))
(install_method discr_anyrecv put_objdest putobjdest_catchall_anydiscr)


(defun getctype_objvalue (recv env)
  (assert_msg "check recv objvalue" (is_a recv class_objvalue))
  (unsafe_get_field :obv_type recv))
(install_method class_objvalue get_ctype getctype_objvalue)





;; nil are ctype_value
(defun gectyp_objnil (recv env)  
  (debug_msg recv "gectyp_objnil recv")
  ctype_value)
(install_method class_objnil get_ctype gectyp_objnil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; in the debug output routineobj-s make huge output, so print the detail only when at toplevel
(defun dbgout_routineobj (self dbgi :long depth)
  (if (<=i depth 0)
      (dbgout_namedobject_method self dbgi 0)
    (dbgout_namedobject_method self dbgi 30))
  )
(install_method class_routineobj dbg_output dbgout_routineobj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;; common put destination of objdestinstr....
(defun putobjdest_objdestinstr (recv desto)
  (assert_msg "putobjdest_objdestinstr check recv" (is_a recv class_objdestinstr))
  (debug_msg recv "putobjdest_objdestinstr recv")
  (debug_msg desto "putobjdest_objdestinstr desto@@  " )
  (let ( (destl (unsafe_get_field :obdi_destlist recv)) )
    (if (not (is_list destl))
	(progn 
	  (setq destl (make_list discr_list))
	  (unsafe_put_fields recv :obdi_destlist destl)))
    (let ( (firstd (pair_head (list_first destl))) )
      (if (== firstd desto)
	  (return recv)
	(progn
	  (list_append destl desto)
	  (return recv)
	  )))))
(install_method class_objdestinstr put_objdest putobjdest_objdestinstr)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; notes about code generation
;;;
;;; in addition of the code structure generated by cold-melt we
;;; need to be able to import values (hence bindings) from a start
;;; environment which is the only argument given to the generated
;;; start routine of the module


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;







;; for some reason, final returns are sometimes putobjdest-ed - a NOP here
(defun putobjdest_objfinalreturn (recv desto)
  (assert_msg "check recv" (is_a recv class_objfinalreturn))
  recv
  )
(install_method class_objfinalreturn put_objdest putobjdest_objfinalreturn)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; compile a single procedure
(defun compile2obj_procedure (pro modctx compicache :long num)
  (debug_msg pro "compilproc pro")
  ;;(debug_msg compicache "compilproc compicache")
  (assert_msg "check pro" (is_a pro class_nrep_routproc))
  (assert_msg "check compicache" (is_mapobject compicache))
  (assert_msg "check modctx" (is_a modctx class_modulcontext))
  (let ( (namsbuf (make_strbuf discr_strbuf)) 
	 (routfunam (the_null))
	 )
    (add2sbuf_strconst namsbuf "rout_")
    (add2sbuf_longdec namsbuf num)
    (if (is_a pro class_nrep_routproc)
	(let ( (pronam (unsafe_get_field :nrpro_name pro)) 
	       )
	  (if (is_a pronam class_named)
	      (progn
		(setq routfunam (unsafe_get_field :named_name pronam))
		(add2sbuf_strconst namsbuf "_")
		(add2sbuf_cident namsbuf (unsafe_get_field :named_name pronam)))
	    )))
    (let ( 
	  (nbody (unsafe_get_field :nproc_body pro))
	  (nloc (unsafe_get_field :nrep_loc pro))
	  (nargb (if (is_a pro class_nrep_routproc) (unsafe_get_field :nrpro_argb pro)))
	  (obodylist (make_list discr_list))
	  (obrout (instance class_procroutineobj
			    :named_name (strbuf2string discr_string namsbuf)
			    :obrout_proc pro
			    :obrout_body obodylist
			    :obrout_nbval (make_integerbox discr_integer 0)
			    :obrout_nblong (make_integerbox discr_integer 0)
			    :obrout_others (make_list discr_list)
			    :obrout_cntciter (make_integerbox discr_integer 0)
			    :oprout_loc nloc
			    :oprout_funam routfunam
			    )) 
	  (locmap (make_mapobject discr_mapobjects (+i 20 (*i 3 (multiple_length nargb)))))
	  (gcx (instance class_genercontext
			 :gncx_objrout obrout
			 :gncx_locmap locmap
			 :gncx_freeptrlist (make_list discr_list)
			 :gncx_freelonglist (make_list discr_list)
			 :gncx_freeothermaps (make_mapobject discr_mapobjects 20)
			 :gncx_compicache compicache
			 :gncx_modulcontext modctx
			 :gncx_matchmap (make_mapobject discr_mapobjects 40)
			 ))
	  (retloc 
	   (let ( (retl (get_free_objlocptr gcx '_retval_)) )
	     (unsafe_put_fields gcx :gncx_retloc retl)
	     retl))
	  (gtatup 
	   (multiple_map 
	    nargb
	    (lambda (bnd :long ix)
	      (assert_msg "check bnd" (is_a bnd class_formal_binding))
					;	      (debug_msg bnd "compilproc bnd")
	      (let ( (bctyp (unsafe_get_field :fbind_type bnd)) 
		     (bnam (unsafe_get_field :binder bnd))
		     (oloc 
		      (cond ( (== bctyp ctype_value)
			      (get_free_objlocptr gcx bnam) )
			    ( (== bctyp ctype_long)
			      (get_free_objloclong gcx bnam) )
			    (:else
			     (get_free_objloctyped gcx bnam bctyp)))
		      ) 
		     (ogarg
		      (instance class_objgetarg
				:obi_loc nloc
				:obarg_obloc oloc
				:obarg_bind bnd))
		     )
		(if (and (<=i ix 0) (!= bctyp ctype_value))
		    (error_plain nloc "first argument of function should be a value"))
		(mapobject_put locmap bnd oloc)
		ogarg
		))
	    ))
	  )
      ;; associate the procedure with its objroutine in the compiler cache
      (mapobject_put compicache pro obrout)
      (unsafe_put_fields obrout :oprout_getargs gtatup)
      (debug_msg obrout "compile2obj_procedure obrout")
      (debug_msg nbody "compile2obj_procedure nbody")
      (assert_msg "check nbody" (is_a nbody class_nrep))
      (if (is_a pro class_nrep_routproc)
	  (let ( (pthuls (unsafe_get_field :nrpro_thunklist pro)) )
	    (debug_msg pthuls "compile2obj_procedure pthuls")
	    (list_every 
	     pthuls
	     (lambda (pthu) 
	       (debug_msg pthu "compile2obj_procedure pthu")
	       (assert_msg "compile2obj_procedure check pthu" (is_closure pthu))
	       (pthu gcx)
	       )
	     )))
      (let ( (obody (compile_obj nbody gcx)) 
	     )
	(debug_msg obody "compile2obj_procedure obody")
	(list_append obodylist obody)
	)
      (debug_msg obrout "compile2obj_procedure return obrout")
      obrout
      )))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  the initial routine uses the initial system data ...
(definstance initialsystemdata_objpredef class_objpredef
  :obv_type ctype_value
  :obpredef 'INITIAL_SYSTEM_DATA
  )

(defun append_comment (ilist comstr iloc)
  (list_append ilist (instance class_objcommentinstr :obi_loc iloc :obci_comment comstr)))
(defun append_commentconst (ilist :cstring comment :value iloc)
  (list_append ilist (instance class_objcommentinstr :obi_loc iloc :obci_comment (make_stringconst discr_string comment))))

;;;; compile the initial procedure into an object
(defun compile2obj_initproc (ipro modctx idata compicache procurmodenvlist importvalues)
  (assert_msg "check ipro" (is_a ipro class_nrep_initproc))
  (assert_msg "check idata" (is_list idata))
  (assert_msg "check modctx" (is_a modctx class_modulcontext))
  (assert_msg "check compicache" (is_mapobject compicache))
  (assert_msg "check importvalues" (is_list importvalues))
  (debug_msg ipro "compile2obj_initproc ipro")
  (debug_msg compicache "compile2obj_initproc compicache")
  (debug_msg procurmodenvlist "compile2obj_initproc start procurmodenvlist")
  (debug_msg importvalues "compile2obj_initproc start importvalues")
  (let ((locmap (make_mapobject discr_mapobjects 50))
	(oiniprolog (make_list discr_list))
	(oinibody (make_list discr_list))
	(oinitrout
	 (instance class_initialroutineobj
		   :named_name (make_stringconst discr_string "start_module_melt")
		   :obrout_proc ipro
		   :obrout_body oinibody
		   :obrout_nbval (make_integerbox discr_integer 0)
		   :obrout_nblong (make_integerbox discr_integer 0)
		   :obrout_others (make_list discr_list)
		   :obrout_cntciter (make_integerbox discr_integer 0)
		   :oirout_fill (make_list discr_list)
		   :oirout_prolog oiniprolog
		   ))
	(importmap (make_mapobject discr_mapobjects 50))
	(gcx (instance 
	      class_initgenercontext
	      :gncx_objrout oinitrout
	      :gncx_locmap locmap
	      :gncx_freeptrlist (make_list discr_list)
	      :gncx_freelonglist (make_list discr_list)
	      :gncx_freeothermaps (make_mapobject discr_mapobjects 20)
	      :gncx_compicache compicache
	      :gncx_modulcontext modctx
	      :gncx_matchmap (make_mapobject discr_mapobjects 60)
	      :igncx_procurmodenvlist
	      (list_map 
	       procurmodenvlist
	       (lambda (curpro)
		 (debug_msg curpro "compile2obj_initproc procurmodenvlist curpro")
		 (let ( (curou (mapobject_get compicache curpro)) )
		   (debug_msg curou "compile2obj_initproc procurmodenvlist curou")
		   (assert_msg "check curou" (is_object curou))
		   curou)))
	      ;; perhaps we should store not a list of procedures, but their matching routines
	      :igncx_importmap importmap
	      ))
	(retinit 
	 (let ( (reti (get_free_objlocptr gcx '_retinit_)) )
	   (unsafe_put_fields gcx :gncx_retloc reti)
	   (unsafe_put_fields oinitrout :obrout_retval reti)
	   reti))
	(boxloc
	 (let ( (boxl (get_free_objlocptr gcx '_contenv_)) )
	   (unsafe_put_fields gcx :igncx_contenvloc boxl)
	   boxl))
	(ofreshenv  (get_free_objlocptr gcx '_freshenv_))
	(oprevenv  (let ( (preve (get_free_objlocptr gcx '_prevenv_))
			  )
		     (unsafe_put_fields gcx :igncx_prevenvloc preve)
		     preve))
	(ovalueexporter (get_free_objlocptr gcx '_valexport_)) 
	(ovalueimporter (get_free_objlocptr gcx '_valimport_))
	)
    (append_commentconst oinibody "start of oinibody")
    (debug_msg boxloc "boxloc is")
    ;; create a commentedblock to compute the new environemnt box in boxloc if it is null 
    (let (
	  ;; block to compute boxloc
	  (ocomputboxloc
	   (let ( (bodfel (make_list discr_list)) 
		  )
	     (append_commentconst bodfel "start computing boxloc")
	     ;; retrieve the fresh_env from the systemdata
	     (list_append bodfel
			  (instance class_objgetslot
				    :obdi_destlist (list1 ofreshenv)
				    :ogetsl_obj initialsystemdata_objpredef 
				    :ogetsl_field sysdata_cont_fresh_env))
	     ;; always generate a test for fresh_env being a closure if the oprevenv exists
	     (list_append 
	      bodfel
	      (instance class_objcompute
			:obcpt_expr (make_tuple7
				     discr_multiple
				     (make_stringconst discr_verbatimstring 
						       "if ((") 
				     oprevenv
				     (make_stringconst discr_verbatimstring 
						       ") && melt_magic_discr((melt_ptr_t)(")
				     ofreshenv
				     (make_stringconst discr_verbatimstring 
						       ")) != OBMAG_CLOSURE) warning(0, \"bad MELT fresh_env @%p in system data <%s:%d>\", ")
				     ofreshenv
				     (make_stringconst discr_verbatimstring ", __FILE__, __LINE__);"))))
	     ;; generate the apply of ofreshenv
	     (list_append
	      bodfel
	      (instance class_objapply
			:obdi_destlist (list1 boxloc)
			:obapp_clos ofreshenv
			:obapp_args (make_tuple1 discr_multiple oprevenv)))
	     ;; ocomputboxloc is this block
	     (instance class_objcommentedblock
		       :oblo_bodyl bodfel
		       :oblo_epil (the_null)
		       :ocomblo_comment (make_stringconst discr_string "compute fresh module environment")))
	   )
	  ;; cond to test boxloc & compute it if null and if the initial_system_data is a valid object
	  (otestcomputboxloc 
	   (instance class_objcond
		     :obcond_test
		     (instance
		      class_objexpv 
		      :obx_cont (make_tuple2 
				 discr_multiple
				 boxloc
				 (make_stringconst discr_verbatimstring
						   " || melt_object_length((melt_ptr_t) MELT_PREDEF (INITIAL_SYSTEM_DATA))<FSYSDAT_BOX_FRESH_ENV"
						   )
				 ))
		     :obcond_then (the_null)
		     :obcond_else ocomputboxloc))
	  ;;
	  (limplocv
	   (list_map 
	    importvalues
	    (lambda (ival)
	      (debug_msg ival "compile2obj_initproc imported ival")
	      (assert_msg "check ival" (is_a ival class_nrep_importedval))
	      (let ( (isym (unsafe_get_field :nimport_symb ival)) 
		     (ilocv (get_free_objlocptr gcx isym))
		     )
		(debug_msg ilocv "compile2obj_initproc imported ilocv")
		(mapobject_put importmap isym ilocv)
		ilocv
		))))
	  )
      (debug_msg otestcomputboxloc "compile2obj_initproc otestcomputboxloc")
      ;; the prologue starts by getting the previous environment from the
      ;; modargp_ unique argument
      (let ( (lisdest (make_list discr_list)) )
	(list_append lisdest oprevenv)
	(append_commentconst oiniprolog "get previous environment")
	(list_append oiniprolog
		     (instance class_objcompute
			       :obdi_destlist lisdest
			       :obcpt_expr (make_stringconst discr_verbatimstring "modargp_"))
		     )
	)
      (append_commentconst oiniprolog "compute boxloc")
      ;; we compute the boxloc at first
      (list_append oiniprolog otestcomputboxloc)
      ;; the tuple to compile the body
      (let (
	    (odatatup 
	     (list_to_multiple
	      idata discr_multiple
	      (lambda (curdat)
		;;(debug_msg curdat "compile2obj_initproc curdat")
		(assert_msg "check curdat" (is_a curdat class_nrep_data))
		(let ( (curobd (compile_obj curdat gcx)) )
		  ;;(debug_msg curobd "compile2obj_initproc curobd")
		  curobd))))
	    (toplis (unsafe_get_field :ninit_topl ipro)) 
	    )
	(unsafe_put_fields oinitrout
			   :oirout_data odatatup)
	(assert_msg "check toplis" (is_list_or_null toplis))
	;; compile the toplevels
	(let ( (objtoplis 
		(list_map
		 toplis
		 (lambda (curtop)
		   (let ( (otop (compile_obj curtop gcx)) )
		     (debug_msg otop "compile2obj_initproc otop")
		     otop)))) 
	       )
	  ;; generate the getting of symbols & keywords
	  (append_commentconst oiniprolog "get symbols & keywords")
	  (multiple_every
	   odatatup
	   (lambda (curpdat :long curk) 
	     (if (is_a curpdat class_objinitobject)
		 (let ( (odat (unsafe_get_field :oie_data curpdat))
			)
		   (debug_msg curpdat "compile2obj_initproc getting curpdat")
		   (cond 
		    ;; first  check for keywords, since they are also symbols (so order is important)
		    ( (is_a odat class_nrep_datakeyword)
		      (let ( (ogkw (instance class_objgetnamedkeyword
					     :obgnamed_iobj curpdat))
			     )
			(list_append oiniprolog ogkw)
			(debug_msg ogkw "compile2obj_initproc added keyword getting ogkw")
			))
		    ( (is_a odat class_nrep_datasymbol)
		      (let ( (ogsy (instance class_objgetnamedsymbol
					     :obgnamed_iobj curpdat))
			     )
			(list_append oiniprolog ogsy)
			(debug_msg ogsy "compile2obj_initproc added symbol getting ogsy")
			))
		    )))))
	  ;; get the value importer if needed
	  (if (>i (mapobject_count importmap) 0)
	      (progn
		(append_commentconst oiniprolog "get the value importer")
		(list_append oiniprolog
			     (instance class_objgetslot
				       :obdi_destlist (list1 ovalueimporter)
				       :ogetsl_obj initialsystemdata_objpredef 
				       :ogetsl_field sysdata_value_importer))
		))
	  (if (>i (list_length importvalues) 0)
	      (progn
		(append_commentconst oiniprolog "before getting imported values")
		;; generate the getting of imported values
		(list_every
		 importvalues
		 (lambda (curimport)
		   (debug_msg curimport "compile2obj_initproc curimport")
		   (assert_msg "check curimport" (is_a curimport class_nrep_importedval))
		   (let ( (impsym (unsafe_get_field :nimport_symb curimport)) 
			  (impsydat (unsafe_get_field :nimport_sydata curimport))
			  (osymdat (compile_obj impsydat gcx))
			  (oimplocv (mapobject_get importmap impsym))
			  (oimpappl (instance class_objapply
					      :obdi_destlist (list1 oimplocv)
					      :obapp_clos ovalueimporter
					      :obapp_args (make_tuple2 discr_multiple osymdat oprevenv)))
			  )
		     (list_append oiniprolog oimpappl)
		     )))
		(append_commentconst oiniprolog "after getting imported values")
		))
	  ;; append the compiled toplevel
	  (append_commentconst oinibody "before toplevel body")
	  (list_every 
	   objtoplis
	   (lambda (curobjt)
	     (list_append oinibody curobjt)))
	  (append_commentconst oinibody "after toplevel body")
	  ;; we compute the boxloc again
	  (append_commentconst oinibody "compute boxloc again")
	  (list_append oinibody otestcomputboxloc)
	  (append_commentconst oinibody "intern symbols")
	  ;; generate interning of symbols & keywords
	  (multiple_every
	   odatatup
	   (lambda (curpdat :long curk) 
	     (if (is_a curpdat class_objinitobject)
		 (let ( (odat (unsafe_get_field :oie_data curpdat))
			)
		   (debug_msg curpdat "compile2obj_initproc interning curpdat")
		   (cond 
		    ;; first  check for keywords, since they are also symbols (so order is important)
		    ( (is_a odat class_nrep_datakeyword)
		      (let ( (oikw (instance class_objinternkeyword
					     :obintern_iobj curpdat))
			     )
			(list_append oinibody oikw)
			(debug_msg oikw "compile2obj_initproc added keyword interning oikw")
			))
		    ( (is_a odat class_nrep_datasymbol)
		      (let ( (oisy (instance class_objinternsymbol
					     :obintern_iobj curpdat))
			     )
			(list_append oinibody oisy)
			(debug_msg oisy "compile2obj_initproc added symbol interning oisy")
			))
		    )))))
	  )				;end of toplevels
	(append_commentconst oinibody "set retinit from boxloc")
	;; emit setting the retinit from the boxloc
	(let ( (osetretinit
		(instance 
		 class_objcompute
		 :obdi_destlist (list1 retinit)
		 :obcpt_expr
		 (make_tuple3 discr_multiple
			      (make_stringconst discr_verbatimstring
						"/*final freshenv get*/ melt_container_value((melt_ptr_t)(")
			      boxloc	
			      (make_stringconst discr_verbatimstring "))")	
			      )
		 ))
	       )
	  (debug_msg osetretinit "compile2obj_initproc adding osetretinit")
	  (list_append oinibody osetretinit))
;;; ending
	(append_commentconst oinibody "end the initproc")
	(debug_msg oinibody "compile2obj_initproc final oinibody")
	(debug_msg gcx "compile2obj_initproc final gcx")
	(debug_msg oinitrout "compile2obj_initproc final oinitrout")
	(return oinitrout)
	))))


(export_values 
 compile2obj_initproc
 compile2obj_procedure
 )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;function to get a free local value pointer for some name
;; any free ptr is only reused for its offset. the objlocv is not reused...
(defun get_free_objlocptr (gcx nam)
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  ;;(debug_msg nam "get_free_objlocptr start nam")
  (let ( (orout (unsafe_get_field :gncx_objrout gcx))
	 (freeli (unsafe_get_field :gncx_freeptrlist gcx)) 
	 (pfree (list_popfirst freeli))
	 (:long off -1)
	 )
    ;;    (debug_msg pfree "get_free_objlocptr start pfree")
    ;;    (debug_msg freeli "get_free_objlocptr popped freeli")
    (if (not (is_a orout class_routineobj))
	(debug_msg orout "get_free_objlocptr bad orout"))
    (assert_msg "check orout" (is_a orout class_routineobj))
    (if (is_a pfree  class_objlocv)
	(let ( (offpfree (unsafe_get_field :obl_off pfree)) )
	  (debug_msg pfree "get_free_objlocptr pfree")
	  (assert_msg "get_free_objlocptr check offpfree" (is_integerbox offpfree))
	  ;; check that pfree has no objnum so was unused 
	  (assert_msg "check pfree not used" (not (get_int pfree)))
	  (setq off (get_int offpfree)))
      (let ( (nbvalorout (unsafe_get_field :obrout_nbval orout)) )
	(setq off (get_int nbvalorout))
	))
    (assert_msg "check off" (>=i off 0))
    (let ( (nbvalbox (unsafe_get_field :obrout_nbval orout)) 
	   (:long nbval (get_int nbvalbox))  
	   (nambuf (make_strbuf discr_strbuf))
	   )
      (cond ( (is_a nam class_named)
	      (let ( (namstr (unsafe_get_field :named_name nam)) )
		(add2sbuf_cident nambuf namstr)))
	    ( (is_string nam)
	      (add2sbuf_cident nambuf nam)))
      (add2sbuf_strconst nambuf "__V")
      (add2sbuf_longdec nambuf (+i nbval 1))
      (put_int nbvalbox (+i nbval 1))
      (let ( (namstr (strbuf2string discr_string nambuf))
	     (oldnbvalbox (make_integerbox discr_integer nbval))
	     (nloc (instance class_objlocv
			     :obv_type ctype_value
			     :obl_off (make_integerbox discr_integer off)
			     :obl_proc orout
			     :obl_cname namstr)) 
	     )
	(debug_msg nloc "get_free_objlocptr new nloc")
	(return nloc)
	))))



;;; function to get a free local long for some name
(defun get_free_objloclong (gcx nam)
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (let ( (orout (unsafe_get_field :gncx_objrout gcx))
	 (freeli (unsafe_get_field :gncx_freelonglist gcx)) 
	 (pfree (list_popfirst freeli))
	 (:long off -1)
	 )
    (assert_msg "check orout" (is_a orout class_routineobj))
    (if (is_a pfree  class_objlocv)
	(let ( (offpfree (unsafe_get_field :obl_off pfree)) )
	  (debug_msg pfree "get_free_objloclong pfree")
	  (assert_msg "check offpfree" (is_integerbox offpfree))
	  ;; check that pfree has no objnum so was unused 
	  (assert_msg "check pfree not used" (not (get_int pfree)))
	  (setq off (get_int offpfree)))
      (let ( (nblongorout (unsafe_get_field :obrout_nblong orout)) )
	(assert_msg "check nblongorout" (is_integerbox nblongorout))
	(setq off (get_int nblongorout))))
    (assert_msg "check off" (>=i off 0))
    (let ( (nblongbox (unsafe_get_field :obrout_nblong orout)) 
	   (:long nblong (get_int nblongbox))  
	   (nambuf (make_strbuf discr_strbuf))
	   )
      (cond ( (is_a nam class_named)
	      (add2sbuf_cident nambuf (unsafe_get_field :named_name nam)))
	    ( (is_string nam)
	      (add2sbuf_cident nambuf nam))
	    )
      (add2sbuf_strconst nambuf "__L")
      (add2sbuf_longdec nambuf (+i nblong 1))
      (put_int nblongbox (+i nblong 1))
      (let ( (nloc (instance class_objlocv
			     :obv_type ctype_long
			     :obl_off (make_integerbox discr_integer off)
			     :obl_proc orout
			     :obl_cname (strbuf2string discr_string nambuf))) )
	(debug_msg nloc "get_free_objloclong new nloc")
	(return nloc)
	))))

;;; function to get a free local otherstuff for some name and ctype
(defun get_free_objloctyped (gcx nam ctyp)
  (debug_msg nam "get_free_objloctyped nam")
  (debug_msg ctyp "get_free_objloctyped ctyp")
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (assert_msg "check ctyp" (is_a ctyp class_ctype))
  (cond ( (== ctyp ctype_long)
	  (return (get_free_objloclong gcx nam)))
	( (== ctyp ctype_value)
	  (return (get_free_objlocptr gcx nam)))
	;; return null for the void ctype
	( (== ctyp ctype_void)
	  (return (the_null)))
	(:else 
	 (debug_msg nam "getfreeobjloctyped nam")
	 (debug_msg ctyp "getfreeobjloctyped ctyp")
	 (let ( (freemap (unsafe_get_field :gncx_freeothermaps gcx)) 
		(orout (unsafe_get_field :gncx_objrout gcx))
		(:long off -1)
		)
	   (assert_msg "check freemap" (is_mapobject freemap))
	   (assert_msg "check orout" (is_a orout class_routineobj))
	   (let ( (freeli (mapobject_get freemap ctyp)) )
	     (if (null freeli) 
		 (progn
		   (setq freeli (make_list discr_list))
		   (mapobject_put freemap ctyp freeli)))
	     (let ( (pfree (list_popfirst freeli)) )
	       (if (is_a pfree  class_objlocv)
		   (progn 
		     (debug_msg pfree "get_free_objloctyped pfree")
		     (assert_msg "check pfree was unused" (not (get_int pfree)))
		     (setq off (get_int (unsafe_get_field :obl_off pfree)))
		     )
		 (setq off  (list_length (unsafe_get_field :obrout_others orout))))
	       (let ( 
		     (nambuf (make_strbuf discr_strbuf)) 
		     (others (unsafe_get_field :obrout_others orout))
		     (:long nbothers (list_length others))
		     )
		 (assert_msg "check others" (is_list others))
		 (add2sbuf_strconst nambuf "loc_")
		 (add2sbuf_cident nambuf  (unsafe_get_field :named_name ctyp))
		 (add2sbuf_strconst nambuf "__o")
		 (add2sbuf_longdec nambuf nbothers)
		 (let ( (nloc (instance class_objlocv
					:obv_type ctyp
					:obl_proc orout
					:obl_off (make_integerbox discr_integer off)
					:obl_cname (strbuf2string discr_string nambuf))) )
		   (debug_msg nloc "getfreeobjloctyped new nloc")
		   (list_append others nloc)
		   (return nloc)
		   )
		 )))))))




;; function to dispose, i.e. mark as free and reusable, an  objlocation
(defun dispose_objloc (oldloc gcx)
  (assert_msg "check oldloc" (is_a oldloc class_objlocv))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  ;; the obl_proc iff it has already been freed
  (assert_msg "check used oldloc" (unsafe_get_field :obl_proc oldloc))
  (let ( (oldcty (unsafe_get_field :obv_type oldloc)) )
    (assert_msg "check oldcty not void" (!= oldcty ctype_void))
    (assert_msg "check oldcty is ctype" (is_a oldcty class_ctype))
    (put_fields oldloc :obl_proc ())			;mark the objlocation as freed
    (debug_msg oldloc "dispose_objloc freed oldloc")
    (cond ( (== oldcty ctype_value)
	    (let  ( (freepl (unsafe_get_field :gncx_freeptrlist gcx)) )
	      (list_append freepl oldloc)))
	  ( (== oldcty ctype_long)
	    (let  ( (freenl (unsafe_get_field :gncx_freelonglist gcx)) )
	      (list_append freenl oldloc)))
	  (:else
	   (let ( (freemap (unsafe_get_field :gncx_freeothermaps gcx)) 
		  (orout (unsafe_get_field :gncx_objrout gcx))
		  )
	     (assert_msg "check freemap" (is_mapobject freemap))
	     (assert_msg "check orout" (is_a orout class_routineobj))
	     (let ( (freeli (mapobject_get freemap oldcty)) )
	       ;; since we are freeing, freeli should exist
	       (assert_msg "check freeli" (is_list freeli))
	       (list_append freeli oldloc))))))
  )

;; function to dispose, i.e. mark as free, a binding 
(defun dispose_bnd_obj (bnd gcx)
  (assert_msg "check bnd" (is_a bnd class_any_binding))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg bnd "dispose_bnd_obj start bnd")
  (let ( (locmap (unsafe_get_field :gncx_locmap gcx))
	 (oldloc (mapobject_get locmap bnd)) )
    ;;(debug_msg locmap "dispose_bnd_obj start locmap")
    (if (null oldloc)
	(progn
	  ;; special hack to dispose a void let binding - return immediately in that case
	  (and (is_a bnd class_let_binding)
	       (== (unsafe_get_field :letbind_type bnd) ctype_void)
	       (return))
	  (debug_msg bnd "dispose_bnd_obj nulloldloc bnd")
	  ))
    (assert_msg "check oldloc" (is_a oldloc class_objlocv))
    ;;(debug_msg oldloc "dispose_bnd_obj oldloc")
    (dispose_objloc oldloc gcx)
    (mapobject_remove locmap bnd)
    (debug_msg bnd "dispose_bnd_obj end bnd")
    ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_chunk (nchk gcx)
  (assert_msg "check nchk" (is_a nchk class_nrep_chunk))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg nchk "compilobj nrepchunk nchk")
  (let ( (loc (unsafe_get_field :nrep_loc nchk))
	 (nexp (unsafe_get_field :nchunk_expansion nchk))
	 (noper (unsafe_get_field :nchunk_oper nchk))
	 (ntyp (unsafe_get_field :nexpr_ctyp nchk))
	 )
    (assert_msg "check noper" (is_a noper class_named))
    (assert_msg "check nexp" (is_multiple nexp))
    (assert_msg "check ntyp" (is_a ntyp class_ctype))
    (let (  (otup (multiple_map
		   nexp
		   (lambda (comp :long ix)
		     (debug_msg comp "compobj nrepchunk comp")
		     (if (== (discrim comp) discr_verbatimstring)
			 comp
		       (compile_obj comp gcx)))
		   ))
	    (oexp (if loc
		      (instance class_objlocatedexpv
				:obv_type ntyp
				:obx_cont otup
				:obcx_loc loc
				)
		    (instance class_objexpv
			      :obv_type ntyp
			      :obx_cont otup)
		    ))      
	    )
      (assert_msg "check ntyp" (is_a ntyp class_ctype))
      (debug_msg oexp "compilobj nrepchunk oexp")
      oexp)
    ))
(install_method class_nrep_chunk compile_obj compilobj_nrep_chunk)


;;;;;;;;;;;;;;;;
(defun getctype_typexpr (recv env)
  (assert_msg "check recv" (is_a recv class_nrep_typexpr))
   (unsafe_get_field :nexpr_ctyp recv))
(install_method class_nrep_typexpr get_ctype getctype_typexpr)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_nil (nilo gcx)
  (assert_msg "check nilo" (is_a nilo class_nrep_nil))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg nilo "compilobj_nrep_nil nilo")
  (let ( (obnil (instance class_objnil
			  :obv_type ctype_value)) )
    (return obnil))
  )

(install_method class_nrep_nil compile_obj compilobj_nrep_nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_comment (ncomm gcx)
  (assert_msg "check ncomm" (is_a ncomm class_nrep_comment))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg ncomm "compilobj_nrep_comment start")
  (let ( (coms (unsafe_get_field :ncomm_string ncomm))
	 (nloc (unsafe_get_field :nrep_loc ncomm))
	 (sbuf (make_strbuf discr_strbuf)) )
    (add2sbuf_strconst sbuf "/**!* ")
    (add2sbuf_ccomstring sbuf coms)
    (add2sbuf_strconst sbuf " *!**/")
    (let ( (ostr (strbuf2string discr_verbatimstring sbuf)) 
	   (res  (instance class_objcompute
			   :obi_loc nloc
			   :obdi_destlist ()
			   :obcpt_expr ostr))
	   )  
      (debug_msg ostr "compilobj_nrep_comment ostr")
      (debug_msg res "compilobj_nrep_comment res")
      (return res)
      )))
(install_method class_nrep_comment compile_obj compilobj_nrep_comment)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_locsymocc (lsyo gcx)
  (assert_msg "check nchk" (is_a lsyo class_nrep_locsymocc))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (let ( (loc (unsafe_get_field :nrep_loc lsyo))
	 (locmap (unsafe_get_field :gncx_locmap gcx))
	 (sym (unsafe_get_field :nocc_symb lsyo))
	 (oty (unsafe_get_field :nocc_ctyp lsyo))
	 (sbnd (unsafe_get_field :nocc_bind lsyo))
	 (ovar (mapobject_get locmap sbnd))
	 )
					;    (debug_msg gcx "compilobj locsymocc gcx")
					;    (debug_msg lsyo "compilobj locsymocc begin lsyo")
					;    (debug_msg sbnd "compilobj locsymocc sbnd")
					;    (debug_msg oty "compilobj locsymocc oty")
					;    (debug_msg ovar "compilobj locsymocc ovar")
    (if (null sbnd)
	(progn
	  (debug_msg lsyo "compilobj locsymocc null sbnd; lsyo=")
	  (debug_msg sym "compilobj locsymocc null sbnd; sym=")
					; (shortbacktrace_dbg "compilobj locsymocc  null sbnd" 16)
	  (assert_msg "locsymocc without binding" ())
	  ))
    (if (null ovar) 
	(progn
	  (debug_msg sbnd "compilobj locsymocc null ovar sbnd")
	  ;;(debug_msg gcx "compilobj locsymocc null ovar gcx")
	  ;;(debug_msg locmap "compilobj locsymocc null ovar locmap")
	  (debug_msg lsyo "compilobj locsymocc null ovar lsyo")
	  (assert_msg "compilobj locsymocc null ovar without ctype_void" (== oty ctype_void))
	  )
      (assert_msg "compilobj locsymocc check ovar"  (is_a ovar class_objlocv)))
					;    (debug_msg ovar "compilobj locsymocc return ovar")
    (return ovar)
    ))
(install_method class_nrep_locsymocc compile_obj compilobj_nrep_locsymocc)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_closedocc (nclo gcx)
  (assert_msg "check nclo" (is_a nclo class_nrep_closedocc))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg nclo "compilobj closedocc nclo")
  ;;(debug_msg gcx "compilobj closedocc gcx")
  (let ( 
	(orout (unsafe_get_field :gncx_objrout gcx))
	(osym (unsafe_get_field :nocc_symb nclo))
	(obind (unsafe_get_field :nocc_bind nclo))
	(cprocs (unsafe_get_field :ncloc_procs nclo))
	(lastcproc (pair_head (list_last cprocs)))
	(nloc (unsafe_get_field :nrep_loc nclo))
	)
    ;;(debug_msg orout "compilobj closedocc orout")
    ;;(debug_msg nclo "compilobj closedocc nclo")
    ;;(debug_msg lastcproc "compilobj closedocc lastcproc")
    (assert_msg "check lastcproc" (is_a lastcproc class_nrep_routproc))
    (let ( (cloblis (unsafe_get_field :nrpro_closedb lastcproc)) 
	   (:long clorank -1)
	   )
      (assert_msg "check cloblis" (is_list cloblis))
      (let ( (curpair (list_first cloblis)) 
	     (:long curank 0)
	     )
	(forever 
	 looplis
	 (if (not (is_pair curpair)) (exit looplis))
	 (let ( (curbind (pair_head curpair)) )
	   (if (== curbind obind)
	       (progn
		 (setq clorank curank)
		 (exit looplis)))
	   (setq curpair (pair_tail curpair))
	   (setq curank (+i curank 1))
	   ))
	(assert_msg "check good closed rank" (>=i clorank 0))
	(let ( 
	      (nclotyp (unsafe_get_field :nocc_ctyp nclo))
	      (ocloccv 
	       (instance class_objcloccv
			 :obv_type nclotyp
			 :obc_off (make_integerbox discr_integer
						   clorank)
			 :obc_proc lastcproc
			 :obc_name (unsafe_get_field :named_name osym)))
	      )
	  (assert_msg "check nclotyp" (is_a nclotyp class_ctype))
	  (debug_msg ocloccv "compilobj closedocc result ocloccv")
	  ocloccv
	  )))))

(install_method class_nrep_closedocc compile_obj compilobj_nrep_closedocc)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_constocc (ncnst gcx)
  (assert_msg "check ncnst" (is_a ncnst class_nrep_constocc))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg ncnst "compilobj_nrep_constocc ncnst")
  ;;(debug_msg gcx "compilobj constocc gcx")
  (let ( 
	(orout (unsafe_get_field :gncx_objrout gcx))
	(osym (unsafe_get_field :nocc_symb ncnst))
	(cprocs (unsafe_get_field :ncloc_procs ncnst))
	(lastcproc (pair_head (list_last cprocs)))
	(nloc (unsafe_get_field :nrep_loc ncnst))
	)
    ;;(debug_msg orout "compilobj constocc orout")
    ;;(debug_msg nloc "compilobj constocc nloc")
    (debug_msg lastcproc "compilobj_nrep_constocc lastcproc")
    (assert_msg "check lastcproc" (is_a lastcproc class_nrep_routproc))
    (let ( (cnstlis (unsafe_get_field :nrpro_const lastcproc)) 
	   (:long cnstrank -1)
	   )
      (assert_msg "check cnstlis" (is_list cnstlis))
      (let ( (curpair (list_first cnstlis)) 
	     (:long curank 0)
	     )
	(forever 
	 looplis
	 (if (not (is_pair curpair)) (exit looplis))
	 (let ( (curelem (pair_head curpair)) )
	   (if (== curelem ncnst)
	       (progn
		 (setq cnstrank curank)
		 (exit looplis)))
	   (setq curpair (pair_tail curpair))
	   (setq curank (+i curank 1))
	   ))
	(assert_msg "check good const rank" (>=i cnstrank 0))
	(let ( 
	      (cnstyp (unsafe_get_field :nocc_ctyp ncnst))
	      (oconstv 
	       (instance class_objconstv
			 :obv_type cnstyp
			 :obc_off (make_integerbox discr_integer
						   cnstrank)
			 :obc_proc lastcproc
			 :obc_name (unsafe_get_field :named_name osym))) )
	  (assert_msg "check cnstyp" (is_a cnstyp class_ctype))
	  (debug_msg oconstv "compilobj constocc result oconstv")
	  oconstv
	  )))))

(install_method class_nrep_constocc compile_obj compilobj_nrep_constocc)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_importedval (nsva gcx)
  (assert_msg "check gcx" (is_a gcx class_initgenercontext))
  (assert_msg "check nsva" (is_a nsva class_nrep_importedval))
  (debug_msg nsva "compilobj_nrep_importedval nsva")
  (debug_msg gcx "compilobj_nrep_importedval gcx")
  (let ( (var (unsafe_get_field :nimport_symb nsva))
	 (olocv (mapobject_get (unsafe_get_field :igncx_importmap gcx) var))
	 )
    (debug_msg olocv "compilobj_nrep_importedval result olocv")
    (assert_msg "check var" (is_a var class_symbol))
    (assert_msg "check olocv" (is_a olocv class_objlocv))
    (return olocv)
    ))
(install_method class_nrep_importedval compile_obj compilobj_nrep_importedval)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a quasiconstant
(defun compilobj_nrep_quasiconstant (nconst gcx)
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (assert_msg "check nconst" (is_a nconst class_nrep_quasiconstant))
  (debug_msg nconst "compilobj quasiconstant nconst")
  (let ( (nloc (unsafe_get_field :nrep_loc nconst))
	 (sval (unsafe_get_field :nconst_sval nconst))
	 (data (unsafe_get_field :nconst_data nconst))
	 (proc (unsafe_get_field :nconst_proc nconst))
	 )
    (if (is_a proc class_nrep_routproc)
	(let ( (constlist (unsafe_get_field :nrpro_const proc)) 
	       (curpair (list_first constlist))
	       (:long coff -1)
	       (:long curank 0)
	       (nambuf (make_strbuf discr_strbuf))
	       )
	  (forever 
	   constloop
	   (if (is_pair curpair)
	       (let ((curconst (pair_head curpair)))
		 (if (== curconst data)
		     (progn
		       (setq coff curank)
		       (exit constloop)))
		 )
	     (exit constloop))
	   (setq curpair (pair_tail curpair))
	   (setq curank (+i curank 1))
	   )
	  (assert_msg "check coff" (>=i coff 0))
	  (add2sbuf_strconst nambuf "konst_")
	  (add2sbuf_longdec nambuf coff)
	  (if (is_a sval class_named)
	      (progn
		(add2sbuf_strconst nambuf "_")
		(add2sbuf_cident nambuf (unsafe_get_field :named_name sval))
		)
	    )
	  (let ( (constv 
		  (instance class_objconstv
			    :obv_type ctype_value
			    :obc_off (make_integerbox discr_integer coff)
			    :obc_proc proc
			    :obc_name (strbuf2string discr_string nambuf)
			    )) )
	    (debug_msg constv "compilobj quasiconstant constv")
	    (return constv)
	    )
	  )
      (let ( (odata (compile_obj data gcx)) )
	;; not inside a proc, just return the compiled data
	(debug_msg odata "compilobj quasiconstant odata")
	(return odata)
	)
      )
    )
  )
(install_method class_nrep_quasiconstant compile_obj compilobj_nrep_quasiconstant)

(defun compilobj_nrep_quasiconst_current_module_environment_container (nqcme gcx)
  (debug_msg nqcme "start of compilobj_nrep_quasiconst_current_module_environment_container")
  (assert_msg "check nqme" (is_a nqcme class_nrep_quasiconst_current_module_environment_container))
  (let ( (onres (compilobj_nrep_quasiconstant nqcme gcx))
	 (scomm (unsafe_get_field :nqcmec_comment nqcme))
	 (str (let ( (sbuf (make_strbuf discr_strbuf)) )
		(add2sbuf_strconst sbuf "/*quasi.cur.mod.env.cont ")
		(add2sbuf_ccomstring sbuf scomm)
		(add2sbuf_strconst sbuf "*/\n")
		(strbuf2string discr_verbatimstring sbuf)
		)
	      )
	 (ores (instance class_objlocatedexpv
			 :obv_type ctype_value
			 :obcx_loc (unsafe_get_field :nrep_loc nqcme)
			 :obx_cont (make_tuple2 
				    discr_multiple
				    str
				    onres
				    )
			 ))
	 )
    (debug_msg ores "compilobj_nrep_quasiconstant_current_module_environment_container result ores")
    (return ores)
    ))
(install_method class_nrep_quasiconst_current_module_environment_container compile_obj
		compilobj_nrep_quasiconst_current_module_environment_container)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a forever
(defun compilobj_nrep_forever (nfor gcx)
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (assert_msg "check nfor" (is_a nfor class_nrep_forever))
  (debug_msg nfor "compilobj_nrep_forever nfor")
  ;;(debug_msg gcx "compilobj_nrep_forever gcx")
  (let ( (nloc (unsafe_get_field :nrep_loc nfor))
	 (nbind (unsafe_get_field :nforever_bind nfor))
	 (nbody (unsafe_get_field :nforever_body nfor))
	 (nres (unsafe_get_field :nforever_result nfor)) 
	 (oresv (get_free_objlocptr gcx nres))
;;;; the 99bis are useless - just for devbugging! should be removed later
	 (nbind99bis (unsafe_get_field :nforever_bind nfor))
	 (oresv99bis oresv)
	 )
    (debug_msg nbind "compilobj_nrep_forever initial nbind")
    (debug_msg (discrim nbind) "compilobj_nrep_forever initial nbind's class")
    (debug_msg (unsafe_get_field :labind_clonsy nbind) ":labind_clonsy in nbind")
    (assert_msg "check nbind" (is_a nbind class_label_binding))
    (debug_msg oresv "compilobj_nrep_forever oresv")
    (assert_msg "check oresv" (is_a oresv class_objlocv))
    (unsafe_put_fields nbind :labind_res oresv)
    (assert_msg "check again nbind" (is_object nbind))
    (debug_msg (unsafe_get_field :labind_clonsy nbind99bis) ":labind_clonsy in nbind99bis")
    (assert_msg "check 99bis nbind" (== nbind99bis nbind))
    (assert_msg "check 99bis oresv" (== oresv99bis oresv))
    (debug_msg nbind "compilobj_nrep_forever updated nbind")
    (let ( (closy (unsafe_get_field :labind_clonsy nbind)) 
	   (bodyl (make_list discr_list))
	   (epilogl (make_list discr_list))
	   (oloop (instance class_objloop
			    :obi_loc nloc
			    :oblo_bodyl bodyl
			    :oblo_epil epilogl
			    :obloop_label closy
			    :obloop_resv oresv))
	   )
      (assert_msg "check closy" (is_a closy class_clonedsymbol))
      (multiple_every
       nbody
       (lambda (ncomp :long ix)
	 (list_append bodyl (compile_obj ncomp gcx))))
      (debug_msg oloop "compilobj forever result oloop")
      oloop
      )
    )  
  )
(install_method class_nrep_forever compile_obj compilobj_nrep_forever)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile an exit
(defun compilobj_nrep_exit (nexi gcx)
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (assert_msg "check nexi" (is_a nexi class_nrep_exit))
  (debug_msg nexi "compilobj_nrep_exit nexi")
  ;;(debug_msg gcx "compilobj_nrep_exit gcx")
  (let ( 
	(nloc (unsafe_get_field :nrep_loc nexi))
	(nbindx (unsafe_get_field :nexit_bind nexi))
	(nval (unsafe_get_field :nexit_val nexi)) )
    (assert_msg "check nbindx" (is_a nbindx class_label_binding))
    (let ( 
	  (inslist (make_list discr_list)) 
	  (epilist (make_list discr_list)) 
	  (destlist (make_list discr_list))
	  (oval (compile_obj nval gcx))
	  (bxres (unsafe_get_field :labind_res nbindx))
	  (obloc (instance class_objblock
			   :obi_loc nloc
			   :oblo_bodyl inslist
			   :oblo_epil epilist
			   ))
	  (obex (instance class_objexit
			  :obi_loc nloc
			  :obexit_label (unsafe_get_field :labind_clonsy nbindx)
			  )) 
	  (obcom (instance class_objcompute
			   :obi_loc nloc
			   :obdi_destlist destlist
			   :obcpt_expr oval))
	  )
      (list_append inslist obcom)
      (list_append epilist obex)
      (list_append destlist bxres)
      (debug_msg obloc "compilobj_nrep_exit return obloc")
      (return obloc)
      )))
(install_method class_nrep_exit compile_obj compilobj_nrep_exit)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_discrany (anyv gcx)
  (assert_msg "check gcx" (is_a gcx class_genercontext))
					;  (debug_msg anyv "compilobj_discrany anyv")
  anyv
  )
(install_method discr_anyrecv compile_obj compilobj_discrany)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_let (rlet gcx)
  (assert_msg "check rlet" (is_a rlet class_nrep_let))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (let ( (loc (unsafe_get_field :nrep_loc rlet))
	 (bnds (unsafe_get_field :nlet_bindings rlet))
	 (bdy (unsafe_get_field :nlet_body rlet))
	 (locmap (unsafe_get_field :gncx_locmap gcx))
	 (obodl (make_list discr_list))
	 (oepil (make_list discr_list))
	 (oblock (instance class_objblock
			   :obi_loc loc
			   :oblo_bodyl obodl
			   :oblo_epil oepil))
	 )
    (debug_msg rlet "compilobj_nrep_let initial rlet")
    (debug_msg loc "compilobj_nrep_let initial loc")
    ;;(debug_msg locmap "compilobj_nrep_let initial locmap")
    ;;(debug_msg bdy "compilobj_nrep_let initial bdy")
    ;;    (debug_msg gcx "compilobj_nrep_let gcx")
    ;;    (debug_msg bnds "compilobj_nrep_let bnds")
    ;; for each normalexp in the bnds tuple
    ;; add the binding and the setting in the body and the clear in the epilogue
    (assert_msg "compilobj_nrep_let check bnds multiple" (is_multiple_or_null bnds))
    ;;(debug_msg loc "compilobj_nrep_let before iterate normbind loc")
    ;; iterate on normal bindings
    (multiple_every
     bnds
     (lambda (nlbnd :long ix)
       (debug_msg loc "compilobj_nrep_let current normbinding loc")
       (debug_msg nlbnd "compilobj_nrep_let current normbinding nlbnd")
       (debug_msg locmap "compilobj_nrep_let current normbinding locmap")
       (assert_msg "check nlbnd in compilobj_nrep_let" (is_a nlbnd class_normlet_binding))
       (let ( (bder (unsafe_get_field :binder nlbnd))
	      (cty (unsafe_get_field :letbind_type nlbnd))
	      (nexp (unsafe_get_field :letbind_expr nlbnd))
	      (obva (get_free_objloctyped gcx bder cty))
	      )
	 (debug_msg obva "compilobj_nrep_let current normbinding obva")
	 (debug_msg nexp "compilobj_nrep_let current normbinding nexp")
	 (let ( (obnx (compile_obj nexp gcx)) )
	   (debug_msg obnx "compilobj_nrep_let current normbinding obnx")
	   (if (is_a nexp class_sexpr) 
	       (if (not (is_object obnx))
		   (progn 
		     (debug_msg nexp "compilobj_nrep_let current normbinding faulty nexp")
		     (debug_msg obnx "compilobj_nrep_let current normbinding faulty obnx")
		     (assert_msg "compilobj_nrep_let check obnx" (is_object obnx)))))
	   (if obva
	       ;; non void cty
	       (progn
		 (mapobject_put locmap nlbnd obva)
		 (let ( (obpd (put_objdest obnx obva)) 
			(obmy (or obpd obnx))
			)
		   (debug_msg obpd "compilobj_nrep_let current obpd")
		   (debug_msg obmy "compilobj_nrep_let append obmy")
		   (list_append obodl obmy)
		   ))
	     (progn
	       ;; obva is nil when cty is void type 
	       (debug_msg obnx "compilobj_nrep_let append obnx")
	       (list_append obodl obnx)
	       ))
	   ;; add clearing of obva to epilogue part of oblock
	   (if obva 
	       (let ( (obcl (instance class_objclear
				      :obi_loc loc
				      :oclr_vloc obva)) 
		      )
		 (list_append oepil obcl)
		 ))))))
    (debug_msg loc "compilobj_nrep_let after iterate normbind loc")
    (debug_msg locmap "compilobj_nrep_let updated locmap")
    ;; compile each body component
    (multiple_every
     bdy
     (lambda (bdycomp :long ix)
       (debug_msg loc "compilobj_nrep_let body loc")
       (debug_msg bdycomp "compilobj_nrep_let body bdycomp")
       (let ( (objcomp  (compile_obj bdycomp gcx)) 
	      )
	 (debug_msg objcomp "compilobj_nrep_let body objcomp")
	 ;; objcomp is null when compiling a locvar of ctype_void;
	 ;; this happens with primitive of :void type
	 (if (null objcomp) (return objcomp)) ;return from the inner lambda
	 (list_append obodl objcomp))))
    (debug_msg loc "compilobj_nrep_let after iterate body loc")
    ;; dispose each binding
    (multiple_every
     bnds
     (lambda (obnd :long ix)
       (debug_msg loc "compilobj_nrep_let dispose loc")
       (debug_msg obnd "compilobj_nrep_let disposing obnd")
       (dispose_bnd_obj obnd gcx)))
    (debug_msg loc "compilobj_nrep_let quasifinal loc")
    (debug_msg locmap "compilobj_nrep_let final locmap")
    (debug_msg loc "compilobj_nrep_let final loc")
    (debug_msg oblock  "compilobj_nrep_let return oblock")
    (return oblock)			;return it
    ))

(install_method class_nrep_let compile_obj compilobj_nrep_let)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun compilobj_nrep_citeration (nciter gcx)
  (assert_msg "check nciter" (is_a nciter class_nrep_citeration))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg nciter "compilobj_nrep_citeration nciter")
  (let ( (loc (unsafe_get_field :nrep_loc nciter))
	 (obrout (unsafe_get_field :gncx_objrout gcx))
	 (citer (unsafe_get_field :nciter_citerator nciter))
	 (nlocbind (unsafe_get_field :nciter_locbindings nciter))
	 (nchkbef (unsafe_get_field :nciter_chunkbefore nciter))
	 (nstatocc (let ( (ns (unsafe_get_field :nciter_statocc nciter)) ) 
		     (assert_msg "check nstatocc" (is_a ns class_nrep_locsymocc))
		     (debug_msg ns "compilobj_nrep_citeration nstatocc")
		     ns))
	 (nbody (unsafe_get_field :nciter_body nciter))
	 (nbodbind (unsafe_get_field :nciter_bodbindings nciter))
	 (nchkaft (unsafe_get_field :nciter_chunkafter nciter))
	 (nstatbind (let ( (bi (unsafe_get_field :nocc_bind nstatocc)) )
		      (assert_msg "check nstatbind" (is_a bi class_normlet_binding))
		      bi))
	 (nstatsy (unsafe_get_field :binder nstatbind))
	 (ostat (get_free_objloctyped gcx nstatsy (unsafe_get_field :nocc_ctyp nstatocc)))
	 (obodl (make_list discr_list))
	 (oepil (make_list discr_list))
	 (ocblock (instance class_objciterblock
			    :obi_loc loc
			    :oblo_bodyl obodl
			    :oblo_epil oepil
			    :obciter_citer citer
			    :obciter_before ()
			    :obciter_after ()
			    ))
	 (locmap  (unsafe_get_field  :gncx_locmap gcx))
	 )
    (debug_msg nlocbind "compilobj_nrep_citeration nlocbind")
    (assert_msg "check citer" (is_a citer class_citerator))
    (assert_msg "check locmap" (is_mapobject locmap))
    (assert_msg "check nlocbind" (is_multiple_or_null nlocbind))
    (multiple_every
     nlocbind
     (lambda (nlbnd :long ix)
       (debug_msg nlbnd "compilobj_nrep_citeration current nlocbinding nlbnd")
       (assert_msg "check nlbnd in compilobj_nrep_citeration" (is_a nlbnd class_normlet_binding))
       (let ( (bder (unsafe_get_field :binder nlbnd))
	      (cty (unsafe_get_field :letbind_type nlbnd))
	      (nexp (unsafe_get_field :letbind_expr nlbnd))
	      (oblva (get_free_objloctyped gcx bder cty))
	      )
	 (debug_msg bder "compilobj_nrep_citeration current local binder")
	 (debug_msg oblva "compilobj_nrep_citeration current oblva")
	 (if (!= cty ctype_void)
	     (let ( (oclr (instance class_objclear
				    :obi_loc loc
				    :oclr_vloc oblva) ) )
	       (list_append oepil oclr)
	       (mapobject_put locmap nlbnd oblva)
	       (debug_msg nlbnd "compilobj_nrep_citeration added clear for nlbnd")
	       ))
	 )))
    (debug_msg ocblock "compilobj_nrep_citeration ocblock start")
    (let ( (boxcntciter (unsafe_get_field :obrout_cntciter obrout))
	   (:long cnt (+i 1 (get_int boxcntciter)))
	   (statstr 
	    (let ( (sbu (make_strbuf discr_strbuf)) )
	      (put_int boxcntciter cnt)
	      (add2sbuf_strconst sbu "cit")
	      (add2sbuf_longdec sbu cnt)
	      (add2sbuf_strconst sbu "__")
	      (add2sbuf_cident sbu (unsafe_get_field :named_name nstatsy))
	      (strbuf2string discr_verbatimstring sbu)
	      ))
	   )
      (unsafe_put_fields 
       ocblock
       :obciter_before (multiple_map 
			nchkbef 
			(lambda (cbef :long ix)
			  (cond 
			   ((is_string cbef) cbef)
			   ((== cbef nstatocc) statstr)
			   (:else
			    (debug_msg cbef "compilobj_nrep_citeration cbef")
			    (let ( (obef (compile_obj cbef gcx)) )
			      (debug_msg obef "compilobj_nrep_citeration obef")
			      obef
			      )))))
       :obciter_after (multiple_map
		       nchkaft 
		       (lambda (caft :long ix)
			 (cond 
			  ((is_string caft) caft)
			  ((== caft nstatocc) statstr)
			  (:else
			   (debug_msg caft "compilobj_nrep_citeration caft")
			   (let ( (oaft (compile_obj caft gcx)) )
			     (debug_msg oaft "compilobj_nrep_citeration oaft")
			     oaft
			     )))))
       )
      )
    (debug_msg ocblock "compilobj_nrep_citeration ocblock filled before&after chunks")
    (assert_msg "check nbodbind" (is_list_or_null nbodbind))
    (list_every
     nbodbind
     (lambda (nbbnd :long ix)
       (debug_msg nbbnd "compilobj_nrep_citeration current nbodbinding nbbnd")
       (assert_msg "check nbbnd in compilobj_nrep_citeration" (is_a nbbnd class_normlet_binding))
       (let ( (bder (unsafe_get_field :binder nbbnd))
	      (cty (unsafe_get_field :letbind_type nbbnd))
	      (nexp (unsafe_get_field :letbind_expr nbbnd))
	      (obbva (get_free_objloctyped gcx bder cty))
	      )
	 (debug_msg obbva "compilobj_nrep_citeration current obbva")
	 (if (!= cty ctype_void)
	     (let ( (oclr (instance class_objclear
				    :obi_loc loc
				    :oclr_vloc obbva)) 
		    )
	       (list_append oepil oclr)
	       (mapobject_put locmap nbbnd obbva)
	       (debug_msg obbva "compilobj_nrep_citeration added clear for obbva")
	       )
	   )
	 (let ( (ocur (compile_obj nexp gcx)) )
	   (debug_msg ocur "compilobj_nrep_citeration raw ocur")
	   (if (!= cty ctype_void)
	       (progn
		 (debug_msg obbva "compilobj_nrep_citeration putobjdest obbva")
		 (let ( (newocur (put_objdest ocur obbva)) )
		   (debug_msg newocur "compilobj_nrep_citeration putobjdest newocur")
		   (if newocur 
		       (list_append obodl newocur)
		     (list_append obodl ocur))
		   ))
	     (progn
	       (debug_msg ocur "compilobj_nrep_citeration ocur")
	       (list_append obodl ocur)
	       )))
	 )))
    (debug_msg nbody "compilobj_nrep_citeration nbody")
    (multiple_every
     nbody
     (lambda (ncurbod :long ix)
       (debug_msg ncurbod "compilobj_nrep_citeration ncurbod")
       (let ( (ocbod (compile_obj ncurbod gcx)) )
	 (debug_msg ocbod "compilobj_nrep_citeration ocbod")
	 (list_append obodl ocbod)
	 )))
					;(debug_msg ocblock "compilobj_nrep_citeration ocblock after body compil")
    (debug_msg ocblock "compilobj_nrep_citeration final ocblock")
    (return ocblock)
    )
  )

(install_method class_nrep_citeration compile_obj compilobj_nrep_citeration)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a setq
(defun compilobj_nrep_setq (nsq gcx)
  (assert_msg "check nsq" (is_a nsq class_nrep_setq))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg nsq "compilobj_nrep_setq nsq")
  (let ( (loc (unsafe_get_field :nrep_loc nsq))
	 (var (unsafe_get_field :nstq_var nsq))
	 (exp (unsafe_get_field :nstq_exp nsq))
	 (cexp (compile_obj exp gcx))
	 (cvar (compile_obj var gcx))
	 (cres (put_objdest cexp cvar))
	 )
    (and (is_a cres class_objinstr)
	 (null (unsafe_get_field :obi_loc cres))
	 (unsafe_put_fields cres :obi_loc loc))
    (debug_msg cres "compilobj_nrep_setq cres")
    cres
    ))
(install_method class_nrep_setq compile_obj compilobj_nrep_setq)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a progn
(defun compilobj_nrep_progn (npro gcx)
  (assert_msg "check npro" (is_a npro class_nrep_progn))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg npro "compilobj_nrep_progn npro")
  (let ( (loc (unsafe_get_field :nrep_loc npro))
	 (nseq (unsafe_get_field :nprogn_seq npro))
	 (nlast (unsafe_get_field :nprogn_last npro))
	 (bodyl (make_list discr_list))
	 (oblock (instance class_objblock
			   :obi_loc loc
			   :oblo_bodyl bodyl
			   ;; :oblo_epil is left null
			   ))
	 )
    (multiple_every
     nseq
     (lambda (ncomp :long ix)
       (let ( (ocomp (compile_obj ncomp gcx)) )
	 (list_append bodyl ocomp)
	 )))
    (let ( (olast (compile_obj nlast gcx)) )
      (list_append bodyl olast))
    (debug_msg oblock "compilobj_nrep_progn oblock")
    (return oblock)
    ))
(install_method class_nrep_progn compile_obj compilobj_nrep_progn)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a multacc [data multiple accessor]
(defun compilobj_nrep_multacc (nma gcx)
  (assert_msg "check nma" (is_a nma class_nrep_multacc))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg nma "compilobj_nrep_multacc nma")
  (let ( (loc (unsafe_get_field :nrep_loc nma))
	 (mul (unsafe_get_field :naccm_mul nma))
	 (ix (unsafe_get_field :naccm_ix nma))
	 (cmul (compile_obj mul gcx))
	 ;; we factor the case when the tuple access cannot be done at
	 ;; compile time
	 (makecompute 
	  (lambda ()
	    (let (
		  (tcont 
		   (make_tuple5 
		    discr_multiple
		    (make_stringconst discr_verbatimstring "/*multacc*/(melt_multiple_nth((")
		    cmul
		    (make_stringconst discr_verbatimstring "), (")
		    ix
		    (make_stringconst discr_verbatimstring ")))")
		    ))
		  (res 
		   (instance class_objexpv
			     :obv_type ctype_value
			     :obx_cont tcont))
		  )
	      (debug_msg res "compilobj_nrep_multacc makecompute res")
	      res
	      ))
	  )
	 )
    (debug_msg cmul "compilobj_nrep_multacc cmul")
    (debug_msg nma "compilobj_nrep_multacc again nma")
    (if (and
	 (is_a cmul class_objinitmultiple)
	 (is_integerbox ix))
	(let ( (comptup (unsafe_get_field :oim_tupval cmul)) )
	  (if (is_multiple comptup)
	      (let (
		    (curval (multiple_nth comptup (get_int ix))) 
		    )
		(debug_msg curval "compilobj_nrep_multacc returning curval")
		(return curval)
		)
	    (makecompute)
	    ))
      (makecompute)
      )))
(install_method class_nrep_multacc compile_obj compilobj_nrep_multacc)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a fieldacc [data field accessor]
(defun compilobj_nrep_fieldacc (nfa gcx)
  (assert_msg "check nfa" (is_a nfa class_nrep_fieldacc))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg nfa "compilobj_nrep_fieldacc nfa")
  (let ( (loc (unsafe_get_field :nrep_loc nfa))
	 (obj (unsafe_get_field :naccf_obj nfa))
	 (fld (unsafe_get_field :naccf_fld nfa))
	 (:long fldoff (get_int fld))
	 (boxfldoff (make_integerbox discr_integer fldoff))
	 (cobj (compile_obj obj gcx))
	 ;; we factor the case when the field access cannot be done at
	 ;; compile time
	 (makecompute 
	  (lambda ()
	    (let ( 
		  (tcont 
		   (make_tuple5 discr_multiple  
				(make_stringconst discr_verbatimstring "/*fieldacc*/(melt_field_object((melt_ptr_t)(")
				cobj
				(make_stringconst discr_verbatimstring "),")
				boxfldoff
				(make_stringconst discr_verbatimstring "))")
				)) 
		  (res 
		   (instance class_objexpv
			     :obv_type ctype_value
			     :obx_cont tcont))
		  )
	      (debug_msg res "compilobj_nrep_fieldacc makecompute res")
	      res
	      )))
	 )
    (assert_msg "compilobj_nrep_fieldacc check fld" (is_a fld class_field))
    (debug_msg cobj "compilobj_nrep_fieldacc cobj")
    (debug_msg fld "compilobj_nrep_fieldacc fld")
    (if (is_a cobj class_objinitobject)
	(let ( (cdata (unsafe_get_field :oie_data cobj)) 
	       )
	  (if (is_a cdata class_nrep_datainstance)
	      (let ( (slotup (unsafe_get_field :ninst_slots cdata)) 
		     (ourslot (multiple_nth slotup fldoff)) 
		     )
		(if (is_a ourslot class_nrep_data)
		    (let ( (cslot (compile_obj ourslot gcx)) )
		      (debug_msg cslot "compilobj_nrep_fieldacc returning cslot")
		      (return cslot))
		  (return (makecompute))))
	    (return (makecompute)))
	  )
      (return (makecompute))
      )))
(install_method class_nrep_fieldacc compile_obj compilobj_nrep_fieldacc)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile an unsafe get field access
(defun compilobj_nrep_unsafe_get_field (nugf gcx)
  (assert_msg "check nugf" (is_a nugf class_nrep_unsafe_get_field))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg nugf "compilobj_nrep_unsafe_get_field nugf")
  (let ( (loc (unsafe_get_field :nrep_loc nugf)) 
	 (nobj (unsafe_get_field :nuget_obj nugf))
	 (nfield (unsafe_get_field :nuget_field nugf))
	 (dlist (make_list discr_list))
	 (oobj (compile_obj nobj gcx))
	 (ogetslot (instance class_objgetslot
			     :obi_loc loc
			     :obdi_destlist dlist
			     :ogetsl_obj oobj
			     :ogetsl_field nfield))
	 )
    (return ogetslot)
    ))
(install_method class_nrep_unsafe_get_field compile_obj compilobj_nrep_unsafe_get_field)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile an unsafe put fields
(defun compilobj_nrep_unsafe_put_fields (nupf gcx)
  (assert_msg "check nupf" (is_a nupf class_nrep_unsafe_put_fields))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg nupf "compilobj_nrep_unsafe_put_fields nupf")
  (let ( (loc (unsafe_get_field :nrep_loc nupf)) 
	 (nobj (unsafe_get_field :nuput_obj nupf))
	 (nfldass (unsafe_get_field :nuput_fields nupf))
	 (obodl (make_list discr_list))
	 (oepil (make_list discr_list))
	 (oblock (instance class_objblock
			   :obi_loc loc
			   :oblo_bodyl obodl
			   :oblo_epil oepil))
	 (oobj (compile_obj nobj gcx))
	 )
    (multiple_every 
     nfldass
     (lambda (nfa :long ix)
       (assert_msg "check nfa" (is_a nfa class_nrep_fieldassign))
       (let ( (aloc (unsafe_get_field :nrep_loc nfa)) 
	      (afield (unsafe_get_field :nfla_field nfa))
	      (aval (unsafe_get_field :nfla_val nfa))
	      (:long aoff (get_int afield))
	      )
	 (assert_msg "check afield" (is_a afield class_field))
	 (let ( 
	       (oval (compile_obj aval gcx)) 
	       (opuf (instance class_objputslot
			       :obi_loc (if aloc aloc loc)
			       :oslot_odata oobj
			       :oslot_field afield
			       :oslot_offset (make_integerbox discr_integer aoff)
			       :oslot_value oval)) )
	   (assert_msg "compilobj_nrep_unsafe_put_fields check oval not nrep" (not (is_a oval class_nrep)))
	   (list_append obodl opuf))
	 )))
    (list_append obodl (instance class_objtouch
				 :obi_loc loc
				 :otouch_val oobj))
    ;; add the touched obj to the block
    (list_append obodl oobj)
    (return oblock)
    ))
(install_method class_nrep_unsafe_put_fields compile_obj compilobj_nrep_unsafe_put_fields)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a simple application
(defun compilobj_nrep_apply (napp gcx)
  (assert_msg "check napp" (is_a napp class_nrep_apply))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (let ( (loc (unsafe_get_field :nrep_loc napp))
	 (fun (unsafe_get_field :napp_fun napp))
	 (args (unsafe_get_field :napp_args napp))
	 )
    (debug_msg napp "compilobj_nrep_apply napp")
    (let ( (oclos (compile_obj fun gcx)) 
	   (oargs (multiple_map
		   args
		   (lambda (comp :long ix)
		     (let ( (ocomp (compile_obj comp gcx)) )
		       (assert_msg "compilobj_nrep_apply check ocomp not objinstr"
				   (not (is_a ocomp class_objinstr)))
		       ocomp))))
	   (dlist (make_list discr_list))
	   (oapp 
	    (instance 
	     class_objapply
	     :obi_loc loc
	     :obdi_destlist dlist
	     :obapp_clos oclos
	     :obapp_args oargs))
	   )
      (debug_msg oapp "compilobj_nrep_apply return oapp")
      oapp
      )))
(install_method class_nrep_apply compile_obj compilobj_nrep_apply)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_multiapply (nmapp gcx)
  (assert_msg "check napp" (is_a nmapp class_nrep_multiapply))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg nmapp "compilobj_nrep_multiapply nmapp")
  (let ( (loc (unsafe_get_field :nrep_loc nmapp))
	 (rbinds (unsafe_get_field :nmulapp_bindings nmapp))
	 (fun (unsafe_get_field :napp_fun nmapp))
	 (args (unsafe_get_field :napp_args nmapp))
	 (nbody (unsafe_get_field :nmulapp_body nmapp))
	 (locmap (unsafe_get_field :gncx_locmap gcx))
	 (:long nbres (multiple_length rbinds))
	 (reslocs 
	  (multiple_map
	   rbinds
	   (lambda (bind :long ix)
	     (debug_msg bind "compilobj_nrep_multiapply bind")
	     (assert_msg "compilobj_nrep_multiapply check bind" 
			 (is_a bind class_formal_binding))
	     (let ( (bder (unsafe_get_field :binder bind))
		    (cty (unsafe_get_field :fbind_type bind)) 
		    (obva (get_free_objloctyped gcx bder cty))
		    )
	       (assert_msg "compilobj_nrep_multiapply check cty" 
			   (is_a cty class_ctype))
	       ;; link nlbnd to obva in locmap
	       (if obva (mapobject_put locmap bind obva))
	       (debug_msg obva "compilobj_nrep_multiapply obva")
	       obva
	       ))))
	 (obodl (make_list discr_list))
	 (oepil (make_list discr_list))
	 (oblock (instance class_objblock
			   :obi_loc loc
			   :oblo_bodyl obodl
			   :oblo_epil oepil))
	 (oxres (if (>i nbres 1) (make_multiple discr_multiple (-i nbres 1)) ()))
	 (firstres (multiple_nth reslocs 0))
	 (ofun (compile_obj fun gcx))
	 (reslist (make_list discr_list))
	 (oargs (multiple_map args
			      (lambda (comp :long ix)
				(compile_obj comp gcx))))
	 (obody (compile_obj nbody gcx))
	 (omapp (instance class_objmultiapply
			  :obi_loc loc
			  :obdi_destlist reslist
			  :obapp_clos (compile_obj fun gcx)
			  :obapp_args oargs
			  :obmultapp_xres oxres))
	 )
    (if firstres (list_append reslist firstres))
    ;; add every compiled argument to the resulting block unless it is a pure value
    (multiple_every 
     oargs
     (lambda (ocurarg :long ix)
       (debug_msg ocurarg "compilobj_nrep_multiapply ocurarg")
       (if (and ocurarg (is_not_a ocurarg class_objpurevalue))
	   (list_append obodl ocurarg))))
    ;; add the multiapply to the block
    (list_append obodl omapp)
    ;; add the compiled body to the block
    (debug_msg obody "compilobj_nrep_multiapply obody")
    (list_append obodl obody)
    ;; add the clearing of each result to epilog
    (multiple_every 
     reslocs
     (lambda (rloc :long ix)
       (if (>i ix 0) 
	   (let ( (oclear (instance class_objclear 
				    :obi_loc loc
				    :oclr_vloc rloc)) )
	     (list_append oepil oclear)
	     (multiple_put_nth oxres (-i ix 1) rloc)
	     ))))
    ;; dispose the local bindings
    (multiple_every 
     rbinds
     (lambda (bind :long ix) (dispose_bnd_obj bind gcx)))
    (debug_msg oblock "compilobj_nrep_multiapply final oblock")
    oblock
    ))
(install_method class_nrep_multiapply compile_obj compilobj_nrep_multiapply)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a simple message send
(defun compilobj_nrep_msend (nsnd gcx)
  (assert_msg "check nsnd" (is_a nsnd class_nrep_msend))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (let ( (loc (unsafe_get_field :nrep_loc nsnd))
	 (nsel (unsafe_get_field :nsend_sel nsnd))
	 (nrecv (unsafe_get_field :nsend_recv nsnd))
	 (nargs (unsafe_get_field :nsend_args nsnd))
	 )
    (debug_msg nsnd "compilobj_nrep_msend nsnd")
    (let ( (osel (compile_obj nsel gcx))
	   (orecv (compile_obj nrecv gcx))
	   (oargs (multiple_map nargs
				(lambda (comp :long ix)
				  (compile_obj comp gcx))))
	   (osend
	    (instance 
	     class_objmsend
	     :obi_loc loc
	     :obdi_destlist (make_list discr_list)
	     :obmsnd_sel osel
	     :obmsnd_recv orecv
	     :obmsnd_args oargs
	     ))
	   )
      (debug_msg osend "compilobj_nrep_msend osend")
      osend
      )))
(install_method class_nrep_msend compile_obj compilobj_nrep_msend)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a multiresult message send
(defun compilobj_nrep_multimsend (nmsnd gcx)
  (assert_msg "check nmsnd" (is_a nmsnd class_nrep_multimsend))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg nmsnd "compilobj_nrep_multimsend nmsnd")
  (let ( (loc (unsafe_get_field :nrep_loc nmsnd)) 
	 (rbinds (unsafe_get_field :nmulsend_bindings nmsnd))
	 (nbody (unsafe_get_field :nmulsend_body nmsnd))  ; a single normalized expression
	 (nsel (unsafe_get_field :nsend_sel nmsnd))
	 (nrecv (unsafe_get_field :nsend_recv nmsnd))
	 (nargs (unsafe_get_field :nsend_args nmsnd))
	 (locmap (unsafe_get_field :gncx_locmap gcx))
	 (:long nbres (multiple_length rbinds))
	 (reslocs 
	  (multiple_map
	   rbinds
	   (lambda (bind :long ix)
	     (debug_msg bind "compilobj_nrep_multimsend bind")
	     (assert_msg "compilobj_nrep_multimsend check bind" 
			 (is_a bind class_formal_binding))
	     (let ( (bder (unsafe_get_field :binder bind))
		    (cty (unsafe_get_field :fbind_type bind)) 
		    (obva (get_free_objloctyped gcx bder cty))
		    )
	       (assert_msg "compilobj_nrep_multimsend check cty" 
			   (is_a cty class_ctype))
	       ;; link nlbnd to obva in locmap
	       (if obva (mapobject_put locmap bind obva))
	       (debug_msg obva "compilobj_nrep_multimsend obva")
	       obva
	       ))))
	 (oxres (if (>i nbres 1) 
		    (make_multiple discr_multiple  (-i nbres 1))))
	 (firstres (multiple_nth reslocs 0))
	 (osel (compile_obj nsel gcx))
	 (reslist (make_list discr_list))
	 (orecv (compile_obj nrecv gcx))
	 (oargs (multiple_map nargs
			      (lambda (comp :long ix)
				(compile_obj comp gcx))))
	 (obody (compile_obj nbody gcx))
	 (obodl (make_list discr_list))
	 (oepil (make_list discr_list))
	 (oblock (instance class_objblock
			   :obi_loc loc
			   :oblo_bodyl obodl
			   :oblo_epil oepil))
	 (omsend (instance class_objmultimsend
			   :obi_loc loc
			   :obdi_destlist reslist
			   :obmsnd_sel osel
			   :obmsnd_recv orecv
			   :obmsnd_args oargs
			   :obmultsnd_xres oxres))
	 )
    (debug_msg reslocs "compilobj_nrep_multimsend reslocs")
    (if firstres (list_append reslist firstres))
    ;; add every compiled argument to the resulting block unless it is a pure value
    (multiple_every 
     oargs
     (lambda (ocurarg :long ix)
       (debug_msg ocurarg "compilobj_nrep_multimsend ocurarg")
       (if (and ocurarg (is_not_a ocurarg class_objpurevalue))
	   (list_append obodl ocurarg))))
    ;; add the multisend to the block
    (list_append obodl omsend)
    ;; add the compiled body to the block
    (list_append obodl obody)
    ;; add the clearing of each result to epilog
    (multiple_every 
     reslocs
     (lambda (rloc :long ix)
       (if (>i ix 0)
	   (let ( (oclear (instance class_objclear 
				    :obi_loc loc
				    :oclr_vloc rloc)) )
	     (list_append oepil oclear)
	     (multiple_put_nth oxres (-i ix 1) rloc)))))
    ;; dispose the local bindings
    (multiple_every 
     rbinds
     (lambda (bind :long ix) (dispose_bnd_obj bind gcx)))
    (debug_msg oblock "compilobj_nrep_multimsend final oblock")
    oblock
    ))

(install_method class_nrep_multimsend compile_obj compilobj_nrep_multimsend)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; compile bindings
(defun compilobj_any_binding  (bind gcx)
  (assert_msg "check bind" (is_a bind class_any_binding))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg bind "compilobj_any_binding bind")
  (displaydebugmsg bind "class_bind compile_obj recv")
  (outcstring_err "* compilobj unimplemented reciever binding class ")
  (let ( (discr (discrim bind)) ) (outstr_err (unsafe_get_field :named_name discr)))
  (outnewline_err)
  (assert_msg "@@compile_obj should be implemented in anybinding-s subclasses" ())
  )
(install_method class_any_binding compile_obj compilobj_any_binding)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; compile value bindings
(defun compilobj_value_binding  (bind gcx)
  (assert_msg "check bind" (is_a bind class_value_binding))
  (assert_msg "check gcx" (is_a gcx class_initgenercontext))
  (debug_msg bind "compilobj_value_binding bind")
  (let ( (sym (unsafe_get_field :binder bind))
	 (importmap (unsafe_get_field :igncx_importmap gcx))
	 (olocv (mapobject_get importmap sym))
	 )
    (debug_msg olocv "compilobj_value_binding olocv")
    (assert_msg "check olocv" (is_a olocv class_objlocv))
    (return olocv)
    )
  )
(install_method class_value_binding compile_obj compilobj_value_binding)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_fixed_binding (bind gcx)
  (assert_msg "check bind" (is_a bind class_fixed_binding))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg bind "compilobj_fixed_binding bind")
  (let ( (sbdata (unsafe_get_field :fixbind_data bind)) 
	 (osdata (compile_obj sbdata gcx)) )
    (debug_msg osdata "compilobj_fixed_binding osdata")
    (return osdata)
    )
  )
(install_method class_fixed_binding compile_obj compilobj_fixed_binding)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun putobjdest_objvalue (recv desto)
  (assert_msg "check recv" (is_a recv class_objvalue))
  (assert_msg "check desto" (is_a desto class_objlocv))
  (let ( (typrecv (unsafe_get_field :obv_type recv))
	 (typdesto (unsafe_get_field :obv_type desto)) 
	 )
    (cond
     ;; special case when reciver is void
     ( (== typrecv ctype_void)
       (if (== typdesto ctype_void)
	   (return recv)
	 ;; if recv is void we just create a block with recv and the
	 ;; clear of desto
	 (let ( 
	       (obodl (make_list discr_list))
	       (oblk (instance class_objblock
			       ;; dont fill :obi_loc
			       :oblo_bodyl obodl
			       :oblo_epil ()
			       )
		     )
	       (oclr (instance class_objclear
			       ;; dont fill :obi_loc
			       :oclr_vloc desto
			       ))
	       )
	   (list_append obodl recv)
	   (list_append obodl oclr)
	   ;; the last of the block is the destination location, to
	   ;; avoid latter putobjdest-s on the objclear
	   (list_append obodl desto)
	   (return oblk)
	   )))
     ;; common case when desto & recv have same type
     ( (== typrecv typdesto)
       (assert_msg "check same typrecv&rtpdesto" (is_a typrecv class_ctype))
       (let ( (destlis (make_list discr_list))
	      (explis (make_list discr_list))
	      (obc (instance class_objcompute
			     ;; dont fill :obi_loc
			     :obdi_destlist destlis
			     :obcpt_expr explis
			     )) 
	      )
	 (list_append destlis desto)
	 (list_append explis recv)
	 (return obc)))
     ;; error case: type mismatch
     (:else
      (debug_msg recv "putobjdest_objvalue mismatching recv")
      (debug_msg typrecv "putobjdest_objvalue mismatching typrecv")
      (debug_msg desto "putobjdest_objvalue mismatching desto")
      (debug_msg typdesto "putobjdest_objvalue mismatching typdesto")
      (outcstring_err "putobjdest_objvalue type mismatch : recv <")
      (let ( (discr (discrim recv)) ) (outstr_err (unsafe_get_field :named_name discr)))
      (outcstring_err "> & desto<") 
      (let ( (discr (discrim desto)) ) (outstr_err (unsafe_get_field :named_name discr)))
      (outcstring_err ">")
      (outnewline_err)
      (assert_msg "putobjdest_objvalue type mismatch" ())
      (return recv)))
    ))

(install_method class_objvalue  put_objdest  putobjdest_objvalue)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun putobjdest_integer (recv desto)
  (assert_msg "check recv" (is_integerbox recv))
  (assert_msg "check desto" (is_a desto class_objlocv))
  (debug_msg recv "putobjdest_integer recv")
  (debug_msg desto "putobjdest_integer desto")
  (let ( (destlis (make_list discr_list))
	 (explis (make_list discr_list))
	 (typdesto (unsafe_get_field :obv_type desto))
	 (obc (instance class_objcompute
			;; dont fill :obi_loc
			:obdi_destlist destlis
			:obcpt_expr explis
			)) 
	 )
    (assert_msg "check typdesto" (== typdesto ctype_long))
    (list_append destlis desto)
    (list_append explis recv)
    (debug_msg obc "putobjdest_integer return obc")
    obc
    ))
(install_method discr_integer put_objdest putobjdest_integer)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun putobjdest_null (recv desto)
  (assert_msg "check recv" (null recv))
  (assert_msg "check desto" (is_a desto class_objlocv))
  (debug_msg recv "putobjdest_null recv")
  (debug_msg desto "putobjdest_null desto")
  (if (need_dbg 0) (shortbacktrace_dbg "putobjdest_null" 15))
  (let ( (destlis (make_list discr_list))
	 (explis (make_list discr_list))
	 (typdesto (unsafe_get_field :obv_type desto))
	 (obc (instance class_objcompute
			;; dont fill :obi_loc
			:obdi_destlist destlis
			:obcpt_expr explis
			)) 
	 )
    (list_append destlis desto)
    (if (== typdesto ctype_long)
	(list_append explis (make_integerbox discr_integer 0))
      (list_append explis recv))
    (debug_msg obc "putobjdest_null return obc")
    obc
    ))
(install_method discr_nullrecv put_objdest putobjdest_null)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun putobjdest_objblock (recv desto)
  (assert_msg "check recv" (is_a recv class_objblock))
  (assert_msg "check desto" (is_a desto class_objlocv))
					;  (debug_msg recv "putobjdest block recv")
					;  (debug_msg desto "putobjdest block desto")
  (let ( (obl (unsafe_get_field :oblo_bodyl recv))
	 (oep (unsafe_get_field :oblo_epil recv))
	 )
    (assert_msg "check obl" (is_list_or_null obl))
    (assert_msg "check oep" (is_list_or_null oep))
    ;; maybe we should remove in the epilogue any clear of same ctype & offset
    (let ( (lpby (list_last obl))
	   (lasbp (pair_head lpby))
	   )
      (if lasbp 
	  (let ( (uplasb (put_objdest lasbp desto)) )
	    (pair_set_head lpby uplasb)
	    )
	)
      )
					;    (debug_msg recv "putobjdest block updated recv")
    recv
    ))

(install_method class_objblock  put_objdest  putobjdest_objblock)


;;;;;;;;;;
(defun putobjdest_objmultiblock (recv desto)
  (assert_msg "check recv" (is_a recv class_objmultiblock))
  (debug_msg recv "putobjdest_objmultiblock recv")
  (debug_msg desto "putobjdest_objmultiblock recv")
  (let ( (osubcomp (unsafe_get_field :omulblo_subcomp recv)) )
    (assert_msg "check osubcomp" (is_multiple_or_null osubcomp))
    (foreach_in_multiple
     (osubcomp)
     (cursubcomp :long curix)
     (debug_msg cursubcomp "putobjdest_objmultiblock cursubcomp")
     (put_objdest cursubcomp desto))
    (debug_msg recv "putobjdest_objmultiblock done recv")
))
(install_method class_objmultiblock put_objdest putobjdest_objmultiblock)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun putobjdest_objloop (recv desto)
  (assert_msg "check recv" (is_a recv class_objloop))
  (assert_msg "check desto" (is_a desto class_objlocv))
  (let ( (epil (unsafe_get_field :oblo_epil recv)) 
	 (resv (unsafe_get_field :obloop_resv recv))
	 (destlist (make_list discr_list))
	 (obc (instance class_objcompute
			;; dont fill :obi_loc
			:obdi_destlist destlist
			:obcpt_expr resv
			))
	 )
    (list_append destlist desto)
    (assert_msg "check epil" (is_list epil))
    (assert_msg "check resv" (is_a resv class_objlocv))
    (list_append epil obc)
    )
  (debug_msg recv "putobjdest loop updated recv")
  recv
  )
(install_method class_objloop  put_objdest  putobjdest_objloop)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; do nothing when puting a destination into an objexit
(defun putobjdest_objexit (recv desto)
  (assert_msg "check recv" (is_a recv class_objexit))
  (assert_msg "check desto" (is_a desto class_objlocv))
  recv
  )
(install_method class_objexit put_objdest putobjdest_objexit)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_if (rif gcx)
  (assert_msg "check rif" (is_a rif class_nrep_if))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg rif "compilobj_nrep_if rif")
  (let ( (loc (unsafe_get_field :nrep_loc rif))
	 (ntest (unsafe_get_field :nif_test rif))
	 (nthen (unsafe_get_field :nif_then rif))
	 (nelse (unsafe_get_field :nif_else rif))
	 (nctyp (unsafe_get_field :nexpr_ctyp rif))
	 )
    (assert_msg "check nctyp" (is_a nctyp class_ctype))
    (let ( (otest (compile_obj ntest gcx))
	   (othen (compile_obj nthen gcx))
	   (oelse (if (is_not_a nelse class_nrep_nil) 
		      (compile_obj nelse gcx)))
	   (obif (instance class_objcond
			   :obi_loc loc
			   :obcond_test otest
			   :obcond_then othen
			   :obcond_else oelse))
	   )
      (assert_msg "check otest" (notnull otest))
      (debug_msg obif "compilobj_nrep_if obif")
      obif
      )))
(install_method class_nrep_if compile_obj compilobj_nrep_if)


;;;;;;;;;;;;;;;;
(defun compilobj_nrep_ifisa (rif gcx)
  (assert_msg "check rif" (is_a rif class_nrep_ifisa))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg rif "compilobj_nrep_ifisa rif")
  (let ( (loc (unsafe_get_field :nrep_loc rif))
	 (nthen (unsafe_get_field :nif_then rif))
	 (nelse (unsafe_get_field :nif_else rif))
	 (nctyp (unsafe_get_field :nexpr_ctyp rif))
	 (nval (unsafe_get_field :nifa_val rif))
	 (ncla (unsafe_get_field :nifa_class rif))
	 )
    (assert_msg "check nctyp" (is_a nctyp class_ctype))
    (let ( (othen (compile_obj nthen gcx))
	   (oval (compile_obj nval gcx))
	   (ocla (compile_obj ncla gcx))
	   (oelse (if (is_not_a nelse class_nrep_nil) 
		      (compile_obj nelse gcx)))
	   (otest (instance class_objexpv
			    :obx_cont
			    (make_tuple5 discr_multiple
					 (make_stringconst discr_verbatimstring
							   "/*ifisa*/ melt_is_instance_of((melt_ptr_t)(")
					 oval
					 (make_stringconst discr_verbatimstring
							   "), (melt_ptr_t)(")
					 ocla
					 (make_stringconst discr_verbatimstring
							   "))"))
			    ))
	   (obif (instance class_objcond
			   :obi_loc loc
			   :obcond_test otest
			   :obcond_then othen
			   :obcond_else oelse))
	   )
      (debug_msg obif "compilobj_nrep_ifisa obif")
      obif
      )))
(install_method class_nrep_ifisa compile_obj compilobj_nrep_ifisa)


;;;;;;;;;;;;;
(defun putobjdest_objcond (recv desto)
					;  (debug_msg recv "putobjdest objcond recv")
					;  (debug_msg desto "putobjdest objcond desto")
  (assert_msg "check recv" (is_a recv class_objcond))
  (assert_msg "check desto" (is_a desto class_objlocv))
  (let ( (othen (unsafe_get_field :obcond_then recv))
	 (oelse (unsafe_get_field :obcond_else recv)) 
	 )
					;   (debug_msg othen "putobjdest objcond othen")
					;   (debug_msg oelse "putobjdest objcond oelse")
    (let ( (dthen (put_objdest othen desto))
	   (delse (put_objdest oelse desto)) )
					;      (debug_msg dthen "putobjdest objcond dthen")
					;      (debug_msg delse "putobjdest objcond delse")
      (unsafe_put_fields recv
			 :obcond_then dthen
			 :obcond_else delse)
					;      (debug_msg recv "putobjdest objcond updated recv")
      recv
      )))

(install_method class_objcond  put_objdest  putobjdest_objcond)
;;;;;;;;;;;;;;;;

(defun compilobj_nrep_cppif (pif gcx)
  (assert_msg "check pif" (is_a pif class_nrep_cppif))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg pif "compilobj_nrep_cppif pif")
  (let ( (loc (unsafe_get_field :nrep_loc pif))
	 (ncond (unsafe_get_field :nifp_cond pif))
	 (nthen (unsafe_get_field :nifp_then pif))
	 (nelse (unsafe_get_field :nifp_else pif))
	 (ctyp (unsafe_get_field :nifp_ctyp pif))
	 (scond (cond
		 ( (is_a ncond class_symbol) (unsafe_get_field :named_name ncond))
		 ( (is_string ncond) ncond)
		 (:else (assert_msg "invalid ncond in nrep_cppif" ()))))
	 (othen (compile_obj nthen gcx))
	 (oelse (compile_obj nelse gcx))
	 (res (instance class_objcppif
			:obi_loc loc
			:obifp_cond scond
			:obifp_then othen
			:obifp_else oelse))
	 )
    (debug_msg res "compilobj_nrep_cppif result")
    (return res)
    ))
(install_method class_nrep_cppif compile_obj compilobj_nrep_cppif)


;;;;;;;;;;;;;
(defun putobjdest_objcppif (recv desto)
					;  (debug_msg recv "putobjdest objcppif recv")
					;  (debug_msg desto "putobjdest objcppif desto")
  (assert_msg "check recv" (is_a recv class_objcppif))
  (assert_msg "check desto" (is_a desto class_objlocv))
  (let ( (othen (unsafe_get_field :obifp_then recv))
	 (oelse (unsafe_get_field :obifp_else recv)) 
	 )
					;   (debug_msg othen "putobjdest objcppif othen")
					;   (debug_msg oelse "putobjdest objcppif oelse")
    (let ( (dthen (put_objdest othen desto))
	   (delse (put_objdest oelse desto)) )
					;      (debug_msg dthen "putobjdest objcppif dthen")
					;      (debug_msg delse "putobjdest objcppif delse")
      (unsafe_put_fields recv
			 :obifp_then dthen
			 :obifp_else delse)
					;      (debug_msg recv "putobjdest objcppif updated recv")
      recv
      )))

(install_method class_objcppif  put_objdest  putobjdest_objcppif)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
(defun compilobj_nrep_return (nret gcx)
  (assert_msg "check nret" (is_a nret class_nrep_return))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
					;  (debug_msg gcx "compilobj_nrep_return gcx")
  (debug_msg nret "compilobj_nrep_return nret")
  (let ( (rloc (unsafe_get_field :nrep_loc nret))
	 (rmain (unsafe_get_field :nret_main nret))
	 (rrest (unsafe_get_field :nret_rest nret)) ;; a tuple or nil
	 (retloc (unsafe_get_field :gncx_retloc gcx))
	 (orout (unsafe_get_field :gncx_objrout gcx))
	 (olis (make_list discr_list))
	 (oblock (instance class_objblock
			   :obi_loc rloc
			   :oblo_bodyl olis))
	 (omainv (compile_obj rmain gcx))
	 )
    (assert_msg "check orout" (is_a orout class_routineobj))
    (debug_msg rrest "compilobj_nrep_return rrest")
    (assert_msg "check rrest" (is_multiple_or_null rrest))
    (if (null (unsafe_get_field :obrout_retval orout))
	(unsafe_put_fields orout :obrout_retval retloc))
    (list_append olis (put_objdest omainv retloc))
    (multiple_every
     rrest
     (lambda (rxtra :long ix)
					;       (debug_msg rxtra "compilobj_nrep_return rxtra")
       (let ( (oxres 
	       (instance class_objputxtraresult
			 :obi_loc rloc
			 :obxres_rank (make_integerbox discr_integer ix)
			 :obxres_obloc (compile_obj rxtra gcx))) )
	 ;; maybe we need to compute the ctype of the extra result....
					;	 (debug_msg oxres "compilobj_nrep_return oxres")
	 (list_append olis oxres))))
    (list_append olis 
		 (instance class_objfinalreturn
			   :obi_loc rloc))
    (debug_msg oblock "compilobj_nrep_return final oblock")
    oblock
    )
  )
(install_method class_nrep_return compile_obj compilobj_nrep_return)

(install_method class_nrep_return get_ctype 
		(lambda (recv env) ctype_value))
;; all the closures generated by lambda share the same ...
(definstance discrclosure_objpredef class_objpredef
  :obv_type ctype_value
  :obpredef 'DISCR_CLOSURE
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_lambda (nlam gcx)
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (assert_msg "check nlam" (is_a nlam class_nrep_lambda))
  (debug_msg nlam "compilobj_nrep_lambda nlam")
  (let ( (nloc (unsafe_get_field :nrep_loc nlam))
	 (npro (let 
		   ( (checkpro (unsafe_get_field :nlambda_proc nlam)) )
		 (assert_msg "check checkpro" (is_a checkpro class_nrep_routproc))
		 checkpro))
	 (nam (unsafe_get_field :nrpro_name npro))
	 (nclovtup (unsafe_get_field :nlambda_closedv nlam))
	 (:long nbclosed (multiple_length nclovtup))
	 (locv (get_free_objlocptr gcx nam))
	 (nrou (unsafe_get_field :nlambda_constrout nlam))
	 (orout (unsafe_get_field :gncx_objrout gcx))
	 (olis (make_list discr_list))
	 (oblock (instance class_objblock
			   :obi_loc nloc
			   :oblo_bodyl olis))
	 (destlist (make_list discr_list))
	 )
    (list_append destlist locv)
    (list_append olis 
		 (instance 
		  class_objnewclosure
		  :obi_loc nloc
		  :obnclo_discr discrclosure_objpredef
		  :obnclo_rout 
		  (progn 
		    (debug_msg nrou "compilobj_nrep_lambda should use nrpro_thunklist nrou")
		    (let ( (crou (compile_obj nrou gcx)) )
		      (debug_msg crou "compilobj_nrep_lambda crou")
		      crou)
		    )
		  :obnclo_len (make_integerbox discr_integer nbclosed)
		  :obdi_destlist destlist))
    (multiple_every
     nclovtup
     (lambda (clov :long ix)
       (debug_msg clov "compilobj_nrep_lambda clov")
       (list_append 
	olis
	(instance class_objputclosedv
		  :obi_loc nloc
		  :opclov_clos locv
		  :opclov_off (make_integerbox discr_integer ix)
		  :opclov_cval (compile_obj clov gcx)))))
    ;; we don't need to add any objtouch because the nlam was normalized!
    (list_append olis locv) ;;; last instruction is just the value, which can be set to some dest
    (debug_msg oblock "compilobj_nrep_lambda result oblock")
    oblock
    ))
(install_method class_nrep_lambda compile_obj compilobj_nrep_lambda)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_makeinst (nmki gcx)
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (assert_msg "check nmki" (is_a nmki class_nrep_make_instance))
  (debug_msg nmki "compilobj_nrep_makeinst nmki")
  ;; (debug_msg gcx "compilobj_nrep_makeinst gcx")
  (let ( (nloc (unsafe_get_field :nrep_loc nmki))
	 (ncla (unsafe_get_field :nmins_class nmki))
	 (ncladat (unsafe_get_field :nmins_cladata nmki))
	 (nfields (unsafe_get_field :nmins_fields nmki)) 
	 )
    (assert_msg "check ncla" (is_a ncla class_class))
    (let ( (:long nbfld (multiple_length (unsafe_get_field :class_fields ncla)))
	   (destlist (make_list discr_list))
	   (locv (get_free_objlocptr gcx 'inst))
	   (olis (make_list discr_list))
	   (ocladat (compile_obj ncladat gcx))
	   (oblock (instance class_objblock
			     :obi_loc nloc
			     :oblo_bodyl olis))
	   (orallobj (instance class_objrawallocobj
			       :obi_loc nloc
			       :obrallobj_class ocladat
			       :obrallobj_len (make_integerbox discr_integer nbfld)
			       :obrallobj_classname (unsafe_get_field :named_name  ncla)
			       :obdi_destlist destlist))
	   )
      (list_append destlist locv)
      (list_append olis orallobj)
      ;; handle each field assign
      (multiple_every
       nfields
       (lambda (cfla :long ix)
	 (assert_msg "compilobj_nrep_makeinst check cfla" (is_a cfla class_nrep_fieldassign))
	 (let ( (cfloc (unsafe_get_field :nrep_loc cfla))
		(cfield (unsafe_get_field :nfla_field cfla))
		(cval (unsafe_get_field :nfla_val cfla)) )
	   (assert_msg "compilobj_nrep_makeinst check cfield" (is_a cfield class_field))
	   (list_append 
	    olis
	    (let ( (oval (compile_obj cval gcx)) )
	      (assert_msg "compilobj_nrep_makeinst check oval not nrep" (not (is_a oval class_nrep)))
	      (instance class_objputslot 
			:obi_loc (if cfloc cfloc nloc)
			:oslot_odata locv
			:oslot_field cfield
			:oslot_offset (make_integerbox discr_integer (get_int cfield))
			:oslot_value oval)
	      )))))
      ;; we don't need to add any objtouch because the nmki was normalized!
      (list_append olis locv) ;;; last instruction is just the value, which can be set to some dest
      (debug_msg oblock "compilobj_nrep_makeinst result oblock")
      oblock
      ))
  )
(install_method class_nrep_make_instance compile_obj compilobj_nrep_makeinst)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a procedure should not be called
(defun compilobj_routproc (npro gcx)
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (assert_msg "check npro" (is_a npro class_nrep_routproc))
  (debug_msg gcx "compilobj_routproc gcx")
  (debug_msg npro "compilobj_routproc npro")
  (assert_msg "UNEXPECTED CALL TO compilobj_routproc" ())
  )
(install_method class_nrep_routproc compile_obj compilobj_routproc)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
(defun compilobj_predef (npr gcx)
  (assert_msg "check gcx" (is_a gcx class_genercontext))
					;  (debug_msg npr "compilobj_predef npr")
  (let ( (opr (instance class_objpredef
			:obv_type ctype_value
			:obpredef (unsafe_get_field :nrpredef npr))) )
					;    (debug_msg opr "compilobj_predef opr")
    opr)
  )

(install_method class_nrep_predef compile_obj compilobj_predef)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; common code to compilobj_datasymbol & compilobj_datainstance
;;; to add the initial data fill and the slots filling
;;; return a tuple of bindings to be disposed
(defun compil_data_and_slots_fill (ndat obj odiscr irout gcx)
  (assert_msg "compil_data_and_slots_fill check ndat" (is_a ndat class_nrep_data))
  (assert_msg "compil_data_and_slots_fill check obj" (is_a obj class_objinitobject))
  (assert_msg "compil_data_and_slots_fill check odiscr" (is_a odiscr class_objvalue))
  (assert_msg "compil_data_and_slots_fill check irout" (is_a irout class_initialroutineobj))
  (assert_msg "compil_data_and_slots_fill check gcx" (is_a gcx class_genercontext))
  (debug_msg ndat "compil_data_and_slots_fill start ndat")
  (debug_msg obj "compil_data_and_slots_fill start obj")
  (debug_msg odiscr "compil_data_and_slots_fill odiscr")
  (debug_msg irout "compil_data_and_slots_fill irout un")
  (let (
	(ipredef (if (is_a ndat class_nrep_datainstance) (unsafe_get_field :ninst_predef ndat)))
	(ibodylis (unsafe_get_field :obrout_body irout))
	(ifilllis (unsafe_get_field :oirout_fill irout))
	(locvar (get_free_objlocptr gcx '_valdata_))
	(comm (unsafe_get_field :named_name '_valuedata_))
	(nloc (unsafe_get_field :nrep_loc ndat))
	(dlocbind (unsafe_get_field :ndata_locbind ndat))
	(locmap (unsafe_get_field :gncx_locmap gcx))
	(istmtlis ibodylis) ;the statement list to which the putslots are appended
	;; a tuple to store the objvar for localbinds to be able to clear them later
	(tupvar (make_multiple discr_multiple (multiple_length locmap)))
	)
    (assert_msg "compil_data_and_slots_fill check ibodylis" (is_list ibodylis))
    (assert_msg "compil_data_and_slots_fill check fresh obj" (null (unsafe_get_field :oie_locvar obj)))
    (unsafe_put_fields obj :oie_locvar locvar)
    (assert_msg "compil_data_and_slots_fill check ifilllis" (is_list ifilllis))
    (assert_msg "compil_data_and_slots_fill check ibodylis" (is_list ibodylis))
    ;; if the data is predefined, we fill it conditionally on !predefinited[..]
    (if ipredef
	(let ( 
	      (otestpredef 
	       (cond 
		( (is_a ipredef class_symbol)
		  (instance 
		   class_objexpv
		   :obx_cont (make_tuple3 discr_multiple
					  (make_stringconst discr_verbatimstring 
							    "MELTPREDEFIX(predefinited,")
					  (make_string discr_verbatimstring 
						       (unsafe_get_field :named_name ipredef))
					  (make_stringconst discr_verbatimstring 
							    ")")
					  ))
		  )
		( (is_integerbox ipredef)
		  (instance
		   class_objexpv
		   :obx_cont (make_tuple3 discr_multiple
					  (make_stringconst discr_verbatimstring 
							    "predefinited[")
					  ipredef
					  (make_stringconst discr_verbatimstring 
							    "]")
					  ))
		  )
		))
	      (initlis (make_list discr_list))
	      (oblockpredef (instance 
			     class_objcommentedblock
			     :oblo_bodyl initlis
			     :ocomblo_comment (make_stringconst discr_string "fill predef slots")))
	      (ocondpredef (instance
			    class_objcond
			    :obi_loc nloc
			    :obcond_test otestpredef
			    :obcond_then ()
			    :obcond_else oblockpredef))
	      )
	  (setq istmtlis initlis)
	  (list_append ibodylis ocondpredef)
	  ))
    ;; (debug_msg dlocbind "compil_data_and_slots_fill dlocbind")
    (multiple_every
     dlocbind
     (lambda (lbind :long bindrk)
       ;; (debug_msg lbind "compil_data_and_slots_fill lbind")
       (assert_msg "compil_data_and_slots_fill check lbind" (is_a lbind class_normlet_binding))
       (let ( (bder (unsafe_get_field :binder lbind))
	      (cty (unsafe_get_field :letbind_type lbind))
	      (nexp (unsafe_get_field :letbind_expr lbind))
	      (obva (get_free_objloctyped gcx bder cty))
	      (obnx (compile_obj nexp gcx)) 
	      )
	 (if obva (mapobject_put locmap lbind obva))
	 (let ( (obmy (if obva (put_objdest obnx obva) obnx)) )
	   ;; add the modified obmy in the ibodylis
	   (list_append istmtlis obmy)
	   )
	 (if obva (multiple_put_nth tupvar bindrk obva))
	 )))
    ;; for every non nil slot, append its initialization to istmtlis
    (multiple_every
     (unsafe_get_field :ninst_slots ndat)
     (lambda (sloval :long slork)
       ;;(debug_msg sloval "compil_data_and_slots_fill sloval")
       (if sloval
;;; add to list inifill the filling in dai of slot#slork by slobj
	   (let ( (slobj (compile_obj sloval gcx)) 
		  )
					;(debug_msg slobj "compil_data_and_slots_fill slobj")
	     (assert_msg "compil_data_and_slots_fill check slobj not nrep" (not (is_a slobj class_nrep)))
	     (let (
		   (ooff (make_integerbox discr_integer slork))
		   (oput 
		    (instance class_objputslot
			      :obi_loc  nloc
			      :oslot_odata obj
			      :oslot_offset ooff
			      :oslot_value slobj
			      )) 
		   )
	       (list_append istmtlis oput)
	       )))))
    ;; touch the object
    (list_append istmtlis 
		 (instance class_objtouch
			   :obi_loc (if nloc nloc (unsafe_get_field :nrep_loc ndat))
			   :otouch_comment comm
			   :otouch_val obj))
    ;; for every non nil local obvar, clear it
    (multiple_every
     tupvar
     (lambda (obva :long ix)
       (if obva
	   (progn
	     (list_append ibodylis
			  (instance class_objclear 
				    :obi_loc nloc
				    :oclr_vloc obva))
	     ))))
;;; add the obj as the last instr of the block
    (list_append ibodylis obj)
    ;;
    (debug_msg dlocbind "compil_data_and_slots_fill final dlocbind")
    ;; the caller is supposed to do
    ;; dispose_dlocbind_after_data_and_slots_fill with the result if
    ;; needed but in practice this is never needed
    (return dlocbind)
    )
  (return)				;force a nil return
  )


;; probably useless function
(defun dispose_dlocbind_after_data_and_slots_fill (dlocbind gcx)
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg dlocbind "dispose_dlocbind_after_data_and_slots_fill dlocbind")
  (multiple_every
   dlocbind
   (lambda (bnd :long ix) (dispose_bnd_obj bnd gcx)))
  )
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_datasymbol (syv gcx)
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (assert_msg "check syv" (is_a syv class_nrep_datasymbol))
  (debug_msg syv "compilobj_datasymbol syv")
  (let ( (compicache (unsafe_get_field :gncx_compicache gcx)) 
	 (chobj (mapobject_get compicache syv))
	 (inirout (unsafe_get_field :gncx_objrout gcx))
	 )
    ;; datasymbol compiled only in initial routines
    (assert_msg "check inirout" (is_a inirout class_initialroutineobj))
    (if chobj
	(progn
	  (debug_msg chobj "compilobj_datasymbol found chobj")
	  (return chobj)))
    (let (
	  (odiscr  (compile_obj (unsafe_get_field :ndata_discrx syv) gcx))
	  (obsym 
	   (instance class_objinitobject
		     :obv_type ctype_value
		     :oie_data syv
		     :oie_discr odiscr
		     )) 
	  )
      (mapobject_put compicache syv obsym)
      (debug_msg inirout "compilobj_datasymbol inirout")
      ;; make a cname
      (let ( (nambuf (make_strbuf discr_strbuf))
	     (:long syrk (get_int (unsafe_get_field :ndata_rank syv)))
	     )
	(add2sbuf_strconst nambuf "dsym_")
	(add2sbuf_longdec nambuf syrk)
	(add2sbuf_strconst nambuf "__")
	(add2sbuf_cident nambuf (unsafe_get_field :ndsy_namestr syv))
	(unsafe_put_fields obsym
			   :oie_cname (strbuf2string discr_string nambuf)))
      ;; put the length as obj_num of obsym
      (put_int obsym (multiple_length (unsafe_get_field :ninst_slots syv)))
					;(debug_msg gcx "compilobj_datasymbol gcx")
					;(debug_msg obsym "compilobj_datasymbol obsym beforfill")
      (let ( (dlocbind (compil_data_and_slots_fill syv obsym odiscr inirout gcx)) ) 
	(debug_msg dlocbind "compilobj_datasymbol dlocbind")
					;(dispose_dlocbind_after_data_and_slots_fill dlocbind gcx)
	)
      (debug_msg obsym "compilobj_datasymbol obsym final")
      (return obsym)
      )))
(install_method class_nrep_datasymbol compile_obj compilobj_datasymbol)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;; compilobj of datainstance
(defun compilobj_datainstance (dai gcx)
  (assert_msg "check gcx" (is_a gcx class_genercontext))
					;  (debug_msg gcx "compilobj_datainstance gcx")
  (debug_msg dai "compilobj_datainstance dai")
  (let ( (compicache (unsafe_get_field :gncx_compicache gcx)) 
	 (chobj (mapobject_get compicache dai))
	 (inirout (unsafe_get_field :gncx_objrout gcx))
	 )
    ;; datainstance compiled only in initial routines
    (assert_msg "check inirout" (is_a inirout class_initialroutineobj))
    (if chobj
	(progn
	  (debug_msg chobj "compilobj_datainstance return found chobj")
	  (return chobj)))
    (let ( (loc (unsafe_get_field :nrep_loc dai))
	   (nam (unsafe_get_field :ndata_name dai))
	   ;; nam is a symbol, not a string
	   (disx (unsafe_get_field :ndata_discrx dai))
	   (drank (unsafe_get_field :ndata_rank dai))
	   (dhash (unsafe_get_field :ninst_hash dai))
	   (dpredef (unsafe_get_field :ninst_predef dai))
	   (dslots (unsafe_get_field :ninst_slots dai)) 
	   (ininsl (unsafe_get_field :ninit_topl inirout))
	   (inifill (unsafe_get_field :oirout_fill inirout))
	   )
      ;; if the drank is invalid or nil, the data has never been added
      ;; with add_nctx_data (should not happen)
      (assert_msg "compilobj_datainstance check drank" (is_integerbox drank))
					;(debug_msg disx "compilobj_datainstance disx")
					;(debug_msg gcx "compilobj_datainstance avant gcx")
      (debug_msg loc "compilobj_datainstance loc before cdisx")
      (let ( (cdisx (compile_obj disx gcx)) 
	     )
	(debug_msg loc "compilobj_datainstance loc after cdisx")
					;(debug_msg cdisx "compilobj_datainstance cdisx")
	(let (
	      ;; make a cname
	      (oini (instance class_objinitobject
			      :obv_type ctype_value
			      :oie_data dai
			      :oie_discr cdisx
			      :oio_predef dpredef
			      ))
	      (nambuf (make_strbuf discr_strbuf))
	      (:long drk (get_int drank))
	      )
	  (mapobject_put compicache dai oini)
	  (debug_msg loc "compilobj_datainstance loc after put compicache")
	  (add2sbuf_strconst nambuf "dobj_")
	  (add2sbuf_longdec nambuf drk)
	  (if nam (progn
		    (add2sbuf_strconst nambuf "__")
		    (add2sbuf_cident nambuf (unsafe_get_field :named_name nam))))
	  (let ( (cnam (strbuf2string discr_string nambuf)) )
	    (unsafe_put_fields oini :oie_cname cnam)
	    (debug_msg cnam "compilobj_datainstance cnam")
	    )
	  (put_int oini (multiple_length dslots))
					;(debug_msg gcx "compilobj_datainstance apres gcx")
	  (debug_msg oini "compilobj_datainstance oini before data&slots")
	  (debug_msg loc "compilobj_datainstance loc before data&slots")
	  (let ( (dlocbind (compil_data_and_slots_fill dai oini cdisx inirout gcx)) )
	    (debug_msg dlocbind "compilobj_datainstance dlocbind")
					;(dispose_dlocbind_after_data_and_slots_fill dlocbind gcx)
	    )
	  (debug_msg loc "compilobj_datainstance loc after data&slots")
	  (debug_msg oini "compilobj_datainstance final oini")
	  oini
	  )  
	)
      )
    )
  )
(install_method class_nrep_datainstance compile_obj compilobj_datainstance)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;; compile a data tuple
(defun compilobj_datatuple (nti gcx)
  (assert_msg "check nti" (is_a nti class_nrep_datatuple))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  ;;(debug_msg gcx "compilobj_datatuple gcx")
  (debug_msg nti "compilobj_datatuple nti")
  (let ( (compicache (unsafe_get_field :gncx_compicache gcx)) 
	 (chobj (mapobject_get compicache nti))
	 (inirout (unsafe_get_field :gncx_objrout gcx))
	 )
    ;; datatuples compiled only in initial routines
    (assert_msg "check inirout" (is_a inirout class_initialroutineobj))
    (if chobj
	(progn
	  (debug_msg chobj "compilobj_datatuple found chobj")
	  (return chobj)))
    (let ( (ncompi (unsafe_get_field :ntup_comp nti))
	   (ocompi (multiple_map 
		    ncompi
		    (lambda (c :long ix) (if c (compile_obj c gcx)))))
	   (disx (unsafe_get_field :ndata_discrx nti))
	   (drank (unsafe_get_field :ndata_rank nti))
	   (odiscr (compile_obj disx gcx)) 
	   (nam (unsafe_get_field :ndata_name nti))
	   (nambuf (make_strbuf discr_strbuf))
	   (locvar (get_free_objlocptr gcx '_valtup_))
	   (:long drk (get_int drank))
	   (inibody (unsafe_get_field :obrout_body inirout))
	   (comm (unsafe_get_field :named_name '_initup_))
	   )
      (add2sbuf_strconst nambuf "dtup_")
      (add2sbuf_longdec nambuf drk)
      (if nam (progn
		(add2sbuf_strconst nambuf "__")
		(add2sbuf_cident nambuf (unsafe_get_field :named_name nam))))
      (let ( (otup (instance class_objinitmultiple
			     :obv_type ctype_value
			     :oie_discr odiscr
			     :oie_locvar locvar
			     :oie_cname (strbuf2string discr_string nambuf)
			     :oim_tupval ocompi
			     ))
	     )
	(mapobject_put compicache nti otup)
	(put_int otup (multiple_length ncompi))
	(multiple_every
	 ncompi
	 (lambda (scomp :long srk)
	   (if scomp 
	       (let ( (ocomp (multiple_nth ocompi srk)) )
		 (list_append inibody
			      (instance class_objputuple
					:oputu_tupled otup
					:oputu_offset (make_integerbox discr_integer srk)
					:oputu_value ocomp)))
	     )))
	(list_append inibody
		     (instance class_objtouch
			       :otouch_val otup
			       :otouch_comment comm))
	(debug_msg otup "compilobj datatuple otup")
	(return otup)
	)
      )
    )
  )

(install_method class_nrep_datatuple compile_obj compilobj_datatuple)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;; compile a data string
(defun compilobj_datastring (nds gcx)
  (assert_msg "check nds" (is_a nds class_nrep_datastring))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
					; (debug_msg gcx "compilobj_datastring gcx")
  (debug_msg nds "compilobj_datastring nds")
  (let ( (compicache (unsafe_get_field :gncx_compicache gcx)) 
	 (inirout (unsafe_get_field :gncx_objrout gcx))
	 (chobj (mapobject_get compicache nds))
	 )
    ;; datastring compiled only in initial routines
    (assert_msg "check inirout" (is_a inirout class_initialroutineobj))
    (if chobj
	(progn
	  (debug_msg chobj "compilobj_datastring found chobj")
	  (return chobj)))
    (let (
	  (nambuf (make_strbuf discr_strbuf))
	  (ndisx (unsafe_get_field :ndata_discrx nds))
	  (odiscr (compile_obj ndisx gcx))
	  (odata (unsafe_get_field :nstr_string nds))
	  (drank (unsafe_get_field :ndata_rank nds))
	  (nam (unsafe_get_field :ndata_name nds))
	  (locvar (get_free_objlocptr gcx '_valstr_))
	  (:long drk (get_int drank))
	  (ostr (instance class_objinitstring
			  :oie_data odata
			  :oie_discr odiscr
			  :oie_locvar locvar
			  )) 
	  )
      (mapobject_put compicache nds ostr)
      (add2sbuf_strconst nambuf "dstr_")
      (add2sbuf_longdec nambuf drk)
      (add2sbuf_strconst nambuf "__")
      (add2sbuf_cidentprefix nambuf odata 16)
      (put_int ostr (string_length odata))
      (if nam 
	  (progn
	    (add2sbuf_strconst nambuf "__")
	    (add2sbuf_cident nambuf (unsafe_get_field :named_name nam))))
      (unsafe_put_fields ostr :oie_cname (strbuf2string discr_string nambuf))
      (debug_msg ostr "compilobj_datastring ostr")
      ostr
      )
    ))
(install_method class_nrep_datastring compile_obj compilobj_datastring)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;; compile a data closure
(defun compilobj_dataclosure (ncl gcx)
  (assert_msg "check ncl" (is_a ncl class_nrep_dataclosure))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
					;(debug_msg gcx "compilobj_dataclosure gcx")
  (debug_msg ncl "compilobj_dataclosure ncl")
  (let ( (compicache (unsafe_get_field :gncx_compicache gcx)) 
	 (inirout (unsafe_get_field :gncx_objrout gcx))
	 (inibody (unsafe_get_field :obrout_body inirout))
	 (chobj (mapobject_get compicache ncl))
	 )
    (assert_msg  "check inirout" (is_a inirout class_initialroutineobj))
    (if chobj
	(progn
	  (debug_msg chobj "compilobj_dataclosure found chobj")
	  (return chobj)))
    (let ( 
	  (nam (unsafe_get_field :ndata_name ncl))
	  (discx (unsafe_get_field :ndata_discrx ncl))
	  (nrank (unsafe_get_field :ndata_rank ncl))
	  (nloc (unsafe_get_field :nrep_loc ncl))
	  (npro (unsafe_get_field :ndclo_proc ncl))
	  (nclov (unsafe_get_field :ndclo_closv ncl))
	  (:long nbclos (multiple_length nclov))
	  (nambuf (make_strbuf discr_strbuf))
	  (odiscr (compile_obj discx gcx))
	  (locvar (get_free_objlocptr gcx '_valclo_))
	  (comm (unsafe_get_field :named_name '_dataclosure_))
	  )
      (assert_msg "check npro" (is_a npro class_nrep_routproc))
      (add2sbuf_strconst nambuf "dclo_")
      (add2sbuf_longdec nambuf (get_int nrank))
      (if nam (progn
		(add2sbuf_strconst nambuf "__")
		(add2sbuf_cident nambuf (unsafe_get_field :named_name nam))))
					;    (debug_msg ncl "compilobj_dataclosure encore ncl")
      (let (
	    (ndatarou (unsafe_get_field :nrpro_datarout npro))
	    (oiclo
	     (instance class_objinitclosure
		       :obv_type ctype_value
		       :oie_discr odiscr
		       :oie_data ncl
		       :oie_locvar locvar
		       :oie_cname (strbuf2string discr_string nambuf)
		       )) 
	    )
	(put_int oiclo nbclos)
	(mapobject_put compicache ncl oiclo)
	(assert_msg "check ndatarou" (is_a ndatarou class_nrep_dataroutine))
	(let (
	      ;; npro should already have been compiled, so should be in the compiler cache
	      (ocrout (mapobject_get compicache npro))
	      (odatrout (compile_obj ndatarou gcx))
	      (ocputrout (instance  class_objputclosurout
				    :obi_loc nloc
				    :opclor_clos oiclo
				    :opclor_rout odatrout
				    ;;@@OLDBUGGY :opclor_rout (mapobject_get compicache ndatarou)
				    ))
	      (bxoff (make_integerbox discr_integer 0))
	      )
	  (assert_msg "check ocrout" (is_a ocrout class_procroutineobj))
	  (list_append inibody ocputrout)
	  (debug_msg nclov "compilobj_dataclosure nclov")
	  (debug_msg ocrout "compilobj_dataclosure ocrout")
	  (multiple_every
	   nclov
	   (lambda (clov :long ix)
	     (let ( (cloval (compile_obj clov gcx)) 
		    (ocputclos (instance class_objputclosedv
					 :obi_loc nloc
					 :opclov_clos oiclo
					 :opclov_off (make_integerbox discr_integer (get_int bxoff))
					 :opclov_cval cloval))
		    )
	       (list_append inibody ocputclos)
	       )
	     (put_int bxoff (+i (get_int bxoff) 1))))
	  (list_append inibody (instance class_objtouch
					 :obi_loc nloc
					 :otouch_comment comm
					 :otouch_val oiclo))
	  oiclo
	  ))
      ))
  )
(install_method class_nrep_dataclosure compile_obj compilobj_dataclosure)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;; compile a data routine
(defun compilobj_dataroutine (ndrou gcx)
  (assert_msg "check ndrou" (is_a ndrou class_nrep_dataroutine))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  ;;(debug_msg gcx "compilobj_dataroutine+ gcx" )
  (debug_msg ndrou "compilobj_dataroutine+ ndrou")
  (let ( (compicache (unsafe_get_field :gncx_compicache gcx)) 
	 (inirout (unsafe_get_field :gncx_objrout gcx))
	 (chobj (mapobject_get compicache ndrou))
	 (unused_stuff ())	  ;to circumvent a bug in cold-melt
	 )
    ;; dataroutine compiled only in initial routines
    (assert_msg "check inirout" (is_a inirout class_initialroutineobj))
    (if chobj
	(progn
	  (debug_msg chobj "compilobj_dataroutine+ found chobj")
	  (return chobj)))
    (let ( (nam (unsafe_get_field :ndata_name ndrou))
	   (disx (unsafe_get_field :ndata_discrx ndrou))
	   (nloc (unsafe_get_field :nrep_loc ndrou))
	   (drank (unsafe_get_field :ndata_rank ndrou))
	   (nam (unsafe_get_field :ndata_name ndrou))
	   (npro (unsafe_get_field :ndrou_proc ndrou))
	   (inibody (unsafe_get_field :obrout_body inirout))
	   (locvar (get_free_objlocptr gcx '_valrout_))
	   )
      (if (null nloc)
	  (if (is_a npro class_nrep)
	      (setq nloc (unsafe_get_field :nrep_loc npro))))
      (assert_msg "check compicache" (is_mapobject compicache))
      (let (
	    (nambuf (make_strbuf discr_strbuf))
	    (:long drk (get_int drank))
	    (odiscr (compile_obj disx gcx))
	    )
	(add2sbuf_strconst nambuf "drout_")
	(add2sbuf_longdec nambuf drk)
	(if nam (progn
		  (add2sbuf_strconst nambuf "__")
		  (add2sbuf_cident nambuf (unsafe_get_field :named_name nam))))
	;;(debug_msg ndrou "compilobj_dataroutine encore ndrou")
	(let (
	      (oirout 
	       (instance class_objinitroutine
			 :obv_type ctype_value
			 :oie_discr odiscr
			 :oie_data ndrou
			 :oie_locvar locvar
			 :oie_cname (strbuf2string discr_string nambuf)
			 :oir_procroutine (mapobject_get compicache npro)
			 )) 
	      )
	  (mapobject_put compicache ndrou oirout)
	  (if (is_a npro class_nrep_routproc)
	      (let ( (pconstl (unsafe_get_field :nrpro_const npro)) 
		     (:long nbconst (list_length pconstl))
		     (bxoff (make_integerbox discr_integer 0))
		     (comm (unsafe_get_field :named_name '_iroutval_))
		     )
		(debug_msg pconstl "compilobj_dataroutine pconstl")
		(put_int oirout nbconst)
		(list_every
		 pconstl
		 (lambda (constx)
		   (debug_msg constx "compilobj_dataroutine constx")
		   (cond
		    ( (is_a constx class_nrep_constocc)
		      (let ( (cnstbind (unsafe_get_field :nocc_bind constx)) )
			(assert_msg "compilobj_dataroutine check cnstbind" (is_a cnstbind class_any_binding))
			(let ( 
			      (oconstx (compile_obj cnstbind gcx)) 
			      (:long off (get_int bxoff))
			      ) 
			  (if oconstx 
			      (let (
				    (iput
				     (if (is_a cnstbind class_fixed_binding)
					 (instance class_objputroutconstnotnull
						   :obi_loc nloc
						   :oprconst_rout oirout
						   :oprconst_off (make_integerbox discr_integer off)
						   :oprconst_cval oconstx)
				       (instance class_objputroutconst
						 :obi_loc nloc
						 :oprconst_rout oirout
						 :oprconst_off (make_integerbox discr_integer off)
						 :oprconst_cval oconstx)
				       )) 
				    ) 
				(list_append inibody iput)
				(put_int bxoff (+i off 1))))))
		      )
		    ( (is_a constx class_nrep_quasidata)
		      (debug_msg constx "compilobj_dataroutine constx data")
		      (let ( 
			    (oconstx (compile_obj constx gcx)) 
			    (:long off (get_int bxoff))
			    ) 
			(if oconstx 
			    (let ( (iput (instance class_objputroutconst
						   :obi_loc nloc
						   :oprconst_rout oirout
						   :oprconst_off (make_integerbox discr_integer off)
						   :oprconst_cval oconstx)) ) 
			      (list_append inibody iput)
			      (put_int bxoff (+i off 1))))))
		    (:else
		     (debug_msg constx  "compilobj_dataroutine unexpected constx")
		     (assert_msg "compilobj_dataroutine unexepected constx" ())
		     )
		    )
		   )
		 )
		(if (>i (get_int bxoff) 0)
		    (list_append inibody (instance class_objtouch
						   :obi_loc nloc
						   :otouch_val oirout
						   :otouch_comment comm
						   )))
		(debug_msg npro "compilobj_dataroutine here npro")
		(debug_msg oirout "compilobj_dataroutine here fresh oirout")
		oirout)
	    ))))
    )
  )
(install_method class_nrep_dataroutine compile_obj compilobj_dataroutine)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_quasidata_current_module_environment_container (qdcm gcx)
  (assert_msg "check qdcm" (is_a qdcm class_nrep_quasidata_current_module_environment_container))
  (assert_msg "check gcx" (is_a gcx class_initgenercontext))
  (debug_msg qdcm "compilobj_quasidata_current_module_environment_container qdcm")
  (let ( (locbox (unsafe_get_field :igncx_contenvloc gcx)) 
	 )
    (debug_msg locbox "compilobj_quasidata_current_module_environment_container return locbox")
    (return locbox)))
(install_method class_nrep_quasidata_current_module_environment_container compile_obj compilobj_quasidata_current_module_environment_container)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_quasidata_parent_module_environment (qdpm gcx)
  (assert_msg "check qdpm" (is_a qdpm class_nrep_quasidata_parent_module_environment))
  (assert_msg "check gcx" (is_a gcx class_initgenercontext))
  (debug_msg qdpm "compilobj_quasidata_parent_module_environment qdpm")
  (let ( (prevenvloc (unsafe_get_field :igncx_prevenvloc gcx)) 
	 )
    (debug_msg prevenvloc "compilobj_quasidata_parent_module_environment return prevenvloc")
    (return prevenvloc)))
(install_method class_nrep_quasidata_parent_module_environment compile_obj compilobj_quasidata_parent_module_environment)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_store_predefined (nspr gcx)
  (assert_msg "check nspr" (is_a nspr class_nrep_store_predefined))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg nspr "compilobj_nrep_store_predefined start nspr")
  (let ( (nloc (unsafe_get_field :nrep_loc nspr))
	 (npred (unsafe_get_field :nstpd_predef nspr))
	 (nval (unsafe_get_field :nstpd_value nspr))
	 (oval (compile_obj nval gcx)) 
	 (res ())
	 )
    (cond 
     ( (is_a npred class_symbol)
       (setq res 
	     (instance class_objcompute
		       :obi_loc nloc
		       :obcpt_expr 
		       (make_tuple5
			discr_multiple
			(make_stringconst discr_verbatimstring
					  "MELT_STORE_PREDEF(")
			(make_string discr_verbatimstring 
				     (get_field :named_name npred))
			(make_stringconst discr_verbatimstring ", (")
			oval
			(make_stringconst discr_verbatimstring "))"))
		       ))
       )
     ( (is_integerbox npred)
       (setq res 
	     (instance class_objcompute
		       :obi_loc nloc
		       :obcpt_expr 
		       (make_tuple5
			discr_multiple
			(make_stringconst discr_verbatimstring
					  "melt_store_predefined(")
			npred
			(make_stringconst discr_verbatimstring ", (")
			oval
			(make_stringconst discr_verbatimstring "))"))
		       ))
       )
     (:else
      (debug_msg npred "compilobj_nrep_store_predefined")
      (assert_msg "compilobj_nrep_store_predefined invalid npred" ())
      (return))
     )
    (debug_msg res "compilobj_nrep_store_predefined result res")
    res
    ))
(install_method class_nrep_store_predefined compile_obj compilobj_nrep_store_predefined)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defun compilobj_nrep_update_current_module_environment_container (nucmeb gcx)
  (assert_msg "check nucmeb" (is_a nucmeb class_nrep_update_current_module_environment_container))
  (assert_msg "check gcx" (is_a gcx class_initgenercontext))
  (debug_msg nucmeb "compilobj_nrep_update_current_module_environment_container nucmeb")
  (let ( (nloc (unsafe_get_field :nrep_loc nucmeb))
	 (ncomm (unsafe_get_field :ncumeb_comment nucmeb))
	 (nex (unsafe_get_field :nucmeb_expr nucmeb))
	 (pcml (unsafe_get_field :igncx_procurmodenvlist gcx))
	 (ocontenvloc (unsafe_get_field :igncx_contenvloc gcx))
	 (csbuf (let ( (sb (make_strbuf discr_strbuf)) 
		       )
		  (add2sbuf_strconst sb "upd.cur.mod.env.cont")
		  (if (is_string ncomm)
		      (progn
			(add2sbuf_strconst sb " : ")
			(add2sbuf_string sb ncomm)))
		  sb
		  ))
	 (obodl (make_list discr_list))
	 (ocblo (instance class_objcommentedblock
			  :obi_loc nloc
			  :oblo_bodyl obodl
			  :ocomblo_comment 
			  (strbuf2string discr_string csbuf)))
	 (oex (compile_obj nex gcx))
	 )
    (debug_msg pcml "compilobj.upd.cur.mod.env.box pcml")
    ;; get the igncx_procurmodenvlist from gcx
    ;; for each routine of class_procroutineobj  get its nrpro_const list and
    ;; for each CLASS_NREP_QUASIDATA_CURRENT_MODULE_ENVIRONMENT_CONTAINER there do ....
    (list_every 
     pcml
     (lambda (curout)
       (debug_msg curout "compilobj.upd.cur.mod.env.box curout")
       (if (is_a curout class_procroutineobj)
	   (let (
		 (curproc (unsafe_get_field :obrout_proc curout))
		 (cnslis (unsafe_get_field :nrpro_const curproc)) 
		 (datarout (unsafe_get_field :nrpro_datarout curproc))
		 (odatarout (compile_obj datarout gcx))
		 (boxcount (make_integerbox discr_integer 0))
		 (oroutlocvar (unsafe_get_field :oie_locvar odatarout))
		 )
	     (debug_msg cnslis "compilobj.upd.cur.mod.env.box cnslis")
	     (debug_msg odatarout "compilobj.upd.cur.mod.env.box odatarout")
	     (assert_msg "check odatarout" (is_a odatarout class_objinitroutine))
	     (debug_msg oroutlocvar "compilobj.upd.cur.mod.env.box oroutlocvar")
	     (list_every 
	      cnslis
	      (lambda (curconst)
		(debug_msg curconst "compilobj.upd.cur.mod.env.box curconst")
		(let (
		      (:long curcount (get_int boxcount))
		      )
		  (if (is_a curconst class_nrep_quasidata_current_module_environment_container)
		      ;; set into oroutlocvar  the constant ranked curcount to oex
		      ;; and touch it
		      (let (
			    (oputrout (instance class_objputroutconst
						:obi_loc nloc
						:oprconst_rout oroutlocvar
						:oprconst_off  (make_integerbox discr_integer curcount)
						:oprconst_cval oex
						))
			    (otouchrout (instance class_objtouch
						  :obi_loc nloc
						  :otouch_val oroutlocvar
						  :otouch_comment (make_stringconst discr_string "compobj.upd.mod.env.box")
						  ))
			    (ocopy (instance class_objcompute
					     :obi_loc nloc
					     :obdi_destlist (list1 ocontenvloc)
					     :obcpt_expr oex
					     ))
			    )
			(debug_msg oputrout "compobj.upd.mod.env.box oputrout")
			(debug_msg otouchrout "compobj.upd.mod.env.box otouchrout")
			(list_append obodl oputrout)
			(list_append obodl otouchrout)
			(list_append obodl ocopy)
			)
		    )
		  )
		))
	     (put_int boxcount (+i (get_int boxcount) 1))
	     ))))
    (debug_msg ocblo "compobj.upd.mod.env.box result ocblo")
    (return ocblo)
    ))
(install_method class_nrep_update_current_module_environment_container compile_obj compilobj_nrep_update_current_module_environment_container)






;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; selector to compile a matcher
;; reciever: some indirect instance of class_any_matcher
;; arguments:
;;; * the match compilation context
;;; * the generation context
;;;   
(defselector compile_matcher class_selector
)

(export_values compile_matcher)
(defclass class_matchcompilcontext 
  :super class_proped
  :fields (mcx_loc			;the location of the matcher
	   mcx_normtester		;the normtester
	   mcx_gotothen			;the goto then part
	   mcx_gotoelse 		;the goto else part
	   mcx_olist			;the objcode list to be filled
	   mcx_prefix			;the prefix
	   ))
(export_class class_matchcompilcontext)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; selector to compile a tester
;;;; reciever: the tester
;;;; first argument: the generator context gcx
;;;; second argument: the tester context tcx
;;;; return values: primary, the objcode or lists; secondary the destination objcode
(defselector compile_tester class_selector
 )
(export_values compile_tester)
(defclass class_testercompilcontext
  :super class_proped
  :fields (tcx_nrmatch			;the nrep_matcher
	   tcx_freelist			;the list of free objloc
))
(export_class class_testercompilcontext)


;;;; catch all
(defun compiltst_anytester (ntester gcx tcx)
  (assert_msg "check ntester" (is_a ntester class_normtester_any))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (assert_msg "check tcx" (is_a tcx class_testercompilcontext))
  (debug_msg ntester "compiltst_anytester ntester")
  (outcstring_err "* compiltst unimplemented reciever class ")
  (let ( (discr (discrim ntester)) ) (outstr_err (unsafe_get_field :named_name discr)))
  (outnewline_err)
  (assert_msg "@@compile_tester should be implemented in normtesters-s subclasses" ())
)
(install_method class_normtester_any compile_tester compiltst_anytester)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compilation of matches
(defun compilobj_nrep_match (nmat gcx)
  (assert_msg "check nmat" (is_a nmat class_nrep_match))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg nmat "compilobj_nrep_match nmat")
  (let ( 
	(nloc (unsafe_get_field :nrep_loc nmat))
	(nctyp (unsafe_get_field :nexpr_ctyp nmat))
	(ntests (unsafe_get_field :nmatch_tests nmat))
	(stuffmap (unsafe_get_field :nmatch_stuffmap nmat))
	(nmatched (get_field :nmatch_matched nmat))
	(matmap (unsafe_get_field :gncx_matchmap gcx))
	(matlabel (let ( (:long nbmat (mapobject_count matmap))
			 (labuf (make_strbuf discr_strbuf))
			 )
		    (add2sbuf_strconst labuf "labmatch_")
		    (add2sbuf_longdec labuf (+i nbmat 1))
		    (add2sbuf_strconst labuf "_")
		    (let ( (labstr (strbuf2string discr_verbatimstring labuf)) )
		      (mapobject_put matmap  nmat labstr)
		      labstr
		      )))
	(endlabel (let (
			(labuf (make_strbuf discr_strbuf))
			)
		    (add2sbuf_string labuf matlabel)
		    (add2sbuf_strconst labuf "_end")
		    (strbuf2string discr_verbatimstring labuf)))
	;; the list of suborders for putobjdest dispatch...
	;; should be the *last* of each sequence added...
	(subcomplist (make_list discr_list))
	(obodyl (make_list discr_list))
	(ombloc (instance class_objmultiblock
			  :obi_loc nloc
			  :oblo_bodyl obodyl
			  :omulblo_subcomp ()
			  ))
	(ofirstgoto (instance class_objgotoinstr
			      :obi_loc nloc
			      :obgoto_prefix matlabel
			      :obgoto_rank (make_integerbox discr_integer 0)
			      ))
	(oendlabel (instance class_objlabelinstr
			     :obi_loc nloc
			     :oblab_prefix endlabel
			     :oblab_rank ()))
	(tcx (instance class_testercompilcontext
		       :tcx_nrmatch nmat
		       :tcx_freelist (make_list discr_list)
		       ))
	(donetests (make_list discr_list))
	(omatched 
	 (progn 
	   (debug_msg nmatched "compilobj_nrep_match nmatched")
	   (compile_obj nmatched gcx)))
	)
    (list_append obodyl ofirstgoto)
    (debug_msg ntests "compilobj_nrep_match ntests")
    (debug_msg omatched "compilobj_nrep_match omatched")
    (foreach_in_multiple
     (ntests)
     (curotest :long testix)
     (messagenum_dbg "compilobj_nrep_match testix=" testix)
     (debug_msg curotest "compilobj_nrep_match curotest")
     (assert_msg "check curotest" (is_a curotest class_normtester_any))
     (assert_msg "check curotest rank" (==i (get_int curotest) testix))
     (let (
	   (labins (normtester_labelinstr curotest gcx))
	   (curnmatched (get_field :ntest_matched curotest))
	   )
       (multicall
	(curcomp curobdest) 
	(compile_tester curotest gcx tcx)
	(debug_msg labins "compilobj_nrep_match labins")
	(debug_msg curcomp "compilobj_nrep_match curcomp")
	(debug_msg curobdest "compilobj_nrep_match curobdest")
	(debug_msg tcx "compilobj_nrep_match tcx")
	(assert_msg "check curcomp" curcomp)
	;; always add the labins and the curcomp or its element into obodyl
	(list_append obodyl labins)
	(cond 
	 ( (is_list curcomp)
	   (let ( (lastlicomp (pair_head (list_last curcomp))) )
	     (debug_msg lastlicomp "compilobj_nrep_match lastlicomp")
	     (list_append2list obodyl curcomp)
	     ))
	 ( (is_multiple curcomp)
	   (let ( (lastupcomp (multiple_nth curcomp -1)) )
	     (debug_msg lastupcomp "compilobj_nrep_match lastupcomp")
	     (foreach_in_multiple
	      (curcomp)
	      (subtest :long subix)
	      (list_append obodyl subtest))
	     ))
	 ( (is_object curcomp)
	   (debug_msg curcomp "compilobj_nrep_match obj curcomp")
	   (list_append obodyl curcomp)
	   )
	 (:else
	  (assert_msg "unexpected curcomp" ())
	  ))
	;; add into subcomplist the curobdest if not null
	(if curobdest (list_append subcomplist curobdest))
	;; 
	(list_append donetests curotest)
	;; dispose some stuff
	(let ( (disposablist (make_list discr_list)) )
	  (debug_msg curotest "compilobj_nrep_match disposing curotest")
	  (cond
	   ;; if the current test is a success, we can dispose all the
	   ;; stuff which has already been tested
	   ( (is_a curotest class_normtester_success)
	     (mapobject_every 
	      stuffmap
	      (lambda (stuff stutests)
		(debug_msg stuff "compilobj_nrep_match succ stuff")
		(debug_msg stutests "compilobj_nrep_match succ stutest")
		(if (!= stuff omatched)
		(let ( (remstuff stuff) )
		  (foreach_in_list 
		   (stutests)
		   (testpair curtest)
		   (if (list_find donetests curtest)
		       (setq testpair ())
		     (setq remstuff ()))
		   )
		  (if remstuff 
		      (list_append disposablist remstuff))
		)))))
	   ;; if the curnmatched is the nmatched, we do nothing
	   ;; because we cannot dispose it
	   ( (== curnmatched nmatched)
	     (debug_msg curnmatched 
			"compilobj_nrep_match curnmatched == nmatched")
	     )
	   ;; if the current test is not a success and the curnmatched
	   ;; is an object, we can dispose it if all its stuff has been
	   ;; tested
	   ( (is_object curnmatched)
	     (debug_msg curnmatched
			"compilobj_nrep_match disposing curnmatched")
	     (debug_msg omatched
			"compilobj_nrep_match omatched")
	     (let ( (stutests (mapobject_get stuffmap curnmatched)) )
	       (let ( (remstuff curnmatched) )
		 (foreach_in_list 
		  (stutests)
		  (testpair curtest)
		  (if (list_find donetests curtest)
		      (setq testpair ())
		    (setq remstuff ()))
		  )
		 (if remstuff 
		     (list_append disposablist remstuff))
		 )))) 
;;; dispose all the stuff in the disposablist 
	  (foreach_in_list
	   (disposablist)
	   (dispair dispstuff)
	   (mapobject_remove stuffmap dispstuff)
	   (debug_msg dispstuff "compilobj_nrep_match dispstuff")
	   (let ( (dispobj (compile_obj dispstuff gcx)) )
	     (debug_msg dispobj "compilobj_nrep_match dispobj")
	     (assert_msg "check dispobj" (is_a dispobj class_objlocv))
	     ;; but never dispose omatched itself
	     (if (!= dispobj omatched)
		 (dispose_objloc dispobj gcx)
	       (debug_msg omatched "compilobj_nrep_match dont dispose omatched"))
	     ))))))
    (list_append obodyl oendlabel)
    (put_fields ombloc 
		:omulblo_subcomp (list_to_multiple subcomplist discr_multiple))
    (debug_msg ombloc "compilobj_nrep_match return ombloc")
    (return ombloc)
    ))
(install_method class_nrep_match compile_obj compilobj_nrep_match)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; utility function to return the label instr of a tester
(defun normtester_labelinstr (nt gcx)
  (debug_msg nt "normtester_labelinstr start nt")
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (if (is_not_a nt class_normtester_any)
      (progn
	(debug_msg () "normtester_labelinstr return nil")
	(return)))
  (let ( 
	(nloc (unsafe_get_field :nrep_loc nt))
	(:long ntestix (get_int nt))
	(normatch (unsafe_get_field :ntest_normatch nt))
	(matchmap (unsafe_get_field :gncx_matchmap gcx))
	)
    (assert_msg "check normatch" (is_a normatch class_nrep_match))
    (assert_msg "check valid normatch" 
		(== (multiple_nth (get_field :nmatch_tests normatch) 
				  ntestix) 
		    nt))
    (let (
	  (prefix (mapobject_get matchmap normatch))
	  (labins (instance class_objlabelinstr
			    :obi_loc nloc
			    :oblab_prefix prefix
			    :oblab_rank nt)) 
	  )
      (debug_msg labins "normtester_labelinstr result labins")
      (assert_msg "check prefix" (is_string prefix))
      (return labins)
      )))


;; utility function to return the goto instr into a tester
(defun normtester_gotoinstr (nt gcx)
  (debug_msg nt "normtester_gotoinstr start nt")
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (if (is_not_a nt class_normtester_any)
      (progn
	(debug_msg () "normtester_gotoinstr return nil")
	(return)))
  (let ( 
	(nloc (unsafe_get_field :nrep_loc nt))
	(:long ntestix (get_int nt))
	(normatch (unsafe_get_field :ntest_normatch nt))
	(matchmap (unsafe_get_field :gncx_matchmap gcx))
	)
    (debug_msg normatch "normtester_gotoinstr normatch")
    (assert_msg "check normatch" (is_a normatch class_nrep_match))
    (assert_msg "check valid normatch" 
		(== (multiple_nth (get_field :nmatch_tests normatch) 
				  ntestix) 
		    nt))
    (let (
	  (prefix (mapobject_get matchmap normatch))
	  (goins (instance class_objgotoinstr
			    :obi_loc nloc
			    :obgoto_prefix prefix
			    :obgoto_rank nt)) 
	  )
      (debug_msg goins "normtester_gotoinstr result goins")
      (assert_msg "check prefix" (is_string prefix))
      (return goins)
)))


;;; utility function to return the goto instr at end of matcher
(defun endmatch_gotoinstr (nma gcx nloc)
  (assert_msg "check nma" (is_a nma class_nrep_match))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (let ( 
	(matchmap (unsafe_get_field :gncx_matchmap gcx))
	(prefix (mapobject_get matchmap nma))
	(labuf (make_strbuf discr_strbuf))
	)
    (add2sbuf_string labuf prefix)
    (add2sbuf_strconst labuf "_end")
    (let (
	  (goins (instance 
		  class_objgotoinstr
		  :obi_loc nloc
		  :obgoto_prefix (strbuf2string discr_verbatimstring labuf)
		  :obgoto_rank ()))
	  )
      (return goins)
)))


;;; utility function to get free objloc for the local occurrences of a tester
(defun normtester_free_objloc_list (nt gcx tcx)
  (debug_msg nt "normtester_free_objloc_list nt")
  (assert_msg "check nt" (is_a nt class_normtester_any))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (assert_msg "check tcx" (is_a tcx class_testercompilcontext))
  (let ( 
	(nloclist (unsafe_get_field :ntest_locclist nt))
	(locmap (unsafe_get_field :gncx_locmap gcx))
	)
    (debug_msg nloclist "normtester_free_objloc_list nloclist")
    (let ( (freelist
	    (list_map 
	     nloclist 
	     (lambda (nloc) 
	       (assert_msg "check nloc" (is_a nloc class_nrep_locsymocc))
	       (let ( (oblo
		       (get_free_objloctyped gcx 
				     (get_field :nocc_symb nloc)
				     (get_field :nocc_ctyp nloc)
				     )) )
		 (mapobject_put locmap (get_field :nocc_bind nloc) oblo)
		 oblo
	       )))) 
	   )
      (list_append2list (get_field :tcx_freelist tcx) freelist)
      (debug_msg freelist "normtester_free_objloc_list result freelist")
      (return freelist)
      )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; catch-all for unimplemented normtester
(defun compiltst_normtester_any (nta gcx tcx)
  (debug_msg nta "compiltst_normtester_any nta")
  (error_strv (get_field :nrep_loc nta) 
	      "**UNIMPLEMENTED normal tester compilation "
	      (get_field :named_name (discrim nta)))
  (assert_msg "@$@UNIMPLEMENTED normal tester compilation" ())
)
(install_method class_normtester_any compile_tester compiltst_normtester_any)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compiltst_normtester_matcher (ntma gcx tcx)
  (debug_msg ntma "compiltst_normtester_matcher ntma")
  (assert_msg "check ntma" (is_a ntma class_normtester_matcher))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (assert_msg "check tcx" (is_a tcx class_testercompilcontext))
  (let ( 
	(nloc (unsafe_get_field :nrep_loc ntma))
	(nmatched (unsafe_get_field :ntest_matched ntma))
	(nthen (unsafe_get_field :ntest_then ntma))
	(nelse (unsafe_get_field :ntest_else ntma))
	(nmatcher (unsafe_get_field :ntmatch_matcher ntma))
	(nins (unsafe_get_field :ntmatch_inargs ntma))
	(nouts (unsafe_get_field :ntmatch_outlocs ntma))
	(normatch (unsafe_get_field :ntest_normatch ntma))
	(gotothen (normtester_gotoinstr nthen gcx))
	(gotoelse (normtester_gotoinstr nelse gcx))
	(olist (make_list discr_list))
	(matchmap (unsafe_get_field :gncx_matchmap gcx))
	(prefix (mapobject_get matchmap normatch))
	(freelist (normtester_free_objloc_list ntma gcx tcx))
	)
    (debug_msg matchmap "compiltst_normtester_matcher matchmap")
    (if (null gotothen)
	(setq gotothen (endmatch_gotoinstr normatch gcx nloc)))
    (debug_msg gotothen "compiltst_normtester_matcher fixed gotothen")
    (if (null gotoelse)
	(setq gotoelse (endmatch_gotoinstr normatch gcx nloc)))
    (debug_msg gotoelse "compiltst_normtester_matcher fixed gotoelse")
    (debug_msg freelist "compiltst_normtester_matcher freelist")
    (debug_msg prefix "compiltst_normtester_matcher prefix")
    (assert_msg "check prefix" (is_string prefix))
    ;; clear the freelist
    (foreach_in_list
     (freelist)
     (locpair obloc)
     (debug_msg obloc "compiltst_normtester_matcher obloc")
     (assert_msg "check obloc" (is_a obloc class_objlocv))
     (let ( (oclearob (instance class_objclear
				 :obi_loc nloc
				 :oclr_vloc obloc
				 )) )
       (list_append olist oclearob)
     ))
    (debug_msg nmatcher "compiltst_normtester_matcher before nmatcher")
    (let ( (matcx (instance class_matchcompilcontext
			    :mcx_loc nloc
			    :mcx_normtester ntma
			    :mcx_gotothen gotothen
			    :mcx_gotoelse gotoelse
			    :mcx_olist olist
			    :mcx_prefix prefix)) )
      (debug_msg matcx "compiltst_normtester_matcher matcx")
      (compile_matcher nmatcher matcx gcx)
      (debug_msg olist "compiltst_normtester_matcher return olist")
      (return olist)
      )
    ))
(install_method class_normtester_matcher compile_tester compiltst_normtester_matcher)

;;;;;;;;;;;;;;;;
(defun compiltst_normtester_instance (ntmi gcx tcx)
  (debug_msg ntmi "compiltst_normtester_instance ntmi")
  (assert_msg "check ntmi" (is_a ntmi class_normtester_instance))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (assert_msg "check tcx" (is_a tcx class_testercompilcontext))
  (let ( 
	(nloc (unsafe_get_field :nrep_loc ntmi))
	(nmatched (unsafe_get_field :ntest_matched ntmi))
	(nthen (unsafe_get_field :ntest_then ntmi))
	(nelse (unsafe_get_field :ntest_else ntmi))
	(normatch (unsafe_get_field :ntest_normatch ntmi))
	(nlocclist (unsafe_get_field :ntest_locclist ntmi))
	(olist (make_list discr_list))
	(:long ntestix (get_int ntmi))	
	(ntclass (unsafe_get_field :ntinst_class ntmi))
	(ntflds (unsafe_get_field :ntinst_fieldlocs ntmi))
	(gotothen (or (normtester_gotoinstr nthen gcx)
		      (endmatch_gotoinstr normatch gcx nloc)))
	(gotoelse (or (normtester_gotoinstr nelse gcx)
		      (endmatch_gotoinstr normatch gcx nloc)))
	(oclass (compile_obj ntclass gcx))
	(omatched (compile_obj nmatched gcx))
	(freelist (normtester_free_objloc_list ntmi gcx tcx))
	(othenlist (make_list discr_list))
	(oelselist (make_list discr_list))
	(othenblock (instance class_objblock
			      :obi_loc nloc
			      :oblo_bodyl othenlist
			      ))
	(oelseblock (instance class_objblock
			      :obi_loc nloc
			      :oblo_bodyl oelselist))
	(otest (instance
		class_objlocatedexpv
		:obcx_loc nloc
		:obx_cont (make_tuple5
			   discr_multiple
			   (make_stringconst discr_verbatimstring 
					     "/*normtesterinst*/ (melt_is_instance_of((")
			   omatched
			   (make_stringconst discr_verbatimstring "), (")
			   oclass
			   (make_stringconst discr_verbatimstring ")))"))
		))
	(ocond (instance class_objcond
			 :obi_loc nloc
			 :obcond_test otest
			 :obcond_then othenblock
			 :obcond_else oelseblock))
	)
    (debug_msg gotothen "compiltst_normtester_instance gotothen")
    (debug_msg gotoelse "compiltst_normtester_instance gotoelse")
    (debug_msg ocond "compiltst_normtester_instance oclass")
    (assert_msg "check oclass" (is_object oclass))
    ;; clear the freelist
    (foreach_in_list
     (freelist)
     (locpair obloc)
     (debug_msg obloc "compiltst_normtester_instance obloc")
     (assert_msg "check obloc" (is_a obloc class_objlocv))
     (let ( (oclearob (instance class_objclear
				 :obi_loc nloc
				 :oclr_vloc obloc
				 )) )
       (list_append olist oclearob)
     ))
    ;; add the cond
    (list_append olist ocond)
    ;; we have to add into the othenlist the fetch of each field and
    ;; the gotothen
    (debug_msg ntflds "compiltst_normtester_instance ntflds")
    (debug_msg nlocclist "compiltst_normtester_instance nlocclist")
    (foreach_in_multiple
     (ntflds)
     (fldoc :long fldix)
     (if fldoc
	 (progn
	   (debug_msg fldoc "compiltst_normtester_instance fldoc")
	   (assert_msg "check fldoc" (is_a fldoc class_nrep_locsymocc))
	   (let ( (flovar (compile_obj fldoc gcx))
		  (flbind (unsafe_get_field :nocc_bind fldoc))
		  (fldget (unsafe_get_field :letbind_expr flbind))
		  (ofget (compile_obj fldget gcx))
		  )
	     (assert_msg "check flbind" (is_a flbind class_normlet_binding))
	     (assert_msg "check fldget" (is_a fldget class_nrep_unsafe_get_field))
	     (put_objdest ofget flovar)
	     (debug_msg ofget "compiltst_normtester_instance ofget")
	     (assert_msg "check ofget" (is_object ofget))
	     (list_append othenlist ofget)
     ))))
    ;; also add the gotothen
    (assert_msg "check gotothen" (is_object gotothen))
    (list_append othenlist gotothen)
    ;;
    ;; add into the oelselist the gotoelse
    (debug_msg gotoelse "compiltst_normtester_instance gotoelse")
    (assert_msg "check gotoelse" (is_object gotoelse))
    (list_append oelselist gotoelse)
    (warning_plain nloc "not fully implemented compiltst_normtester_instance")
    (shortbacktrace_dbg "compiltst_normtester_instance" 15)
    (debug_msg olist "compiltst_normtester_instance final olist")
    (return olist)
    )
  )
(install_method class_normtester_instance compile_tester compiltst_normtester_instance)
;;;;;;;;;;;;;;;;
(defun compiltst_normtester_same (ntsa gcx tcx)
  (debug_msg ntsa "compiltst_normtester_same ntsa")
  (assert_msg "check ntsa" (is_a ntsa class_normtester_same))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (assert_msg "check tcx" (is_a tcx class_testercompilcontext))
  (let ( 
	(nloc (unsafe_get_field :nrep_loc ntsa))
	(nmatched (unsafe_get_field :ntest_matched ntsa))
	(nthen (unsafe_get_field :ntest_then ntsa))
	(nelse (unsafe_get_field :ntest_else ntsa))
	(normatch (unsafe_get_field :ntest_normatch ntsa))
	(nidentical (unsafe_get_field :ntsame_identical ntsa))
	(:long ntestix (get_int ntsa))	
	(omatched (compile_obj nmatched gcx))
	(oidentical (compile_obj nidentical gcx))
	(gotothen (or (normtester_gotoinstr nthen gcx)
		      (endmatch_gotoinstr normatch gcx nloc)))
	(gotoelse (or (normtester_gotoinstr nelse gcx)
		      (endmatch_gotoinstr normatch gcx nloc)))
	(freelist (normtester_free_objloc_list ntsa gcx tcx))
	(othenlist (make_list discr_list))
	(oelselist (make_list discr_list))
	(othenblock (instance class_objblock
			      :obi_loc nloc
			      :oblo_bodyl othenlist
			      ))
	(oelseblock (instance class_objblock
			      :obi_loc nloc
			      :oblo_bodyl oelselist))
	(otest (instance
		class_objlocatedexpv
		:obcx_loc nloc
		:obx_cont (make_tuple5
			   discr_multiple
			   (make_stringconst discr_verbatimstring 
					     "/*same*/ ((")
			   omatched
			   (make_stringconst discr_verbatimstring ") == (")
			   oidentical
			   (make_stringconst discr_verbatimstring "))"))
		))
	(ocond (instance class_objcond
			 :obi_loc nloc
			 :obcond_test otest
			 :obcond_then othenblock
			 :obcond_else oelseblock))
	(olist (make_list discr_list))
	)
    ;; clear the freelist
    (foreach_in_list
     (freelist)
     (locpair obloc)
     (debug_msg obloc "compiltst_normtester_same obloc")
     (assert_msg "check obloc" (is_a obloc class_objlocv))
     (let ( (oclearob (instance class_objclear
				 :obi_loc nloc
				 :oclr_vloc obloc
				 )) )
       (list_append olist oclearob)
     ))
    ;; add the cond
    (list_append olist ocond)
    ;; also add the gotothen
    (assert_msg "check gotothen" (is_object gotothen))
    (list_append othenlist gotothen)
    ;; add into the oelselist the gotoelse
    (debug_msg gotoelse "compiltst_normtester_instance gotoelse")
    (assert_msg "check gotoelse" (is_object gotoelse))
    (list_append oelselist gotoelse)
    (return olist)
    )
)
(install_method class_normtester_same compile_tester compiltst_normtester_same)


;;;;;;;;;;;;;;;;
(defun compiltst_normtester_success (ntsu gcx tcx)
  (debug_msg ntsu "compiltst_normtester_success ntsu")
  (debug_msg tcx "compiltst_normtester_success tcx")
  (assert_msg "check ntsu" (is_a ntsu class_normtester_success))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (assert_msg "check tcx" (is_a tcx class_testercompilcontext))
  (let ( 
	(nloc (unsafe_get_field :nrep_loc ntsu))
	(nmatched (unsafe_get_field :ntest_matched ntsu))
	(nthen (unsafe_get_field :ntest_then ntsu))
	(nelse (unsafe_get_field :ntest_else ntsu))
	(nloclis (unsafe_get_field :ntest_locclist ntsu))
	(normatch (unsafe_get_field :ntest_normatch ntsu))
	(nsucdo (unsafe_get_field :ntsuccess_do ntsu))
	(:long ntestix (get_int ntsu))	
	(gotoend (endmatch_gotoinstr normatch gcx nloc))
	)
    (assert_msg "check nil nloclis" (null nloclis))
    (assert_msg "check nil nthen" (null nthen))
    (assert_msg "check nil nelse" (null nelse))
    (debug_msg nsucdo "compiltst_normtester_success nsucdo")
    (let ( (osucc (compile_obj nsucdo gcx)) 
	   )
      (debug_msg osucc "compiltst_normtester_success osucc")
      ;; maybe we have to free all the location allocated for this test
      (if (is_list osucc)
	  (progn
	    (list_append osucc gotoend)
	    (return osucc (list_last osucc)))
	(return (list2 osucc gotoend) osucc))
      )))
(install_method class_normtester_success compile_tester compiltst_normtester_success)

;;;;;;;;;;;;;;;;

;; to compile a disjunction, just goto the else case, because the
;; disjunction is only here to redistribute the then case inside the
;; disjuncts.
(defun compiltst_normtester_disjunction (ntdj gcx tcx)
  (debug_msg ntdj "compiltst_normtester_disjunction ntdj")
  (assert_msg "check ntdj" (is_a ntdj class_normtester_disjunction))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (assert_msg "check tcx" (is_a tcx class_testercompilcontext))
  (let (
	(nloc (unsafe_get_field :nrep_loc ntdj))
	(nelse (unsafe_get_field :ntest_else ntdj))
	(:long ntestix (get_int ntdj))	
	(normatch (unsafe_get_field :ntest_normatch ntdj))
	(gotoelse (or (normtester_gotoinstr nelse gcx)
		      (endmatch_gotoinstr normatch gcx nloc)))
	)
    (debug_msg gotoelse "compiltst_normtester_disjunction gotoelse")
    (return gotoelse)
    )
  )
(install_method class_normtester_disjunction compile_tester compiltst_normtester_disjunction)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilmatcher_cmatcher (cmat mcx gcx)
  (debug_msg cmat "compilmatcher_cmatcher cmat")
  (debug_msg mcx "compilmatcher_cmatcher mcx")
  (assert_msg "check cmat" (is_a cmat class_cmatcher))
  (assert_msg "check mcx" (is_a mcx class_matchcompilcontext))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (let (
	(cmins (unsafe_get_field :amatch_in cmat))
	(cmbind (unsafe_get_field :amatch_matchbind cmat))
	(cmouts (unsafe_get_field :amatch_out cmat))
	(cmstate (unsafe_get_field :cmatch_state cmat))
	(cmexptest (unsafe_get_field :cmatch_exptest cmat))
	(cmexpfill (unsafe_get_field :cmatch_expfill cmat))
	;; the normtester
	(normtester (unsafe_get_field :mcx_normtester mcx))
	;; the subsitution map
	(substmap (make_mapobject discr_mapobjects 
				  (+i 5
				      (*i 2 (+i (multiple_length cmins)
						(multiple_length cmouts))))))
	;; generate a unique state string
	(uniqstate (let ( (sbuf (make_strbuf discr_strbuf)) )
		     (add2sbuf_string sbuf (get_field :mcx_prefix mcx))
		     (add2sbuf_strconst sbuf "__")
		     (add2sbuf_cident sbuf (get_field :named_name cmstate))
		     (strbuf2string discr_verbatimstring sbuf)))
	;; fetch the olist to add instructions into
	(olist (get_field :mcx_olist mcx))
	)
    ;; map the state to the unique string 
    (mapobject_put substmap cmstate uniqstate)
    ;; map the matched thing 
    (let ( (nmatched (get_field :ntest_matched normtester)) )
      (debug_msg nmatched "compilmatcher_cmatcher nmatched")
      (let ( (obmatched (compile_obj nmatched gcx)) )
	(debug_msg obmatched "compilmatcher_cmatcher obmatched")
	(mapobject_put substmap
		       (get_field :binder cmbind)
		       obmatched
		       )))
    ;;
    (debug_msg normtester "compilmatcher_cmatcher normtester")
    ;; map each input arguments
    (multiple_every_both 
     (get_field :ntmatch_inargs normtester)
     cmins
     (lambda (curin formin :long ix)
       (debug_msg curin "compilmatcher_cmatcher curin")
       (debug_msg formin "compilmatcher_cmatcher formin")
       (assert_msg "check formin" (is_a formin class_formal_binding))
       (let ( (oin (compile_obj curin gcx)) )
	 (debug_msg oin "compilmatcher_cmatcher oin")
	 (mapobject_put substmap
			(get_field :binder formin)
			oin)
	 )))
    ;; map each output arguments
    (multiple_every_both
     (get_field :ntmatch_outlocs normtester)
     cmouts
     (lambda (curout formout :long ix)
       (debug_msg curout "compilmatcher_cmatcher curout")
       (debug_msg formout "compilmatcher_cmatcher formout")
       (assert_msg "check formout" (is_a formout class_formal_binding))
       (let ( (oout (compile_obj curout gcx)) )
	 (debug_msg oout "compilmatcher_cmatcher oout")
	 (mapobject_put substmap
			(get_field :binder formout)
			oout))
       ))
    (debug_msg substmap "compilmatcher_cmatcher substmap")
    ;; expand
    (let ( 
	  (expander 
	   (lambda (tup)
	     (multiple_map
	      tup
	      (lambda (c)
		(cond 
		 ( (is_a c class_symbol)
		   (let ( (r (mapobject_get substmap c)) )
		     (if (null r)
			 (error_strv (get_field :mcx_loc mcx)
				     "invalid symbol to expand for cmatcher" (get_field :named_name c)))
		     r))
		 ( (is_object c)
		   (error_plain (get_field :mcx_loc mcx)
				"invalid object to expand for cmatcher"))
		 ( (is_string c)
		   (make_string discr_verbatimstring c))
		 (:else
		  (error_plain (get_field :mcx_loc mcx)
			       "invalid stuff to expand for cmatcher")))))))
	  (exptest (expander cmexptest))
	  (expfill (expander cmexpfill))
	  (mloc (get_field :mcx_loc mcx))
	  (testchunk (instance class_objlocatedexpv
			       :obv_type ctype_long
			       :obx_cont exptest
			       :obcx_loc mloc))
	  (fillchunk (instance class_objlocatedexpv
			       :obv_type ctype_void
			       :obx_cont expfill
			       :obcx_loc mloc))
	  )
      (debug_msg exptest "compilmatcher_cmatcher exptest")
      (debug_msg expfill  "compilmatcher_cmatcher expfill")
      (let ( 
	    (othenlist (make_list discr_list))
	    (othenbody (instance class_objblock
				 :obi_loc mloc
				 :oblo_bodyl othenlist
				 ))
	    (oelselist (make_list discr_list))
	    (oelsebody (instance class_objblock
				 :obi_loc mloc
				 :oblo_bodyl oelselist
				 ))
	    (ocond (instance class_objcond
			     :obi_loc mloc
			     :obcond_test testchunk
			     :obcond_then othenbody
			     :obcond_else oelsebody
			     ))
	    )
	(list_append olist ocond)
	(foreach_in_multiple
	 (cmouts)
	 (curout :long outix)
	 (debug_msg curout "compilmatcher_cmatcher curout")
	 (assert_msg "check curout" (is_a curout class_formal_binding))
	 (let ( (locout
		 (mapobject_get substmap 
				(unsafe_get_field :binder curout)))
		(oclearout (instance class_objclear
				     :obi_loc mloc
				     :oclr_vloc locout)) )
	   (debug_msg oclearout "compilmatcher_cmatcher oclearout")
	   (assert_msg "check locout" (is_object locout))
	   (list_append othenlist oclearout)
	   )
	 )
	(list_append othenlist fillchunk)
	(list_append othenlist (get_field :mcx_gotothen mcx))
	(list_append oelselist (get_field :mcx_gotoelse mcx))
	(debug_msg ocond "compilmatcher_cmatcher final ocond")
	)
      )))
(install_method class_cmatcher compile_matcher compilmatcher_cmatcher)

;; eof warmelt-genobj.melt





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilmatcher_funmatcher (fmat mcx gcx)
  (debug_msg fmat "compilmatcher_funmatcher fmat")
  (debug_msg mcx "compilmatcher_funmatcher mcx")
  (assert_msg "check fmat" (is_a fmat class_funmatcher))
  (assert_msg "check mcx" (is_a mcx class_matchcompilcontext))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (let (
	(fmins (unsafe_get_field :amatch_in fmat))
	(fmbind (unsafe_get_field :amatch_matchbind fmat))
	(fmouts (unsafe_get_field :amatch_out fmat))
	(ntma (get_field :mcx_normtester mcx))
	;; fetch the olist to add instructions into
	(olist (get_field :mcx_olist mcx)) 
	(mloc (get_field :mcx_loc mcx))
	)
    (debug_msg ntma "compilmatcher_funmatcher ntma")
    (assert_msg "check ntma" (is_a ntma class_normtester_matcher))
    (let ( (matndata (get_field :ntmatch_matndata ntma)) 
	   (omatdata (compile_obj matndata gcx))
	   (nmatched (get_field :ntest_matched ntma))
	   (omatched (compile_obj nmatched gcx))
	   (nins (get_field :ntmatch_inargs ntma))
	   (nouts (get_field :ntmatch_outlocs ntma))
	   (oins (multiple_map 
		  nins 
		  (lambda (thein)
		    (compile_obj thein gcx)
		    )))
	   (oouts (multiple_map 
		  nouts 
		  (lambda (theout)
		    (compile_obj theout gcx)
		    )))
	   (otestres (get_free_objlocptr gcx fmat))
	   (otestclos (get_free_objlocptr gcx '_closfunmatch))
	   )
      (debug_msg matndata "compilmatcher_funmatcher matndata")
      (debug_msg omatdata "compilmatcher_funmatcher omatdata")
      (debug_msg fmins "compilmatcher_funmatcher fmins")
      (debug_msg fmbind "compilmatcher_funmatcher fmbind")
      (debug_msg fmouts "compilmatcher_funmatcher fmouts")
      (debug_msg nins "compilmatcher_funmatcher nins")
      (debug_msg nouts "compilmatcher_funmatcher nouts")
      (debug_msg nmatched "compilmatcher_funmatcher nmatched")
      (debug_msg omatched "compilmatcher_funmatcher omatched")
      (debug_msg oins "compilmatcher_funmatcher oins")
      (debug_msg oouts "compilmatcher_funmatcher oouts")
      (debug_msg ntma "compilmatcher_funmatcher ntma")
      (debug_msg otestres "compilmatcher_funmatcher otestres")
      (debug_msg otestclos "compilmatcher_funmatcher otestclos")
      ;; should generate a multiapplication etc...
      (let (
	    (oargs (make_multiple discr_multiple (+i 2 (multiple_length oins))))
	    (ogetclos (instance class_objgetslot
				:obi_loc mloc
				:obdi_destlist (list1 otestclos)
				:ogetsl_obj omatdata
				:ogetsl_field fmatch_matchf
				))
	    (omapp (instance class_objmultiapply
			      :obi_loc mloc
			      :obdi_destlist (list1 otestres)
			      :obapp_clos otestclos
			      :obapp_args oargs
			      :obmultapp_xres oouts
			      ))
	    (othenlist (make_list discr_list))
	    (othenbody (instance class_objblock
				 :obi_loc mloc
				 :oblo_bodyl othenlist
				 ))
	    (oelselist (make_list discr_list))
	    (oelsebody (instance class_objblock
				 :obi_loc mloc
				 :oblo_bodyl oelselist
				 ))
	    (ocond (instance class_objcond
			     :obi_loc mloc
			     :obcond_test otestres
			     :obcond_then othenbody
			     :obcond_else oelsebody
			     ))
	     )
	(multiple_put_nth oargs 0 omatdata)
	(multiple_put_nth oargs 1 omatched)
	(foreach_in_multiple
	 (oins)
	 (curins :long inix)
	 (multiple_put_nth oargs (+i inix 2) curins)
	 )
	;; add the clear of all the outs in the else branch
	(foreach_in_multiple
	 (oouts)
	 (curouts :long outix)
	 (let ( (obcl (instance class_objclear
				:obi_loc mloc
				:oclr_vloc curouts)) )
	   (debug_msg obcl "compilmatcher_funmatcher obcl")
	   (list_append oelselist obcl)
	 ))
	;; dispose the temporary variables
	(dispose_objloc otestres gcx)
	(dispose_objloc otestclos gcx)
	;; add the final gotos
	(list_append othenlist (get_field :mcx_gotothen mcx))
	(list_append oelselist (get_field :mcx_gotoelse mcx))
	(debug_msg ogetclos "compilmatcher_funmatcher ogetclos")
	(debug_msg omapp "compilmatcher_funmatcher omapp")
	(debug_msg ocond "compilmatcher_funmatcher ocond")
	(list_append olist ogetclos)
	(list_append olist omapp)
	(list_append olist ocond)
	)
      )
    ))
(install_method class_funmatcher compile_matcher compilmatcher_funmatcher)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; eof warmelt-genobj.melt
