;; -*- Lisp -*-
;; file ana-base.bysl
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(comment "
    Copyright 2008 Free Software Foundation, Inc.
    Contributed by Basile Starynkevitch <basile@starynkevitch.net>

    This file is part of GCC.

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
")

;; the copyright notice above apply both to ana-base.bysl and 
;; to the generated file  ana-base*.c

;; a class containing the analysis state
(defclass class_analysis_state
  :super class_proped
  :fields (
))


;;; primitive to access the gdbmstate

(defprimitive fetch_gdbmstate_constr (:cstring keystr) :value
  "(basilysgc_fetch_gdbmstate_const((" keystr ")))")

(defprimitive fetch_gdbmstate (key) :value
  "(basilysgc_fetch_gdbmstate((" key ")))")

(defprimitive put_gdbmstate_constr (:cstring keystr :value data) :void
  "basilysgc_put_gdbmstate_const((" keystr "), (basilys_ptr_t) (" data "))")

(defprimitive put_gdbmstate (key data) :void
  "basilysgc_put_gdbmstate((basilys_ptr_t)(" key "), (basilys_ptr_t)(" data "))")

(defun install_gcc_pass (pass)
  (assert_msg "check pass" (is_a pass class_gcc_pass))
  (mapstring_putstr (unsafe_get_field :sysdata_pass_dict initial_system_data)
		 (unsafe_get_field :named_name pass)
		 pass)
  (debug_msg pass "installed gcc pass")
)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; gimple & tree related primitives

(defprimitive is_gimple (v) :long
  "(basilys_magic_discr((basilys_ptr_t)(" v ")) == OBMAG_GIMPLE)")

(defprimitive make_gimple (discr :gimple g) :value
  "(basilysgc_new_gimple((basilysobject_ptr_t)(" discr "),(" g ")))")

(defprimitive gimple_content (v) :gimple
  "(basilys_gimple_content((basilys_ptr_t)(" v ")))")

(defprimitive is_gimpleseq (v) :long
  "(basilys_magic_discr((basilys_ptr_t)(" v ")) == OBMAG_GIMPLESEQ)")

(defprimitive make_gimpleseq (discr :gimpleseq g) :value
  "(basilysgc_new_gimpleseq((basilysobject_ptr_t)(" discr "),(" g ")))")

(defprimitive gimpleseq_content (v) :gimpleseq
  "(basilys_gimpleseq_content((basilys_ptr_t)(" v ")))")

(defprimitive is_tree (v) :long
  "(basilys_magic_discr((basilys_ptr_t)(" v ")) == OBMAG_TREE)")

(defprimitive make_tree (discr :tree g) :value
  "(basilysgc_new_tree((basilysobject_ptr_t)(" discr "),(" g ")))")

(defprimitive tree_content (v) :tree
  "(basilys_tree_content((basilys_ptr_t)(" v ")))")

(defprimitive ppstrbuf_gimple (sbuf :long indent :gimple g) :void
  "basilysgc_ppstrbuf_gimple((basilys_ptr_t)(" sbuf 
  "), (int) (" indent "), (" g "))")

(defprimitive ppstrbuf_gimple_seq (sbuf :long indent :gimpleseq gseq) :void
  "basilysgc_ppstrbuf_gimple_seq((basilys_ptr_t)(" sbuf 
  "), (int) (" indent "), (" gseq "))")

(defprimitive ppstrbuf_tree (sbuf :long indent :tree t) :void
  "basilysgc_ppstrbuf_tree((basilys_ptr_t)(" sbuf 
  "), (int) (" indent "), (" t "))")

;;;; boxed gimple debug
(defun dbgout_boxgimple_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (let ( (dis (discrim self)) 
	 (sbuf  (unsafe_get_field :dbgi_sbuf dbgi)) ) 
    (add2sbuf_strconst sbuf " ?/")
    (if (is_a dis class_named) (add2sbuf_string sbuf (unsafe_get_field :named_name dis)))
    (add2sbuf_strconst sbuf "/{ ")
    (ppstrbuf_gimple sbuf depth (gimple_content self))
    (add2sbuf_strconst sbuf "}/ ")
    )
  )
(install_method discr_gimple dbg_output dbgout_boxgimple_method)

;;;; boxed gimple seq debug
(defun dbgout_boxgimpleseq_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (let ( (dis (discrim self)) 
	 (sbuf  (unsafe_get_field :dbgi_sbuf dbgi)) ) 
    (add2sbuf_strconst sbuf " ?/")
    (if (is_a dis class_named) (add2sbuf_string sbuf (unsafe_get_field :named_name dis)))
    (add2sbuf_strconst sbuf "/{ ")
    (ppstrbuf_gimple_seq sbuf depth (gimpleseq_content self))
    (add2sbuf_strconst sbuf "}/ ")
    )
  )
(install_method discr_gimpleseq dbg_output dbgout_boxgimpleseq_method)

;;;; boxed tree debug
(defun dbgout_boxtree_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (let ( (dis (discrim self)) 
	 (sbuf  (unsafe_get_field :dbgi_sbuf dbgi)) ) 
    (add2sbuf_strconst sbuf " ?/")
    (if (is_a dis class_named) (add2sbuf_string sbuf (unsafe_get_field :named_name dis)))
    (add2sbuf_strconst sbuf "/{ ")
    (ppstrbuf_tree sbuf depth (tree_content self))
    (add2sbuf_strconst sbuf "}/ ")
    )
  )
(install_method discr_tree dbg_output dbgout_boxtree_method)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;; G C C      P A S S E S 
;; the named_name of passes is builtin in gcc/basilys.c [lowercase]


;;;;;;;;;;;;;;;;;; lowering pass
;; the CFG is available, but the tree is not in SSA form
(definstance basilys_lowering_gccpass 
  class_gcc_pass
  :named_name (make_stringconst discr_string "basilys-lowering")
  :gccpass_data ()
)
(install_gcc_pass basilys_lowering_gccpass)

;;;;;;;;;;;;;;;;;; ipa (interprocedural analysis) pass
;; the CFG is available & tree is in SSA form
(definstance basilys_ipa_gccpass 
  class_gcc_pass
  :named_name (make_stringconst discr_string "basilys-ipa")
  :gccpass_gate ()
  :gccpass_exec ()
  :gccpass_data ()
)
(install_gcc_pass basilys_ipa_gccpass)


;;;;;;;;;;;;;;;;;; early optimisation pass
;; code in SSA
(definstance basilys_earlyopt_gccpass
  class_gcc_pass
  :named_name (make_stringconst discr_string "basilys-earlyopt")
  :gccpass_data ()
)
(install_gcc_pass basilys_earlyopt_gccpass)

;;;;;;;;;;;;;;;;;; late optimisation pass
;; code in SSA, soon to be removed
(definstance basilys_lateopt_gccpass class_gcc_pass
  :named_name (make_stringconst discr_string "basilys-lateopt")
  :gccpass_data ()
)
(install_gcc_pass basilys_lateopt_gccpass)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; iterators needed in our analysis

;;; an iterator is simply something which translates to a for loop in
;;; C. It usually binds some variables (local to the iterated body)
;;; to some C stuff.

;;; Be careful to not declare any iterator related stuff in
;;; warmelt*.bysl file, because we want to be able to bootstrap
;;; Basilys/MELT (ie to generate the warmelt*.c files) even when GCC
;;; internal representation changes a little.

;;;;;;;;;;;;;;;;
;;;; iterate on every cgraph_node which is a function with a body
(defciterator each_cgraph_fun 
  ()					; startformals
  eachcgrfun 				;state symbol
  (:tree funtree :gimpleseq funbody)	;local formals
  (					;; before expansion
   "struct cgraph_node *" eachcgrfun "_nd=0; "
   "for (" eachcgrfun "_nd = cgraph_nodes; "
   eachcgrfun "_nd != 0; "
   eachcgrfun "_nd = " eachcgrfun "_nd->next) {\n"
   "tree " eachcgrfun "_dcl = 0;\n"
   "gimple_seq " eachcgrfun "_bdy = 0;\n"
   eachcgrfun "_dcl = " eachcgrfun "_nd->decl;\n"
   "if (!" eachcgrfun "_dcl) continue;\n"
   "if (TREE_CODE(" eachcgrfun "_dcl) != FUNCTION_DECL) continue;\n"
   eachcgrfun "_bdy = gimple_body(" eachcgrfun "_dcl);\n"
   "if (!" eachcgrfun "_bdy) continue;\n"
   funtree " = " eachcgrfun "_dcl;\n"
   funbody " = " eachcgrfun "_bdy;\n"
   )
  ( ;;after expansion
   "}"
   )
  )

;; apply a function to every cfun -its decl & bodyseq
(defun do_each_cfun (f)
  (each_cgraph_fun  
   () 
   (:tree decl :gimpleseq bdy)
   (let ( (dclval (make_tree discr_tree decl)) 
	  (bdyval (make_gimpleseq discr_gimpleseq bdy))
	  )
     (f dclval bdyval)
   )))

;;;; iterate on a gimpleseq
(defciterator each_in_gimpleseq
  (:gimpleseq gseq)			;start formals
  eachgimplseq
  (:gimple g)				;local formals
  ( ;;; before expansion
   "gimple_stmt_iterator gsi_" eachgimplseq ";\n"
   "for (gsi_" eachgimplseq " = gsi_start (" gseq "); !gsi_end_p (gsi_" eachgimplseq ");"
   " gsi_next (&gsi_" eachgimplseq ")) {\n"
    g " = gsi_stmt (gsi_" eachgimplseq ");"
   )
  ( ;;; after expansion
   "}"
   )
)

;;;; reverseiterate on a gimpleseq
(defciterator reveach_in_gimpleseq
  (:gimpleseq gseq)			;start formals
  eachgimplseq
  (:gimple g)				;local formals
  ( ;;; before expansion
   "gimple_stmt_iterator gsi_" eachgimplseq ";\n"
   "for (gsi_" eachgimplseq " = gsi_last (" gseq "); !gsi_end_p (gsi_" eachgimplseq ");"
   " gsi_prev (&gsi_" eachgimplseq ")) {\n"
    g " = gsi_stmt (gsi_" eachgimplseq ");"
   )
  ( ;;; after expansion
   "}"
   )
)

;; apply a function to each boxed gimple in a gimple seq
(defun do_each_gimpleseq (f :gimpleseq gseq)
  (each_in_gimpleseq 
   (gseq) (:gimple g)
   (let ( (gplval (make_gimple discr_gimple g)) )
     (f gplval)))
)


;; apply a function to each boxed gimple in a gimple seq
(defun do_reveach_gimpleseq (f :gimpleseq gseq)
  (reveach_in_gimpleseq 
   (gseq) (:gimple g)
   (let ( (gplval (make_gimple discr_gimple g)) )
     (f gplval)))
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(export_values
 basilys_earlyopt_gccpass
 basilys_ipa_gccpass
 basilys_lateopt_gccpass
 basilys_lowering_gccpass
 each_cgraph_fun
 each_in_gimpleseq
 fetch_gdbmstate
 fetch_gdbmstate_constr
 install_gcc_pass
 put_gdbmstate
 put_gdbmstate_constr
 reveach_in_gimpleseq
)

(export_class
 class_analysis_state
)
;; eof ana-base.bysl