;; -*- Lisp -*-
;; file ana-base.bysl
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(comment "
    Copyright 2008 Free Software Foundation, Inc.
    Contributed by Basile Starynkevitch <basile@starynkevitch.net>

    This file is part of GCC.

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
")

;; the copyright notice above apply both to ana-base.bysl and 
;; to the generated file  ana-base*.c

;; a class containing the analysis state
(defclass class_analysis_state
  :super class_proped
  :fields (
))


;;; primitive to access the gdbmstate

(defprimitive fetch_gdbmstate_constr (:cstring keystr) :value
  "(basilysgc_fetch_gdbmstate_const((" keystr ")))")

(defprimitive fetch_gdbmstate (key) :value
  "(basilysgc_fetch_gdbmstate((" key ")))")

(defprimitive put_gdbmstate_constr (:cstring keystr :value data) :void
  "basilysgc_put_gdbmstate_const((" keystr "), (basilys_ptr_t) (" data "))")

(defprimitive put_gdbmstate (key data) :void
  "basilysgc_put_gdbmstate((basilys_ptr_t)(" key "), (basilys_ptr_t)(" data "))")

(defun install_gcc_pass (pass)
  (assert_msg "check pass" (is_a pass class_gcc_pass))
  (mapstring_putstr (unsafe_get_field :sysdata_pass_dict initial_system_data)
		 (unsafe_get_field :named_name pass)
		 pass)
  (debug_msg pass "installed gcc pass")
)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; gimple & tree related primitives

(defprimitive is_gimple (v) :long
  "(basilys_magic_discr((basilys_ptr_t)(" v ")) == OBMAG_GIMPLE)")

(defprimitive make_gimple (discr :gimple g) :value
  "(basilysgc_new_gimple((basilysobject_ptr_t)(" discr "),(" g ")))")

(defprimitive gimple_content (v) :gimple
  "(basilys_gimple_content((basilys_ptr_t)(" v ")))")

(defprimitive is_tree (v) :long
  "(basilys_magic_discr((basilys_ptr_t)(" v ")) == OBMAG_TREE)")

(defprimitive make_tree (discr :tree g) :value
  "(basilysgc_new_tree((basilysobject_ptr_t)(" discr "),(" g ")))")

(defprimitive tree_content (v) :tree
  "(basilys_tree_content((basilys_ptr_t)(" v ")))")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;; G C C      P A S S E S 
;; the named_name of passes is builtin in gcc/basilys.c [lowercase]


;;;;;;;;;;;;;;;;;; lowering pass
;; the CFG is available, but the tree is not in SSA form
(definstance basilys_lowering_gccpass 
  class_gcc_pass
  :named_name (make_stringconst discr_string "basilys-lowering")
  :gccpass_data ()
)
(install_gcc_pass basilys_lowering_gccpass)

;;;;;;;;;;;;;;;;;; ipa (interprocedural analysis) pass
;; the CFG is available & tree is in SSA form
(definstance basilys_ipa_gccpass 
  class_gcc_pass
  :named_name (make_stringconst discr_string "basilys-ipa")
  :gccpass_gate ()
  :gccpass_exec ()
  :gccpass_data ()
)
(install_gcc_pass basilys_ipa_gccpass)


;;;;;;;;;;;;;;;;;; early optimisation pass
;; code in SSA
(definstance basilys_earlyopt_gccpass
  class_gcc_pass
  :named_name (make_stringconst discr_string "basilys-earlyopt")
  :gccpass_data ()
)
(install_gcc_pass basilys_earlyopt_gccpass)

;;;;;;;;;;;;;;;;;; late optimisation pass
;; code in SSA, soon to be removed
(definstance basilys_lateopt_gccpass class_gcc_pass
  :named_name (make_stringconst discr_string "basilys-lateopt")
  :gccpass_data ()
)
(install_gcc_pass basilys_lateopt_gccpass)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; iterators needed in our analysis

;;; an iterator is simply something which translates to a for loop in
;;; C. It usually binds some variables (local to the iterated body)
;;; to some C stuff.

;;; Be careful to not declare any iterator related stuff in
;;; warmelt*.bysl file, because we want to be able to bootstrap
;;; Basilys/MELT (ie to generate the warmelt*.c files) even when GCC
;;; internal representation changes a little.

;;;;;;;;;;;;;;;;
;;;; iterate on every cgraph_node which is a function with a body
(defciterator each_cgraph_fun 
  ()					; startformals
  eachcgrfun 				;state symbol
  (:tree funtree)	;local formals
  (					;; before expansion
   "struct cgraph_node *" eachcgrfun "_nd=0; "
   "for (" eachcgrfun "_nd = cgraph_nodes; "
   eachcgrfun "_nd != 0; "
   eachcgrfun "_nd = " eachcgrfun "_nd->next) {\n"
   "tree " eachcgrfun "_dcl = 0;\n"
   "gimple_seq " eachcgrfun "_bdy = 0;\n"
   eachcgrfun "_dcl = " eachcgrfun "_nd->decl;\n"
   "if (!" eachcgrfun "_dcl) continue;\n"
   eachcgrfun "_bdy = gimple_body(" eachcgrfun "_nd->decl);\n"
   "if (!" eachcgrfun "_bdy) continue;\n"
   funtree " = " eachcgrfun "_dcl;\n"
   )
  ( ;;after expansion
   "}"
   )
  )

(defun do_each_cfun (f)
  (each_cgraph_fun  
   () 
   (:tree decl)
   (let ( (dclval (make_tree discr_tree decl))
	  )
     (f dclval)
   )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(export_values
 fetch_gdbmstate
 fetch_gdbmstate_constr
 put_gdbmstate
 put_gdbmstate_constr
 install_gcc_pass
 basilys_earlyopt_gccpass
 basilys_lateopt_gccpass
 basilys_lowering_gccpass
 basilys_ipa_gccpass
 each_cgraph_fun
)

(export_class
 class_analysis_state
)
;; eof ana-base.bysl