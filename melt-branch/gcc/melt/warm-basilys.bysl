;; -*- Lisp -*-
;; file warm-basilys.bysl
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(comment "
    Copyright 2008 Free Software Foundation, Inc.
    Contributed by Basile Starynkevitch <basile@starynkevitch.net>

    This file is part of GCC.

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
")

;; the copyright notice above apply both to warm-basilys.bysl and 
;; to the generated file warm-basilys*.c

;;;;;;
;;    This file is a bootstrapping compiler for the basilys lisp dialect
;;    it should be able to compile itself (into a generated C file)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;****************************************************************
;;       C L A S S E S 
;;****************************************************************

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; ================ general classes

;; root class
(defclass class_root 
  :predef CLASS_ROOT)

;; class of everything with a property table
(defclass class_proped 
 :super class_root 
 :fields (prop_table)
 :predef CLASS_PROPED)


;; arbitrary container as class
(defclass class_container
  :super class_root
  :fields (container_value))

;; class of named objects
(defclass class_named 
  :super class_proped 
  :fields (named_name) 
  :predef CLASS_NAMED)
 
;; class of discriminants
(defclass class_discr 
  :super class_named 
  :fields (disc_methodict 
	   disc_sender 
	   disc_super)
  :predef CLASS_DISCR)
 
;; class of classes
(defclass class_class
   :super class_discr
   :fields (class_ancestors class_fields class_objnumdescr class_data)
   :predef CLASS_CLASS)
 
;; class of fields
(defclass class_field
  ;; the fields' objnum is its offset
   :super class_named
   :fields (fld_ownclass fld_typinfo)
   :predef CLASS_FIELD)
 
;; class of primitive
(defclass class_primitive
   :super class_named
   :fields (prim_formals prim_type prim_expansion)
   :predef CLASS_PRIMITIVE)
 
;; class of located stuff
(defclass class_located
  :super class_proped
  :fields (loca_location)
  :predef CLASS_LOCATED)

;; class of source expressions
(defclass class_sexpr
  :super class_located
  :fields (sexp_contents		;list of contents
	   )
  :predef CLASS_SEXPR)

;; class of message selectors
(defclass class_selector
  :super class_named
  :fields (sel_signature sel_data)
  :predef CLASS_SELECTOR)


;; class of symbols
(defclass class_symbol
  :predef CLASS_SYMBOL
  :super class_named
  :fields (symb_data))

;; class of generated (ie cloned) symbols - like lisp gensym
(defclass class_clonedsymbol
  :super class_symbol
  :fields (csym_urank			;unique rank as a boxed integer
	   ))

;; class of keyword symbols
(defclass class_keyword
  :predef CLASS_KEYWORD
  :super class_symbol
  :fields ())

;; class of C types keywords
(defclass class_ctype
  :super class_named
  :fields (
	   ctype_keyword ;the keyword associated to the ctype (e.g. :long)
	   ctype_cname	 ;the name for C of the type (eg long)
	   ctype_parchar ;the name of the basilys parameter char (eg BPAR_LONG)
	   ctype_parstring ;the name of the basilys parameter string (eg BPARSTR_LONG)
	   ctype_argfield ;the name of the basilys argument union field (eg bp_long)
	   ctype_resfield ;the name of the basilys result union field (eg bp_longptr)
	   )
  )

;; class of tokenizers
(defclass class_tokenizer
  :super class_named
  :fields (tok_symboldict 		; stringmap for symbols
	   tok_keywdict 			;stringmap for keywords
	   tok_addsymbol 		;closure to add a symbol of given name
	   tok_addkeyw		;closure to add a keyword of given name
	   tok_internsymbol		;closure to intern a symbol
	   tok_internkeyw		;closure to intern a keyword
	   )
  :predef CLASS_TOKENIZER)

;; class of command dispatchers
(defclass class_command_dispatcher
  :predef CLASS_COMMAND_DISPATCHER
  :super class_named
  :fields (cmd_fundict			;stringmap for closures
	   ))


;; class for debug information (used for debug_msg & dbgout* stuff)
(defclass class_debuginfo 
  :super class_root
  :fields (dbgi_sbuf 			;the produced stringbuf
	   dbgi_occmap ;the occurrence map (to avoid outputing twice the same object)
	   dbgi_maxdepth ;the boxed integer maximal depth
	   )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; ================ classes for environments & bindings

;;;; the class for environments
(defclass class_environment
  :super class_root
  :fields (env_bind			;the map of bindings
	   env_prev			;the previous environment
	   env_proc			;the procedure of this environment
))

;; the (super-)class of any binding
(defclass class_any_binding
  :super class_root
  :fields (binder)
)

;;; superclass of exported bindings
(defclass class_exported_binding
  :super class_any_binding
  :fields ( )
)

;; macro binding
(defclass class_macro_binding
  :super class_exported_binding
  :fields (mbind_expanser))


;; value binding - as exported 
(defclass class_value_binding
  :super class_exported_binding
  :fields (vbind_value
))

; formal binding (used in generated defprimitive)
(defclass class_formal_binding
  :super class_any_binding
  :fields (fbind_type)
  ;;the obj_num is the argument rank
  :predef CLASS_FORMAL_BINDING)


;;; fixed bindings are defined in a compilation unit and can be implemented as constants in routine
(defclass class_fixed_binding
  :super class_any_binding
  :fields ()
)

;; selector binding
(defclass class_selector_binding
  :super class_fixed_binding
  :fields (sbind_selectordef 		;the "source" defselector
	   sbind_selectordata		;the compiled data
	   ;; maybe we need an selectorval for the actual value
	   )
)

;; primitive binding
(defclass class_primitive_binding
  :super class_fixed_binding
  :fields (pbind_primdef		;the source defprimitive
	   pbind_primitive		;the primitive proper
	   pbind_primdata		;the primitive data as compiled
))


;; function binding
(defclass class_function_binding
  :super class_fixed_binding
  :fields (fubind_defun ;the source definition
	   fubind_fundata		;compiled data
))

;; class binding
(defclass class_class_binding
  :super class_fixed_binding
  :fields (cbind_defclass ;the source definition
	   cbind_class			;the built class
	   cbind_cladata		;compiled data
))

;; field binding
(defclass class_field_binding
  :super class_fixed_binding
  :fields (flbind_clabind		;the class binding
	   flbind_field			;the field proper
	   flbind_fdata			;the compiled field data
))

;; instance binding
(defclass class_instance_binding
  :super class_fixed_binding
  :fields ( ibind_iclass		;the instance's class
	    ibind_data			;the compiled data
	    ))
;; let binding
(defclass class_let_binding
  :super class_any_binding
  :fields (letbind_type			;the ctype 
	   letbind_expr			;the expression
	   letbind_loc			;the optional src location
	   ))

;; normalized let binding
(defclass class_normlet_binding
  :super class_let_binding
  :fields  ())				;no additional field, but
					;letbind_expr is "normal"

;; label binding
(defclass class_label_binding
  :super class_any_binding
  :fields (labind_loc			;location of the label
;;; following fields are filled later in the compilation phase
	   labind_clonsy		;unique cloned symbol
	   labind_res			;result localvar
))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; ================  source program elements

;; common superclass of source elements
(defclass class_src 
  :super class_root
  :fields (src_loc			;the source location (if any)
	   )
)


;;; source application 
(defclass class_src_apply
  :super class_src
  :fields (sapp_fun			;the function to apply
	   sapp_args			;the arguments tuple
	   ))

;;; source message sending 
(defclass class_src_msend
  :super class_src
  :fields ( 
	    msend_selbind		;the selector binding
	    msend_recv			;the reciever
	    msend_args 			;the tuple of arguments
	   ))

;;; source primitive call
(defclass class_src_primitive
  :super class_src
  :fields (sprim_oper			;the primitive operation
	   sprim_args			;the arguments tuple
	   ))

;;; source progn
(defclass class_src_progn
  :super class_src
  :fields (sprogn_body			;the body tuple
))

;;; source return
(defclass class_src_return
  :super class_src
  :fields (sreturn_body			;the body tuple
))

;;;; source setq
(defclass class_src_setq
  :super class_src
  :fields (sstq_var
	   sstq_expr))

;;;; source comment
(defclass class_src_comment
  :super class_src
  :fields (scomm_str
	  ))

;;;; source quote
(defclass class_src_quote
  :super class_src
  :fields (squoted
))
;;; superclass for all source definitions
(defclass class_srcdef
  :super class_src
  :fields (sdef_name			;defined name
))

;;; superclass for all definitions with formal arglist
(defclass class_srcdeformal
  :super class_srcdef
  :fields (sformal_args			;formal arguments binding tuple
))

;;;; define a function
(defclass class_src_defun
  :super class_srcdeformal
  :fields (sfun_body			;body sequence
))

;;; define a primitive
(defclass class_src_defprimitive
  :super class_srcdeformal
  :fields (sprim_type			;result type of primitive
	   sprim_expansion		;primitive expansion
))

;; define an object (common to instance, class, selector)
(defclass class_src_defobjcommon
  :super class_srcdef
  :fields (sobj_predef			;the predefined rank
	   sobj_docstr			;documentation string
))

;; define a class 
;;;; the class has been built (at compile time), but we need a
;;;; srcdefclass to actually generate code
(defclass class_src_defclass
  :super class_src_defobjcommon
  :fields (sclass_clabind		;the binding of the class
	   sclass_superbind		;binding of superclass (or nil if none)
	   sclass_fldbinds		;the sequence of (own field bindings)
))


;; define an instance
(defclass class_src_definstance
  :super class_src_defobjcommon
  :fields (sinst_class			;the class of the instance
	   sinst_clabind		;the classbinding of the instance
	   sinst_objnum			;the object number symbol or integer
	   sinst_fields			;the sequence of field assignment
))

;; define a selector 
(defclass class_src_defselector
  :super class_src_definstance
)

;; a field assignment
(defclass class_src_fieldassign
  :super class_src
  :fields (sfla_field			;the field 
	   sfla_expr			;the expression
))


;; make an instance
(defclass class_src_make_instance
  :super class_src
  :fields (smins_class			;the class to be instantiated
	   smins_clabind		;its (class|value) binding
	   smins_fields			;the sequence of field assignment
))

;;; source unsafe get field
(defclass class_src_unsafe_get_field
  :super class_src
  :fields (suget_obj	     ;the object expression
	   suget_field	     ;the field keyword
))

;; source unsafe put fields
(defclass class_src_unsafe_put_fields
  :super class_src
  :fields (suput_obj	     ;the object expression
	   suput_fields			;the sequence of field assignment
))


;; a conditional (if, and, cond)
(defclass class_src_if
  :super class_src
  :fields (sif_test
	   sif_then
))

(defclass class_src_ifelse
  :super class_src_if
  :fields ( sif_else
))

;; an or
;;; since (OR a1 a2) is (IF a1 a1 a2) we need to normalize it to avoid evaluating twice a1
;;; so there is no normalized or... (only normalized if-s)
(defclass class_src_or
  :super class_src
  :fields (sor_disj			;tuple of disjuncts
))


;; preprocessor conditional
(defclass class_src_cppif
  :super class_src
  :fields (sifp_cond			;C preprocessor symbol or verbatim string to test
	   sifp_then			;then clause
	   sifp_else			;else clause
))
;;;;;;;;;;;;;;;;

;;; letbinding source
(defclass class_src_letbinding
  :super class_src
  :fields (sletb_type			;the type of the binding
	   sletb_binder			;the binder (variable)
	   sletb_expr			;the expression
))

;; let source
(defclass class_src_let
  :super class_src
  :fields (slet_bindings		;the tuple of letbinding-s
	   slet_body			;the body tuple 
))

;; lambda
(defclass class_src_lambda
  :super class_src 
  :fields (slam_argbind			;tuple of argument bindings
	   slam_body			;tuple for body
))


;; multicall
(defclass class_src_multicall
  :super class_src
  :fields (smulc_resbind		;tuple of argument bindings for multiple results
	   smulc_call			;called stuff
	   smulc_body			;tuple for body
))

;;; forever & exit share a common label
(defclass class_src_labelled
  :super class_src
  :fields (slabel_bind			;the label binding
))

;; forever
(defclass class_src_forever
  :super class_src_labelled
  :fields (sfrv_body			;tuple for body
))

;; exit
(defclass class_src_exit
  :super class_src_labelled
  :fields ( sexi_body			;tuple for body
))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; ================ normalized representations


;; basically, the normalized representation of (f a (g x)) 
;; is let y=(g x) in (f a y)
;; etc... where y is a cloned symbol

(defclass class_nrep
  :super class_root
  :fields (nrep_loc			;location in source
))

;; a simple stuff is a non-object, a symbol (or keyword or clonedsym),
;; ...
(defclass class_nrep_simple
  :super class_nrep
  :fields (
))

;; a normalized expression should never be the result of normal_exp;
;; it should only appear in bindings!
(defclass class_nrep_expr
  :super class_nrep
  :fields (
))

;; normal applications have simple functions & arguments
(defclass class_nrep_apply
  :super class_nrep_expr
  :fields (napp_fun			;simple function to apply
	   napp_args			;tuple of simple arguments
))

;; normalized multiresult apply
(defclass class_nrep_multiapply
  :super class_nrep_apply
  :fields (nmulapp_bindings 		;a tuple of formal result bindings
	   nmulapp_body			;body normexp
))

;;; normal message sending
(defclass class_nrep_msend
  :super class_nrep_expr
  :fields (nsend_sel		   ;the normalized selector occurrence
	   nsend_recv		   ;the reciever
	   nsend_args		   ;the tuple of simple arguments
))



;; normalized multiresult message send
(defclass class_nrep_multimsend
  :super class_nrep_msend
  :fields (nmulsend_bindings		;tuple of formal bindings
	   nmulsend_body		;body normexp
))

;; normal chunk is a normalized expansion of primitive
(defclass class_nrep_chunk
  :super class_nrep_expr
  :fields (nchunk_expansion		;the expansion
	   nchunk_primitive		;the primitive
))

;; normal comment is a normalized comment
(defclass class_nrep_comment
  :super class_nrep_expr
  :fields (ncomm_string	;the comment
))

;; normal lets have simple binding & body subexpressions
(defclass class_nrep_let
  :super class_nrep_expr
  :fields (nlet_bindings		;a tuple of class_normlet_binding-s
	   nlet_body
))

;; normal return have a main & supplementary subexpressions
(defclass class_nrep_return
  :super class_nrep_expr
  :fields (nret_main			;main normal expression to return
	   nret_rest			;tuple of normal expr...
))

;; normal if have simple test, then, else clauses & a ctype
(defclass class_nrep_if
  :super class_nrep_expr
  :fields (nif_test
	   nif_then
	   nif_else
	   nif_ctyp
))

;; normal ifcpp have a symbol and a ctyp
(defclass class_nrep_cppif
  :super class_nrep_expr
  :fields (nifp_cond
	   nifp_then
	   nifp_else
	   nifp_ctyp
))

;; normal progn has a distingished last
(defclass class_nrep_progn
  :super class_nrep_expr
  :fields (nprogn_seq			;tuple of all but last
	   nprogn_last
	   ))

;; normalized unsafe get field
(defclass class_nrep_unsafe_get_field
  :super class_nrep_expr
  :fields (nuget_obj
	   nuget_field))


;; normalized unsafe_put_field
(defclass class_nrep_unsafe_put_fields
  :super class_nrep_expr
  :fields (nuput_obj
	   nuput_fields))

;; normalized setq
(defclass class_nrep_setq
  :super class_nrep_expr
  :fields (nstq_var
	   nstq_exp
))

;; normalized forever
(defclass class_nrep_forever
  :super class_nrep_expr
  :fields (nforever_bind 		;the label binding
	   nforever_body		;a tuple
	   nforever_result		;cloned symbol for result
))

;; normalized exit
(defclass class_nrep_exit
  :super class_nrep_expr
  :fields (nexit_bind			;the label binding
	   nexit_val			;the exited value
))

;; normalized field assign (in make instance)
(defclass class_nrep_fieldassign
  :super class_nrep
  :fields (nfla_field			;the field
	   nfla_val			;its normalized value
))

;; normalized make instance
(defclass class_nrep_make_instance
  :super class_nrep_expr
  :fields (nmins_class			;the instanciated class
	   nmins_cladata		;its data
	   nmins_fields			;the tuple of field assignments
))

;; normalized lambda
(defclass class_nrep_lambda 
  :super class_nrep_expr
  :fields (nlambda_proc			;the procedure
	   nlambda_constrout		;the constant routine
	   nlambda_closedv		;the tuple of closed normal values
))


;;; procedures
(defclass class_nrep_anyproc
  :super class_nrep
  :fields (
	   nproc_body
))


;; the class of the initial procedure
(defclass class_nrep_initproc
  :super class_nrep_anyproc
  :fields (ninit_topl			;list of toplevel nrep
))

;; normal routine procedure
(defclass class_nrep_routproc
  :super class_nrep_anyproc
  :fields (
	   nrpro_name			;name (if any)
	   nrpro_argb			;argument bindings
	   nrpro_closedb		;list of closed bindings
	   nrpro_const			;list of constants
	   nrpro_datarout		;routine data object
	   nrpro_dataclos		;closure data object
	   nrpro_thunklist		;list of thunks to be called when compiling it
))


;;; static normalized predef
(defclass class_nrep_predef
  :super class_nrep_simple
  :fields (
	   nrpredef			;the predef is a symbol or a boxed integer
))

;; normalized nil
(defclass class_nrep_nil
  :super class_nrep_simple
  :fields (
))


;;;; static data is build at module initialization time
(defclass class_nrep_data
  ;; the objnum is the predefined rank if any
  :super class_nrep_simple
  :fields (ndata_name			;name if any of the data
	   ndata_discrx		;discriminant normal expression 
	   ndata_rank			;boxed integer rank of the data 
	   ;;; we box the integer and don't use the objnum bzcause we
	   ;;; might have a lot (>30000) of data
	   ndata_locbind		;local binding tuple to fill the data
	   ))

;; normal "static" instance - built at modules initialization
(defclass class_nrep_datainstance
  :super class_nrep_data
  :fields (ninst_objnum			;object number (a number or a symbol)
	   ninst_predef			;predefined rank (number or symbol)
	   ninst_hash			;integer hash
	   ninst_slots			;tuple of normalized slots expressions
))

;; normal "static" string
(defclass class_nrep_datastring
  :super class_nrep_data
  :fields ( nstr_string		    ;the string
))

;; normal "static" tuple
(defclass class_nrep_datatuple
  :super class_nrep_data
  :fields ( ntup_comp			;the tuple of component values expressions
))

;; normal interned static symbol
(defclass class_nrep_datasymbol
  :super class_nrep_datainstance
  :fields ( ndsy_namestr
))

;; normal interned static keyword
(defclass class_nrep_datakeyword
  :super class_nrep_datasymbol
  :fields ( 
))

;; normal static routine data
(defclass class_nrep_dataroutine
  :super class_nrep_data
  :fields (ndrou_proc		    ;associated procedure
))

;; normal static closure data
(defclass class_nrep_dataclosure
  :super class_nrep_data
  :fields (ndclo_proc		    ;associated procedure
	   ndclo_closv		    ;tuple of closed values
))

;; normal static start value
;; obtained from an initial binding
(defclass class_nrep_startval
  :super class_nrep_simple
  :fields (nstart_var		    ;the variable
	   ))

;; normal  occurrence of a symbol 
(defclass class_nrep_symocc
  :super class_nrep_simple
  :fields (nocc_symb
	   nocc_ctyp			;the ctype of the symbol, eg ctype_value
	   nocc_bind			;the binding of the symbol
))

;; normal local occurrence of a symbol
(defclass class_nrep_locsymocc
  :super class_nrep_symocc
  :fields (
))

;; normal closed occurrence of a symbol
(defclass class_nrep_closedocc
  :super class_nrep_symocc
  :fields (ncloc_procs			;list of enclosing procedures
))

;; normal constant occurrence of a symbol
(defclass class_nrep_constocc
  :super class_nrep_closedocc
)

;; normal constant (.e.g a quoted symbol, a keyword, ...)
(defclass class_nrep_constant
  :super class_nrep_simple
  :fields (nconst_sval			;source value
	   nconst_data			;normalized data
	   nconst_proc			;containing proc
))

;; data field accessor (mostly used for defclass initialization) this
;; translates into basilys_field_object(<obj>,<off>) of obj is not a
;; datainstance and directly to the field if it is a datainstance
(defclass class_nrep_fieldacc
  :super class_nrep_expr
  :fields (naccf_obj			;data for the object to be accessed 
	   naccf_fld			;rank or field to be accessoed
))

;;; data multiple accessor (mostly used for defclass initialization)
;; this translates into basilys_multiple_nth(<mul>,<ix>) if mul is not
;; a datatuple and directly to the component if it is a datatuple
(defclass class_nrep_multacc
  :super class_nrep_expr
  :fields (naccm_mul			;data for the multiple to be accessed
	   naccm_ix			;index to be accessed (a boxed integer)
))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; normalization context
(defclass class_normcontext
  :super class_root
  :fields (nctx_initproc		;initial procedure
	   nctx_proclist		;list of procedures
	   nctx_datalist		;list of data
	   nctx_symbmap			;stringmap of name to interned symbols
	   nctx_keywmap			;stringmap of name to interned keywords
	   nctx_symbcachemap		;objmap of cached symbol -> occurrence
	   nctx_predefmap		;objmap of predef -> boxedrank or symbols
	   nctx_valmap			;objmap of values -> data 
	   nctx_valbindmap 		;objmap of value binding -> data
	   nctx_curproc			;current procedure
))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; ================ classes for code generation


;;; code generation context
(defclass class_genercontext
  :super class_root
  :fields ( gncx_objrout 		;the containing object routine
	    gncx_locmap			;objmap from normal bindings to locals
	    gncx_freeptrlist		;list of freed local pointers
	    gncx_freelonglist		;list of freed local longs
	    gncx_freeothermaps		;map keyed by ctypes of list of freed local others
	    gncx_retloc			;return location
	    gncx_compicache		;cache map of procedure to compiled routines
))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; common superclass for objcode
(defclass class_objcode
  :super class_root
  :fields (
))


;;;; value like objects
(defclass class_objvalue
  :super class_objcode
  :fields ( obv_type			;the ctype
))


;;; pure values are side-effect free
(defclass class_objpurevalue
  :super class_objvalue
  :fields ())

;; object local variable
(defclass class_objlocv
  :super class_objpurevalue
  :fields (obl_off			;offset in frame
	   obl_proc			;containing procedure
	   obl_cname			;symbolic cname string
))


;; closed occurrence
(defclass class_objcloccv
  :super class_objpurevalue
  :fields (obc_off			;offset in closure
	   obc_proc			;containing procedure
	   obc_name			;symbolic name
))


;; constant [closed] occurrence
(defclass class_objconstv
  :super class_objcloccv
  :fields (
))

;; predefined object
(defclass class_objpredef
  :super class_objpurevalue
  :fields (obpredef
))

;; nil
(defclass class_objnil
  :super class_objpurevalue
  :fields ())

;; initial element 
(defclass class_objinitelem
  :super class_objpurevalue
  :fields (oie_cname 			;symbolic cname string - fieldname in cdat
	   oie_data			;normal data
	   oie_discr			;compiled discriminant
	   oie_locvar			;initial routine's local variable
	   ;; the size, if any is the obj_num
))

;;; initial object - see BASILYS_OBJECT_STRUCT in basilys.h
(defclass class_objinitobject
  :super class_objinitelem
  :fields (
	   oio_predef			;the predef name or number to contain this object
))


;;; initial multiple - see BASILYS_MULTIPLE_STRUCT in basilys.h
(defclass class_objinitmultiple
  :super class_objinitelem
  :fields (
	   ;; we may need to tuple of compiled values for accessing
	   ;; the nth at compilation time in compilobj_nrep_multacc
	   oim_tupval			;tuple of compiled values
))

;;; initial closure - see BASILYS_CLOSURE_STRUCT in basilys.h
(defclass class_objinitclosure 
  :super  class_objinitelem
  :fields (
))

;;; initial routine - see  BASILYS_ROUTINE_STRUCT in basilys.h
(defclass class_objinitroutine
  :super class_objinitelem
  :fields (
	   oir_procroutine		;the procroutine associated
))

;;; initial string - see BASILYS_STRING_STRUCT in basilys.h
(defclass class_objinitstring
  :super class_objinitelem
  :fields (
))


;; expanded value
(defclass class_objexpv
  :super class_objvalue
  :fields (obx_cont
))

;; expanded value with location 
(defclass class_objlocatedexpv
  :super class_objexpv
  :fields (obcx_loc			;optional location
))

;;;; instructions
(defclass class_objinstr
  :super class_objcode
  :fields (obi_loc			;src location
))


;;;; instructions with a list of destinations (computes, calls, sends, etc...)
(defclass class_objdestinstr
  :super class_objinstr
  :fields (obdi_destlist		;a list of destination lovations
))

;;; compute instruction
(defclass class_objcompute
  :super class_objdestinstr
  :fields (obcpt_expr			;expression list
))

;; get argument instruction
(defclass class_objgetarg
  :super class_objinstr
  :fields (obarg_obloc			;objlocation
	   obarg_bind			;formal binding
))


;; put extra result instruction
(defclass class_objputxtraresult
  :super class_objinstr
  :fields (obxres_rank 			;boxed rank
	   obxres_obloc			;objlocation
))

;; final return
(defclass class_objfinalreturn
  :super class_objinstr
  :fields (				;no argument
))

;; clear instruction
(defclass class_objclear
  :super class_objinstr
  :fields (oclr_vloc			;varlocation to clear
))

;; block instruction
(defclass class_objblock
  :super class_objinstr
  :fields ( oblo_bodyl			;body list
	    oblo_epil			;epilogue list
))

;; looping block
(defclass class_objloop
  :super class_objblock		 ;the body is looped, not the epilogue
  :fields (obloop_label		 ;cloned symbol
	   obloop_resv		 ;the result of the loop
))

;; exit a loop
(defclass class_objexit
  :super class_objinstr
  :fields (obexit_label			;cloned symbol for goto destination
))

;; conditional instruction
(defclass class_objcond
  :super class_objinstr
  :fields (obcond_test
	   obcond_then
	   obcond_else
))

;; preprocessor conditional instruction
(defclass class_objcppif
  :super class_objinstr
  :fields (obifp_cond
	   obifp_then
	   obifp_else
))

;;; apply instruction
(defclass class_objapply
  :super class_objdestinstr
  :fields (obapp_clos			;closure to be applied
	   obapp_args			;argument tuple
))

;;; multiapply instruction
(defclass class_objmultiapply
  :super class_objapply
  :fields (obmultapp_xres		;extraresult tuple
))

;;; message send instruction
(defclass class_objmsend
  :super class_objdestinstr
  :fields (obmsnd_sel			;selector object (compiled)
	   obmsnd_recv			;message reciever (compiled)
	   obmsnd_args 			;argument tuple (compiled)
))

;;; multisend instruction
(defclass class_objmultimsend
  :super class_objmsend
  :fields (obmultsnd_xres		;extraresult tuple
))

;; raw object allocation instruction
(defclass class_objrawallocobj
  :super class_objdestinstr
  :fields (
	   obrallobj_class		;the class data
	   obrallobj_len		;the boxed integer length
))


;; new closure allocation
(defclass class_objnewclosure
  :super class_objdestinstr
  :fields (obnclo_discr		     ;the discriminant
	   obnclo_rout		     ;the routine
	   obnclo_len		     ;the boxed integer length
))

;; put a component inside a tuple
(defclass class_objputuple
  :super class_objinstr
  :fields (oputu_tupled			;the tuple data
	   oputu_offset			;numerical offset
	   oputu_value			;the new value
))

;; put a slot inside an object
(defclass class_objputslot
  :super class_objinstr
  :fields ( oslot_odata			;the object data to put
	    oslot_offset		;numerical offset
	    oslot_field			;the [optional] field (only for generated comment)
	    oslot_value			;the new value
))


;; get a slot from an object
(defclass class_objgetslot
  :super class_objdestinstr
  :fields (ogetsl_obj		   ;the object to get from
	   ogetsl_field		   ;the fieldname
))

;; put the routine inside a closure
(defclass class_objputclosurout
  :super class_objinstr
  :fields (opclor_clos			;the closure data
	   opclor_rout			;the routine data
))

;; put a closed value inside a closure
(defclass class_objputclosedv
  :super class_objinstr
  :fields (opclov_clos			;the closure data or local
	   opclov_off 			;the boxed offset
	   opclov_cval			;the closed value
))

;; put a constant value inside a routine
(defclass class_objputroutconst
  :super class_objinstr
  :fields (oprconst_rout	 ;the routine data
	   oprconst_off		 ;the boxed offset
	   oprconst_cval	 ;the constant value
))

;; touch a value, with a tiny comment
(defclass class_objtouch
  :super class_objinstr
  :fields (otouch_val
	   otouch_comment
))

;; set a predef
(defclass class_objsetpredef
 :super class_objinstr
 :fields ( ospr_object			;the object 
	   ospr_predef			;its predef rank
))


;;; routines
(defclass class_routineobj
  :super class_named
  :fields (obrout_proc			;the associated procedure
	   obrout_body			;the body (a list)
	   obrout_nbval			;the boxed number of value pointers
	   obrout_nblong		;the boxed number of longs
	   ;;; if double are needed, we might later add some obrout_nbdouble
	   obrout_others		;the list of other (nonvalue,
					;nonlongs) locals (usually C
					;pointers like tree-s,
					;cstrings, ...)
	   obrout_retval		;the main return value
))

;; procedure routine
(defclass class_procroutineobj
  :super class_routineobj
  :fields (oprout_getargs		;the get arguments tuple of instructions
	   oprout_loc			;the source location
	   oprout_funam			;function name
))

;; initial routine
(defclass class_initialroutineobj
  :super class_routineobj
  :fields (
	   oirout_data			;the tuple of initial data
	   oirout_fill			;the fill of the data (a list of instr)
))







;; 

;;****************************************************************
;;       P R I M I T I V E S 
;;****************************************************************

;; primitive to ignore a value
(defprimitive ignore (v) :void
  "/*ignore*/(" v ")")

;; primitive to return a void
(defprimitive void () :void "/*void*/0")

;; primitive for converting a string constant into a string value
(defprimitive stringconst2val (discr :cstring strc) :value
  " basilysgc_new_string((" discr "), (" strc "))")


;; primitive for testing if an object is a (sub) instance of a class
(defprimitive is_a (obj cla) :long
  " basilys_is_instance_of((" obj "), (" cla "))")

;; primitive for testing if an object is NOT a (sub) instance of a class
(defprimitive is_not_a (obj cla) :long
  " !basilys_is_instance_of((" obj "), (" cla "))")
  
;; primitive for testing objectness
(defprimitive is_object (obj) :long
  " (basilys_magic_discr(" obj ") == OBMAG_OBJECT)")
(defprimitive is_not_object (obj) :long
  " (basilys_magic_discr(" obj ") != OBMAG_OBJECT)")
  

;; primitive to return the last predefined index
(defprimitive last_globpredef_index () :long
  "BGLOB__LASTGLOB")

;; primitive to safely return a global predef by its index
(defprimitive get_globpredef (:long ix) :value
  "(basilys_globpredef((" ix ")))")

;; primitive to get the discriminant of a value
(defprimitive discrim (v) :value
  "(basilys_discr((" v ")))")

;; primitive to get the integer inside a boxed or mixed integer or objnum
(defprimitive get_int (v) :long
  "(basilys_get_int((" v ")))")
;; primitive to put the integer inside a boxed or mixed integer or objnum
(defprimitive put_int (v :long i) :void
  "basilys_put_int((" v "), (" i "))")

;; primitive to get the hashcode of an object (or 0)
(defprimitive obj_hash(v) :long
  "(basilys_obj_hash((" v ")))")
;; primitive to get the length of an object (or 0)
(defprimitive obj_len(v) :long
  "(basilys_obj_len((" v ")))")
;; primitive to get the number of an object (or 0)
(defprimitive obj_num(v) :long
  "(basilys_obj_num((" v ")))")
;; primitive to compue a nonzero hash
(defprimitive nonzero_hash () :long
  "(basilys_nonzerohash())")

;; primitive for identity and non-identity test
(defprimitive == (a b) :long "((" a ") == (" b "))")
(defprimitive != (a b) :long "((" a ") != (" b "))")

;; primitive always returning nil
(defprimitive the_null () :value "(NULL)")

;;; the call counter - do not redefine the name, it is used by expansion of debug_msg macro!
(defprimitive the_callcount () :long "callcount")
;;; the current frame depth
(defprimitive the_framedepth () :long "(basilys_curframdepth())")

;;; the timestamp of compilation & md5 checksum of the generated C file
(defprimitive out_cplugin_compiled_timestamp_err () :void "basilys_puts(stderr,basilys_compiled_timestamp)")
(defprimitive out_cplugin_md5_checksum_err () :void "basilys_puts(stderr,basilys_md5)")

;; primitive to force garbage collection
(defprimitive minor_garbcoll (:long siz) :void 
  "basilys_garbcoll((" siz "), BASILYS_MINOR_OR_FULL)")
(defprimitive full_garbcoll (:long siz) :void
  "basilys_garbcoll((" siz "), BASILYS_NEED_FULL)")

;; primitive to get or create a symbol from a string value
(defprimitive get_symbolstr (strv) :value
  "basilysgc_named_symbol( basilys_string_str(" strv "), BASILYS_GET)")
(defprimitive create_symbolstr (strv) :value
  "basilysgc_named_symbol( basilys_string_str(" strv "), BASILYS_CREATE)")

;; primitive to get or create a keyword from a string value
(defprimitive get_keywordstr (strv) :value
  "basilysgc_named_keyword( basilys_string_str(" strv "), BASILYS_GET)")
(defprimitive create_keywordstr (strv) :value
  "basilysgc_named_keyword( basilys_string_str(" strv "), BASILYS_CREATE)")

;; OBSOLETE runtime assertion with message
(defprimitive assertmsg (:cstring msg :long cond) :void
  "basilys_assertmsg(" msg ", ( " cond "))")

;; runtime assertion with message called by expansion of assert_msg
(defprimitive assert_failed (:cstring msg :cstring filename :long lineno) :void
  "basilys_assert_failed((" msg "),(" filename "),(" lineno "), __FUNCTION__)")

;; check explicitly the call stack  
(defprimitive checkcallstack_msg (:cstring msg) :void
 "basilys_check_call_frames(BASILYS_ANYWHERE, (" msg "))")
;; for breakpoint
(defprimitive cbreak_msg (:cstring msg) :void
 "basilys_cbreak(" msg ")")

;;; less, lessorequal, greater, greaterorequal, equal, different number 
(defprimitive <i (:long a b) :long "((" a ") < (" b "))")
(defprimitive <=i (:long a b) :long "((" a ") <= (" b "))")
(defprimitive ==i (:long a b) :long "((" a ") == (" b "))")
(defprimitive >i (:long a b) :long "((" a ") > (" b "))")
(defprimitive >=i (:long a b) :long "((" a ") >= (" b "))")
(defprimitive !=i (:long a b) :long "((" a ") != (" b "))")
;;; integer arithmetic
(defprimitive +i (:long a b) :long "((" a ") + (" b "))")
(defprimitive -i (:long a b) :long "((" a ") - (" b "))")
(defprimitive *i (:long a b) :long "((" a ") * (" b "))")
(defprimitive andi (:long a b) :long "((" a ") & (" b "))")
(defprimitive ori (:long a b) :long "((" a ") | (" b "))")
(defprimitive xori (:long a b) :long "((" a ") ^ (" b "))")
(defprimitive negi (:long i) :long "(-(" i "))")
(defprimitive noti (:long i) :long "(~(" i "))")

(defprimitive /i (:long a b) :long "(basilys_idiv((" a "), (" b ")))")
(defprimitive %i (:long a b) :long "(basilys_imod((" a "), (" b ")))")
(defprimitive /iraw (:long a b)  :long "((" a ") / (" b "))")
(defprimitive %iraw (:long a b)  :long "((" a ") % (" b "))")
;; boolean not
(defprimitive not (:long i) :long "(!(" i "))")
;;; nullity test (for values)
(defprimitive null (v) :long "((" v ") == NULL)")
(defprimitive notnull (v) :long "((" v ") != NULL)")
;;; zero test (for numbers)
(defprimitive zerop (:long i) :long "((" i ") == OL)")
;; primitive for testing if debug
(defprimitive need_dbg (:long depth) :long
  "(dump_file && (" depth ")>=0 && (" depth ") <= BASILYSDBG_MAXDEPTH)")

(defprimitive need_dbglim (:long depth limit) :long
  "(dump_file && (" depth ")>=0 && (" depth ") < (" limit "))")
;;; debug on dumpfile
(defprimitive outcstring_dbg (:cstring s) :void
  "basilys_puts(dump_file,(" s "))")
(defprimitive outnum_dbg (:cstring pref :long l :cstring suf) :void
  "basilys_putnum(dump_file,(" pref "), (" l "), (" suf "))")
(defprimitive outstr_dbg (str) :void
  "basilys_putstr(dump_file,(" str "))")
(defprimitive outstrbuf_dbg (sbuf) :void
  "basilys_putstrbuf(dump_file,(" sbuf "))")
(defprimitive outnewline_dbg () :void
  "basilys_newlineflush(dump_file)")
;;; output on stderr
(defprimitive outnum_err (:cstring pref :long l :cstring suf) :void
  "basilys_putnum(stderr,(" pref "), (" l "), (" suf "))")
(defprimitive outcstring_err (:cstring s) :void
  "basilys_puts(stderr,(" s "))")
(defprimitive outstrbuf_err (sbuf) :void
  "basilys_putstrbuf(stderr,(" sbuf "))")
(defprimitive outnewline_err () :void
  "basilys_newlineflush(stderr)")
(defprimitive outstr_err (str) :void
  "basilys_putstr(stderr,(" str "))")

(defprimitive output_cfile_decl_impl (uninam declbuf implbuf) :void
  "basilys_output_cfile_decl_impl((" uninam "), (" declbuf "), (" implbuf "))")

(defprimitive message_dbg (:cstring msg) :void
  "debugeputs((" msg "))")
(defprimitive messagenum_dbg (:cstring msg :long i) :void
  "debugnum((" msg "), (" i "))")
(defprimitive messageval_dbg (:cstring msg :value val) :void
  "debugvalue((" msg "), ((void*)(" val ")))")
(defprimitive longbacktrace_dbg (:cstring msg :long maxdepth) :void
  "debugbacktrace((" msg "), (int)(" maxdepth "))")
(defprimitive shortbacktrace_dbg (:cstring msg :long maxdepth) :void
  "basilys_dbgshortbacktrace((" msg "), (" maxdepth "))")
(defprimitive checkval_dbg (val :cstring msg) :value
  "basilys_checked_assignmsg((" val "),(" msg "))")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; STRBUF primitives
;; primitive to make a strbuf
(defprimitive make_strbuf (discr) :value
  "basilysgc_new_strbuf((basilysobject_ptr_t)(" discr "), (char*)0)")
(defprimitive strbuf_usedlength (sbuf) :long
  "basilys_strbuf_usedlength((" sbuf "))")

(defprimitive is_strbuf (v) :long
  "(basilys_magic_discr((" v ")) == OBMAG_STRBUF)")
;; primitive to add a string const into a strbuf
(defprimitive add2sbuf_strconst (sbuf :cstring str) :void 
  "basilysgc_add_strbuf((void*)(" sbuf "), (" str "))")
;; primitive to add a string value into a strbuf
(defprimitive add2sbuf_string (sbuf str) :void 
  "basilysgc_add_strbuf((void*)(" sbuf "), basilys_string_str(" str "))")

;; primitive to add an indentation or space into a strbuf
(defprimitive add2sbuf_indent (sbuf :long depth) :void
  "basilysgc_strbuf_add_indent((void*)(" sbuf "), (" depth "), 64)")


;; primitive to add an indented newline into a strbuf
(defprimitive add2sbuf_indentnl (sbuf :long depth) :void
  "basilysgc_strbuf_add_indent((void*)(" sbuf "), (" depth "), 0)")


;; primitive to add a strbuf into a strbuf
(defprimitive add2sbuf_sbuf (sbuf asbuf) :void 
  "basilysgc_add_strbuf((void*)(" sbuf "), basilys_strbuf_str(" asbuf "))")

;; primitive to add a string value, C encoded, into a strbuf
(defprimitive add2sbuf_cencstring (sbuf str) :void 
  "basilysgc_add_strbuf_cstr((void*)(" sbuf "), basilys_string_str(" str "))")

;; primitive to add a strbuf, C encoded, into a strbuf
(defprimitive add2sbuf_cencstrbuf (sbuf asbuf) :void 
  "basilysgc_add_strbuf_cstr((void*)(" sbuf "), basilys_strbuf_str(" asbuf "))")

;; primitive to add a string value, Ccomment encoded, into a strbuf
(defprimitive add2sbuf_ccomstring (sbuf str) :void 
  "basilysgc_add_strbuf_ccomment((void*)(" sbuf "), basilys_string_str(" str "))")

;; primitive to add a strbuf, C encoded, into a strbuf
(defprimitive add2sbuf_ccomstrbuf (sbuf asbuf) :void 
  "basilysgc_add_strbuf_ccomment((void*)(" sbuf "), basilys_strbuf_str(" asbuf "))")


;; primitive to add into a strbuf a string as C ident (nonalphanum
;; replaced by _)
(defprimitive add2sbuf_cident (sbuf str) :void
  "basilysgc_add_strbuf_cident((" sbuf "), basilys_string_str(" str "))")

;; primitive to add into a strbuf the prefix of a string as C ident (nonalphanum
;; replaced by _) limited by a small length 
(defprimitive add2sbuf_cidentprefix  (sbuf str :long preflen) :void
  "basilysgc_add_strbuf_cidentprefix((" sbuf "), basilys_string_str(" str "), (" preflen "))")

;; primitive to add a long in decimal into a strbuf
(defprimitive add2sbuf_longdec (sbuf :long num) :void
  "basilysgc_add_strbuf_dec((void*)(" sbuf "), (" num "))")

;; primitive to add a long in hex into a strbuf
(defprimitive add2sbuf_longhex (sbuf :long num) :void
  "basilysgc_add_strbuf_hex((void*)(" sbuf "), (" num "))")

;; primitive to add a routine descr into a strbuf
(defprimitive add2sbuf_routinedescr (sbuf rout) :void
  "basilysgc_add_strbuf((void*)(" sbuf "), basilys_routine_descrstr(" rout "))")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; STRING primitives
;; primitive for testing if a value is a string
(defprimitive is_string (str) :long
  " (basilys_magic_discr(" str ") == OBMAG_STRING)")
;; string equal
(defprimitive ==s (s1 s2) :long
  "basilys_string_same((" s1 "), (" s2 "))")
;;; make a string
(defprimitive make_string (dis str) :value
  "(basilysgc_new_stringdup((void*)(" dis "), basilys_string_str((" str "))))")
(defprimitive make_stringconst (dis :cstring cstr) :value
  "(basilysgc_new_stringdup((void*)(" dis "), (" cstr ")))")
(defprimitive is_stringconst (str :cstring cs) :long
  "(basilys_is_string_const((void*)(" str "), (" cs ")))")
(defprimitive string_length (str) :long
  "basilys_string_length((" str "))")
(defprimitive string= (s1 s2) :long "basilys_string_same((" s1 "), (" s2 "))")
(defprimitive string< (s1 s2) :long "basilys_string_less((" s1 "), (" s2 "))")
(defprimitive string> (s1 s2) :long "basilys_string_less((" s2 "), (" s1 "))")

;;; convert a strbuf into a string
(defprimitive strbuf2string (dis sbuf) :value
  "(basilysgc_new_stringdup((void*)(" dis "), basilys_strbuf_str((" sbuf "))))")
;;; compute the naked basename
(defprimitive make_string_nakedbasename (dis str) :value
 "(basilysgc_new_string_nakedbasename((basilysobject_ptr_t)(" dis "), basilys_string_str((" str "))))")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; OBJECT primitives
;; primitive to get an object length
(defprimitive object_length (ob) :long 
  "((long)basilys_object_length((" ob ")))")
;; primitive to get the nth field of an object
(defprimitive object_nth_field (ob :long n) :value
  "(basilys_field_object((" ob "), (" n ")))")

(defprimitive subclass_of (cl1 cl2) :long
  "basilys_is_subclass_of((" cl1 "), (" cl2 "))")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; MULTIPLEs primitives
;;;; test
(defprimitive is_multiple (mul) :long
 "(basilys_magic_discr((" mul  ")) == OBMAG_MULTIPLE)")
(defprimitive is_multiple_or_null (mul) :long
 "((" mul ") == NULL || (basilys_magic_discr((" mul  ")) == OBMAG_MULTIPLE))")
;;; make
(defprimitive make_multiple (discr :long ln) :value
  "(basilysgc_new_multiple((basilysobject_ptr_t)(" discr "), (" ln ")))")
(defprimitive make_tuple1 (discr v1) :value
  "(basilysgc_new_mult1((basilysobject_ptr_t)(" discr "),(" v1 ")))")
(defprimitive make_tuple2 (discr v1 v2) :value
  "(basilysgc_new_mult2((basilysobject_ptr_t)(" discr "),(" v1 "), (" v2 ")))")
(defprimitive make_tuple3 (discr v1 v2 v3) :value
  "(basilysgc_new_mult3((basilysobject_ptr_t)(" discr "),(" v1 "), (" v2  "), (" v3 ")))")
(defprimitive make_tuple4 (discr v1 v2 v3 v4) :value
  "(basilysgc_new_mult4((basilysobject_ptr_t)(" discr "),(" v1 "), (" v2  "), (" v3  "), (" v4 ")))")
(defprimitive make_tuple5 (discr v1 v2 v3 v4 v5) :value
  "(basilysgc_new_mult5((basilysobject_ptr_t)(" discr "),(" v1 "), (" v2  "), (" v3  "), (" v4  "), (" v5 ")))")
;; primitive to get the nth  in a multiple
(defprimitive multiple_nth (mul :long n) :value
    "(basilys_multiple_nth((void*)(" mul "), (" n ")))")
;; primitive to get the length of a multiple
(defprimitive multiple_length (v) :long
  "(basilys_multiple_length((void*)(" v ")))")
;; be careful to avoid circularities
(defprimitive multiple_put_nth (mul :long n :value v) :void
  " basilysgc_multiple_put_nth((void*)(" mul "), (" n "), (void*)(" v "))")
;; sort a multiple, the compare function should return a boxed integer
(defprimitive multiple_sort (mul cmp discrm) :value
  " basilysgc_sort_multiple((" mul "), (" cmp "),( " discrm "))")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; MAPOBJECTs primitives
;;;; test
(defprimitive is_mapobject (map) :long
 "(basilys_magic_discr((" map  ")) == OBMAG_MAPOBJECTS)")
;; primitive to get the allocated size of a mapobject
(defprimitive mapobject_size (map) :long
  "(basilys_size_mapobjects((void*)(" map ")))")
;; primitive to get the attribute count of a mapobject
(defprimitive mapobject_count (map) :long
  "(basilys_count_mapobjects((void*)(" map ")))")
;; primitive to get the nth attribute of a mapobject
(defprimitive mapobject_nth_attr (map :long n) :value
  "(basilys_nthattr_mapobjects((void*)(" map "), (int)(" n ")))")
;; primitive to get the nth value of a mapobject
(defprimitive mapobject_nth_val (map :long n) :value
  "(basilys_nthval_mapobjects((void*)(" map "), (int)(" n ")))")
;; primitive to get the value of an attribute in a mapobject
(defprimitive mapobject_get (map attr) :value
  "(basilys_get_mapobjects((void*)(" map "), (" attr ")))")
;; primitive for making a new map of objects
(defprimitive make_mapobject (discr :long len) :value
  " (basilysgc_new_mapobjects( (void*) (" discr "), (" len ")))")
;; primitive for putting into a map of objects
(defprimitive mapobject_put (map key val) :void
 " basilysgc_put_mapobjects( (void*) (" map "), (" key "), (" val "))")
;; primivite for removing from a map of objects
(defprimitive mapobject_remove (map key) :void
  " basilysgc_remove_mapobjects( (void*) (" map "), (" key "))")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; MAPSTRINGs primitive
;; test
(defprimitive is_mapstring (map) :long
"(basilys_magic_discr((" map ")) == OBMAG_MAPSTRINGS)")
;; primitive to get the allocated size of a mapstring
(defprimitive mapstring_size (map) :long 
  "(basilys_size_mapstrings(" map "))")
;; primitive to get the attribute count of a mapstring
(defprimitive mapstring_count (map) :long
  "(basilys_count_mapstrings(" map "))")
;; get an entry in a mapstring from a C string
(defprimitive mapstring_rawget (map :cstring cstr) :value
  "(basilys_get_mapstrings((void*)(" map "), (" cstr ")))")
;; primitive for making a new map of strings
(defprimitive make_mapstring (discr :long len) :value
  " (basilysgc_new_mapstrings( (basilysobject_ptr_t) (" discr "), (" len ")))")
;; primitive for putting into a map of strings
(defprimitive mapstring_rawput (map :cstring key :value val) :void
 " basilysgc_put_mapstrings( (void*) (" map "), (" key "), (" val "))")
(defprimitive mapstring_putstr (map keystr val) :void
  " basilysgc_put_mapstrings((void*) (" map "), basilys_string_str(" keystr "), (" val "))")
(defprimitive mapstring_getstr (map keystr) :value
  "(basilys_get_mapstrings((void*)(" map "), basilys_string_str(" keystr ")))")
;; primivite for removing from a map of strings
(defprimitive mapstring_rawremove (map :cstring key) :void
  " basilysgc_remove_mapstrings( (void*) (" map "), (" key "))")

;; primitive to make the nth stringattr of a mapobject
(defprimitive mapstring_nth_attrstr (map sdicr :long n) :value
  "(basilysgc_new_stringdup((void*)(" sdicr "), basilys_nthattrraw_mapstrings((" map "), (int)(" n "))))")
;; primitive to get the nth value of a mapobject
(defprimitive mapstring_nth_val (map :long n) :value
  "(basilys_nthval_mapstrings((" map "), (int)(" n ")))")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; ROUTINEs primitives
;; test
(defprimitive is_routine (rou) :long
"(basils_magic_discr((" rou ")) == OBMAG_ROUTINE)")
;;; descriptive string of a routine
(defprimitive routine_descr (rou) :value
  "(basilysgc_new_stringdup(basilys_routine_descrstr((" rou "))))")
;;; size of a routine
(defprimitive routine_size  (rou) :long
  "(basilys_routine_size((" rou ")))")
;;; nth comp in routine
(defprimitive routine_nth (rou :long ix) :value
"(basilys_routine_nth((" rou "), (int) (" ix ")))")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; CLOSUREs primitives
;; test
(defprimitive is_closure (clo) :long
  " (basilys_magic_discr((" clo ")) == OBMAG_CLOSURE)")
(defprimitive closure_size (clo) :long
  " (basilys_closure_size((" clo ")))")
(defprimitive closure_routine (clo) :value
 " (basilys_closure_routine((" clo ")))")
(defprimitive closure_nth (clo :long ix) :value
  "(basilys_closure_nth((" clo "), (int)(" ix ")))")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; boxed INTEGERs primitives
;; test
(defprimitive is_integerbox (ib) :long
  "(basilys_magic_discr((void*)(" ib ")) == OBMAG_INT)")
;; to get the boxed integer use get_int
;; make
(defprimitive make_integerbox (discr :long n) :value
  "(basilysgc_new_int((void*)(" discr "), (" n ")))")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; BOX primitives (boxed values)
;; test
(defprimitive is_box (bx) :long
  "(basilys_magic_discr((" bx ")) == OBMAG_BOX)")
;; safe fetch content
(defprimitive box_content (box) :value
  "basilys_box_content((void*)(" box "))")
;; put into a box
(defprimitive box_put (box val) :void
  "basilysgc_box_put((void*)(" box "), (" val "))")
;; make a box
(defprimitive make_box (discr valb) :value
  "basilysgc_new_box((void*)(" discr "), (void*)(" valb "))")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; LIST primitives
;; test
(defprimitive is_list (li) :long
  "(basilys_magic_discr((" li ")) == OBMAG_LIST)")
(defprimitive is_list_or_null (li) :long
  "((" li ") == NULL || (basilys_magic_discr((" li ")) == OBMAG_LIST))")
;; first pair of list
(defprimitive list_first (li) :value
  "(basilys_list_first((" li ")))")
;; last pair of list
(defprimitive list_last (li) :value
"(basilys_list_last((" li ")))")
;; length of list
(defprimitive list_length (li) :long
"(basilys_list_length((" li ")))")
;; append into list
(defprimitive list_append (li el) :void
"basilysgc_append_list((" li "), (" el "))")
;; prepend into list
(defprimitive list_prepend (li el) :void
"basilysgc_prepend_list((" li "), (" el "))")
;; pop first from list
(defprimitive list_popfirst (li) :value
  "(basilysgc_popfirst_list((" li ")))")
;; make list
(defprimitive make_list (discr) :value
"(basilysgc_new_list((void*)(" discr ")))")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; PAIR primitives
;; test
(defprimitive is_pair (pa) :long
  "(basilys_magic_discr((" pa ")) == OBMAG_PAIR)")
;; head
(defprimitive pair_head (pa) :value
  "(basilys_pair_head((" pa ")))")
;; tail
(defprimitive pair_tail (pa) :value
  "(basilys_pair_tail((" pa ")))")
;; change the head of a pair
(defprimitive pair_set_head (pa hd) :void
  "basilysgc_pair_set_head((" pa "), (" hd "))")
;; length of a pair list
(defprimitive pair_listlength (pa) :long
  "(basilys_pair_listlength((" pa ")))")
;; make
(defprimitive pair_make (discr hd tl) :value
  "(basilysgc_new_pair((" discr "), (" hd "), (" tl ")))")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; MIXINT primitives (use get_int to get the integer)
;; test
(defprimitive is_mixint (mi) :long
  "(basilys_magic_discr((" mi ")) == OBMAG_MIXINT)")
;; get the value
(defprimitive mixint_val (mi) :value
  "(basilys_val_mixint((" mi ")))")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; READ FILE primitive
(defprimitive read_file (filnam) :value
  "(basilysgc_read_file (basilys_string_str((" filnam ")), (char*)0))")

;; to signal an error in a basilys source with some additional string value
(defprimitive error_strv (loc :cstring msg :value strv) :void
  "error(\"BASILYS ERROR: file %s, line %d : %s - %s\","
  " basilys_string_str(basilys_val_mixint(" loc ")), "
  " (int) basilys_num_mixint(" loc "), ("
  msg
  "), basilys_string_str((" strv ")))"
  )
;; signal a plain error in a basilys source
(defprimitive error_plain (loc :cstring msg) :void
  "error(\"BASILYS ERROR: file %s, line %d :: %s \","
  " basilys_string_str(basilys_val_mixint(" loc ")), "
  " (int) basilys_num_mixint(" loc "), ("
  msg "))"
  )

;; to signal an warning in a basilys source with some additional string value
(defprimitive warning_strv (loc :cstring msg :value strv) :void
  "warning(0, \"BASILYS WARNING: file %s, line %d : %s - %s\","
  " basilys_string_str(basilys_val_mixint(" loc ")), "
  " (int) basilys_num_mixint(" loc "), ("
  msg
  "), basilys_string_str((" strv ")))"
  )
;; signal a plain warning in a basilys source
(defprimitive warning_plain (loc :cstring msg) :void
  "warning(0, \"BASILYS WARNING: file %s, line %d :: %s \","
  " basilys_string_str(basilys_val_mixint(" loc ")), "
  " (int) basilys_num_mixint(" loc "), ("
  msg "))"
  )
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; the discriminant for name strings
(definstance discr_namestring class_discr
 :predef DISCR_NAMESTRING
 :obj_num OBMAG_STRING
;;; :named_name (stringconst2val discr_namestring "DISCR_NAMESTRING")
;;; :disc_super discr_string   ;; forward reference not allowed
)

;;; the discriminant for strings
(definstance discr_string class_discr
 :predef DISCR_STRING
 :obj_num OBMAG_STRING
 :named_name (stringconst2val discr_namestring "DISCR_STRING"))

(unsafe_put_fields discr_namestring :disc_super discr_string)
(unsafe_put_fields discr_namestring :named_name
		   (stringconst2val discr_namestring "DISCR_NAMESTRING"))
;;; the discriminant for verbatim strings (used for defprimitive)
(definstance discr_verbatimstring class_discr
 :obj_num OBMAG_STRING
 :predef DISCR_VERBATIMSTRING
 :named_name (stringconst2val discr_namestring "DISCR_VERBATIMSTRING")
 :disc_super discr_string
)

;;; the discriminant for any reciever (used for sending to everything)
(definstance discr_anyrecv class_discr
  :named_name (stringconst2val discr_namestring "DISCR_ANYRECV")
)

(unsafe_put_fields discr_string :disc_super discr_anyrecv)

;;; the discriminant for null reciever (used for sending to nil)
(definstance discr_nullrecv class_discr
  :predef DISCR_NULLRECV
  :disc_super discr_anyrecv
  :named_name (stringconst2val discr_namestring "DISCR_NULLRECV"))

;;; the discriminant for strbuf
(definstance discr_strbuf class_discr
 :obj_num OBMAG_STRBUF  
 :disc_super discr_anyrecv
 :named_name (stringconst2val discr_namestring "DISCR_STRBUF"))

;;; the discriminant for integers
(definstance discr_integer class_discr
 :predef DISCR_INTEGER
 :obj_num OBMAG_INT 
 :disc_super discr_anyrecv
 :named_name (stringconst2val discr_namestring "DISCR_INTEGER"))

;;; the discriminant for lists
(definstance discr_list class_discr
  :predef DISCR_LIST
  :obj_num OBMAG_LIST 
  :disc_super discr_anyrecv
  :named_name (stringconst2val discr_namestring "DISCR_LIST"))

;;; the discriminant for pairs
(definstance discr_pair class_discr
  :predef DISCR_PAIR
  :obj_num OBMAG_PAIR 
  :disc_super discr_anyrecv
  :named_name (stringconst2val discr_namestring "DISCR_PAIR"))

;;; the discriminant for multiples
(definstance discr_multiple class_discr
  :predef DISCR_MULTIPLE
  :obj_num OBMAG_MULTIPLE
  :disc_super discr_anyrecv
  :named_name (stringconst2val discr_namestring "DISCR_MULTIPLE"))

;;; the discriminant for sequence of fields
(definstance discr_seqfield class_discr
  :predef DISCR_SEQFIELD
  :obj_num OBMAG_MULTIPLE
  :named_name (stringconst2val discr_namestring "DISCR_SEQFIELD")
  :disc_super discr_multiple
)

;;; the discriminant for boxes
(definstance discr_box class_discr
  :predef DISCR_BOX
  :obj_num OBMAG_BOX
  :disc_super discr_anyrecv
  :named_name (stringconst2val discr_namestring "DISCR_BOX"))

;;; the discriminant for maps of objects
(definstance discr_mapobjects class_discr
  :predef DISCR_MAPOBJECTS
  :obj_num OBMAG_MAPOBJECTS
  :disc_super discr_anyrecv
  :named_name (stringconst2val discr_namestring "DISCR_MAPOBJECTS"))

;;; the discriminant for maps of strings
(definstance discr_mapstrings class_discr
  :predef DISCR_MAPSTRINGS
  :obj_num OBMAG_MAPSTRINGS
  :disc_super discr_anyrecv
  :named_name (stringconst2val discr_namestring "DISCR_MAPSTRINGS"))

;;; the discriminant for sequence of classes 
(definstance discr_seqclass class_discr
  :predef DISCR_SEQCLASS
  :obj_num OBMAG_MULTIPLE
  :named_name (stringconst2val discr_namestring "DISCR_SEQCLASS")
  :disc_super discr_multiple
)


;;; the discriminant for method dictionnary maps
(definstance discr_methodmap class_discr
  :predef DISCR_METHODMAP
  :obj_num OBMAG_MAPOBJECTS
  :disc_super discr_mapobjects
  :named_name (stringconst2val discr_namestring "DISCR_METHODMAP"))

;;; the discriminant for charcode integers
(definstance discr_charinteger class_discr
 :predef DISCR_CHARINTEGER
 :obj_num OBMAG_INT
 :named_name (stringconst2val discr_namestring "DISCR_CHARINTEGER")
 :disc_super discr_integer
)


;;; the discriminant for mixedintegers
(definstance discr_mixedint class_discr
 :predef DISCR_MIXEDINT
 :obj_num OBMAG_MIXINT
 :disc_super discr_anyrecv
 :named_name (stringconst2val discr_namestring "DISCR_MIXEDINT"))


;;; the discriminant for closures
(definstance discr_closure class_discr
 :predef DISCR_CLOSURE
 :obj_num OBMAG_CLOSURE
 :disc_super discr_anyrecv
 :named_name (stringconst2val discr_namestring "DISCR_CLOSURE"))

;;; the discriminant for routines
(definstance discr_routine class_discr
 :predef DISCR_ROUTINE
 :obj_num OBMAG_ROUTINE
 :disc_super discr_anyrecv
 :named_name (stringconst2val discr_namestring "DISCR_ROUTINE"))

(defun install_ctype (ctyp)
  (debug_msg ctyp "install_ctype")
  (assert_msg "check ctyp" (is_a ctyp class_ctype)) 
  (let ( (ckw (unsafe_get_field :ctype_keyword ctyp)) )
    (assert_msg "check ckw" (is_a ckw class_keyword))
    (unsafe_put_fields ckw :symb_data ctyp)
    ))


;;; every ctype should be predefined. normexp_defprimitive requires this
;;; while predef are somehow costly, we don't have that much many ctype-s
;;; and each of them nearly requires some code in basilys.h
;;; which should be enhanced for any new ctype
;; the C type for values
(definstance ctype_value class_ctype
  :predef CTYPE_VALUE
  :named_name  (stringconst2val discr_namestring "CTYPE_VALUE")
  :ctype_keyword (quote :value)
  :ctype_cname  (stringconst2val discr_namestring "basilys_ptr_t")
  :ctype_parchar (stringconst2val discr_namestring "BPAR_PTR")
  :ctype_parstring (stringconst2val discr_namestring "BPARSTR_PTR")
  ;; value have to be passed specially, we need to pass the address of the pointer
  :ctype_argfield (stringconst2val discr_namestring "bp_aptr")
  :ctype_resfield (stringconst2val discr_namestring "bp_aptr")
  )
(install_ctype ctype_value)

;; the C type for long
(definstance ctype_long class_ctype
  :predef CTYPE_LONG
  :named_name  (stringconst2val discr_namestring "CTYPE_LONG")
  :ctype_keyword (quote :long)
  :ctype_cname  (stringconst2val discr_namestring "long")
  :ctype_parchar (stringconst2val discr_namestring "BPAR_LONG")
  :ctype_parstring (stringconst2val discr_namestring "BPARSTR_LONG")
  :ctype_argfield (stringconst2val discr_namestring "bp_long")
  :ctype_resfield (stringconst2val discr_namestring "bp_longptr")
  )
(install_ctype ctype_long)

;; the C type for gcc trees
(definstance ctype_tree class_ctype
  :predef CTYPE_TREE
  :named_name  (stringconst2val discr_namestring "CTYPE_TREE")
  :ctype_keyword ':tree
  :ctype_cname  (stringconst2val discr_namestring "tree")
  :ctype_parchar (stringconst2val discr_namestring "BPAR_TREE")
  :ctype_parstring (stringconst2val discr_namestring "BPARSTR_TREE")
  :ctype_argfield (stringconst2val discr_namestring "bp_tree")
  :ctype_resfield (stringconst2val discr_namestring "bp_treeptr")
  )
(install_ctype ctype_tree)

;; the C type for void
(definstance ctype_void class_ctype
  :predef CTYPE_VOID
  :named_name  (stringconst2val discr_namestring "CTYPE_VOID")
  :ctype_keyword ':void
  :ctype_cname  (stringconst2val discr_namestring "void")
  ;; void is never passed as argument or as extra result
  )
(install_ctype ctype_void)

;; the C type for constant C strings
(definstance ctype_cstring class_ctype
  :predef CTYPE_CSTRING
  :named_name  (stringconst2val discr_namestring "CTYPE_CSTRING")
  :ctype_keyword ':cstring
  :ctype_cname  (stringconst2val discr_namestring "const char*")
  :ctype_parchar (stringconst2val discr_namestring "BPAR_CSTRING")
  :ctype_parstring (stringconst2val discr_namestring "BPARSTR_CSTRING")
  :ctype_argfield (stringconst2val discr_namestring "bp_cstring")
  )
(install_ctype ctype_cstring)


;; function to box a value

(defun boxval (v) 
  (make_box discr_box v))

;; function to add a new symbol
(defun add_new_symbol_token (tokz str)
  (let ( (sy (make_instance class_symbol :named_name str)) 
	 (sydict (unsafe_get_field :tok_symboldict tokz))
	 )
    (mapstring_putstr sydict str sy)
    sy))
    
;; function to add a new keyword
(defun add_new_keyword_token (tokz str)
  (let ( (kw (make_instance class_keyword :named_name str)) 
	 (kwdict (unsafe_get_field :tok_keywdict tokz))
	 )
    (mapstring_putstr kwdict str kw)
    kw))
    
;; function to intern a symbol (or return the previous one)
(defun intern_symbol (tokz symb)
  (assert_msg "check tokz" (is_a tokz class_tokenizer))
  (assert_msg "check sym" (is_a symb class_symbol))
  (let ( (syname (unsafe_get_field :named_name symb)) 
	 (sydict (unsafe_get_field :tok_symboldict tokz))
	 (oldsy (mapstring_getstr sydict syname)) )
    (if oldsy 
	oldsy 
      (progn 
		(mapstring_putstr sydict syname symb) 
;		(messageval_dbg "warm interning symbol" symb)
		symb))
))

;; function to intern a keyword (or return the previous one)
(defun intern_keyword (tokz keyw)
  (assert_msg "check tokz" (is_a tokz class_tokenizer))
  (assert_msg "check keyw" (is_a keyw class_keyword))
  (let ( (kwname (unsafe_get_field :named_name keyw)) 
	 (kwdict (unsafe_get_field :tok_keywdict tokz))
	 (oldkw (mapstring_getstr kwdict kwname)) )
    (if oldkw 
	oldkw
      (progn (mapstring_putstr kwdict kwname keyw) keyw))
))

;;; container of a mapstring for cloning symbol, maping symbol names to boxed integer
(definstance container_clonemapstring class_container
  :container_value (make_mapstring discr_mapstrings 200)
)

(defun clone_symbol (symb)
  (let ( (mapstr (unsafe_get_field :container_value container_clonemapstring)) 
	 (synam (cond
		 ( (is_a symb class_named) 
		   (unsafe_get_field :named_name symb))
		 ( (is_string symb) 
		   symb)
		 (:else 
		  ;(debug_msg symb "clone_symbol bad symb")
		  (assert_msg "invalid symb in clone_symbol" ())
		  (the_null))))
	 (boxi (mapstring_getstr mapstr synam)) )
    (assert_msg "check synam" (is_string synam))
    (if (not (is_integerbox boxi))
	(progn 
	  (setq boxi (make_integerbox discr_integer 0))
	  (mapstring_putstr mapstr synam boxi)))
    (let ( (:long i (get_int boxi)) )
      (setq i (+i i 1))
      (put_int boxi i)
      (make_instance class_clonedsymbol
		     :named_name synam
		     :csym_urank (make_integerbox discr_integer i)))))

;; the tokenizer
(definstance tokenizer class_tokenizer
  :predef TOKENIZER
  :named_name  (stringconst2val discr_namestring "TOKENIZER")
  :tok_symboldict (make_mapstring discr_mapstrings 200)
  :tok_keywdict (make_mapstring discr_mapstrings 100)
  :tok_addsymbol add_new_symbol_token
  :tok_addkeyw  add_new_keyword_token
  :tok_internsymbol intern_symbol
  :tok_internkeyw intern_keyword
  )

;;; iterate fully in map of objects 
(defun mapobject_every (map f)
  (if (is_mapobject map)
      (if (is_closure f)
	  (let ( (:long ix 0) )
	    (forever maploop
		     (if (>=i ix (mapobject_size map)) (exit maploop))
		     (let ( (curat (mapobject_nth_attr map ix))
			    (curval (mapobject_nth_val map ix)) )
		       (if curat  (f curat curval))
		       )
		     (setq ix (+i ix 1))
		     )))))

;;; iterate & test over a map of objects - if the called f returns nil the
;;; iteration is stopped and returns the "failing" attr
(defun mapobject_iterate_test (map f)
  (if (is_mapobject map)
      (if (is_closure f)
	  (let ( (:long ix 0) )
	    (forever maploop
		     (if (>=i ix (mapobject_size map)) (exit maploop))
		     (let ( (curat (mapobject_nth_attr map ix))
			    (curval (mapobject_nth_val map ix)) )
		       (if curat 
			   (if (null (f curat curval))
			       (return curat))
			 ))
		     (setq ix (+i ix 1))
		     )))))

;;; iterate fully in a map of strings
(defun mapstring_every (map f)
  (if (is_mapstring map)
      (if (is_closure f)
	  (let ( (:long ix 0) )
	    (forever maploop
		     (if (>=i ix (mapstring_size map)) 
			 (exit maploop))
		     (let ( (curat (mapstring_nth_attrstr map discr_string ix))
			    (curval (mapstring_nth_val map ix)) )
		       (if curat (f curat curval))
		       )
		     (setq ix (+i ix 1))
		     )))))

;;; iterate & test over a map of strings - if the called f returns nil the
;;; iteration is stopped
(defun mapstring_iterate_test (map f)
  (if (is_mapstring map)
      (if (is_closure f)
	  (let ( (:long ix 0) )
	    (forever maploop
		     (if (>=i ix (mapstring_size map)) 
			 (exit maploop))
		     (let ( (curat (mapstring_nth_attrstr map discr_string ix))
			    (curval (mapstring_nth_val map ix)) )
		       (if curat 
			   (if (null (f curat curval))
			       (return curat)
			     )))
		     (setq ix (+i ix 1))
		     )))))

;;; iterate fully in a dictionnary ie on the value in a map of strings 
(defun mapstringval_every (map f)
  (if (is_mapstring map)
      (if (is_closure f)
	  (let ( (:long ix 0) )
	    (forever maploop
		     (if (>=i ix (mapstring_size map)) 
			 (exit maploop))
		     (let ( (curval (mapstring_nth_val map ix)) )
		       (if curval  (f curval)))
		     (setq ix (+i ix 1))
		     )))))

;;; iterate & test over a dictionnary ie on the value in a map of strings - if
;;; the called f returns nil the iteration is stooped
(defun mapstringval_iterate_test (map f)
  (if (is_mapstring map)
      (if (is_closure f)
	  (let ( (:long ix 0) )
	    (forever maploop
		     (if (>=i ix (mapstring_size map)) (exit maploop))
		     (let ( (curval (mapstring_nth_val map ix)) )
		       (if curval 
			   (if (null (f curval))
			       (return curval)
			     )))
		     (setq ix (+i ix 1))
		     )))))


;;; full iterator on a list
(defun list_every (lis f)
  (if (is_list lis)
      (if (is_closure f)
	  (let ( (curpair (list_first lis)) )
	    (forever lisloop
		     (if (is_pair curpair)
			 (let ( (curhead (pair_head curpair))
				(curtail (pair_tail curpair))
				)
			   (f curhead)
			   (setq curpair curtail))
		       (exit lisloop)))))))

;;; iterator on a list, if the called f returns nil the iteration is stopped
(defun list_iterate_test (lis f)
  (if (is_list lis)
      (if (is_closure f)
	  (let ( (curpair (list_first lis)) )
	    (forever lisloop
		     (if (not (is_pair curpair)) (exit lisloop))
		     (let ( (curelem (pair_head curpair)) )
		       (if (null (f curelem)) (return curelem)))
		       (setq curpair (pair_tail curpair)))))))

;; add to a destination list a source list
(defun list_append2list (dlist slist)
  (if (not (is_list slist)) (return dlist))
  (if (not (is_list dlist)) (setq dlist (make_list discr_list)))
  (list_every slist 
		(lambda (e) (list_append dlist e)))
  dlist)

;;; full iterator on a pairlist  if the called f returns nil the iteration is stopped
(defun pairlist_every (pair f)
  (if (is_closure f)
      (forever pairloop
	       (if (not (is_pair pair)) (exit pairloop))
	       (f (pair_head pair)) 
	       (setq pair (pair_tail pair)))))
		   
;;; tested iterator on a pairlist  if the called f returns nil the iteration is stopped
(defun pairlist_iterate_test (pair f)
      (if (is_closure f)
	  (forever pairloop
		   (if (not (is_pair pair)) (exit pairloop))
		     (let ( (curelem (pair_head pair)) )
		       (if (null (f curelem)) (return curelem)))
		       (setq pair (pair_tail pair)))))
		   
;;; map on a list (list_map lis f) where lis is (e1 ... en) is ((f e1) .... (f en))
(defun list_map (lis f)
  (if (is_list lis)
      (if (is_closure f)
	  (let ( (reslis (make_list discr_list)) 
		 (curpair (list_first lis)) )
	    (forever lisloop
		     (if (not (is_pair curpair)) (exit lisloop reslis))
		     (let ( (curelem (pair_head curpair)) )
		       (list_append reslis (f curelem)))
		     (setq curpair (pair_tail curpair)))
	    ))))
		    
;;; translate a list to a multiple - with each element transformed by a function f (default the identity)
(defun list_to_multiple (lis disc f)
  (if (null disc) (setq disc discr_multiple))
  (if (is_list lis)
      (let ( (:long ln (list_length lis))
	     (tup (make_multiple disc ln))
	     (ixb (make_integerbox discr_integer 0))
	     (curpair (list_first lis)) )
	(list_every 
	 lis
	 (lambda (c) 
	   (let ( (:long ix (get_int ixb)) 
		  (tc (if (is_closure f) (f c) c))
		  )
	     (put_int ixb (+i ix 1))
	     (multiple_put_nth tup ix tc))
	   ))
	tup
	)))

;;; translate a pairlist to a tuple - with each element transformed by a function f (default the identity)
(defun pairlist_to_multiple (pair disc f)
  (if (null disc) (setq disc discr_multiple))
  (let ( (:long ln 0) )
    (let ( (curpair pair) )
      (forever loopln
	       (if (not (is_pair curpair)) (exit loopln))
	       (setq ln (+i ln 1))
	       (setq curpair (pair_tail curpair))))
    (let ( (tup (make_multiple disc ln))
	   (:long ix 0) 
	   (curpair pair)
	   )
      (forever loopfi
	       (if (not (is_pair curpair)) (exit loopfi))
	       (let ( (c (pair_head curpair))
		      (tc (if (is_closure f) (f c) c)) )
		 (multiple_put_nth tup ix tc)
		 (setq ix (+i ix 1))
		 (setq curpair (pair_tail curpair))))
      (return tup)
      )))

;;; full iterator on tuple - 
;;; the function is called with the component and its index
(defun multiple_every (tup f)
  (if (is_multiple tup)
      (if (is_closure f)
	  (let ( (:long ln (multiple_length tup))
		 (:long ix 0) )
	    (forever tuploop
		     (if (>=i ix ln) (exit tuploop))
		     (f  (multiple_nth tup ix) ix)
		     (setq ix (+i ix 1)))))))

;; full iterator backward
(defun multiple_backward_every (tup f)
  (if (is_multiple tup)
      (if (is_closure f)
	  (let ( (:long ln (multiple_length tup))
		 (:long ix (-i ln 1)) )
	    (forever tuploop
		     (if (<i ix 0) (exit tuploop))
		     (f  (multiple_nth tup ix) ix)
		     (setq ix (-i ix 1)))))))

;;; iterator on tuple , if the called f returns nil the iteration is stopped
;;; the function is called with the component and its index
(defun multiple_iterate_test (tup f)
  (if (is_multiple tup)
      (if (is_closure f)
	  (let ( (:long ln (multiple_length tup))
		 (:long ix 0) )
	    (forever tuploop
		     (if (>=i ix ln) (exit tuploop))
		     (let ( (curcomp (multiple_nth tup ix)) )
		       (if (null (f curcomp ix)) 
			   (return curcomp)))
		     (setq ix (+i ix 1)))))))

;;; map on tuple -- with tup= (t0 t1 ... t_n-1) return ((f t0 0) (f t1 1) ... (f t_n-1 n-1)
(defun multiple_map (tup f)
  (if (is_multiple tup)
      (if (is_closure f)
	  (let ( (:long ln (multiple_length tup))
		 (:long ix 0) 
		 (res (make_multiple discr_multiple ln))
		 )
	    (forever tuploop
		     (if (>=i ix ln) (exit tuploop res))
		     (let ( (curcomp (multiple_nth tup ix)) )
		       (multiple_put_nth res ix (f curcomp ix)))
		     (setq ix (+i ix 1)))
	    ))))
		     

;;; installation of a method in a class or discriminant
(defun install_method (cla sel fun)
  ;;(messageval_dbg "install_method cla!VAL" cla)
  ;;(messageval_dbg "install_method sel!VAL" sel)
  ;;(debug_msg cla "install_method cla%")
  ;;(debug_msg sel "install_method sel%")
  ;;(debug_msg fun "install_method fun%")
  (if 
      (is_a cla class_discr)
      (if 
	  (is_a sel class_selector)
	  (if 
	      (is_closure fun)
	      (let 
		  ( (mapdict 
		     (unsafe_get_field :disc_methodict cla)) )
		(if (is_mapobject mapdict)
		    (mapobject_put mapdict sel fun)
		  (let ( (newmapdict (make_mapobject discr_methodmap 35)) )
		    (unsafe_put_fields cla :disc_methodict newmapdict)
		    (mapobject_put newmapdict sel fun)
		    ))))))
;- (progn
;-   (debug_msg cla "install_method failed cla=")
;-   (debug_msg sel "install_method failed sel=")
;-   (debug_msg fun "install_method failed fun=")
;-   (messageval_dbg "install_method failed cla!=" cla)
;-   (messageval_dbg "install_method failed sel!=" sel)
;-   (messageval_dbg "install_method failed fun!=" fun)
;-					;(assert_msg "install_method failed" ())
;-   )
  )



;;; selector to output for debugging
;;; reciever: any object or value
;;; arguments: the debuginfo (instance of class_debuginfo), the depth (long)
(defselector dbg_output class_selector
;  :named_name  (stringconst2val discr_namestring "DBG_OUTPUT")
)


;;; selector to output again for debugging
;;; reciever: any object (already output)
;;; arguments: the debuginfo (instance of class_debuginfo), the depth (long)
(defselector dbg_outputagain class_selector
;  :named_name  (stringconst2val discr_namestring "DBG_OUTPUTAGAIN")
)


;; somehow needed to be a separate function because of a bug in cold
(defun dbg_outobject (obj dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (let ( (occmap (unsafe_get_field :dbgi_occmap dbgi)) )
    (if (is_mapobject occmap)
	(let ( (occ (mapobject_get occmap obj)) )
	  (checkcallstack_msg "in dbg_outobject")
	  (if (is_integerbox occ)
	      (progn
		(dbg_outputagain obj dbgi depth)
		(put_int occ (+i (get_int occ) 1))
		)
	    (let ( (newocc (make_integerbox discr_integer 1)) )
	      (mapobject_put occmap obj newocc)
	      (checkcallstack_msg "in dbg_outobject output")
	      (dbg_output obj dbgi depth)
	      )))))
  )

(defun dbg_out (obj dbgi  :long depth) 
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (checkcallstack_msg "start dbg_out")
  (let ( (sbuf (unsafe_get_field :dbgi_sbuf dbgi))
	 (discr (discrim obj))
	 )
    (if (need_dbglim depth (get_int (unsafe_get_field :dbgi_maxdepth dbgi)))
	(if (is_object obj)
	    (progn
	      ;; (checkcallstack_msg "start dbg_out outobject")
	      (dbg_outobject obj dbgi depth)
	      )
	  (if obj
	      (progn
		;; (checkcallstack_msg "start dbg_out output")
		(dbg_output obj dbgi depth)
		)
	    (if (is_strbuf sbuf) (add2sbuf_strconst sbuf "()")
	      )))
      (if (is_strbuf sbuf)
	  (add2sbuf_strconst sbuf "..")
	))))
  
;; utility to dump fields in an object from a given rank
(defun dbgout_fields (obj dbgi :long depth rank)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (assert_msg "check obj" (is_object obj))
  (let ( (:long nbf (object_length obj)) 
	 (cla (discrim obj))
	 (:long ix rank)
	 (clafieldseq (unsafe_get_field :class_fields cla))
	 (sbuf  (unsafe_get_field :dbgi_sbuf dbgi))
	 )
    (assert_msg "check sbuf" (is_strbuf sbuf))
    (if (<i ix 0) (setq ix 0))
    (if (need_dbglim depth (get_int (unsafe_get_field :dbgi_maxdepth dbgi)))
	(forever fldloop
		 (if (>=i ix nbf)
		     (exit fldloop))
		 (let ( (curfld (multiple_nth clafieldseq ix))
			(curval (object_nth_field obj ix))
			)
		   (if curval
		       (let ( (:long curulen (strbuf_usedlength sbuf)) )
			 (add2sbuf_indent sbuf depth)
			 (add2sbuf_string sbuf (unsafe_get_field :named_name curfld))
			 (add2sbuf_strconst sbuf "=")
			 (dbg_out curval dbgi (+i depth 1))
			 (let ( (:long deltalen (-i (strbuf_usedlength sbuf) curulen)) )
			   (if  (>i deltalen 80)
			       (add2sbuf_indentnl sbuf depth)))
			 )))
		 (setq ix (+i ix 1))
		 )
      )))

;; null debug output
(defun dbgout_null_method  (self dbgi :long depth)
  (let (  (sbuf  (unsafe_get_field :dbgi_sbuf dbgi))
	  )
    (add2sbuf_strconst sbuf "()")))
(install_method discr_nullrecv dbg_output dbgout_null_method)
(install_method discr_nullrecv dbg_outputagain dbgout_null_method)

;; string debug output
(defun dbgout_string_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (let ( (dis (discrim self)) 
	 (sbuf  (unsafe_get_field :dbgi_sbuf dbgi))
	 )
    (if (== dis DISCR_STRING)
	(progn
	  (add2sbuf_strconst sbuf " \"")
	  (add2sbuf_cencstring sbuf self)
	  (add2sbuf_strconst sbuf "\"")
	  )
      (progn
	(add2sbuf_strconst sbuf " |")
	(add2sbuf_string sbuf (unsafe_get_field :named_name dis))
	(add2sbuf_strconst sbuf "\"")
	(add2sbuf_cencstring sbuf self)
	(add2sbuf_strconst sbuf "\"")
	))))

(install_method discr_string  dbg_output dbgout_string_method)
;(install_method discr_namestring  dbg_output dbgout_string_method)
;(install_method discr_verbatimstring  dbg_output dbgout_string_method)

;; integer debug output
(defun dbgout_integer_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (let ( (dis (discrim self)) 
	 (sbuf  (unsafe_get_field :dbgi_sbuf dbgi))
	 )
    (if (== dis DISCR_INTEGER)
	(progn 
	  (add2sbuf_strconst sbuf " #")
	  (add2sbuf_longdec sbuf (get_int self)))
      (progn
	(add2sbuf_strconst sbuf " |")
	(add2sbuf_string sbuf (unsafe_get_field :named_name dis))
	(add2sbuf_strconst sbuf "#")
	(add2sbuf_longdec sbuf (get_int self)))
      )))

(install_method discr_integer dbg_output dbgout_integer_method)
(install_method discr_charinteger dbg_output dbgout_integer_method)

;; mixint debug value
(defun dbgout_mixint_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (let ( (dis (discrim self)) 
	 (sbuf  (unsafe_get_field :dbgi_sbuf dbgi))
	 )
    (if (== dis DISCR_MIXEDINT)
	(progn 
	  (add2sbuf_strconst sbuf " #[")
	  (add2sbuf_longdec sbuf (get_int self)))
      (progn
	(add2sbuf_strconst sbuf " |")
	(add2sbuf_string sbuf (unsafe_get_field :named_name dis))
	(add2sbuf_strconst sbuf "#[")
	(add2sbuf_longdec sbuf (get_int self)))
      )
    (if  (need_dbglim depth (get_int (unsafe_get_field :dbgi_maxdepth dbgi)))
	(progn
	  (add2sbuf_strconst sbuf ",")
	  (dbg_out (mixint_val self) dbgi (+i depth 1))
	  )
      (add2sbuf_strconst sbuf ",..")
      )
    (add2sbuf_strconst sbuf "]")
    ))
(install_method discr_mixedint dbg_output dbgout_mixint_method)

;; multiple debug out
(defun dbgout_multiple_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (let ( (dis (discrim self)) 
	 (sbuf (unsafe_get_field :dbgi_sbuf dbgi))
	 )
    (if (== dis DISCR_MULTIPLE)
	(add2sbuf_strconst sbuf " *")
      (progn
	(add2sbuf_strconst sbuf " |")
	(add2sbuf_string sbuf (unsafe_get_field :named_name dis))
	(add2sbuf_strconst sbuf "*")))
    (let ( (:long ln (multiple_length self)) )
      (add2sbuf_longdec sbuf ln)
      (add2sbuf_strconst sbuf "[")
      (if (need_dbg depth)
	  (let ( (:long ix 0) )
	    (forever comploop
		     (if (>=i ix ln) (exit comploop))
		     (add2sbuf_indent sbuf depth)
		     (let ( (:long curulen (strbuf_usedlength sbuf)) )
		       (dbg_out  (multiple_nth self ix) dbgi (+i 1 depth))
		       (and (>i (-i (strbuf_usedlength sbuf) curulen) 100)
			    (<i ix (-i ln 1))
			    (add2sbuf_indentnl sbuf (+i 1 depth))))
		     (setq ix (+i ix 1))
		     ))
	(add2sbuf_strconst sbuf "..")
	)
      (add2sbuf_strconst sbuf "]")
      )))

(install_method discr_multiple dbg_output dbgout_multiple_method)

;; routine debug out - don't print the routine components
(defun dbgout_routine_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (let ( (dis (discrim self)) 
	 (sbuf (unsafe_get_field :dbgi_sbuf dbgi))
	 )
    (if (== dis DISCR_ROUTINE)
	(add2sbuf_strconst sbuf " *rou[%")
      (progn
	(add2sbuf_strconst sbuf " |")
	(add2sbuf_string sbuf (unsafe_get_field :named_name dis))
	(add2sbuf_strconst sbuf "[%")))
    (add2sbuf_routinedescr sbuf self)
    (add2sbuf_strconst sbuf "%]")
    )
  )

(install_method discr_routine dbg_output dbgout_routine_method)

;; closure debug out 
(defun dbgout_closure_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (let ( (dis (discrim self)) 
	 (:long oldmaxdepth (get_int (unsafe_get_field :dbgi_maxdepth dbgi)))
	 (sbuf  (unsafe_get_field :dbgi_sbuf dbgi)) )
    (if (== dis DISCR_CLOSURE)
	(add2sbuf_strconst sbuf " *clo<")
      (progn
	(add2sbuf_strconst sbuf " |")
	(add2sbuf_string sbuf (unsafe_get_field :named_name dis))
	(add2sbuf_strconst sbuf "*clo<")))
    (put_int (unsafe_get_field :dbgi_maxdepth dbgi) 2)
    (dbg_out (closure_routine self) dbgi depth)
    (put_int (unsafe_get_field :dbgi_maxdepth dbgi) oldmaxdepth)
    (if (need_dbglim depth (get_int (unsafe_get_field :dbgi_maxdepth dbgi)))
	(let ((:long ix 0))
	  (add2sbuf_strconst sbuf "/")
	  (add2sbuf_longdec sbuf (closure_size self))
	  (forever outloop
		   (if (>=i ix (closure_size self))
		       (exit outloop))
		   (add2sbuf_indent sbuf depth)
		   (let ( (:long curulen (strbuf_usedlength sbuf)) )
		     (dbg_out (closure_nth self ix) dbgi (+i depth 1))
		     (if (>i (-i (strbuf_usedlength sbuf) curulen) 100)
			 (add2sbuf_indentnl sbuf (+i 1 depth))))
		   (setq ix (+i ix 1))
		   )))
    (add2sbuf_strconst sbuf ">")
    ))

(install_method discr_closure dbg_output dbgout_closure_method)      



;; list debug out 
(defun dbgout_list_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (let ( (dis (discrim self)) 
	 (sbuf  (unsafe_get_field :dbgi_sbuf dbgi)) )
    (if (== dis DISCR_LIST)
	(add2sbuf_strconst sbuf " *li(")
      (progn
	(add2sbuf_strconst sbuf " |")
	(add2sbuf_string sbuf (unsafe_get_field :named_name dis))
	(add2sbuf_strconst sbuf "(")))
    (let (
	  (curpair (list_first self))
	  (:long ix 0) 
	  )
      (checkcallstack_msg "before loop dbgout_list_method")
      (if (need_dbglim depth (get_int (unsafe_get_field :dbgi_maxdepth dbgi)))
	  (forever listloop
		   (checkcallstack_msg "start loop dbgout_list_method")
		   (if (>i ix 300)
		       (progn
			 (add2sbuf_strconst sbuf "...")
			 (exit listloop)))
		   (if (not (is_pair curpair)) (exit listloop))
		   (add2sbuf_indent sbuf depth)
		   (let ( (:long curulen (strbuf_usedlength sbuf)) )
		     (dbg_out (pair_head curpair) dbgi (+i depth 1))
		     (setq curpair (pair_tail curpair))
		     (checkcallstack_msg "near endloop dbgout_list_method")
		     (if (not curpair)
			 (exit listloop))
		     (setq ix (+i ix 1))
		     (if (>i (-i (strbuf_usedlength sbuf) curulen) 100)
			 (add2sbuf_indentnl sbuf (+i 1 depth))))
		   ))
      (checkcallstack_msg "end dbgout_list_method")
      (add2sbuf_strconst sbuf ")")))
  )
(install_method discr_list dbg_output dbgout_list_method)      

;; pair debug output
(defun dbgout_pair_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (let ( (dis (discrim self)) 
	 (sbuf  (unsafe_get_field :dbgi_sbuf dbgi)) )
    (if (== dis DISCR_PAIR)
	(add2sbuf_strconst sbuf " *pa(.")
      (progn
	(add2sbuf_strconst sbuf " |")
	(add2sbuf_string sbuf (unsafe_get_field :named_name dis))
	(add2sbuf_strconst sbuf "(.")))
    (if (need_dbglim depth (get_int (unsafe_get_field :dbgi_maxdepth dbgi)))
	(progn
	  (dbg_out (pair_head self) dbgi (+i depth 1))
	  (add2sbuf_indent sbuf depth)
	  (dbg_out (pair_tail self) dbgi (+i depth 1))))
    (add2sbuf_strconst sbuf ".)")))
	
(install_method discr_pair dbg_output dbgout_pair_method)      


;;; the cold compiler prefers this way... to have an internal function
;;; to output an entry...
(defun dbgoutinternal_mapobj_entry (at va dbgi nextdepthbox)
  (let ( (:long nextdepth (get_int nextdepthbox))
	 (:long oldmaxdepth (get_int (unsafe_get_field :dbgi_maxdepth dbgi)))
	 (sbuf  (unsafe_get_field :dbgi_sbuf dbgi)) )
    (assert_msg "check sbuf" (is_strbuf sbuf))
    (add2sbuf_indentnl sbuf nextdepth)
    (add2sbuf_strconst sbuf "**")  
    (put_int (unsafe_get_field :dbgi_maxdepth dbgi) 0)
    (dbg_outobject at dbgi nextdepth)
    (put_int (unsafe_get_field :dbgi_maxdepth dbgi) oldmaxdepth)
    (add2sbuf_strconst sbuf " ==")  
    (add2sbuf_indent sbuf (+i nextdepth 1))
    (dbg_out va dbgi nextdepth)
    (add2sbuf_strconst sbuf "; ")
    ))

;; an internal compare function used to display mapobject-s & mapstring-s in a canonical order.
(defun compare_obj_ranked (x1 bxrk1 x2 bxrk2 vless veq vgreat)
  (if (== x1 x2)
      (return veq)
    (let ( (x1dis (discrim x1))
	   (x2dis (discrim x2))
	   (:long rk1 (get_int bxrk1))
	   (:long rk2 (get_int bxrk2))
	   )
      (cond ( (!= x1dis x2dis)
	      (if (string< (unsafe_get_field :named_name x1dis) 
			   (unsafe_get_field :named_name x2dis))
		  (return vless)
		(return vgreat)
		))
	    ( (is_a x1 class_clonedsymbol)
	      (let ( (n1 (unsafe_get_field :named_name x1))
		     (n2 (unsafe_get_field :named_name x2)) )
		(cond ( (string< n1 n2)
			(return vless))
		      ( (string> n1 n2)
			(return vgreat))
		      (:else 
		       (let (
			     (yr1 (unsafe_get_field :csym_urank x1))
			     (yr2 (unsafe_get_field :csym_urank x2))
			     (:long nr1 (get_int yr1))
			     (:long nr2 (get_int yr2))
			     )
			 (cond ( (<i nr1 nr2)
				 (return vless))
			       ( (>i nr1 nr2)
				 (return vgreat))
			       (:else 
				;; this should not happen, two distinct cloned symbols with same name & rank
				(assert_msg "corrupted same cloned symbols" ())
				(return (the_null)))
			       ))))
		))
	    ( (is_a x1 class_named)
	      (let ( (n1 (unsafe_get_field :named_name x1))
		     (n2 (unsafe_get_field :named_name x2))
		     )
		(cond ( (string< n1 n2)
			(return vless))
		      ( (string> n1 n2)
			(return vgreat))
		      ( (<i rk1 rk2)
			(return vless))
		      ( (>i rk1 rk2)
			(return vgreat))
		      (:else 
		       (return veq)))
		)
	      )
	    ( (is_a x1 class_any_binding)
	      (let ( (bsy1 (unsafe_get_field :binder x1))
		     (bsy2 (unsafe_get_field :binder x1)) )
		(return (compare_obj_ranked bsy1 bxrk1 bsy2 bxrk2 vless veq vgreat))))
	    ( (is_string x1)
	      (cond ( (string< x1 x2)
		      (return vless))
		    ( (string> x1 x2)
		      (return vgreat))
		    ( (<i rk1 rk2)
		      (return vless))
		    ( (>i rk1 rk2)
		      (return vgreat))
		    (:else 
		     (return veq))))
	    ( (<i rk1 rk2)
	      (return vless))
	    ( (>i rk1 rk2)
	      (return vgreat))
	    (:else
	     (return veq))
	    ))))




(defun dbgout_mapobject_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (let ( (dis (discrim self)) 
	 (sbuf  (unsafe_get_field :dbgi_sbuf dbgi))
	 (:long mapcount (mapobject_count self))
	 )
    (if (== dis DISCR_MAPOBJECTS)
	(add2sbuf_strconst sbuf " {")
      (progn
	(add2sbuf_strconst sbuf " |")
	(add2sbuf_string sbuf (unsafe_get_field :named_name dis))
	(add2sbuf_strconst sbuf "{")))
    (add2sbuf_strconst sbuf "/")
    (add2sbuf_longdec sbuf (mapobject_count self))
    (if (need_dbglim depth (get_int (unsafe_get_field :dbgi_maxdepth dbgi)))
	(let (
	      (nextdepthbox (make_integerbox discr_integer (+i 1 depth)))
	      (countbox (make_integerbox discr_integer 0))
	      (boxedone (make_integerbox discr_integer 1))
	      (boxedzero (make_integerbox discr_integer 0))
	      (boxedminusone (make_integerbox discr_integer -1))
	      (tupl (make_multiple discr_multiple mapcount))
	      )
	  ;; fill the tupl with (attribute value rank) entries
	  (mapobject_every
	   self
	   (lambda (at va)
	     (let ( (:long curcount (get_int countbox)) 
		    (ent (make_tuple3 discr_multiple 
				      at va 
				      (make_integerbox discr_integer curcount)))
		    )
	       (multiple_put_nth tupl curcount ent)
	       (put_int countbox (+i curcount 1))
	       )))
	  (assert_msg "check tupl" (is_multiple tupl))
;;; sort the tuple and output in sorted order
	  (let ( (sortupl 
		  (multiple_sort 
		   tupl
		   (lambda (e1 e2)
		     (let ( (e1at (multiple_nth e1 0))
			    (e1va (multiple_nth e1 1))
			    (e1rk (multiple_nth e1 2))
			    (e2at (multiple_nth e2 0))
			    (e2va (multiple_nth e2 1))
			    (e2rk (multiple_nth e2 2))
			    )
		       (compare_obj_ranked e1at e1rk e2at e2rk boxedminusone boxedzero boxedone)
		       ))
		   discr_multiple
		   ))
		 )
	    (assert_msg "check sortupl" (is_multiple sortupl))
	    (multiple_every 
	     sortupl
	     (lambda (el :long ix)
	       (let ( (elat (multiple_nth el 0))
		      (elva (multiple_nth el 1)) )
		 (dbgoutinternal_mapobj_entry elat elva dbgi nextdepthbox)
		 )))
	    )
	  (add2sbuf_strconst sbuf "}")))))
(install_method discr_mapobjects dbg_output dbgout_mapobject_method)




;; multiple debug out
(defun dbgout_mapstring_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (let ( (dis (discrim self)) 
	 (sbuf (unsafe_get_field :dbgi_sbuf dbgi))
	 (:long ix 0)
	 (:long mapcount (mapstring_count self))
	 (nextdepthbox (make_integerbox discr_integer (+i 1 depth)))
	 (countbox (make_integerbox discr_integer 0))
	 (boxedone (make_integerbox discr_integer 1))
	 (boxedzero (make_integerbox discr_integer 0))
	 (boxedminusone (make_integerbox discr_integer -1))
	 (tupl (make_multiple discr_multiple mapcount))
	 )
    (if (== dis DISCR_MAPSTRINGS)
	(add2sbuf_strconst sbuf " <(")
      (progn
	(add2sbuf_strconst sbuf " |")
	(add2sbuf_string sbuf (unsafe_get_field :named_name dis))
	(add2sbuf_strconst sbuf "<(")))
    (add2sbuf_strconst sbuf "/")
    (add2sbuf_longdec sbuf mapcount)
    ;; fill the tuple with string, value, rank triples
    (mapstring_every 
     self
     (lambda (str val)
       (let ( (:long curcount (get_int countbox)) 
	      (ent (make_tuple3 discr_multiple 
				str val 
				(make_integerbox discr_integer curcount)))
	      )
	 (multiple_put_nth tupl curcount ent)
	 (put_int countbox (+i curcount 1))
	 )))
    ;; sort the tuple and display it
    (let ( (sortupl
	    (multiple_sort 
	     tupl
	     (lambda (e1 e2)
	       (let ( (e1at (multiple_nth e1 0))
		      (e1va (multiple_nth e1 1))
		      (e1rk (multiple_nth e1 2))
		      (e2at (multiple_nth e2 0))
		      (e2va (multiple_nth e2 1))
		      (e2rk (multiple_nth e2 2))
		      )
		 (compare_obj_ranked e1at e1rk e2at e2rk boxedminusone boxedzero boxedone)
		 ))
	     discr_multiple
	     ))
	   )
      (assert_msg "check sortupl" (is_multiple sortupl)) 
      (multiple_every 
       sortupl
       (lambda (el :long ix)
	 (let ( (curstr (multiple_nth el 0))
		(curval (multiple_nth el 1)) 
		(:long nextdepth (get_int nextdepthbox))
		)
	   (if (and (is_string curstr) (notnull curval))
	       (progn
		 (add2sbuf_indentnl sbuf nextdepth)
		 (add2sbuf_strconst sbuf "!*")
		 (dbg_out curstr dbgi nextdepth)
		 (add2sbuf_strconst sbuf " => ")  
		 (add2sbuf_indent sbuf nextdepth)
		 (dbg_out curval dbgi (+i nextdepth 1))
		 ))))))
    (add2sbuf_strconst sbuf " )>")))
(install_method discr_mapstrings dbg_output dbgout_mapstring_method)


;;;; generic object debug
(defun dbgout_anyobject_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (let ( (dis (discrim self)) 
	 (sbuf  (unsafe_get_field :dbgi_sbuf dbgi)) ) 
    (add2sbuf_strconst sbuf "|")
    (add2sbuf_string sbuf (unsafe_get_field :named_name dis))
    (add2sbuf_strconst sbuf "/")
    (add2sbuf_longhex sbuf (obj_hash self))
    (let ( (:long onum (obj_num self)) )
      (if onum
	  (progn
	    (add2sbuf_strconst sbuf "#")
	    (add2sbuf_longdec sbuf onum))))
    (add2sbuf_strconst sbuf "{")
    (if (need_dbglim depth (get_int (unsafe_get_field :dbgi_maxdepth dbgi)))
	(dbgout_fields self dbgi (+i depth 1) 0)
      )
    (add2sbuf_strconst sbuf "}")
    ))
(install_method class_root  dbg_output dbgout_anyobject_method)

;;;; generic value debug
(defun dbgout_anyrecv_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (let ( (dis (discrim self)) 
	 (sbuf  (unsafe_get_field :dbgi_sbuf dbgi)) ) 
    (add2sbuf_strconst sbuf " ?.")
    (if (is_a dis class_named) (add2sbuf_string sbuf (unsafe_get_field :named_name dis)))
    (add2sbuf_strconst sbuf ".? ")
    ))
(install_method discr_anyrecv dbg_output dbgout_anyrecv_method)

;;; generic object debug outputagain
(defun dbgoutagain_anyobject_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (let ( (dis (discrim self)) 
	 (sbuf  (unsafe_get_field :dbgi_sbuf dbgi)) )  
    (add2sbuf_strconst sbuf " ^^|")
    (add2sbuf_string sbuf (unsafe_get_field :named_name dis))
    (add2sbuf_strconst sbuf "/")
    (add2sbuf_longhex sbuf (obj_hash self))
    ))
(install_method class_root  dbg_outputagain dbgoutagain_anyobject_method)
	
;;;; named object debug
(defun dbgout_namedobject_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (let ( (dis (discrim self)) 
	 (sbuf  (unsafe_get_field :dbgi_sbuf dbgi))
	 (onam (unsafe_get_field :named_name self))
	 (oprop (unsafe_get_field :prop_table self))
	 ) 
    (assert_msg "check sbuf" (is_strbuf sbuf))
    (add2sbuf_strconst sbuf "`")
    (add2sbuf_string sbuf onam)
    (add2sbuf_strconst sbuf "|")
    (add2sbuf_string sbuf (unsafe_get_field :named_name dis))
    (add2sbuf_strconst sbuf "/")
    (add2sbuf_longhex sbuf (obj_hash self))
    (if (need_dbglim depth (get_int (unsafe_get_field :dbgi_maxdepth dbgi)))
	(let ( (:long onum (obj_num self)) )
	  (if onum
	      (progn
		(add2sbuf_strconst sbuf "#")
		(add2sbuf_longdec sbuf onum)))
	  (add2sbuf_strconst sbuf "{")
	  (if oprop
	      (progn 
		(add2sbuf_strconst sbuf "prop=")
		(dbg_out oprop dbgi (+i depth 3))
		))
	  (dbgout_fields self dbgi (+i depth 3) 2)
	  (add2sbuf_strconst sbuf "}")
	  ))))
(install_method class_named  dbg_output dbgout_namedobject_method)

;;;; named object debug outputagain
(defun dbgoutagain_namedobject_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (let ( (dis (discrim self)) 
	 (sbuf  (unsafe_get_field :dbgi_sbuf dbgi))
	 (onam (unsafe_get_field :named_name self)) 
	 )
    (add2sbuf_strconst sbuf " ^^`")
    (add2sbuf_string sbuf onam)
    (add2sbuf_strconst sbuf "|")
    (add2sbuf_string sbuf (unsafe_get_field :named_name dis))
    (add2sbuf_strconst sbuf "/")
    (add2sbuf_longhex sbuf (obj_hash self))
    ))
(install_method class_named dbg_outputagain dbgoutagain_namedobject_method)

;;;; symbol output debug & again
(defun dbgout_symbol_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (assert_msg "check self" (is_a self class_symbol))
  (if (<=i depth 0)
      (dbgout_namedobject_method self dbgi 0)
    (dbgoutagain_symbol_method self dbgi depth)))
(install_method class_symbol dbg_output dbgout_symbol_method)

(defun dbgoutagain_symbol_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (assert_msg "check self" (is_a self class_symbol))
  (let ( (sbuf  (unsafe_get_field :dbgi_sbuf dbgi))
	 (onam (unsafe_get_field :named_name self))
	 )	
    (add2sbuf_strconst sbuf " $")
    (add2sbuf_string sbuf onam)
    (add2sbuf_strconst sbuf "/")
    (add2sbuf_longhex sbuf (obj_hash self))))
(install_method class_symbol dbg_outputagain dbgoutagain_symbol_method)

;;;; keyword output debug & again
(defun dbgout_keyword_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (assert_msg "check self" (is_a self class_keyword))
  (if (<=i depth 0)
      (dbgout_namedobject_method self dbgi 0)
    (dbgoutagain_keyword_method self dbgi depth)))
(install_method class_keyword dbg_output dbgout_keyword_method)

(defun dbgoutagain_keyword_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (assert_msg "check self" (is_a self class_keyword))
  (let ( (sbuf  (unsafe_get_field :dbgi_sbuf dbgi))
	 (onam (unsafe_get_field :named_name self))
	 )	
    (add2sbuf_strconst sbuf " $:")
    (add2sbuf_string sbuf onam)
    (add2sbuf_strconst sbuf "/")
    (add2sbuf_longhex sbuf (obj_hash self))))
(install_method class_keyword dbg_outputagain dbgoutagain_keyword_method)

;;;; clonedsymbol output debug & again
(defun dbgout_clonedsymbol_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (assert_msg "check self" (is_a self class_clonedsymbol))
  (if (<=i depth 0)
      (dbgout_namedobject_method self dbgi 0)
    (dbgoutagain_clonedsymbol_method self dbgi depth)
    ))
(install_method class_clonedsymbol dbg_output dbgout_clonedsymbol_method)

(defun dbgoutagain_clonedsymbol_method (self dbgi :long depth)
  (let ( (dis (discrim self)) 
	 (sbuf  (unsafe_get_field :dbgi_sbuf dbgi))
	 (ourank (unsafe_get_field :csym_urank self))
	 (:long lrk (get_int ourank))
	 (onam (unsafe_get_field :named_name self)) )
    (add2sbuf_strconst sbuf " $$")
    (add2sbuf_string sbuf onam)
    (add2sbuf_strconst sbuf ":")
    (add2sbuf_longdec sbuf lrk)
    (add2sbuf_strconst sbuf "/")
    (add2sbuf_longhex sbuf (obj_hash self))))
(install_method class_clonedsymbol dbg_outputagain dbgoutagain_clonedsymbol_method)

;;;; ctype output debug & again
(defun dbgout_ctype_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (assert_msg "check self" (is_a self class_ctype))
  (if (<=i depth 0)
      (dbgout_namedobject_method self dbgi 0)
    (dbgoutagain_ctype_method self dbgi depth)
))
(install_method class_ctype dbg_output dbgout_ctype_method)

(defun dbgoutagain_ctype_method (self dbgi :long depth)
  (let ( (dis (discrim self)) 
	 (sbuf  (unsafe_get_field :dbgi_sbuf dbgi))
	 (onam (unsafe_get_field :named_name self)) )
    (add2sbuf_strconst sbuf " $!")
    (add2sbuf_string sbuf onam)
    (add2sbuf_strconst sbuf "!/")
    (add2sbuf_longhex sbuf (obj_hash self))))
(install_method class_ctype dbg_outputagain dbgoutagain_ctype_method)
  
;;;;;;;;;;;;;;;;;;;;;;;; debug message function
(defprimitive the_dbgcounter () :long "basilys_dbgcounter")
(defprimitive increment_dbgcounter () :void "(void) ++basilys_dbgcounter")

(defun displaydebugmsg (val :cstring msgstr :long count)
  ;; don't work yet, because internal test for debugging...
  (let ( (:long dbgcounter (progn (increment_dbgcounter) (the_dbgcounter)))
	 (sbuf (make_strbuf discr_strbuf)) 
	 (occmap (make_mapobject discr_mapobjects 50))
	 (boxedmaxdepth (make_integerbox discr_integer 14))
	 (dbgi (make_instance class_debuginfo
			      :dbgi_sbuf sbuf
			      :dbgi_occmap occmap
			      :dbgi_maxdepth boxedmaxdepth))
	 )
    (outnum_err "!*#" dbgcounter "/")
    (outnum_err "" (-i (the_framedepth) 1) ":")
    (outcstring_err msgstr)
    (if (>i count 0) (outnum_err " !" count ": "))
    (dbg_output val dbgi 0)
    (outstrbuf_err sbuf)
    (outnewline_err)
    ))


(defun debugmsg (val :cstring msgstr :long count)
  (if (need_dbg 0) 
      (let ( (:long dbgcounter (progn (increment_dbgcounter) (the_dbgcounter)))
	     (sbuf (make_strbuf discr_strbuf)) 
	     (occmap (make_mapobject discr_mapobjects 50))
	     (boxedmaxdepth (make_integerbox discr_integer 17)) ;;;; @@@ DEBUGDEPTH
	     (dbgi (make_instance class_debuginfo
				  :dbgi_sbuf sbuf
				  :dbgi_occmap occmap
				  :dbgi_maxdepth boxedmaxdepth))
	     )
	(outnum_dbg "!*#" dbgcounter "/")
	(outnum_dbg "" (-i (the_framedepth) 1) ":")
	(outcstring_dbg msgstr)
	(if (>i count 0) (outnum_dbg " !" count ": "))
	(dbg_out val dbgi 0)
	(outstrbuf_dbg sbuf)
	(outnewline_dbg)
	)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; make a fresh environment 
(defun fresh_env (parenv)
  (if (is_a parenv class_environment)
      (make_instance class_environment 
		     :env_bind (make_mapobject discr_mapobjects 6)
		     :env_prev parenv)))

;; the initial environment
(definstance initial_environment class_environment
  :env_bind  (make_mapobject discr_mapobjects 500)
)

;; find a binding inside an environment
(defun find_env (env binder)
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check binder" (is_object binder))
  (forever findloop
	   (if (is_not_a env class_environment)
	       (exit findloop ()))
	   (assert_msg "check env obj" (is_object env))
	   (let ( (bindmap 
		   (unsafe_get_field :env_bind env)) )
	     (assert_msg "check bindmap" (is_mapobject bindmap))
	     (let ( (bnd 
		     (mapobject_get bindmap binder)) )
	       (if bnd 
		   (exit findloop bnd))
	       ))
	   (setq env (unsafe_get_field :env_prev env))
	   )
  )

; find a binding inside an environment and also returns the reversed list of enclosing procedures
(defun find_enclosing_env (env binder)
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check binder" (is_object binder))
  (let ( (proclist (make_list discr_list)) )
  (forever findloop
	   (if (is_not_a env class_environment) (exit findloop))
	   (let ( (bindmap (unsafe_get_field :env_bind env)) 
		  (eproc (unsafe_get_field :env_proc env))
		  )
	     (assert_msg "check bindmap" (is_mapobject bindmap))
	     (let ( (bnd (mapobject_get bindmap binder)) )
	       (if bnd (return bnd proclist)))
	     (if eproc (list_prepend proclist eproc))
	     (setq env (unsafe_get_field :env_prev env))
	       ))))

;; put a binding at top of an environment
(defun put_env (env binding)
  (assert_msg "check binding is obj" (is_object binding))
  (assert_msg "check env is obj" (is_object env))
  (assert_msg "check env" (is_a env class_environment))
  (if (not (is_a binding class_any_binding))
      (progn
	(debug_msg binding "put_env invalid binding")
	(shortbacktrace_dbg "put_env invalid binding" 15)))
  (assert_msg "check binding" (is_a binding class_any_binding))
  (let ( (bindmap (unsafe_get_field :env_bind env)) 
	 (binder (unsafe_get_field :binder binding))
	 )
    (if (not (is_object binder))
	(progn
	  (debug_msg binding "put_env bad binder in binding")
	  (debug_msg binder "put_env bad binder")
	  (shortbacktrace_dbg "put_env  bad binder in binding" 5)))
    (assert_msg "check bindmap" (is_mapobject bindmap))
    (assert_msg "check binder" (is_object binder))
    (mapobject_put bindmap binder binding)
    ))

;; overwrite a binding in the environment where it has been already bind
(defun overwrite_env (env binding)
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check binding" (is_a binding class_any_binding))
  (let ( (binder  (unsafe_get_field :binder binding)) )
    (assert_msg "check binder" (is_object binder))
    (forever findloop
	     (if (not (is_a env class_environment)) (exit findloop))
	     (let ( (bindmap (unsafe_get_field :env_bind env)) )
	       (assert_msg "check bindmap" (is_mapobject bindmap))
	       (let ( (oldbinding (mapobject_get bindmap binder)) )
		 (if oldbinding 
		     (progn 
		       (mapobject_put bindmap binder binding)
		       (exit findloop oldbinding))
		   ))
	       (setq env (unsafe_get_field :env_prev env))
	       ))))

;;;; any binding debug output
(defun dbgout_anybinding_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (assert_msg "check self" (is_a self class_any_binding))
  (let ( (dis (discrim self)) 
	 (sbuf  (unsafe_get_field :dbgi_sbuf dbgi)) 
	 (binder (unsafe_get_field :binder self))
	 ) 
    (add2sbuf_indent sbuf depth)
    (add2sbuf_strconst sbuf "[~")
    (add2sbuf_string sbuf (unsafe_get_field :named_name dis))
    (add2sbuf_strconst sbuf "/")
    (add2sbuf_longhex sbuf (obj_hash self))
    (add2sbuf_strconst sbuf ":")
    (dbg_outputagain binder dbgi (+i depth 2))
    (if (need_dbglim depth (get_int (unsafe_get_field :dbgi_maxdepth dbgi)))
	(progn
	  (add2sbuf_strconst sbuf "; ")
	  (dbgout_fields self dbgi (+i depth 1) 1)
	  ))
    (add2sbuf_strconst sbuf "~]")
    ))
(install_method class_any_binding dbg_output dbgout_anybinding_method)
(install_method class_any_binding dbg_outputagain dbgout_anybinding_method)


;;;;;;;;;;;;;;;;;;;; first pass, macro expansion

;;get the n-th son of a sexpr
(defun sexpr_nth_son (sexp :long n)
  (if (is_a sexp class_sexpr)
      (let ( (:long ix 0)
	     (curpair (list_first (unsafe_get_field :sexp_contents sexp)))
	     )
	(forever nthloop
		 (if (not (is_pair curpair)) (exit nthloop))
		 (if (==i ix n) (exit nthloop (pair_head curpair)))
		 (setq ix (+i ix 1))
		 (setq curpair (pair_tail curpair))
))))

;;expand all but the first element of a list as a tuple
(defun expand_restlist_as_tuple (arglist env mexpander)
  (assert_msg "check end" (is_a env class_environment))
  (assert_msg "check mexpander" (is_closure mexpander))
  (assert_msg "check arglist" (is_list arglist))
  (let ( (:long nbarg (list_length arglist))
	 (:long ix 0)
	 (curpair (pair_tail (list_first arglist)))
	 (tup (make_multiple discr_multiple (-i nbarg 1)))
	 )
    (forever exploop
	     (if (not curpair) (exit exploop))
	     (assert_msg "check curpair" (is_pair curpair))
	     (let ( (curarg (pair_head curpair)) 
		    (curexp (macroexpand_1 curarg env mexpander))
		    )
	       (multiple_put_nth tup ix curexp)
	       (setq ix (+i ix 1))
	       (setq curpair (pair_tail curpair))
	     ))
    tup
    ))

;;expand all of a pairlist as a tuple
(defun expand_pairlist_as_tuple (pair env mexpander)
  (assert_msg "check end" (is_a env class_environment))
  (assert_msg "check mexpander" (is_closure mexpander))
  (let ( (:long nbarg (pair_listlength pair))
	 (:long ix 0)
	 (tup (make_multiple discr_multiple nbarg)) )
    (forever exploop
	     (if (not (is_pair pair)) (exit exploop))
	     (let ( (curarg (pair_head pair)) 
		    (curexp (macroexpand_1 curarg env mexpander))
		    )
	       (multiple_put_nth tup ix curexp)
	       (setq ix (+i ix 1))
	       (setq pair (pair_tail pair))
	     ))
    tup 
))


;;; expand an s-expression known to be an application
(defun expand_apply (sexpr env mexpander)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (assert_msg "check end" (is_a env class_environment))
  (assert_msg "check mexpander" (is_closure mexpander))
  (let ( (scont (unsafe_get_field :sexp_contents sexpr))
	 (sloc (unsafe_get_field :loca_location sexpr))
	 (soper (pair_head (list_first scont)))
	 (xargtup (expand_restlist_as_tuple scont env mexpander))
	 (xoper (if (is_a soper class_sexpr) 
		    (macroexpand_1 soper env mexpander) 
		  soper))
	 )
    (make_instance class_src_apply
		   :src_loc sloc
		   :sapp_fun xoper
		   :sapp_args xargtup)))
     

;;; expand an s-expression known to be a message send
(defun expand_msend  (opbind sexpr env mexpander)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (assert_msg "check end" (is_a env class_environment))
  (assert_msg "check mexpander" (is_closure mexpander))
  (assert_msg "check opbind" (is_a opbind class_selector_binding))
  (debug_msg sexpr "expand_msend sexpr")
  (let ( (scont (unsafe_get_field :sexp_contents sexpr))
	 (sloc (unsafe_get_field :loca_location sexpr))
	 (spair (pair_tail (list_first scont)))
	 (seldata (unsafe_get_field :sbind_selectordata opbind))
	 )
    (if (not (is_pair spair)) (error_plain sloc "missing reciever expression in message send"))
    (let ( (xrecv (pair_head spair))
	   (argtup (expand_pairlist_as_tuple (pair_tail spair) env mexpander)) 
	   (res (make_instance class_src_msend
		     :src_loc sloc
		     :msend_selbind opbind
		     :msend_recv (if (is_a xrecv class_sexpr)
				     (macroexpand_1 xrecv env mexpander)
				   xrecv)
		     :msend_args argtup
		     ))
	   )
      (debug_msg res "expand_msend res")
      res
      )))

;;; expand a keywordfun s-expression
;;; not implemented yet, but might later be useful for stuff like
;;;;; (:fieldname obj) to get a field
;;;;; (:selector recv arg...) to send a message
(defun expand_keywordfun (sexpr env mexpander)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (assert_msg "check end" (is_a env class_environment))
  (assert_msg "check mexpander" (is_closure mexpander))
  (error_plain (unsafe_get_field :loca_location sexpr) "keywordoper not implemented")
  (assert_msg "@@@  expand_keywordfun NOT IMPLEMENTED" 0)
)

(defun macroexpand_1 (sexpr env mexpander)
  (if (null mexpander) (setq mexpander macroexpand_1))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check mexpander" (is_closure mexpander))
  (if (is_a sexpr class_sexpr)
      (let ( (scont (unsafe_get_field :sexp_contents sexpr))
	     (soper (pair_head (list_first scont))) )
	(debug_msg sexpr "macroexpand_1 sexpr")
	(debug_msg soper "macroexpand_1 soper")
	(cond ( (is_a soper class_symbol)
		(let ( (opbind (find_env env soper)) )
		  (debug_msg opbind "macroexpand_1 opbind")
		  (cond ( (is_a opbind class_macro_binding)
			  (let ( (mexp (unsafe_get_field :mbind_expanser opbind)) )
			    (assert_msg "check mexp" (is_closure mexp))
			    (let ( (resm (mexp sexpr env mexpander)) )
			      (debug_msg resm "macroexpand_1 result for macro resm")
			      (return resm)
			      )))
			( (is_a opbind class_selector_binding)
			  (let ( (ress (expand_msend opbind sexpr env mexpander)) )
			    (debug_msg ress "macroexpand_1 result for send ress")
			    (return ress)
			    ))
			( (is_a opbind class_primitive_binding)
			  (let ( (resp (expand_primitive opbind sexpr env mexpander)) )
			    (debug_msg resp "macroexpand_1 result for primitive resp")
			    (return resp)
			    ))
			(:else 
			 ;; this is to catch the case when DEFUN is not bound...
			 (assert_msg "check soper not defun" (!= soper 'defun))
			 (assert_msg "check soper not named DEFUN" (not (is_stringconst (unsafe_get_field :named_name soper) "DEFUN")))
			 (let ( (resa (expand_apply sexpr env mexpander))) 
			   (debug_msg resa "macroexpand_1 result for apply resa")
			   (return resa)
			   )
			 ))))
	      ( (is_a soper class_keyword)
		(let ( (resk (expand_keywordfun sexpr env mexpander)) )
		  (debug_msg resk "macroexpand_1 result for keywordfun resk")
		  (return resk)))
	      ;; the empty list is expanded as nil
	      ( (==i (list_length scont) 0)
		(debug_msg (the_null) "macroexpand_1 result for null")
		(return (the_null)))
	      (:else 
	       (let ( (resca (expand_apply sexpr env mexpander)) )
		 (debug_msg resca "macroexpand_1 result complex apply resca")
		 (return resca)
		 ))))
    (return sexpr)))
  
;;; expand a primitive s-expression
(defun expand_primitive (opbind sexpr env mexpander)
  (assert_msg "check opbind" (is_a opbind class_primitive_binding))
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (assert_msg "check end" (is_a env class_environment))
  (assert_msg "check mexpander" (is_closure mexpander))
  (let ( (scont (unsafe_get_field :sexp_contents sexpr))
	 (sloc (unsafe_get_field :loca_location sexpr))
	 (soper (pair_head (list_first scont)))
	 (xargtup (expand_restlist_as_tuple scont env mexpander))
	 (sprim (unsafe_get_field :pbind_primitive opbind))
	 )
    (assert_msg "check sprim" (is_a sprim class_primitive))
    (make_instance class_src_primitive
		   :src_loc sloc
		   :sprim_oper sprim
		   :sprim_args xargtup)))



(defun macroexpand_toplevel_list (slist env)
  ;; (messageval_dbg "macroexpand_toplevel_list Env" env)
  ;;  (debug_msg  env "macroexpand_toplevel_list env"(the_callcount)) 
  (debug_msg slist "macroexpand_toplevel_list slist") 
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check slist" (is_list slist))
  (let ( (xlist (list_map slist 
			  (lambda (sexp) 
			    (debug_msg sexp "macroexpand_toplevel_list sexp")
			    (let ( (mex (macroexpand_1 sexp env macroexpand_1)) 
				   )
			      (debug_msg mex "macroexpand_toplevel_list mex")
			      mex
			      )))) 
	 )
    (debug_msg xlist "macroexpand_toplevel_list res xlist")
    xlist
    ))

;;; expand an s-expression into a tuple of formal bindings
;;; the formalsexp is the sexpr of formals 
;;; the [optional] checkargs should be set to non-null to check arguments type
(defun lambda_arg_bindings (formalsexp checkargs)
  ;; special case for null arglist
  (if (null formalsexp)
      (progn
	(return (make_multiple discr_multiple 0))))
  (assert_msg "check formalsexp" (is_a formalsexp class_sexpr))
  (let ( (:long argrk 0)
	 (argtype ctype_value)
	 (arglist (unsafe_get_field :sexp_contents formalsexp))
	 (argloc (unsafe_get_field :loca_location formalsexp))
	 (argmap (make_mapobject discr_mapobjects (+i 4 (list_length arglist))))
	 (bndlist (make_list discr_list)) 
	 (curpair (list_first arglist))
	 )
;;; first loop on arg
    (forever argloop
	     (if (null curpair) (exit argloop))
	     (assert_msg "check curpair" (is_pair curpair))
	     (let ( (curarg (pair_head curpair)) )
	       (cond
		( (is_a curarg class_keyword)
		  (let ( (cty (unsafe_get_field :symb_data curarg)) )
		    (if (and (is_a cty class_ctype) 
			     (== (unsafe_get_field :ctype_keyword cty) curarg))
			(setq argtype cty)
		      (progn
			(error_strv argloc "invalid keyword in formal arglist"
				    (unsafe_get_field :named_name curarg))
			()
			)
		      ))
		  ()			;to make the compiler happy we explicitly gives nil
		  )
		( (is_a curarg class_symbol)
		  (if (mapobject_get argmap curarg)
		      (error_strv argloc "duplicate argument in formal arglist"
				  (unsafe_get_field :named_name curarg)))
		  (let ( (curbind
			  (make_instance class_formal_binding 
					 :binder curarg
					 :fbind_type argtype)) )
		    (if checkargs
			(if (or (not (is_a argtype class_ctype))
				(not (is_string (unsafe_get_field :ctype_parstring argtype))))
			    (error_strv argloc "invalid argument type in formal arglist"
					(unsafe_get_field :named_name curarg))))
		    (put_int curbind argrk)
		    (mapobject_put argmap curarg curbind)
		    (list_append bndlist curbind)
		    (setq argrk (+i argrk 1))
		    )
		  ()
		  )
		(:else 
		 (debug_msg curarg "unexpected argument in formal arglist")
		 (let ( (discrarg  (discrim curarg) ))
		   (error_strv argloc "unexepected argument in formal arglist" 
			       (unsafe_get_field :named_name discrarg))
		   )
		 ()
		 ))
	       (setq curpair (pair_tail curpair))))
;;; second loop to fill the bindings tuple
    (let ( (bndtup (make_multiple discr_multiple argrk)) 
	   (:long ix 0)
	   (bndpair (list_first bndlist))
	   )
      (forever bndloop
	       (if (null bndpair) (exit bndloop))
	       (assert_msg "check bndpair" (is_pair bndpair))
	       (let ( (curbnd (pair_head bndpair)) )
		 (assert_msg "check curbnd" (is_a curbnd class_formal_binding))
		 (multiple_put_nth bndtup ix curbnd)
		 )
	       (setq ix (+i ix 1))
	       (setq bndpair (pair_tail bndpair))
	       )
      bndtup
      )))


;;;;;;;;;;;;;;;; install an initial macro expanser
(defun install_initial_macro (symb expander)
  (assert_msg "check sexpr" (is_a symb class_symbol))
  (assert_msg "check expander" (is_closure expander))
  (let ( (mbind (make_instance class_macro_binding 
			       :binder symb
			       :mbind_expanser expander
			       )) )
	 (put_env initial_environment mbind)
))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;; macro expansers
;; the defprimitive expander
(defun mexpand_defprimitive (sexpr env mexpander)
  (debug_msg sexpr "mexpand_defprimitive sexpr")
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (assert_msg "check env" (is_a env class_environment))
  (let ( (cont (unsafe_get_field :sexp_contents sexpr))
	 (loc  (unsafe_get_field :loca_location sexpr))
	 (curpair (pair_tail (list_first cont)))
	 (symb (pair_head curpair))
	 )
    (if (is_not_a symb class_symbol)
	(error_plain loc "missing symbol for defprimitive"))
    (setq curpair (pair_tail curpair))
    ;; parse the formal arguments
    (let ( (btup (lambda_arg_bindings (pair_head curpair) (the_null))) )
      (setq curpair (pair_tail curpair))
      ;; parse the type keyword
      (let ( (typkw  (pair_head curpair)) )
	(if (is_not_a typkw class_keyword)
	    (error_plain loc "missing type keyword for defprimitive"))
	(let ( (cty (unsafe_get_field :symb_data typkw)) )
	  (if (is_not_a cty class_ctype)
	      (progn
		(debug_msg typkw "mexpand_defprimitive bad cty")
		(error_strv loc "bad type keyword for defprimitive"
			    (unsafe_get_field :named_name typkw))
		(return (the_null))
		))
	  (if (!= (unsafe_get_field :ctype_keyword cty) typkw)
	      (progn
		(debug_msg typkw "mexpand_defprimitive strange typkw")
		(error_strv loc "invalid type keyword for defprimitive"
			    (unsafe_get_field :named_name typkw)) 
		(return (the_null))   
		))
	  ;; parse the rest as to be expanded
	  (setq curpair (pair_tail curpair))
	  (let ( (:long nbcomp (pair_listlength curpair))
		 (etuple (make_multiple discr_multiple nbcomp))
		 (:long ix 0) )
	    (forever comploop
		     (if (not (is_pair curpair)) (exit comploop))
		     (let ( (curhead  (pair_head curpair)) )
		       (debug_msg curhead "mexpand_defprimitive curhead")
		       (let ( (curcomp  (macroexpand_1 curhead env mexpander)) )
			 (debug_msg curcomp "mexpand_defprimitive curcomp")
			 ;; change string to verbatimstring to ease primitive expansion
			 ;; and check that each component is e string or a symbol
			 (cond ( (== (discrim curcomp) discr_string)
				 (setq curcomp (make_string discr_verbatimstring curcomp))
				 ())
			       ( (!= (discrim curcomp) class_symbol)
				 (error_strv loc "invalid expansion component in primitive"
					     (unsafe_get_field :named_name symb))
				 ()))
			 (multiple_put_nth etuple ix curcomp)
			 (setq curpair (pair_tail curpair))
			 (setq ix (+i ix 1)))))
	    (let ( (sdefpri
		    (make_instance class_src_defprimitive
				   :src_loc loc
				   :sdef_name symb
				   :sformal_args btup
				   :sprim_type cty
				   :sprim_expansion etuple))
		   (primit
		    (make_instance class_primitive
				   :named_name (unsafe_get_field :named_name symb)
				   :prim_formals btup
				   :prim_type cty
				   :prim_expansion etuple))
		   (pbind
		    (make_instance class_primitive_binding
				   :binder symb
				   :pbind_primdef sdefpri
				   :pbind_primitive primit
				   ))
		   )
	      (put_env env pbind)
	      (debug_msg sdefpri "mexpand_defprimitive result sdefpri")
	      (return sdefpri)
	      )))))))
(install_initial_macro 'defprimitive mexpand_defprimitive)



;;;;;;;;;;;;;;;;;; the defun expander
(defun mexpand_defun (sexpr env mexpander)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (assert_msg "check env" (is_a env class_environment))
  (debug_msg sexpr "mexp.defun sexpr")
  (let ( (cont (unsafe_get_field :sexp_contents sexpr))
	 (loc  (unsafe_get_field :loca_location sexpr))
	 (curpair (pair_tail (list_first cont)))
	 (symb (pair_head curpair))
	 (newenv (fresh_env env))
	 )
    (if (is_not_a symb class_symbol)
	(error_plain loc "missing symbol for defun"))
    (setq curpair (pair_tail curpair))
    ;; parse the formal arguments
    (let ( (curpairhead (pair_head curpair)) 
	   (btup 
	    (cond ( (null curpairhead) 
		    (make_multiple discr_multiple 0) )
		  ( (is_a curpairhead class_sexpr)
		    (lambda_arg_bindings (pair_head curpair) sexpr))
		  (:else
		   (debug_msg curpairhead "mexpand_defun strange arglist curpairhead")
		   (error_plain loc "missing or invalid arglist for DEFUN")
		   (the_null)
		   )))
	   )
      (if (not (is_multiple btup))
	  (progn
	    (debug_msg btup "mexpand_defun strange btup")
	    (error_plain loc "missing formal arguments for DEFUN")))
      (multiple_every btup (lambda (fb) (put_env newenv fb)))
      (setq curpair (pair_tail curpair))
      (let ( (bodytup (expand_pairlist_as_tuple curpair newenv mexpander)) 
	     (sdefun
	      (make_instance class_src_defun
			     :src_loc loc
			     :sdef_name symb
			     :sformal_args btup
			     :sfun_body bodytup
			     ))
	     (fbind 
	      (make_instance class_function_binding
			     :binder symb
			     :fubind_defun sdefun
			     ))
	     )
	(put_env env fbind)
	sdefun
	))))
(install_initial_macro 'defun mexpand_defun)



;;;;;;;;;;;;;;;; the defclass expander

;; internal routine with multiple results to scan the defclass
(defun scan_defclass (sexpr env mexpander)
  (let ( (predef ())
	 (supernam ())
	 (superbind ())
	 (superclass ())
	 (fieldnams ())
	 (docstr ())
	 (cont (unsafe_get_field :sexp_contents sexpr))
	 (loc  (unsafe_get_field :loca_location sexpr))
	 (fieldsloc ())
	 (curpair (pair_tail (list_first cont)))
	 (symb (pair_head curpair))
	 )
    (debug_msg sexpr "scan_defclass sexpr")
    (if (is_not_a symb class_symbol)
	(error_plain loc "missing symbol for defclass"))
    (setq curpair (pair_tail curpair))
    (forever scanloop
	     (if (not (is_pair curpair)) (exit scanloop))
	     (let ( (curkw (pair_head curpair)) )
	       (if (not (is_a curkw class_keyword)) 
		   (error_plain loc "expecting keyword in defclass"))
	       (setq curpair (pair_tail curpair))
	       (let ( (curval (pair_head curpair)) )
		 (setq curpair (pair_tail curpair))
		 (cond 
		  ( (== curkw ':super)
		    (if supernam (error_plain loc "duplicate super in defclass"))
		    (if (not (is_a curval class_symbol))
			(error_plain loc "bad super in defclass"))
		    (setq supernam curval)
		    (let ( (superb (find_env env supernam)) )
;;; should handle the case when the class is bound in the start environment
;;; to a value which happens to be a class
		      (cond ( (is_a superb class_class_binding)
			      (setq superbind superb) 
			      (setq superclass (unsafe_get_field :cbind_class superb))
			      )
			    ( (is_a superb class_value_binding)
			      (let ((superval (unsafe_get_field :vbind_value superb)))
				(if (is_a superval class_class)
				    (progn
				      (setq superbind superb)
				      (setq superclass superval)
				      )
				  (error_strv loc "super is not a class in defclass" 
					      (unsafe_get_field :named_name supernam))))
			      )
			    (:else 
			     (error_strv loc "invalid super in defclass" 
					 (unsafe_get_field :named_name supernam))
			     )
			    )
		      ))
		  ( (== curkw ':fields)
		    (if fieldnams (error_plain loc "duplicate fields in defclass"))
		    (if curval
			(if (is_not_a curval class_sexpr)
			    (error_plain loc "bad fields in defclass")))
		    (let ( (namlist (if curval (unsafe_get_field :sexp_contents curval)))
			   (namloc (if curval (unsafe_get_field :loca_location curval)))
			   (:long nbnam  (list_length namlist))
			   (:long ix 0)
			   (nampair (list_first namlist))
			   (namtupl (make_multiple discr_multiple nbnam)) )
		      (setq fieldsloc namloc)
		      (forever namloop
			       (if (not (is_pair nampair)) (exit namloop))
			       (let ( (curnam (pair_head nampair)) )
				 (if (not (is_a curnam class_symbol))
				     (error_plain namloc "non name field in defclass"))
				 (multiple_put_nth namtupl ix curnam)
				 )
			       (setq nampair (pair_tail nampair))
			       (setq ix (+i ix 1))
			       )
		      (setq fieldnams namtupl)
		      ))
		  ( (== curkw ':predef)
		    (if predef (error_plain loc "duplicate predef in DEFCLASS"))
		    (setq predef (macroexpand_1 curval env mexpander))
		    (cond
		     ( (is_integerbox predef) 
		       ()
		       )
		     ( (is_a predef class_symbol)
		       ()
		       )
		     (:else
		      (error_plain loc "bad predef in DEFCLASS")
		      )
		     )
		    )
		  ( (== curkw ':docstr)
		    (if docstr (error_plain loc "duplicate docstr in DEFCLASS"))
		    (setq docstr (macroexpand_1 curval env mexpander))
		    (if (not (is_string docstr))
			(error_plain loc "bad docstr in DEFCLASS"))
		    )
		  (:else
		   (error_strv loc "invalid keyword in DEFCLASS" 
			       (unsafe_get_field :named_name curkw))
		   )
		  ))))
    (debug_msg symb "scan_defclass returns symb")
    (debug_msg loc "scan_defclass returns loc")
    (debug_msg supernam "scan_defclass returns supernam")
    (debug_msg superbind "scan_defclass returns superbinds")
    (debug_msg superclass "scan_defclass returns superclass")
    (debug_msg predef "scan_defclass returns predef")
    (debug_msg fieldnams "scan_defclass returns fieldnams")
    (debug_msg fieldsloc "scan_defclass returns fieldsloc")
    (debug_msg docstr "scan_defclass returns docstr")
    (return symb loc supernam superbind superclass predef fieldnams fieldsloc docstr)
    ))


(defun mexpand_defclass (sexpr env mexpander)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (assert_msg "check env" (is_a env class_environment))
  (debug_msg  sexpr "mexp.defclass sexpr")
  (multicall 
   (symb loc supernam superbind superclass predef fieldnams fieldsloc docstr)
   (scan_defclass sexpr env mexpander)
   (debug_msg symb "mexp.defclass scanned symb")
   (debug_msg loc "mexp.defclass scanned loc")
   (debug_msg supernam "mexp.defclass scanned supernam")
   (debug_msg superbind "mexp.defclass scanned superbind")
   (debug_msg superclass "mexp.defclass scanned superclass")
   (debug_msg predef "mexp.defclass scanned predef")
   (debug_msg fieldnams "mexp.defclass scanned fieldnams")
   (debug_msg fieldsloc "mexp.defclass scanned fieldsloc")
   (debug_msg docstr "mexp.defclass scanned docstr")
   (assert_msg "check symb" (is_a symb class_symbol))
   (let ( 
	 (ancestors (if (is_object superclass)
			(let ( (superancestors (unsafe_get_field :class_ancestors superclass))
			       (:long nbsuperanc (multiple_length superancestors))
			       (anctuple (make_multiple discr_seqclass (+i 1 nbsuperanc)))
			       (:long ix 0)
			       )
			  (assert_msg "check superclass" (is_a superclass class_class))
			  (assert_msg "check superancestors" (is_multiple superancestors))
			  (forever ancloop
				   (if (>=i ix nbsuperanc) (exit ancloop))
				   (multiple_put_nth anctuple ix (multiple_nth superancestors ix))
				   (setq ix (+i ix 1))
				   )
			  (multiple_put_nth anctuple nbsuperanc superclass)
			  anctuple
			  )
		      (make_multiple discr_seqclass 0)))
	 (superfields (if (is_object superclass)
			  (unsafe_get_field :class_fields superclass)))
	 (:long nbsuperfields (multiple_length superfields))
	 (:long nbfieldnames (multiple_length fieldnams))
	 (boxnbsuperfields (make_integerbox discr_integer nbsuperfields))
	 (fieldstrmap (make_mapstring discr_mapstrings (+i 3 (*i 2 (+i nbsuperfields nbfieldnames)))))
	 (fieldtup (make_multiple discr_seqfield (+i nbsuperfields nbfieldnames)))
	 (ownfieldbindings (make_multiple discr_multiple nbfieldnames))
	 (newclass (make_instance class_class
				  :named_name (unsafe_get_field :named_name symb)
				  :class_ancestors ancestors
				  ;; other fields to be set later
				  ))
	 (clabind (make_instance class_class_binding
				 :binder symb
				 :cbind_class newclass))
	 )
     (put_env env clabind)
     (debug_msg superfields "expdefclas superfields")
     (multiple_every 
      superfields 
      (lambda (sfld :long ix)
	(messagenum_dbg "expdefclasupflds ix" ix)
	(messageval_dbg "expdefclasupfldsval sfld" sfld)
	(assert_msg "check superfield" (is_a sfld class_field))
	(multiple_put_nth fieldtup ix sfld)
	(mapstring_putstr fieldstrmap (unsafe_get_field :named_name sfld) sfld)
	))
     (multiple_every
      fieldnams
      (lambda (fldnam :long ix)
	(messagenum_dbg "expdefclafldnam ix" ix)
	(assert_msg "check fldnam" (is_a fldnam class_symbol))
	(let ( (fldstr (unsafe_get_field :named_name fldnam)) 
	       )
	  (if (mapstring_getstr fieldstrmap fldstr)
	      (error_strv fieldsloc "duplicate field in deflclass" fldstr))
	  (let ( (:long fldoff (+i ix (get_int boxnbsuperfields))) 
		 (newfld (make_instance class_field
					:named_name fldstr
					:fld_ownclass newclass
					)) )
	    (put_int newfld fldoff)
	    (messagenum_dbg "expdefclafldnam fldoff" fldoff)
	    (multiple_put_nth fieldtup fldoff newfld)
	    (mapstring_putstr fieldstrmap fldstr newfld)
	    (let ( (newfldbind (make_instance class_field_binding
					      :binder fldnam
					      :flbind_clabind clabind
					      :flbind_field newfld)) )
	      (put_env env newfldbind)
	      (multiple_put_nth ownfieldbindings ix newfldbind)
	      )
	    ))))
     (unsafe_put_fields newclass
			:class_fields fieldtup)
     (debug_msg newclass "mexp.defclass newclass" )
     (make_instance class_src_defclass
		    :src_loc loc
		    :sdef_name symb
		    :sobj_predef predef
		    :sobj_docstr docstr
		    :sclass_clabind clabind
		    :sclass_superbind superbind
		    :sclass_fldbinds ownfieldbindings
		    ))))
(install_initial_macro 'defclass mexpand_defclass)


;;;;;;;;;;;;;;;; the definstance expander

;; internal to parse a field assignment in a given class (or without class, for put_field)
(defun parse_field_assignment (cla loc fldkw expr env mexpander)
  (if (not (is_a fldkw class_keyword))
      (error_plain loc "expecting :fieldname"))
  (assert_msg "check fldkw" (is_a fldkw class_keyword))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check mexpander" (is_closure mexpander))
  ;; expr is an sexpr or a symbol or a string or ...
  (let ( (fldbox (make_box discr_box ())) )
    ;; if we have a class, find the field inside
    (if (is_a cla class_class)
	(multiple_iterate_test
	 (unsafe_get_field :class_fields cla)
	 (lambda (cfld :long ix)
	   (assert_msg "check fld" (is_a cfld class_field))
	   (if (==s (unsafe_get_field :named_name cfld) 
		    (unsafe_get_field :named_name fldkw))
	       (progn 
		 (box_put fldbox cfld)
		 ()			; nil to exit to iteration
		 )
	     cfld))
	 )
      ;; othewise, find the field by its bound name
      (let ( (fldnam (create_symbolstr (unsafe_get_field :named_name fldkw))) 
	     (fldbind (find_env env fldnam)) 
	     (fld  (cond 
		    ( (is_a fldbind class_field_binding)
		      (unsafe_get_field :flbind_field fldbind) )
		    ( (is_a fldbind class_value_binding)
		      (let ( (vfld (unsafe_get_field :vbind_value fldbind)) )
			(if (is_a vfld class_field)
			    vfld)) )
		    )) )
	(if (is_a fld class_field)
	    (box_put fldbox fld)
	  (error_strv loc "invalid field name in field assignment" 
		      (unsafe_get_field :named_name fldkw)))
	()
	))
    ;; at last make the field assignment
    (let ( (fld (box_content fldbox)) )
      (if (is_a fld class_field)
	  (let ( (xex (macroexpand_1 expr env mexpander)) )
	    (make_instance class_src_fieldassign 
			   :src_loc loc
			   :sfla_field fld
			   :sfla_expr xex
			   ))))))

;; the definstance expanser
(defun mexpand_definstance (sexpr env mexpander)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (assert_msg "check env" (is_a env class_environment))
  (debug_msg sexpr "mexp.definstance sexpr")
  (let ( (predef ())
	 (objnum ())
	 (fields ())
	 (fieldnams ())
	 (cont (unsafe_get_field :sexp_contents sexpr))
	 (loc  (unsafe_get_field :loca_location sexpr))
	 (curpair (pair_tail (list_first cont)))
	 (symb (pair_head curpair))
	 (claname ())
	 (cla ())
	 (clabind ())
	 )
    (if (is_not_a symb class_symbol)
	(error_plain loc "missing symbol for definstance"))
    (setq curpair (pair_tail curpair))
    (let ( (nam (pair_head curpair)) )
      (if (is_not_a nam class_symbol)
	  (error_plain loc "missing class name for definstance"))
      (let ( (bnd (find_env env nam)) 
	     (fldlist (make_list discr_list))
	     )
	(cond 
	 ( (is_a bnd class_class_binding)
	   (setq clabind bnd)
	   (setq cla (unsafe_get_field :cbind_class bnd)) )
	 ( (and (is_a bnd class_value_binding)
		(is_a (unsafe_get_field :vbind_value bnd) class_class))
	   (setq clabind bnd)
	   (setq cla (unsafe_get_field :vbind_value bnd)))
	 (:else
	  (error_strv loc "invalid class name for definstance"
		      (unsafe_get_field :named_name nam))
	  (return (the_null))
	  ))
	(setq claname nam)
	(assert_msg "check cla" (is_a cla class_class))
	(setq curpair (pair_tail curpair))
	(forever insloop
		 (if (not (is_pair curpair)) (exit insloop))
		 (let ( (curfkw (pair_head curpair)) )
		   (if (is_not_a curfkw class_keyword)
		       (error_plain loc "expecting keyword in definstance"))
		   (setq curpair (pair_tail curpair))
		   (let ( (curexp (pair_head curpair)) )
		     (cond  ( (== curfkw ':obj_num)
			      (if objnum (error_plain loc "duplicate :obj_num in definstance"))
			      (setq objnum 
				    (if (is_a curexp class_sexpr)
					(macroexpand_1 curexp env mexpander)
				      curexp))
			      )
			    ( (== curfkw ':predef)
			      (if predef (error_plain loc "duplicate :predef in definstance"))
			      (setq predef 
				    (if (is_a curexp class_sexpr)
					(macroexpand_1 curexp env mexpander)
				      curexp))
			      )
			    (:else 
			     (let  ( (flda (parse_field_assignment cla loc curfkw curexp env mexpander)) )
			       (if flda 
				   (list_append fldlist flda)
				 )
			       ))))
		   (setq curpair (pair_tail curpair))
		   ))
	(let ( (fastup (list_to_multiple fldlist discr_multiple)) 
	       (sinst 
		(make_instance class_src_definstance
			       :src_loc loc
			       :sdef_name symb
			       :sobj_predef predef
			       :sinst_class cla
			       :sinst_clabind clabind
			       :sinst_objnum objnum
			       :sinst_fields fastup
			       ))
	       (ibind 
		(make_instance class_instance_binding
			       :binder symb
			       :ibind_iclass cla
			       ))
	       )
	  (put_env env ibind)
	  (debug_msg sinst "mexp.definstance sinst")
	  (return sinst)
	  )))))
(install_initial_macro 'definstance mexpand_definstance)



;; the definstance expanser
(defun mexpand_defselector (sexpr env mexpander)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (assert_msg "check env" (is_a env class_environment))
  (debug_msg sexpr "mexp.definstance sexpr")
  (let ( (predef ())
	 (objnum ())
	 (fields ())
	 (fieldnams ())
	 (cont (unsafe_get_field :sexp_contents sexpr))
	 (loc  (unsafe_get_field :loca_location sexpr))
	 (curpair (pair_tail (list_first cont)))
	 (symb (pair_head curpair))
	 (claname ())
	 (cla ())
	 (clabind ())
	 )
    (if (is_not_a symb class_symbol)
	(error_plain loc "missing symbol for definstance"))
    (setq curpair (pair_tail curpair))
    (let ( (nam (pair_head curpair)) )
      (if (is_not_a nam class_symbol)
	  (error_plain loc "missing class name for definstance"))
      (let ( (bnd (find_env env nam)) 
	     (fldlist (make_list discr_list))
	     )
	(cond 
	 ( (is_a bnd class_class_binding)
	   (setq clabind bnd)
	   (setq cla (unsafe_get_field :cbind_class bnd)) )
	 ( (and (is_a bnd class_value_binding)
		(is_a (unsafe_get_field :vbind_value bnd) class_class))
	   (setq clabind bnd)
	   (setq cla (unsafe_get_field :vbind_value bnd)))
	 (:else
	  (error_strv loc "invalid class name for definstance"
		      (unsafe_get_field :named_name nam))
	  (return (the_null))
	  ))
	(setq claname nam)
	(assert_msg "check cla" (is_a cla class_class))
	(setq curpair (pair_tail curpair))
	(forever insloop
		 (if (not (is_pair curpair)) (exit insloop))
		 (let ( (curfkw (pair_head curpair)) )
		   (if (is_not_a curfkw class_keyword)
		       (error_plain loc "expecting keyword in definstance"))
		   (setq curpair (pair_tail curpair))
		   (let ( (curexp (pair_head curpair)) )
		     (cond  ( (== curfkw ':obj_num)
			      (if curexp (error_plain loc "duplicate :obj_num in definstance"))
			      (setq objnum 
				    (if (is_a curexp class_sexpr)
					(macroexpand_1 curexp env mexpander)
				      curexp))
			      )
			    ( (== curfkw ':predef)
			      (if curexp (error_plain loc "duplicate :predef in definstance"))
			      (setq predef 
				    (if (is_a curexp class_sexpr)
					(macroexpand_1 curexp env mexpander)
				      curexp))
			      )
			    (:else 
			     (let  ( (flda (parse_field_assignment cla loc curfkw curexp env mexpander)) )
			       (if flda 
				   (list_append fldlist flda)
				 )
			       ))))
		   (setq curpair (pair_tail curpair))
		   ))
	(let ( ( fastup (list_to_multiple fldlist discr_multiple)) 
	       (res (make_instance class_src_defselector
				   :src_loc loc
				   :sdef_name symb
				   :sobj_predef predef
				   :sinst_class cla
				   :sinst_clabind clabind
				   :sinst_objnum objnum
				   :sinst_fields fastup
				   ))
	       (selbind (make_instance class_selector_binding
				       :binder symb
				       :sbind_selectordef res
				       ))
	       )
	  (put_env env selbind)
	  res
	  )))))
(install_initial_macro 'defselector mexpand_defselector)



;;;; the make_instance expander
(defun mexpand_make_instance (sexpr env mexpander)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (assert_msg "check env" (is_a env class_environment))
  (let ( (fields ())
	 (fieldnams ())
	 (cont (unsafe_get_field :sexp_contents sexpr))
	 (loc  (unsafe_get_field :loca_location sexpr))
	 (curpair (pair_tail (list_first cont)))
	 (claname (pair_head curpair))
	 (cla ())
	 (clabind ())
	 )
    (debug_msg sexpr "mexpand_make_instance start sexpr")
    (if (is_not_a claname class_symbol)
	(error_plain loc "missing class symbol for make_instance"))
    (let ( (bnd (find_env env claname)) 
	   (fldlist (make_list discr_list))
	   )
      (cond 
       ( (is_a bnd class_class_binding)
	 (setq clabind bnd)
	 (setq cla (unsafe_get_field :cbind_class bnd)) 
	 )
       ( (and (is_a bnd class_value_binding)
	      (is_a (unsafe_get_field :vbind_value bnd) class_class))
	 (setq clabind bnd)
	 (setq cla (unsafe_get_field :vbind_value bnd))
	 )
       (:else
	(error_strv loc "invalid class name for make_instance"
		    (unsafe_get_field :named_name claname))
	(return (the_null))
	))
      (assert_msg "check cla" (is_a cla class_class))
      (setq curpair (pair_tail curpair))
      (forever insloop
	       (if (not (is_pair curpair)) (exit insloop))
	       (let ( (curfkw (pair_head curpair)) )
		 (if (is_not_a curfkw class_keyword)
		     (error_plain loc "expecting keyword in MAKE_INSTANCE"))
		 (setq curpair (pair_tail curpair))
		 (let ( (curexp (pair_head curpair)) )
		   (let  ( (flda (parse_field_assignment cla loc curfkw curexp env mexpander)) )
		     (if flda 
			 (list_append fldlist flda)
		       (error_strv loc "bad field name in MAKE_INSTANCE" (unsafe_get_field :named_name curfkw))
		       ))))
	       (setq curpair (pair_tail curpair))
	       )
      (let ( ( fastup (list_to_multiple fldlist discr_multiple)) )
	(make_instance class_src_make_instance
		       :src_loc loc
		       :smins_class cla
		       :smins_clabind clabind
		       :smins_fields fastup)
	))))
(install_initial_macro 'make_instance mexpand_make_instance)



;;;; the unsafe_put_fields expander
(defun mexpand_unsafe_put_fields (sexpr env mexpander)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (assert_msg "check env" (is_a env class_environment))
  (let ( (fields ())
	 (fieldnams ())
	 (cont (unsafe_get_field :sexp_contents sexpr))
	 (loc  (unsafe_get_field :loca_location sexpr))
	 (curpair (pair_tail (list_first cont)))
	 (objsrc (pair_head curpair))
	 (objexp 
	  (if (is_a objsrc class_sexpr)
	      (macroexpand_1 objsrc env mexpander)
	    objsrc))
	 )
    (setq curpair (pair_tail curpair))
    (let ( (fldlist (make_list discr_list))
	   )
      (forever insloop
	       (if (not (is_pair curpair)) (exit insloop))
	       (let ( (curfkw (pair_head curpair)) )
		 (if (is_not_a curfkw class_keyword)
		     (error_plain loc "expecting heyword in unsafe_put_fields"))
		 (setq curpair (pair_tail curpair))
		 (let ( (curexp (pair_head curpair)) )
		   (let  ( (flda (parse_field_assignment () loc curfkw curexp env mexpander)) )
		     (if flda 
			 (list_append fldlist flda)
		       ))))
	       (setq curpair (pair_tail curpair))
	       )
      (let ( ( fastup (list_to_multiple fldlist discr_multiple)) )
	(make_instance class_src_unsafe_put_fields
		       :src_loc loc
		       :suput_obj objexp
		       :suput_fields fastup)
	))))
(install_initial_macro 'unsafe_put_fields mexpand_unsafe_put_fields)

;;;; the unsafe_get_field expander
(defun mexpand_unsafe_get_field (sexpr env mexpander)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (assert_msg "check env" (is_a env class_environment))
  (let ( (cont (unsafe_get_field :sexp_contents sexpr))
	 (loc  (unsafe_get_field :loca_location sexpr))
	 (curpair (pair_tail (list_first cont)))
	 (curfkw (pair_head curpair)) 
	 )
    (if (is_not_a curfkw class_keyword)
	(progn
	  (error_plain loc "field keyword expected in unsafe_get_field")
	  (return (the_null))))
    (setq curpair (pair_tail curpair))
    (let ( (curexp (pair_head curpair)) )
      (setq curpair (pair_tail curpair))
      (if curpair (error_plain loc "unsafe_get_field with more than two sons"))
      ;; it is not a field assignment but we use the parse_field_assignment
      ;; routine to get the field and the expression
      (let  ( (flda (parse_field_assignment () loc curfkw curexp env mexpander)) )
	(if (not (is_a flda class_src_fieldassign))
	    (progn 
	      (error_plain loc "bad field and expression in unsafe_get_field")
	      (return (the_null))))
	(let ( (fld (unsafe_get_field :sfla_field flda))
	       (exp (unsafe_get_field :sfla_expr flda)) )
	  (make_instance class_src_unsafe_get_field
			 :src_loc loc
			 :suget_obj exp
			 :suget_field fld
	  ))))))
(install_initial_macro 'unsafe_get_field mexpand_unsafe_get_field)



;;;; the setq expander
(defun mexpand_setq (sexpr env mexpander)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (assert_msg "check env" (is_a env class_environment))
  (let ( (cont (unsafe_get_field :sexp_contents sexpr))
	 (loc  (unsafe_get_field :loca_location sexpr))
	 (curpair (pair_tail (list_first cont)))
	 (cursym (pair_head curpair)) 
	 )
    (if (is_not_a cursym class_symbol)
	(progn
	  (error_plain loc "var symbol name expected in setq")
	  (return (the_null))))
    (setq curpair (pair_tail curpair))
    (let ( (curexp (pair_head curpair)) )
      (setq curpair (pair_tail curpair))
      (if curpair (error_plain loc "setq with more than two sons"))
      (make_instance class_src_setq 
		     :src_loc loc
		     :sstq_var cursym
		     :sstq_expr  (macroexpand_1 curexp env mexpander)
		     )
)))
(install_initial_macro 'setq mexpand_setq)

;;;;; the if expanser
(defun mexpand_if (sexpr env mexpander)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (assert_msg "check env" (is_a env class_environment))
  (debug_msg sexpr "mexpand_if sexpr")
  (let (
	(cont (unsafe_get_field :sexp_contents sexpr))
	(loc  (unsafe_get_field :loca_location sexpr))
	(curpair (pair_tail (list_first cont)))
	(curif (pair_head curpair)) )
    (if (not (is_pair curpair))
	(error_plain loc "missing condition in IF"))
    (setq curpair (pair_tail curpair))
    (if (not (is_pair curpair))
	(error_plain loc "missing then in IF"))
    (let ( (xcond (macroexpand_1 curif env mexpander)) )
      (debug_msg xcond "mexpand_if xcond")
      (let ( (curthen (pair_head curpair)) )
	(setq curpair (pair_tail curpair))
	(let ( (xthen (macroexpand_1 curthen env mexpander)) )
	  (debug_msg xthen "mexpand_if xthen")
	  (if (is_pair curpair)
	      (let ( (curelse (pair_head curpair)) 
		     (xelse (macroexpand_1 curelse env mexpander)) )
		(debug_msg xelse "mexpand_if xelse")
		(setq curpair (pair_tail curpair))
		(if (is_pair curpair)
		    (error_plain loc "IF with more than three sons"))
		(let ( (rese
			(make_instance class_src_ifelse
				       :src_loc loc
				       :sif_test xcond
				       :sif_then xthen
				       :sif_else xelse
				       )) )
		  (debug_msg rese "mexpand_if with else return rese")
		  (return rese)))
	    (let ( (resp (make_instance class_src_if
					:src_loc loc
					:sif_test xcond
					:sif_then xthen)) )
	      (debug_msg resp "mexpand_if plain return resp")
	      (return resp))
	    ))))))
(install_initial_macro 'if mexpand_if)

;;;;; the cppif expander
(defun mexpand_cppif (sexpr env mexpander)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (assert_msg "check env" (is_a env class_environment))
  (debug_msg sexpr "mexpand_cppif sexpr")
  (let (
	(cont (unsafe_get_field :sexp_contents sexpr))
	(loc  (unsafe_get_field :loca_location sexpr))
	(curpair (pair_tail (list_first cont)))
	(curif (pair_head curpair)) )
    (if (not (is_pair curpair))
	(error_plain loc "missing condition in CPPIF"))
    (setq curpair (pair_tail curpair))
    (if (not (is_pair curpair))
	(error_plain loc "missing then in CPPIF"))
    (let ( (xcond (macroexpand_1 curif env mexpander)) )
      (debug_msg xcond "mexpand_cppif xcond")
      (cond 
       ( (is_string xcond) ())
       ( (is_a xcond class_symbol) ())
       (:else
	(error_plain loc "invalid cpp-condition in CPPIF - string or symbol expected")
	(return ())))
      (let ( (curthen (pair_head curpair)) )
	(setq curpair (pair_tail curpair))
	(let ( (xthen (macroexpand_1 curthen env mexpander)) 
	       (xelse ())
	       )
	  (debug_msg xthen "mexpand_cppif xthen")
	  (if (is_pair curpair)
	      (let ( (curelse (pair_head curpair)) 
		     (gotxelse (macroexpand_1 curelse env mexpander)) )
		(debug_msg gotxelse "mexpand_cppif gotxelse")
		(setq curpair (pair_tail curpair))
		(setq xelse gotxelse)
		(if (is_pair curpair)
		    (error_plain loc "CPPIF with more than three sons"))))
	  (let ( (resp (make_instance class_src_cppif
				      :src_loc loc
				      :sifp_cond xcond
				      :sifp_then xthen
				      :sifp_else xelse
				      ))
		 )
	    (debug_msg resp "mexpand_cppif return resp")
	    (return resp)
	    ))))))
(install_initial_macro 'cppif mexpand_cppif)



;;;;; the cond expanser
(defun mexpand_cond (sexpr env mexpander)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (assert_msg "check env" (is_a env class_environment))
  (debug_msg sexpr "mexpand_cond sexpr")
  (let (
	(cont (unsafe_get_field :sexp_contents sexpr))
	(loc  (unsafe_get_field :loca_location sexpr))
	(cexptuple (pairlist_to_multiple 
		    (pair_tail (list_first cont))
		    discr_multiple
		    (lambda (c)
		      (if (is_not_a c class_sexpr)
			  (error_plain loc "COND with non-sexpr"))
		      c
		      ))) 
	(:long nbcond (multiple_length cexptuple))
	(lastcexp (let ( (lx (multiple_nth cexptuple -1)) )
		    (debug_msg lx "mexpand_cond lastcexp lx")
		    lx))
	(:long ix (-i nbcond 1))
	(res ())
	)
    (debug_msg cexptuple "mexpand_cond cexptuple")
    (forever condloop
	     (if (<i ix 0) (exit condloop))
	     (let ( (curcond (multiple_nth cexptuple ix)) )
	       (debug_msg curcond "mexpand_cond curcond")
	       (cond  
		( (and (null res)
		       (is_a curcond class_sexpr)
		       (== ':else (pair_head (list_first 
					      (unsafe_get_field :sexp_contents curcond)))))
		  (let ( (restpairs 
			  (pair_tail (list_first (unsafe_get_field :sexp_contents curcond)))) 
			 )
		    (if restpairs 
			(setq res (pairlist_to_progn restpairs 
						     (unsafe_get_field :loca_location curcond) 
						     env mexpander)))
		    (debug_msg res "mexpand_cond res for :else")
		    ))
		( (is_a curcond class_sexpr)
		  (let ( (curcondcont (unsafe_get_field :sexp_contents curcond))
			 (curcondloc (unsafe_get_field :loca_location curcond)) 
			 (curcondtest (pair_head (list_first curcondcont)))
			 (curcondrestpairs (pair_tail (list_first curcondcont))) 
			 )
		    (cond ( (null curcondrestpairs)
			    (setq res (make_instance class_src_or
						     :src_loc curcondloc
						     :sor_disj (make_tuple2 discr_multiple 
									    (macroexpand_1 curcondtest env mexpander)
									    res)))
			    (debug_msg res "mexpand_cond res for monoexp cond")
			    )
			  ( (null (pair_tail curcondrestpairs))
			    (setq res (make_instance class_src_ifelse
						     :src_loc curcondloc
						     :sif_test (macroexpand_1 curcondtest env mexpander)
						     :sif_then (macroexpand_1 (pair_head curcondrestpairs) env mexpander)
						     :sif_else res
						     ))
			    (debug_msg res "mexpand_cond res for biexp cond")
			    )
			  (:else 
			    (setq res (make_instance class_src_ifelse
						     :src_loc curcondloc
						     :sif_test (macroexpand_1 curcondtest env mexpander)
						     :sif_then (pairlist_to_progn curcondrestpairs curcondloc env mexpander)
						     :sif_else res))
			    (debug_msg res "mexpand_cond res for manyexp cond")
			   ))
		    ))
		(:else ;curcond is not a sexpr 
		 (setq res (make_instance class_src_or
					  :src_loc loc
					  :sor_disj (make_tuple2 discr_multiple curcond res)))
		 (debug_msg res "mexpand_cond res for nonsexp cond")
		 )
		)
	       )
	     (setq ix (-i ix 1))
	     )
    (debug_msg res "mexpand_cond final res")
    (return res)
    ))
(install_initial_macro 'cond mexpand_cond)


;;;; the and expanser
;;; AND pseudo syntax
;;; (AND a1) is expanded into a1
;;; (AND a1 a2) is expansed into (IF a1 a2)
;;; (AND a1 a2 a3) is expansed into (IF a1 (IF a2 a3))
(defun mexpand_and (sexpr env mexpander)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (assert_msg "check env" (is_a env class_environment))
  (debug_msg sexpr "mexpand_and sexpr:" )
  (let (
	(cont (unsafe_get_field :sexp_contents sexpr))
	(loc  (unsafe_get_field :loca_location sexpr))
	(curpair (pair_tail (list_first cont)))
	(cxtup (pairlist_to_multiple 
		curpair
		discr_multiple
		(lambda (c) (macroexpand_1 c env mexpander)
		  )))
	(:long nbcomp (multiple_length cxtup))
	)
    (debug_msg cxtup "mexpand_and cxtup")
    (if (<i nbcomp 1)
	(progn
	  (error_plain loc "AND without sons")
	  (return))
      (let ( (res (multiple_nth cxtup (-i nbcomp 1)))
	     (:long ix (-i nbcomp 2)) )
	(forever revloop
		 (if (<i ix 0) (exit revloop))
		 (let ( (curc (multiple_nth cxtup ix)) )
		   (setq res 
			 (make_instance class_src_if
					:src_loc loc
					:sif_test curc
					:sif_then res))
		   )
		 (setq ix (-i ix 1))
		)
	(debug_msg res "mexpand_and res:")
	(return res)))))
(install_initial_macro 'and mexpand_and)
      
;;;; the or expanser
(defun mexpand_or (sexpr env mexpander)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (assert_msg "check env" (is_a env class_environment))
  (debug_msg sexpr "mexpand_or sexpr")
  (let (
	(cont (unsafe_get_field :sexp_contents sexpr))
	(loc  (unsafe_get_field :loca_location sexpr))
	(cxtup (pairlist_to_multiple 
		(pair_tail (list_first cont))
		discr_multiple
		(lambda (c) (macroexpand_1 c env mexpander)
		  )))
	(:long nbcomp (multiple_length cxtup))
	)
    (if (<i nbcomp 1)
	(progn 
	  (error_plain loc "OR without sons")
	  (return (the_null)))
      (let ( (res 
	      (make_instance class_src_or
			     :src_loc loc
			     :sor_disj cxtup)) )
	(debug_msg res "mexpand_or res")
	(return res)
	))))
(install_initial_macro 'or mexpand_or)

;;;;;;;; for LET
;; internal routine to make a letbinding
(defun mexpand_letbinding (sexpr env mexpander)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (assert_msg "check env" (is_a env class_environment))
  (let (
	(cont (unsafe_get_field :sexp_contents sexpr))
	(loc  (unsafe_get_field :loca_location sexpr))
	(ctyp ctype_value)
	(var ())
	(expr ())
	(curpair (list_first cont))
	(curarg ())
	)
    (setq curarg (pair_head curpair))
    (if (is_a curarg class_keyword)
	(let ( (cty (unsafe_get_field :symb_data curarg)) )
	  (if (and (is_a cty class_ctype) 
		   (== (unsafe_get_field :ctype_keyword cty) curarg))
	      (setq ctyp cty)
	    (error_strv loc "letbinding with invalid type keyword"
			(unsafe_get_field :named_name curarg)))
	  (setq curpair (pair_tail curpair))
	  (setq curarg (pair_head curpair))
	  ))
    (cond ( (is_a curarg class_keyword)
	    (error_strv loc "letbinding cannot bind keyword"  
			(unsafe_get_field :named_name curarg)))
	  ( (is_a curarg class_symbol)
	    (setq var curarg)
	    (setq curpair (pair_tail curpair))
	    (setq curarg (pair_head curpair))
	    ))
    (if (null var) 
	(error_plain loc "missing variable in letbinding"))
    (if curarg
	(progn 
	  (setq expr (macroexpand_1 curarg env mexpander))
	  (setq curpair (pair_tail curpair))
	  (setq curarg (pair_head curpair))
	  (if curarg (error_plain loc "too long letbinding"))
	  ))
    (let ( (letb
	    (make_instance class_src_letbinding
			   :src_loc loc
			   :sletb_type ctyp
			   :sletb_binder var
			   :sletb_expr expr)) )
      (return letb)
      )))

;;; the LET expander itself
(defun mexpand_let (sexpr env mexpander)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (assert_msg "check env" (is_a env class_environment))
  (let (
	(cont (unsafe_get_field :sexp_contents sexpr))
	(loc  (unsafe_get_field :loca_location sexpr))
	(secpair (pair_tail (list_first cont)))
	(restpair (pair_tail secpair))
	(bindexpr (pair_head secpair))
	(newenv (fresh_env env))
	(bindtup ())
	(bodytup ())
	)
    (if bindexpr 
	(if (is_a bindexpr class_sexpr) 
	    (setq bindtup 
			  (pairlist_to_multiple 
			   (list_first (unsafe_get_field :sexp_contents bindexpr))
			   discr_multiple
			   (lambda (b) (mexpand_letbinding b env mexpander))))
	  (error_plain loc "missing letbinding-s in LET"))
      )
    (multiple_every
     bindtup
     (lambda (slb)
       (assert_msg "mexp.let. check slb" (is_a slb class_src_letbinding))
       (let (
	     (sx (unsafe_get_field :sletb_expr slb))
	     (lb (make_instance class_let_binding
				:binder (unsafe_get_field :sletb_binder slb)
				:letbind_type (unsafe_get_field :sletb_type slb)
				:letbind_expr sx)) )
	 (assert_msg "mexp.let not list lb" (not (is_list lb)))
	 (put_env newenv lb)
	 )))
    (setq bodytup (pairlist_to_multiple restpair discr_multiple 
					(lambda (e) (macroexpand_1 e newenv mexpander))))
    (let ( (letr
	    (make_instance class_src_let
			   :src_loc loc
			   :slet_bindings bindtup
			   :slet_body bodytup)) )
      (return letr)
      )))
(install_initial_macro 'let mexpand_let)


;;;;;;;; for LAMBDA
(defun mexpand_lambda (sexpr env mexpander)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (assert_msg "check env" (is_a env class_environment))
  (let ( (cont (unsafe_get_field :sexp_contents sexpr))
	 (loc  (unsafe_get_field :loca_location sexpr))
	 (curpair (pair_tail (list_first cont))) 
	 (newenv (fresh_env env))
	 )
    ;; parse the formal arguments
    (let ( (argtup (lambda_arg_bindings (pair_head curpair) sexpr)) )
      (setq curpair (pair_tail curpair))
      (multiple_every argtup 
		      (lambda (lb) (put_env newenv lb)))
      (let ( (bodytup (pairlist_to_multiple curpair discr_multiple 
					    (lambda (e) (macroexpand_1 e newenv mexpander)))) 
	     (lambr 
	      (make_instance class_src_lambda
			     :src_loc loc
			     :slam_argbind argtup
			     :slam_body bodytup))
	     ) 
	(return lambr)
	))))
(install_initial_macro 'lambda mexpand_lambda)
      

;;;;;;;; for MULTICALL
(defun mexpand_multicall (sexpr env mexpander)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (assert_msg "check env" (is_a env class_environment))
  (let ( (cont (unsafe_get_field :sexp_contents sexpr))
	 (loc  (unsafe_get_field :loca_location sexpr))
	 (curpair (pair_tail (list_first cont))) 
	 (newenv (fresh_env env))
	 )
    ;; parse the formal results
    (let ( (restup (lambda_arg_bindings (pair_head curpair) sexpr)) )
      (setq curpair (pair_tail curpair))
      (let ( (curcallexp (pair_head curpair)) )
	(if (not (is_a curcallexp class_sexpr))
	    (error_plain loc "missing called expression in multicall"))
	(setq curpair (pair_tail curpair))
	(let ( (curcall (macroexpand_1 curcallexp env mexpander)) )
	  (multiple_every restup 
			  (lambda (lb) (put_env newenv lb)
			    ))
	  (let ( (bodytup (pairlist_to_multiple curpair discr_multiple 
						(lambda (e) (macroexpand_1 e newenv mexpander)))) 
		 (mulcr
		  (make_instance class_src_multicall
				 :src_loc loc
				 :smulc_resbind restup
				 :smulc_call curcall
				 :smulc_body bodytup
				 )) 
		 )
	    (return mulcr)
	    ))))))
(install_initial_macro 'multicall mexpand_multicall)

;;;;;;;; for QUOTE (only of symbols or keywords)
(defun mexpand_quote (sexpr env mexpander)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (assert_msg "check env" (is_a env class_environment))
  (let ( (cont (unsafe_get_field :sexp_contents sexpr))
	 (loc  (unsafe_get_field :loca_location sexpr))
	 (curpair (pair_tail (list_first cont))) 
	 (quoted (pair_head curpair))
	 )
    (if (pair_tail curpair)
	(error_plain loc "QUOTE should have only one symbol argument"))
    (if (not (is_a quoted class_symbol))
	(error_plain loc "QUOTE should have a symbol argument - composite quotations unsupported"))
    (if (is_a quoted class_keyword)
	(return quoted))
    (let ( (squ (make_instance class_src_quote
			       :src_loc loc
			       :squoted quoted)) )
      (return squ)
      )))
(install_initial_macro 'quote mexpand_quote)

;;;;;;;; for COMMENT (only of strings)
(defun mexpand_comment  (sexpr env mexpander)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (assert_msg "check env" (is_a env class_environment))
  (let ( (cont (unsafe_get_field :sexp_contents sexpr))
	 (loc  (unsafe_get_field :loca_location sexpr))
	 (curpair (pair_tail (list_first cont))) 
	 (comstr (pair_head curpair))
	 )
    (if (pair_tail curpair)
	(error_plain loc "COMMENT should have only one string argument"))
    (if (not (is_string comstr))
	(progn
	  (error_plain loc "COMMENT should have a string")
	  (setq comstr ()))
      )
    (let ( (scom (make_instance class_src_comment
			       :src_loc loc
			       :scomm_str comstr)) )
      (return scom)
)))
(install_initial_macro 'comment mexpand_comment)


;;;;;;;; for PROGN
;; internal routine to make a progn from a pairlist at a location
(defun pairlist_to_progn (pair loc env mexpander)
  (assert_msg "check env" (is_a env class_environment))
  (debug_msg pair "pairlist_to_progn pair")
  (assert_msg "check_pair" (is_pair pair))
  (let ( (bodytup (pairlist_to_multiple 
		   pair 
		   discr_multiple
		   (lambda (e) (macroexpand_1 e env mexpander)))) 
	 (sprogn
	  (make_instance class_src_progn
			 :src_loc loc
			 :sprogn_body bodytup
			 )) )
    (debug_msg sprogn "pairlist_to_progn sprogn")
    (return sprogn)
))

;; internal routine to make a return from a pairlist at a location
(defun pairlist_to_return (pair loc env mexpander)
  (assert_msg "check env" (is_a env class_environment))
  (let ( (bodytup (pairlist_to_multiple 
		   pair 
		   discr_multiple
		   (lambda (e) (macroexpand_1 e env mexpander)))) )
    (make_instance class_src_return
		   :src_loc loc
		   :sreturn_body bodytup
		   )
))

;;;; the progn expanser
(defun mexpand_progn (sexpr env mexpander)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (let ( (progr
	  (pairlist_to_progn (pair_tail
			      (list_first (unsafe_get_field :sexp_contents sexpr)))
			     (unsafe_get_field :loca_location sexpr)
			     env
			     mexpander)) )
    (return progr)
    ))
(install_initial_macro 'progn mexpand_progn)

;;;; the return expanser
(defun mexpand_return (sexpr env mexpander)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (let ( (retr
	  (pairlist_to_return (pair_tail (list_first (unsafe_get_field :sexp_contents sexpr)))
			      (unsafe_get_field :loca_location sexpr)
			      env
			      mexpander)) 
	 )
    (return retr)
    ))
(install_initial_macro 'return mexpand_return)

;;;; the forever expanser
(defun mexpand_forever (sexpr env mexpander)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (let ( (cont (unsafe_get_field :sexp_contents sexpr))
	 (loc  (unsafe_get_field :loca_location sexpr))
	 (curpair (pair_tail (list_first cont))) 
	 (labnam (pair_head curpair))
	 (newenv (fresh_env env))
	 )
    (if (is_not_a labnam class_symbol)
	(progn
	  (error_plain loc "missing label in FOREVER")
	  (return (the_null))))
    (setq curpair (pair_tail curpair))
    (let ( (labind (make_instance class_label_binding
				  :binder labnam
				  :labind_loc loc)) )
      (put_env newenv labind)
      (let ( (bodytup (pairlist_to_multiple
		       curpair
		       discr_multiple
		       (lambda (e) (macroexpand_1 e newenv mexpander)))) 
	     (forr
	      (make_instance class_src_forever
			     :src_loc loc
			     :slabel_bind labind
			     :sfrv_body bodytup)) 
	     )
	(return forr)
	))))
(install_initial_macro 'forever mexpand_forever)


;;;; the exit expanser
(defun mexpand_exit (sexpr env mexpander)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (let ( (cont (unsafe_get_field :sexp_contents sexpr))
	 (loc  (unsafe_get_field :loca_location sexpr))
	 (curpair (pair_tail (list_first cont))) 
	 (labnam (pair_head curpair))
	 (newenv (fresh_env env))
	 )
    (if (is_not_a labnam class_symbol)
	(progn
	  (error_plain loc "missing label in EXIT")
	  (return (the_null))))
    (setq curpair (pair_tail curpair))
    (let ( (labind (find_env env labnam)) )
      (if (is_not_a labind class_label_binding)
	  (progn 
	    (error_strv loc "bad label in EXIT" 
			(unsafe_get_field :named_name labnam))
	    (return (the_null))))
      (let ( (bodytup (pairlist_to_multiple
		       curpair
		       discr_multiple
		       (lambda (e) (macroexpand_1 e newenv mexpander)))) 
	     (exr
	      (make_instance class_src_exit
			     :src_loc loc
			     :slabel_bind labind
			     :sexi_body bodytup)) 
	     )
	(return exr)
	))))
(install_initial_macro 'exit mexpand_exit)

(defun debug_msg_fun (val :cstring msgstr :long count :cstring filenam :long lineno)
  (if (need_dbg 0) 
      (let ( (:long dbgcounter (progn (increment_dbgcounter) (the_dbgcounter)))
	     (sbuf (make_strbuf discr_strbuf)) 
	     (occmap (make_mapobject discr_mapobjects 50))
	     (boxedmaxdepth (make_integerbox discr_integer 17)) ;;;; @@@ DEBUGDEPTH
	     (dbgi (make_instance class_debuginfo
				  :dbgi_sbuf sbuf
				  :dbgi_occmap occmap
				  :dbgi_maxdepth boxedmaxdepth))
	     )
	(outnum_dbg "!*#" dbgcounter "/")
	(outnum_dbg "" (-i (the_framedepth) 1) ":")
	(if filenam
	    (progn
	      (outcstring_dbg filenam)
	      (outnum_dbg ":" lineno ":")
	      ))
	(outcstring_dbg msgstr)
	(if (>i count 0) (outnum_dbg " !" count ": "))
	(dbg_out val dbgi 0)
	(outstrbuf_dbg sbuf)
	(outnewline_dbg)
	)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; assert_msg macro is expanded into other src..
;;;;;; (assert_msg msg check)
;;; becomes
;;;;;; (cppif ENABLE_CHECKING (if check (assert_failed msg filename lineno)) ())
;;; where assert_failed is a primitive

(defun mexpand_assert_msg (sexpr env mexpander)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (assert_msg "check env" (is_a env class_environment))
  (debug_msg sexpr "mexpand_assert_msg sexpr")
  (let (
	(cont (unsafe_get_field :sexp_contents sexpr))
	(loc  (unsafe_get_field :loca_location sexpr))
	(curpair (pair_tail (list_first cont)))
	(xmsg (macroexpand_1 (pair_head curpair)  env mexpander))
	(xtest ())
	(assfail_binding (find_env env 'assert_failed))
	)
    (if (is_not_a assfail_binding class_primitive_binding)
	(progn
	  (error_plain loc "ASSERT_FAILED not bound to a primitive in  (ASSERT_MSG <msg> <test>)")
	  (return)))
    (if (not (is_string xmsg))
	(error_plain loc "non string message in (ASSERT_MSG <msg> <test>)"))
    (setq curpair (pair_tail curpair))
    (if (not (is_pair curpair))
	(error_plain loc "missing test in (ASSERT_MSG <msg> <test>)"))
    (setq xtest (macroexpand_1 (pair_head curpair) env mexpander))
    (if (pair_tail curpair)
	(error_plain loc "extra arg for (ASSERT_MSG <msg> <test>)"))
    (let ( (aprim (make_instance 
		   class_src_primitive
		   :src_loc loc
		   :sprim_oper (unsafe_get_field :pbind_primitive assfail_binding)
		   :sprim_args (make_tuple3 discr_multiple
					   xmsg
					   (mixint_val loc)
					   (make_integerbox discr_integer (get_int loc)))))
	   (atest (make_instance
		   class_src_ifelse
		   :src_loc loc
		   :sif_test xtest
		   :sif_then ()
		   :sif_else aprim))
	   (acppif (make_instance class_src_cppif
				  :src_loc loc
				  :sifp_cond 'ENABLE_CHECKING
				  :sifp_then atest
				  :sifp_else ()
				  )) 
	   )
      (debug_msg acppif "mexpand_assert_msg result acppif")
      (return acppif)
    )))
(install_initial_macro 'assert_msg mexpand_assert_msg)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; debug_msg macro is expanded into other src..
;;;;;; (debug_msg val msg [count]) 
;;; becomes
;;;;;; (cppif ENABLE_CHECKING (debug_msg_fun val msg count filename lineno) ())
;;; where count is (the_callcount) if not given

(defun mexpand_debug_msg (sexpr env mexpander)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr))
  (assert_msg "check env" (is_a env class_environment))
  (debug_msg sexpr "mexpand_debug_msg sexpr")
  (let (
	(cont (unsafe_get_field :sexp_contents sexpr))
	(loc  (unsafe_get_field :loca_location sexpr))
	(curpair (pair_tail (list_first cont)))
	(xval (macroexpand_1 (pair_head curpair)  env mexpander)) 
	(xmsg ())
	(xcount ())
	)
    (setq curpair (pair_tail curpair))
    (if (not (is_pair curpair))
	(error_plain loc "missing message in DEBUG_MSG"))
    (setq xmsg  (macroexpand_1 (pair_head curpair) env mexpander))
    (setq curpair (pair_tail curpair))
    (if (is_pair curpair)
	(progn
	  (setq xcount (macroexpand_1 (pair_head curpair) env mexpander))
	  (setq curpair (pair_tail curpair))))
    (if curpair
	(error_plain loc "too many arguments to DEBUG_MSG"))
    (if (not (is_string xmsg))
	(error_plain loc "message argument should be string in DEBUG_MSG"))
    (if (null xcount)
	(let ( (conlis (make_list discr_list)) )
	  (list_append conlis 'the_callcount)
	  (setq xcount (macroexpand_1 (make_instance class_sexpr 
						     :sexp_contents conlis
						     :loca_location loc)
				      env mexpander))))
    (let ( (dcall (make_instance 
		   class_src_apply
		   :src_loc loc
		   :sapp_fun 'debug_msg_fun
		   :sapp_args (make_tuple5 discr_multiple
					   xval
					   xmsg
					   xcount
					   (mixint_val loc)
					   (make_integerbox discr_integer (get_int loc)))))
	   (dcppif (make_instance class_src_cppif
				  :src_loc loc
				  :sifp_cond 'ENABLE_CHECKING
				  :sifp_then dcall
				  :sifp_else ()
				  )) 
	   )
      (debug_msg dcppif "mexpand_debug_msg result dcppif")
      (return dcppif)
      )))
(install_initial_macro 'debug_msg mexpand_debug_msg)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; add some data to a normalization context and return it
(defun add_nctx_data (nctx ndata)
  (assert_msg "check nctx" (is_a nctx class_normcontext))
  (assert_msg "check ndata" (is_a ndata class_nrep_data))
  (assert_msg "fresh ndata" (null (unsafe_get_field :ndata_rank ndata)))
  (let ( (datlis (unsafe_get_field :nctx_datalist nctx)) )
    (assert_msg "check datlis" (is_list datlis))
    (let ( (lastdat (pair_head (list_last datlis)))  )
      (if (is_a lastdat class_nrep_data)
	  (let ( (:long lastrk (get_int (unsafe_get_field :ndata_rank lastdat))) )
	    (assert_msg "check lastrk" (>i lastrk 0))
	    (let ( (rkbox (make_integerbox discr_integer (+i 1 lastrk))) )
	      (unsafe_put_fields ndata :ndata_rank rkbox)
	      ))
	(let ( (rkbox1 (make_integerbox discr_integer 1)) )
	  (unsafe_put_fields ndata :ndata_rank rkbox1)
	  )))
    (list_append datlis ndata)
    ndata
    ))

;;; keep manually this in sync with enum basilys_globalix_en in basilys.h
(defprimitive global_DISCR_NULLRECV              () :value "(void*)BASILYSG(DISCR_NULLRECV)")
(defprimitive global_DISCR_STRING                () :value "(void*)BASILYSG(DISCR_STRING)")
(defprimitive global_DISCR_INTEGER               () :value "(void*)BASILYSG(DISCR_INTEGER)")
(defprimitive global_DISCR_LIST                  () :value "(void*)BASILYSG(DISCR_LIST)")
(defprimitive global_DISCR_MULTIPLE              () :value "(void*)BASILYSG(DISCR_MULTIPLE)")
(defprimitive global_DISCR_BOX                   () :value "(void*)BASILYSG(DISCR_BOX)")
(defprimitive global_DISCR_MAPOBJECTS            () :value "(void*)BASILYSG(DISCR_MAPOBJECTS)")
(defprimitive global_DISCR_MAPSTRINGS            () :value "(void*)BASILYSG(DISCR_MAPSTRINGS)")
(defprimitive global_DISCR_CHARINTEGER           () :value "(void*)BASILYSG(DISCR_CHARINTEGER)")
(defprimitive global_DISCR_MIXEDINT              () :value "(void*)BASILYSG(DISCR_MIXEDINT)")
(defprimitive global_DISCR_SEQCLASS              () :value "(void*)BASILYSG(DISCR_SEQCLASS)")
(defprimitive global_DISCR_CLOSURE               () :value "(void*)BASILYSG(DISCR_CLOSURE)")
(defprimitive global_DISCR_ROUTINE               () :value "(void*)BASILYSG(DISCR_ROUTINE)")
(defprimitive global_DISCR_PAIR                  () :value "(void*)BASILYSG(DISCR_PAIR)")
(defprimitive global_DISCR_NAMESTRING            () :value "(void*)BASILYSG(DISCR_NAMESTRING)")
(defprimitive global_DISCR_VERBATIMSTRING        () :value "(void*)BASILYSG(DISCR_VERBATIMSTRING)")
(defprimitive global_DISCR_SEQFIELD              () :value "(void*)BASILYSG(DISCR_SEQFIELD)")
(defprimitive global_DISCR_METHODMAP             () :value "(void*)BASILYSG(DISCR_METHODMAP)")
(defprimitive global_CLASS_CLASS                 () :value "(void*)BASILYSG(CLASS_CLASS)")
(defprimitive global_CLASS_ROOT                  () :value "(void*)BASILYSG(CLASS_ROOT)")
(defprimitive global_CLASS_PROPED                () :value "(void*)BASILYSG(CLASS_PROPED)")
(defprimitive global_CLASS_NAMED                 () :value "(void*)BASILYSG(CLASS_NAMED)")
(defprimitive global_CLASS_LOCATED               () :value "(void*)BASILYSG(CLASS_LOCATED)")
(defprimitive global_CLASS_SYMBOL                () :value "(void*)BASILYSG(CLASS_SYMBOL)")
(defprimitive global_CLASS_KEYWORD               () :value "(void*)BASILYSG(CLASS_KEYWORD)")
(defprimitive global_CLASS_SEXPR                 () :value "(void*)BASILYSG(CLASS_SEXPR)")
(defprimitive global_CLASS_FIELD                 () :value "(void*)BASILYSG(CLASS_FIELD)")
(defprimitive global_CLASS_SELECTOR              () :value "(void*)BASILYSG(CLASS_SELECTOR)")
(defprimitive global_CLASS_PRIMITIVE             () :value "(void*)BASILYSG(CLASS_PRIMITIVE)")
(defprimitive global_CLASS_FORMAL_BINDING        () :value "(void*)BASILYSG(CLASS_FORMAL_BINDING)")
(defprimitive global_CLASS_DISCR                 () :value "(void*)BASILYSG(CLASS_DISCR)")
(defprimitive global_CLASS_TOKENIZER             () :value "(void*)BASILYSG(CLASS_TOKENIZER)")
(defprimitive global_CLASS_COMMAND_DISPATCHER    () :value "(void*)BASILYSG(CLASS_COMMAND_DISPATCHER)")
(defprimitive global_ATOM_TRUE                   () :value "(void*)BASILYSG(ATOM_TRUE)")
(defprimitive global_CTYPE_LONG                  () :value "(void*)BASILYSG(CTYPE_LONG)")
(defprimitive global_CTYPE_VALUE                 () :value "(void*)BASILYSG(CTYPE_VALUE)")
(defprimitive global_CTYPE_TREE                  () :value "(void*)BASILYSG(CTYPE_TREE)")
(defprimitive global_CTYPE_VOID                  () :value "(void*)BASILYSG(CTYPE_VOID)")
(defprimitive global_CTYPE_CSTRING               () :value "(void*)BASILYSG(CTYPE_CSTRING)")
(defprimitive global_TOKENIZER                   () :value "(void*)BASILYSG(TOKENIZER)")
(defprimitive global_INITIAL_COMMAND_DISPATCHER  () :value "(void*)BASILYSG(INITIAL_COMMAND_DISPATCHER)")

(defun fill_initial_predefmap (predefmap)
    ;; manually keep in sync  with enum basilys_globalix_en in basilys.h
    (mapobject_put predefmap (global_DISCR_NULLRECV)                 'DISCR_NULLRECV)
    (mapobject_put predefmap (global_DISCR_STRING)                   'DISCR_STRING)
    (mapobject_put predefmap (global_DISCR_INTEGER)                  'DISCR_INTEGER)
    (mapobject_put predefmap (global_DISCR_LIST)                     'DISCR_LIST)
    (mapobject_put predefmap (global_DISCR_MULTIPLE)                 'DISCR_MULTIPLE)
    (mapobject_put predefmap (global_DISCR_BOX)                      'DISCR_BOX)
    (mapobject_put predefmap (global_DISCR_MAPOBJECTS)               'DISCR_MAPOBJECTS)
    (mapobject_put predefmap (global_DISCR_MAPSTRINGS)               'DISCR_MAPSTRINGS)
    (mapobject_put predefmap (global_DISCR_CHARINTEGER)              'DISCR_CHARINTEGER)
    (mapobject_put predefmap (global_DISCR_MIXEDINT)                 'DISCR_MIXEDINT)
    (mapobject_put predefmap (global_DISCR_SEQCLASS)                 'DISCR_SEQCLASS)
    (mapobject_put predefmap (global_DISCR_CLOSURE)                  'DISCR_CLOSURE)
    (mapobject_put predefmap (global_DISCR_ROUTINE)                  'DISCR_ROUTINE)
    (mapobject_put predefmap (global_DISCR_PAIR)                     'DISCR_PAIR)
    (mapobject_put predefmap (global_DISCR_NAMESTRING)               'DISCR_NAMESTRING)
    (mapobject_put predefmap (global_DISCR_VERBATIMSTRING)           'DISCR_VERBATIMSTRING)
    (mapobject_put predefmap (global_DISCR_SEQFIELD)                 'DISCR_SEQFIELD)
    (mapobject_put predefmap (global_DISCR_METHODMAP)                'DISCR_METHODMAP)
    (mapobject_put predefmap (global_CLASS_CLASS)                    'CLASS_CLASS)
    (mapobject_put predefmap (global_CLASS_ROOT)                     'CLASS_ROOT)
    (mapobject_put predefmap (global_CLASS_PROPED)                   'CLASS_PROPED)
    (mapobject_put predefmap (global_CLASS_NAMED)                    'CLASS_NAMED)
    (mapobject_put predefmap (global_CLASS_LOCATED)                  'CLASS_LOCATED)
    (mapobject_put predefmap (global_CLASS_SYMBOL)                   'CLASS_SYMBOL)
    (mapobject_put predefmap (global_CLASS_KEYWORD)                  'CLASS_KEYWORD)
    (mapobject_put predefmap (global_CLASS_SEXPR)                    'CLASS_SEXPR)
    (mapobject_put predefmap (global_CLASS_FIELD)                    'CLASS_FIELD)
    (mapobject_put predefmap (global_CLASS_SELECTOR)                 'CLASS_SELECTOR)
    (mapobject_put predefmap (global_CLASS_PRIMITIVE)                'CLASS_PRIMITIVE)
    (mapobject_put predefmap (global_CLASS_FORMAL_BINDING)           'CLASS_FORMAL_BINDING)
    (mapobject_put predefmap (global_CLASS_DISCR)                    'CLASS_DISCR)
    (mapobject_put predefmap (global_CLASS_TOKENIZER)                'CLASS_TOKENIZER)
    (mapobject_put predefmap (global_CLASS_COMMAND_DISPATCHER)       'CLASS_COMMAND_DISPATCHER)
    (mapobject_put predefmap (global_ATOM_TRUE)                      'ATOM_TRUE)
    (mapobject_put predefmap (global_CTYPE_LONG)                     'CTYPE_LONG)
    (mapobject_put predefmap (global_CTYPE_VALUE)                    'CTYPE_VALUE)
    (mapobject_put predefmap (global_CTYPE_TREE)                     'CTYPE_TREE)
    (mapobject_put predefmap (global_CTYPE_VOID)                     'CTYPE_VOID)
    (mapobject_put predefmap (global_CTYPE_CSTRING)                  'CTYPE_CSTRING)
    (mapobject_put predefmap (global_TOKENIZER)                      'TOKENIZER)
    (mapobject_put predefmap (global_INITIAL_COMMAND_DISPATCHER)     'INITIAL_COMMAND_DISPATCHER)
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; create a normalization context
(defun create_normcontext ()
  (let ( (:long maxpredefix (last_globpredef_index))
	 (:long ix 1)
	 (predefmap (make_mapobject discr_mapobjects (+i 19 (*i 2 maxpredefix))))
	 (valmap (make_mapobject discr_mapobjects 350))
	 )
    (forever predefloop
	     (if (>=i ix maxpredefix) (exit predefloop))
	     (let ( (curpredef (get_globpredef ix)) )
	       (if (is_object curpredef)
		   (mapobject_put predefmap curpredef (make_integerbox discr_integer ix)))
	       )
	     (setq ix (+i ix 1)))
    (fill_initial_predefmap predefmap)
    (let ( (inipro  (make_instance class_nrep_initproc
				   :ninit_topl (make_list discr_list)
				   :nrep_loc ()
				   )) )
      (debug_msg inipro "create_normcontext inipro")
      (make_instance class_normcontext
		     :nctx_initproc inipro
		     :nctx_proclist (make_list discr_list)
		     :nctx_datalist (make_list discr_list)
		     :nctx_symbmap  (make_mapstring discr_mapstrings 50)
		     :nctx_keywmap  (make_mapstring discr_mapstrings 40)
		     :nctx_predefmap predefmap
		     :nctx_valmap valmap
		     :nctx_valbindmap (make_mapobject discr_mapobjects 20)
		     ;; we need a symbcachemap for the toplevel expressions
		     :nctx_symbcachemap (make_mapobject discr_mapobjects 30)
		     :nctx_curproc inipro
		     ))))

;;; the normal_exp selector 
;;;;; expected arguments: 
;;;   recv = the reciever, eg a sexpr
;;;   env = the environment 
;;;   ncx = the normalization context 
;;;   psloc = (parent) source location
;;;;; expected results: normalized + binding list 
;;; IMPORTANT NOTICE: even for simple expressions [like side-effecting
;;; expressions returning void, e.g. RETURN, EXIT, ... other simple
;;; side-effecting expressions like SETQ], the normalized should
;;; always be a simple occurrence, and the work being done in the
;;; bindings list.
(defselector normal_exp class_selector
;  :named_name (stringconst2val discr_namestring "NORMAL_EXP")
)

;; many stuff are already normalized 
(defun normexp_identical (recv env ncx psloc)
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  ;; is a no-op
  (debug_msg recv "normexp_identical recv")
  recv)

(install_method discr_anyrecv normal_exp  normexp_identical)

(defun normexp_null (recv env ncx psloc)
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  (let ( (normnull (make_instance class_nrep_nil :nrep_loc psloc)) )
    (debug_msg normnull "normexp_null normnull")
    normnull
))
(install_method discr_nullrecv normal_exp normexp_null)

;;; catchall for src
(defun normexp_src_catchall (recv env ncx psloc)
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  (debug_msg recv "normexp_src_catchall recv" )
  (let ( (myclass (discrim recv))
	 (myclassname (unsafe_get_field :named_name myclass)) )
    (error_strv (unsafe_get_field :src_loc recv) 
		"unimplemented normalization for " myclassname)
    (assert_msg "normexp_src_catchall unimplemented normexp for src" ())
    ))
(install_method class_src normal_exp normexp_src_catchall)

;; the selector to compute the ctype of a value in an environment
;;; argument: environment
;;;; sometimes this selector is used with a null environment, for
;;;; instance in the code generation phase
(defselector get_ctype class_selector
;  :named_name (stringconst2val discr_namestring "GET_CTYPE")
)
;;; most stuff are really ctype_value
(defun gectyp_anyrecv (recv env) ctype_value)
(install_method discr_anyrecv get_ctype gectyp_anyrecv)

(defun gectyp_root (recv env) ctype_value)
(install_method class_root get_ctype gectyp_root)

;; integers are ctype_long
(defun gectyp_integer (recv env) 
  (debug_msg recv "gectyp_integer recv")
  ctype_long)
(install_method discr_integer get_ctype gectyp_integer)

;; strings are ctype_cstring
(defun gectyp_string (recv env)
  ctype_cstring)
(install_method discr_string get_ctype gectyp_string)

;;; normalize a tuple - returning a tuple & a bindinglist
(defun normalize_tuple (tup env ncx psloc)
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  (assert_msg "check tup" (is_multiple tup))
  (debug_msg tup "normalize_tuple tup" )
  (let ( (bindlist (make_list discr_list)) 
	 (res (multiple_map
	       tup 
	       (lambda (comp :long ix)
		; (debug_msg comp "normalize_tuple comp")
		 (multicall 
		  (norcomp nbinds)
		  (normal_exp comp env ncx psloc)
		 ; (debug_msg norcomp "normalize_tuple norcomp")
		  (assert_msg "check nbinds" (is_list_or_null nbinds))
		  (assert_msg "check norcomp not nrep_expr" (is_not_a norcomp class_nrep_expr))
		  (if (is_list nbinds)
		      (list_every 
		       nbinds
		       (lambda (bnd)
			 (assert_msg "check bnd" (is_a bnd class_any_binding))
			 (assert_msg "check bindlist" (is_list bindlist))
			 (list_append bindlist bnd)
			 ))		
		    )
		  norcomp
		  ))))
	 )
    (if (not (is_pair (list_first bindlist)))
	(setq bindlist ()))
    (debug_msg res "normalize_tuple res")
    (debug_msg bindlist "normalize_tuple bindlist" )
    (return res bindlist)
    ))


;; wrap a normal let around a tuple of normalized expressions and a bindinglist
(defun wrap_normal_letseq (tupnexp bindlist loc)
  (assert_msg "check tupnexp" (is_multiple_or_null tupnexp))
  (assert_msg "check bindlist" (is_list_or_null bindlist))
  (list_every
   bindlist 
   (lambda (cbind) 
     (if (not (is_a cbind class_normlet_binding))
	 (progn
	   (debug_msg tupnexp "wrap_normal_letseq tuplexp")
	   (debug_msg bindlist "wrap_normal_letseq bindlist")
	   (debug_msg cbind "wrap_normal_letseq cbind")))
     (assert_msg "check cbind wrapnormletseq" (is_a cbind class_normlet_binding))))
  (let ( (wnlet
	  (make_instance class_nrep_let
			 :nrep_loc loc
			 :nlet_bindings (list_to_multiple bindlist)
			 :nlet_body tupnexp))
	 )
    (return wnlet)))
    

;; wrap a normal let around a single normalized expression & a bindinglist
(defun wrap_normal_let1 (nexp bindlist loc)
  (assert_msg "check bindlist" (is_list_or_null bindlist))
  (list_every
   bindlist 
   (lambda (cbind) 
     (if (not (is_a cbind class_normlet_binding))
	 (progn
	   (debug_msg nexp "wrap_normal_let1 nexp")
	   (debug_msg bindlist "wrap_normal_let1 bindlist")
	   (debug_msg cbind "wrap_normal_let1 cbind")))
     (assert_msg "check cbind wrapnormlet1" (is_a cbind class_normlet_binding))))
  (if 
      (and (is_list bindlist)
	   (is_pair (list_first bindlist)))
      (let ( (wnlet 
	      (make_instance class_nrep_let
			     :nrep_loc loc
			     :nlet_bindings (list_to_multiple bindlist)
			     :nlet_body (make_tuple1 discr_multiple nexp)))
	     )
	wnlet)
    nexp
))


; for symbols which are imported from a previous environment (this
; only happens when compiling stuff which is not this warm-basilys) we
; should detect them and generate some special data to fetch them, in
; the start routine, from the given environment (which is the only
; argument to the start routine). Detecting such symbols is easy : their
; binding is a class_value_binding

;;;; normalize a symbol occurrence
(defun normexp_symbol (recv env ncx psloc)
  (multicall
   (bind procs)
   (find_enclosing_env env recv)
   (assert_msg "normexp_symbol check recv" (is_a recv class_symbol))
   (if (null bind)
       (progn
	 (error_strv psloc "unbound symbol to normalize"
		     (unsafe_get_field :named_name recv))
	 (return (the_null))))
   (if (null psloc)
       (shortbacktrace_dbg "normex_symbol null psloc" 10)
     )
   (let ( (sycmap (unsafe_get_field :nctx_symbcachemap ncx))
	  (syca (mapobject_get sycmap recv)) )
     (assert_msg "check sycmap" (is_mapobject sycmap))
     (cond 
      ;; check if in the cache
      (syca syca)	     ;already cached
      ;; value binding, get/put it into the map
      ( (is_a bind class_value_binding)
	(let ( (bvar (mapobject_get (unsafe_get_field :nctx_valbindmap ncx) bind)) )
	  (debug_msg bind "normexp_symbol value bind")
	  (if (null bvar)
	      (let ( (newbvar 
		      (make_instance class_nrep_startval
				     :nrep_loc psloc
				     :nstart_var recv)) )
		(mapobject_put (unsafe_get_field :nctx_valbindmap ncx) bind newbvar)
		newbvar)
	      ))
	)
      ;; the procs is a non-empty list, so the symbol is closed
      ( (and (is_list procs)
	     (is_pair (list_first procs)))
	;; check that a closed symbol is always a value
	(let ( (bty
		(cond ( (is_a bind class_formal_binding)
			(unsafe_get_field :fbind_type bind) )
		      ( (is_a bind class_let_binding)
			(unsafe_get_field :letbind_type bind))
		      (:else ()))) 
	       )
	  (if bty 
	      (if (!= bty ctype_value)
		  (error_strv psloc
			      "closed variable has non value type (boxing required)"
			      (unsafe_get_field :named_name recv)
			      )))
	  (setq bty ctype_value
		)
	  (if (is_a bind class_fixed_binding)
	      (let ( (fxocc
		      (make_instance class_nrep_constocc
				     :nrep_loc psloc
				     :nocc_symb recv
				     :nocc_bind bind
				     :nocc_ctyp ctype_value
				     :ncloc_procs procs)) )
		;; cache the result
		(mapobject_put sycmap recv fxocc)
		(debug_msg fxocc "normexp_symbol fxocc")
		;; put the const occurrence if needed in the const list of each proc
		(list_every
		 procs
		 (lambda (pr)
		   (assert_msg "check pr" (is_a pr class_nrep_anyproc))
		   (let ( (clbox (make_box discr_box fxocc))
			  (cnstproc (unsafe_get_field :nrpro_const pr)) )
		     (list_every 
		      cnstproc
		      (lambda (cx) (if (== cx fxocc) (progn (box_put clbox ()) ()))))
		     (let ( (newcl (box_content clbox)) )
		       (if newcl (list_append cnstproc newcl))) 
		     )))
		fxocc
		)
	    (let ( (clocc 
		    (make_instance class_nrep_closedocc
				   :nrep_loc psloc
				   :nocc_symb recv
				   :nocc_ctyp ctype_value
				   :nocc_bind bind
				   :ncloc_procs procs)) 
		   )
	      ;; cache the result
	      (mapobject_put sycmap recv clocc)
	      ;; put the closed occurrence if needed in the closed list of each proc
	      (list_every 
	       procs
	       (lambda (pr)
		 (assert_msg "check pr" (is_a pr class_nrep_anyproc))
		 (let ( (clbox (make_box discr_box clocc))
			(clobindl (unsafe_get_field :nrpro_closedb pr)) )
		   (list_every 
		    clobindl
		    (lambda (clbnd) (if (== clbnd bind) (progn (box_put clbox ()) ()))))
		   (let ( (newcl (box_content clbox)) )
		     (if newcl (list_append clobindl bind))) 
		   )))
	      clocc
	      ) ) ) ) 
      ;; formal arg is a local
      ( (is_a bind class_formal_binding)
	(let ( (syocc
		(make_instance class_nrep_locsymocc
			       :nrep_loc psloc
			       :nocc_ctyp (unsafe_get_field :fbind_type bind) 
			       :nocc_symb recv
			       :nocc_bind bind) ) )
	  ;; cache the result & return it
	  (mapobject_put sycmap recv syocc)
	  syocc
	  ))
      ;; let binding is a local
      ( (is_a bind class_let_binding)
	(let ( (syocc
		(make_instance class_nrep_locsymocc
			       :nrep_loc psloc
			       :nocc_ctyp (unsafe_get_field :letbind_type bind)
			       :nocc_symb recv
			       :nocc_bind bind) ) )
	  ;; cache the result & return it
	  (mapobject_put sycmap recv syocc)
	  syocc
	  ))
      ;; previous function binding at toplevel
      ( (is_a bind class_function_binding)
	(debug_msg bind "normexp_symbol function bind")
	(let ( (fubdat (unsafe_get_field :fubind_fundata bind)) )
	  (if (null fubdat)
	      (error_strv psloc "unresolved forward function reference to"
			  (unsafe_get_field :named_name recv)
			  ))
	  (assert_msg "normexp_symbol check fubdat" (is_a fubdat class_nrep_dataclosure))
	  ;; cache the result & return it
	  (mapobject_put sycmap recv fubdat)
	  fubdat
	  ))
      ;; previous primitive binding at toplevel
      ( (is_a bind class_primitive_binding)
	(let ( (pribidat (unsafe_get_field :pbind_primdata bind)) )
	  (if (null pribidat)
	      (error_strv psloc "unresolved forward primitive reference to"
			  (unsafe_get_field :named_name recv)
			  )
	      )
	  (assert_msg "normexp_symbol check pribdat" (is_a pribidat class_nrep_datainstance))
	  ;; cache the result & return it
	  (mapobject_put sycmap recv pribidat)
	  pribidat))
      ;; previous class binding at toplevel
      ( (is_a bind class_class_binding)
	(let ( (cldat (unsafe_get_field :cbind_cladata bind)) )
	  (if (null cldat)
	      (error_strv psloc "unresolved forward class reference to"
			  (unsafe_get_field :named_name recv)
			  )
	      )
	  (assert_msg "normexp_symbol check cldat" (is_a cldat class_nrep_datainstance))
	  ;; cache the result & return it
	  (mapobject_put sycmap recv cldat)
	  cldat))
      ;; previous field binding at toplevel
      ( (is_a bind class_field_binding)
	(let ( (fdat (unsafe_get_field :flbind_fdata bind)) )
	  (if (null fdat)
	      (error_strv psloc "unresolved forward field reference to"
			  (unsafe_get_field :named_name recv)
			  )
	      )
	  (assert_msg "normexp_symbol check fdat" (is_a fdat class_nrep_datainstance))
	  ;; cache the result & return it
	  (mapobject_put sycmap recv fdat)
	  fdat))
      ;; previous selector binding at toplevel
      ( (is_a bind class_selector_binding)
	(let ( (seldat (unsafe_get_field :sbind_selectordata bind)) )
	  (if (null seldat)
	      (error_strv psloc "unresolved forward selector reference to"
			  (unsafe_get_field :named_name recv)
			  )
	      )
	  (assert_msg "normexp_symbol check seldat" (is_a seldat class_nrep_datainstance))
	  ;; cache the result & return it
	  (mapobject_put sycmap recv seldat)
	  seldat))
      ;; previous instance binding at toplevel
      ( (is_a bind class_instance_binding)
	(let ( (insdat (unsafe_get_field :ibind_data bind)) )
	  (if (null insdat)
	      (error_strv psloc "unresolved forward instance reference to"
			  (unsafe_get_field :named_name recv)
			  )
	      )
	  (assert_msg "normexp_symbol check insdat" (is_a insdat class_nrep_datainstance))
	  ;; cache the result & return it
	  (mapobject_put sycmap recv insdat)
	  insdat)
	)
      ;; all other cases are constants
      (:else 
       (debug_msg bind "normexp_symbol const? bind")
       (let ( (kocc
	       (make_instance class_nrep_constocc
			      :nrep_loc psloc
			      :nocc_ctyp ctype_value
			      :nocc_symb recv
			      :nocc_bind bind) ) )
	 (debug_msg kocc "normexp_symbol kocc" )
	 ;; cache the result & return it
	 (mapobject_put sycmap recv kocc)
	 ;; put the const occurrence if needed in the const list of each proc
	 (list_every
	  procs
	  (lambda (pr)
	    (debug_msg pr "normexp_symbol const pr")
	    (assert_msg "check pr" (is_a pr class_nrep_anyproc))
	    (let ( (clbox (make_box discr_box kocc))
		   (constproc (unsafe_get_field :nrpro_const pr)) )
	      (list_every 
	       constproc
	       (lambda (cl) (if (== cl kocc) (progn (box_put clbox ()) ()))))
	      (let ( (newcl (box_content clbox)) )
		(if newcl (list_append constproc newcl))) 
	      )))
	 kocc
	 ))))))

(install_method class_symbol normal_exp normexp_symbol)

(defun gectyp_symocc (recv env)
  (assert_msg "check recv" (is_a recv class_nrep_symocc))
  (unsafe_get_field :nocc_ctyp recv)
)
(install_method class_nrep_symocc get_ctype gectyp_symocc)


;;; normalize a primitive invocation
(defun normexp_primitive (recv env ncx psloc)
  (debug_msg recv "normexp_primitive recv")
  (assert_msg "check prim recv" (is_a recv class_src_primitive))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  (let ( (sloc (unsafe_get_field :src_loc recv)) 
	 (soper (unsafe_get_field :sprim_oper recv))
	 (sargs (unsafe_get_field :sprim_args recv)) 
	 )
    (assert_msg "check soper" (is_a soper class_primitive))
    (multicall 
     (nargs nbind)
     (normalize_tuple sargs env ncx sloc)
     (let ( (sopnamstr (unsafe_get_field :named_name soper))
	    (sopformals (unsafe_get_field :prim_formals soper))
	    (soptype (unsafe_get_field :prim_type soper))
	    (sopexp (unsafe_get_field :prim_expansion soper)) 
	    (:long nbarg (multiple_length nargs))
	    (:long nbexp (multiple_length sopexp))
	    )
       (if (!=i nbarg (multiple_length sopformals))
	   (progn
	     (error_strv sloc "length mismatch between formals & actuals in primitive" 
			 sopnamstr)
	     (return (the_null)))
	   )
       (let ( (bmap (make_mapobject  discr_mapobjects (+i 2 (/iraw (*i 3 nbarg) 2))))
	      (expargs (make_multiple discr_multiple nbexp))
	      )
	 (multiple_every
	  sopformals
	  (lambda (forb :long ix)
	    (assert_msg "check forb" (is_a forb class_formal_binding))
	    (let ( (forarg (unsafe_get_field :binder forb))
		   (actarg (multiple_nth nargs ix)) )
	      (mapobject_put bmap forarg actarg)
	      )))
;	 (debug_msg bmap "normexp_primitive bmap in sopexp")
	 (multiple_every
	  sopexp
	  (lambda (excu :long jx)
;	    (debug_msg excu "normexp_primitive excu in sopexp")
	    (let ( (exval
		    (if (is_a excu class_symbol)
			(let ( (bval (mapobject_get bmap excu)) )
			  (if (null bval) 
			      (progn 
				(debug_msg recv "normexp_primitive recv unbound symbol in expansion")
				(error_strv sloc "unbound symbol in primitive expansion" 
					    (unsafe_get_field  :named_name excu))))
			  bval)
		      excu)) )
;	    (debug_msg exval "normexp_primitive exval in sopexp")
	    (multiple_put_nth expargs jx exval))
	    ))
	 (let ( (csym (clone_symbol  (unsafe_get_field :sdef_name soper))) 
		(cbind (make_instance class_normlet_binding
				      :letbind_loc sloc
				      :binder csym
				      :letbind_type soptype 
				      :letbind_expr 
				      (make_instance class_nrep_chunk
						     :nrep_loc sloc
						     :nchunk_expansion expargs
						     :nchunk_primitive soper
						     ))) 
		(clocc (make_instance class_nrep_locsymocc
				      :nrep_loc sloc
				      :nocc_ctyp soptype
				      :nocc_symb csym
				      :nocc_bind cbind)) 
		)
	   (if (is_list nbind) 
	       (list_append nbind cbind)
	     (progn
	       (setq nbind (make_list discr_list))
	       (list_append nbind cbind)
	       ))
	   (debug_msg clocc "normexp_primitive result clocc")
	   (return
	    clocc
	    nbind
	    )))))))

(install_method class_src_primitive normal_exp normexp_primitive)
(install_method class_nrep_chunk get_ctype 
		(lambda (recv env)
		  (let ( ( prim (unsafe_get_field :nchunk_primitive recv)) )
		    (assert_msg "check prim" (is_a prim class_primitive))
		    (unsafe_get_field :prim_type prim))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; utility to check that every normalized argument has a passable ctype
(defun check_ctype_nargs (nargs env sloc)
  (multiple_every 
   nargs
   (lambda (cnarg :long ix) 
     (let ( (ctyp (get_ctype cnarg env)) )
       (assert_msg "check_ctype_nargs ctyp" (is_a ctyp class_ctype))
       (if (not (is_string (unsafe_get_field :ctype_parstring ctyp)))
	   (error_strv sloc "argument has invalid type" (unsafe_get_field :named_name ctyp))
     ))
)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; normalize an application
(defun normexp_apply (recv env ncx psloc)
  (assert_msg "check apply recv" (is_a recv class_src_apply))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  (let ( (sloc (unsafe_get_field :src_loc recv)) 
	 (sfun (unsafe_get_field :sapp_fun recv))
	 (sargs (unsafe_get_field :sapp_args recv))
	 (sfusymb (if (is_a sfun class_symbol) sfun '_fun_))
	 )
    (multicall 
     (nfun nbindfun)
     (normal_exp sfun env ncx sloc)
     (assert_msg "check nbindfun" (is_list_or_null nbindfun))
     (multicall
      (nargs nbindargs)
      (normalize_tuple sargs env ncx sloc)
      (assert_msg "check nbindargs" (is_list_or_null nbindargs))
      (check_ctype_nargs nargs env sloc)
      (setq nbindargs (list_append2list nbindargs nbindfun))
      (let ( (csym (clone_symbol sfusymb))
	     (cbind (make_instance class_normlet_binding
				   :letbind_loc sloc
				   :binder csym
				   :letbind_type ctype_value 
				   :letbind_expr 
				   (make_instance class_nrep_apply
						  :nrep_loc sloc
						  :napp_fun nfun
						  :napp_args nargs
						  ))) 
	     (clocc  (make_instance  class_nrep_locsymocc
				     :nrep_loc sloc
				     :nocc_ctyp ctype_value
				     :nocc_symb csym
				     :nocc_bind cbind
				     )) 
	     )
	(if (not (is_list nbindargs))
	    (setq nbindargs (make_list discr_list)))
	(list_append nbindargs cbind)
	(return clocc nbindargs)
	)))))
(install_method class_src_apply normal_exp normexp_apply)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; normalize a message send
(defun normexp_msend (msnd env ncx psloc)
  (assert_msg "check env" (is_a msnd class_src_msend))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  ; (debug_msg ncx "normexp_msend ncx")
  (debug_msg msnd "normexp_msend msnd")
  (let ( (msbind (unsafe_get_field :msend_selbind msnd))
	 (msrecv (unsafe_get_field :msend_recv msnd))
	 (msargs (unsafe_get_field :msend_args msnd))
	 (selnam (unsafe_get_field :binder msbind))
	 (curproc (unsafe_get_field :nctx_curproc ncx))
	 (sloc (unsafe_get_field :src_loc msnd))
	 (nsel (normexp_symbol selnam env ncx sloc))
	 )
    (debug_msg curproc "normexp_msend curproc")
    ;;;; we should add the constant selector into the current routine's constant pool
    (multicall
     (nrecv nbindrecv)
     (normal_exp msrecv env ncx sloc)
     (assert_msg "check nbindrecv" (is_list_or_null nbindrecv))
     ;; check that reciever is a value
     (let ( (ctypr (get_ctype nrecv env)) )
       (assert_msg "normexp_msend check ctypr " (is_a ctypr class_ctype))
       (if (!= ctypr ctype_value)
	   (error_strv sloc "non value reciever for message send of selector"
		       (unsafe_get_field :named_name selnam)))
       )
     (multicall
      (nargs nbindargs)
      (normalize_tuple msargs env ncx sloc)
      (assert_msg "check nbindargs" (is_list_or_null nbindargs))
      (setq nbindrecv (list_append2list nbindrecv nbindargs))
      (check_ctype_nargs nargs env sloc)
      (let (
	    (csym (clone_symbol selnam)) 
	    (nsend (make_instance class_nrep_msend
				  :nrep_loc sloc
				  :nsend_sel nsel
				  :nsend_recv nrecv
				  :nsend_args nargs)) 
	     (cbind (make_instance class_normlet_binding
				   :letbind_loc sloc
				   :binder csym
				   :letbind_type ctype_value 
				   :letbind_expr nsend))
	    (clocc  (make_instance  class_nrep_locsymocc
				    :nrep_loc sloc
				    :nocc_ctyp ctype_value
				    :nocc_symb csym
				    :nocc_bind cbind)) 
	    )
	(unsafe_put_fields clocc :nocc_bind cbind)
	(if (not (is_list nbindrecv))
	    (setq nbindrecv (make_list discr_list)))
	(list_append nbindrecv cbind)
	(debug_msg nbindrecv "normexp_msend final nbindrecv")
	(debug_msg clocc "normexp_msend clocc")
	(return clocc nbindrecv)
	)))))
(install_method class_src_msend normal_exp normexp_msend)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; normalize a return
(defun normexp_return (recv env ncx psloc)
  (debug_msg recv "normexp_return recv")
  (assert_msg "check return recv" (is_a recv class_src_return))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  (let ( (sloc (unsafe_get_field :src_loc recv)) 
	 (srets (unsafe_get_field :sreturn_body recv))
	 (:long nbrets (multiple_length srets))
	 (csym (clone_symbol 'return_)) 
	 ;; while the return effectively go out, it is preferable to give it a value type
	 ;; to avoid make warning on code like (if (p x) (return) (.....))
	 (cbind (make_instance class_normlet_binding
			       :letbind_loc sloc
			       :binder csym
			       :letbind_type ctype_value 
			       ;; :letbind_expr is filled later
			       ))
	 (clocc (make_instance class_nrep_locsymocc
			       :nrep_loc sloc
			       :nocc_ctyp ctype_value
			       :nocc_symb csym
			       :nocc_bind cbind)) 
	 )
    ;; special case for empty return
    (if (<=i nbrets 0)
	(let ( 
	      (nbindemp (make_list discr_list))
	      (nemptret 
	       (make_instance class_nrep_return
			      :nrep_loc sloc
			      :nret_main ()
			      :nret_rest ()
			      ))
	      )
	  (unsafe_put_fields cbind :letbind_expr nemptret)
	  (list_append nbindemp cbind)
	  (debug_msg clocc "normexp_return empty; return clocc")
	  (debug_msg nbindemp "normexp_return empty; return nbindemp")
	  (return clocc nbindemp))
      (multicall
       (nrets nbindrets)
       (normalize_tuple srets env ncx sloc)
       (let ( (nret0 (multiple_nth nrets 0))
	      (toth (make_multiple discr_multiple (-i nbrets 1))) 
	      (ctyp0 (get_ctype nret0 env))
	      )
	 (if (!= ctyp0 ctype_value)
	     (error_plain sloc "main return is not a value"))
	 (if (null nbindrets) 
	     (setq nbindrets (make_list discr_list)))
	 (multiple_every
	  nrets
	  (lambda (ncomp :long ix)
	    (if (>i ix 0)
		(multiple_put_nth toth (-i ix 1) ncomp))))
	 (let ( (nret
		 (make_instance class_nrep_return
				:nrep_loc sloc
				:nret_main nret0
				:nret_rest (if (>i nbrets 0) toth)))
		)
	   (unsafe_put_fields cbind :letbind_expr nret)
	   (list_append nbindrets cbind)
	   (debug_msg clocc "normexp_return result nret")
	   (debug_msg nbindrets "normexp_return result nbindrets")
	   (return clocc nbindrets)
	   ))))))
(install_method class_src_return normal_exp normexp_return)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; normalize an if
(defun normexp_if (recv env ncx psloc)
  (assert_msg "check if recv" (is_a recv class_src_if))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  (debug_msg recv "normexp_if recv")
  (let ( (sloc (unsafe_get_field :src_loc recv))
	 (stest (unsafe_get_field :sif_test recv))
	 (ctypif ctype_void)
	 (sthen (unsafe_get_field :sif_then recv))
	 )
    (multicall 
     (ntest nbindif)	     ;nbindif is also the whole result binding
     (normal_exp stest env ncx sloc)
     (assert_msg "check nbindif test" (is_list_or_null nbindif))
     (debug_msg ntest "normexp_if ntest")
     ;; in practice we don't need to make a common super-
     ;; environment with nbindif since all relevant bindings there are
     ;; generated, with unique cloned symbols, and these bindings 
     ;; are local to the test part
     (multicall 
      (nthen nbindthen)
      (normal_exp sthen env ncx sloc)
      (debug_msg nthen "normexp_if nthen")
      (assert_msg "check nbindthen" (is_list_or_null nbindthen))
      (let ( (newthenenv (fresh_env env)) )
	(list_every 
	 nbindthen
	 (lambda (b) (put_env newthenenv b)))
	;; the ctyp of the whole if is initialized to the ctype of the then part
	(setq ctypif (get_ctype nthen newthenenv))
	;;
	(let ( (csym (clone_symbol '_if_))
	       (clocc  (make_instance  class_nrep_locsymocc
				       :nrep_loc sloc
				       :nocc_ctyp ctypif
				       :nocc_symb csym)) 
	       (wthen (wrap_normal_let1 nthen nbindthen sloc))
	       (cbind (make_instance class_normlet_binding
				     :letbind_loc sloc
				     :binder csym
				     :letbind_type ctypif 
				     :letbind_expr 
				     (make_instance class_nrep_if
						    :nrep_loc sloc
						    :nif_test ntest
						    :nif_then wthen
						    :nif_else (the_null)
						    :nif_ctyp ctypif
						    ))) 
	       )
	  (unsafe_put_fields clocc :nocc_bind cbind)
	  (if (not (is_list nbindif))
	      (setq nbindif (make_list discr_list)))
	  (list_append nbindif cbind)
	  (debug_msg clocc "normexp_if result clocc")
	  (debug_msg nbindif "normexp_if result nbindif")
	  (return clocc nbindif)
	  ))
      ))))
(install_method class_src_if normal_exp normexp_if)
(install_method class_nrep_if get_ctype 
		(lambda (recv env) (unsafe_get_field :nif_ctyp recv)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; normalize an ifelse
(defun normexp_ifelse (recv env ncx psloc)
  (assert_msg "check if recv" (is_a recv class_src_ifelse))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  (debug_msg recv "normexp_ifelse recv")
  (let ( (sloc (unsafe_get_field :src_loc recv))
	 (stest (unsafe_get_field :sif_test recv))
	 (ctypif ctype_void)
	 (sthen (unsafe_get_field :sif_then recv))
	 (selse (unsafe_get_field :sif_else recv))
	 )
    (multicall 
     (ntest nbindif)	     ;nbindif is also the whole result binding
     (normal_exp stest env ncx sloc)
     (debug_msg ntest "normexp_ifelse ntest")
     (assert_msg "check nbindif test" (is_list_or_null nbindif))
     ;; in practice we don't need to make a common super-
     ;; environment with nbindif since all relevant bindings there are
     ;; generated, with unique cloned symbols, and these bindings 
     ;; are local to the test part
     (multicall 
      (nthen nbindthen)
      (normal_exp sthen env ncx sloc)
      (debug_msg nthen "normexp_ifelse nthen")
      (assert_msg "check nbindthen" (is_list_or_null nbindthen))
      (let ( (newthenenv (fresh_env env)) )
	(list_every 
	 nbindthen
	 (lambda (b) (put_env newthenenv b)))
	;; the ctyp of the whole if is initialized to the ctype of the then part
	(setq ctypif (get_ctype nthen newthenenv))
	(multicall 
	 (nelse nbindelse)
	 (normal_exp selse env ncx sloc)
	 (debug_msg nelse "normexp_ifelse nelse")
	 (assert_msg "check nbindelse" (is_list_or_null nbindelse))
	 ;; if we have both then & else branches,
	 ;; ensure their compatibility of types
	 (let ( (newelseenv (let ( (nenv (fresh_env env)) )
			      (list_every 
			       nbindelse
			       (lambda (b) (put_env nenv b)))
			      nenv
			      ))
		(ctypelse (get_ctype nelse newelseenv)) )
	   (assert_msg "check ctypif" (is_a ctypif class_ctype))
	   (assert_msg "check ctypelse" (is_a ctypelse class_ctype))
	   (cond
	    ( (== ctypif ctypelse)
	      ()
	      )
	    ( (and (!= ctypif ctype_void) (== ctypelse ctype_void))
	      () ;; ctypif is correct
	      )
	    ( (and (== ctypif ctype_void) (!= ctypelse ctype_void))
	      (setq ctypif ctypelse)
	      )
	    (:else
	     (warning_plain sloc 
			    "incompatible types in conditional IF/OR/COND branches")
	     (warning_strv sloc "then type in conditional is "
			   (unsafe_get_field :named_name ctypif))
	     (warning_strv sloc "else type in conditional is "
			   (unsafe_get_field :named_name ctypelse))
	     (setq ctypif ctype_void)
	     )
	    ))
	 ;;
	 ;;
	 (let ( (csym (clone_symbol '_ifelse_))
		(clocc  (make_instance  class_nrep_locsymocc
					:nrep_loc sloc
					:nocc_ctyp ctypif
					:nocc_symb csym)) 
		(wthen (wrap_normal_let1 nthen nbindthen sloc))
		(welse (wrap_normal_let1 nelse nbindelse sloc))
		(cbind (make_instance class_normlet_binding
				      :letbind_loc sloc
				      :binder csym
				      :letbind_type ctypif 
				      :letbind_expr 
				      (make_instance class_nrep_if
						     :nrep_loc sloc
						     :nif_test ntest
						     :nif_then wthen
						     :nif_else welse
						     :nif_ctyp ctypif
						     ))) )
	   (unsafe_put_fields clocc :nocc_bind cbind)
	   (if (not (is_list nbindif))
	       (setq nbindif (make_list discr_list)))
	   (list_append nbindif cbind)
	   (debug_msg clocc "normexp_ifelse result clocc")
	   (debug_msg nbindif "normexp_ifelse result nbindif")
	   (return clocc nbindif)
	   )))))))
(install_method class_src_ifelse normal_exp normexp_ifelse)


;;;;;;;;;;;;;;;; normalize a cppif
(defun normexp_cppif (recv env ncx psloc)
  (assert_msg "check cppif recv" (is_a recv class_src_cppif))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  (debug_msg recv "normexp_cppif recv")
  (let ( (sloc (unsafe_get_field :src_loc recv))
	 (scond (unsafe_get_field :sifp_cond recv))
	 (ctypif ctype_void)
	 (sthen (unsafe_get_field :sifp_then recv))
	 (selse (unsafe_get_field :sifp_else recv))
	 )
    ;; normalize the then-part
    (multicall 
     (nthen nbindthen)
     (normal_exp sthen env ncx sloc)
     (debug_msg nthen "normexp_cppif nthen")
     (assert_msg "check nbindthen" (is_list_or_null nbindthen))
     (let ( (newthenenv (fresh_env env)) )
       (list_every 
	nbindthen
	(lambda (b) (put_env newthenenv b)))
       ;; the ctyp of the whole cppif is initialized to the ctype of the then part
       (setq ctypif (get_ctype nthen newthenenv))
       (assert_msg "check ctypif" (is_a ctypif class_ctype))
       ;; normalize the else-part
       (multicall 
	(nelse nbindelse)
	(normal_exp selse env ncx sloc)
	(debug_msg nelse "normexp_cppif nelse")
	(assert_msg "check nbindelse" (is_list_or_null nbindelse))
	(let ( (newelseenv (fresh_env env)) )
	  (list_every 
	   nbindelse
	   (lambda (b) (put_env newelseenv b)))
	  (let ( (ctypelse (get_ctype nelse newelseenv)) )
	    (if (and (!= ctypif ctypelse) (!= ctypif ctype_void) (!= ctypelse ctype_void))
		(progn
		  (error_plain sloc "CPPIF incompatible then & else types")
		  (error_strv sloc "CPPIF incompatible then type :" 
			      (unsafe_get_field :named_name ctypif))
		  (error_strv sloc "CPPIF incompatible else type :" 
			      (unsafe_get_field :named_name ctypelse))))

	    (let ( (csym (clone_symbol 'ifcpp_))
		   (clocc  (make_instance  class_nrep_locsymocc
					   :nrep_loc sloc
					   :nocc_ctyp ctypif
					   :nocc_symb csym)) 
		   (wthen (wrap_normal_let1 nthen nbindthen sloc))
		   (welse (wrap_normal_let1 nelse nbindelse sloc))
		   (cbind (make_instance class_normlet_binding
					 :letbind_loc sloc
					 :binder csym
					 :letbind_type ctypif 
					 :letbind_expr 
					 (make_instance class_nrep_cppif
							:nrep_loc sloc
							:nifp_cond scond
							:nifp_then wthen
							:nifp_else welse
							:nifp_ctyp ctypif
							))) 
		   (nbindres (make_list discr_list))
		   )
	      (unsafe_put_fields clocc :nocc_bind cbind)
	      (list_append nbindres cbind)
	      (debug_msg clocc "normexp_cppif result clocc")
	      (debug_msg nbindres "normexp_cppif result nbindres")
	      (return clocc nbindres)
	      ))))))))
(install_method class_src_cppif normal_exp normexp_cppif)

;;;;;;;;;;;;;;;; normalize an or
    ;; (OR (f1 a1)) is let d1 = (f1 a1) in d1
    ;; (OR (f1 a1) (f2 a2)) is let o1 = (let d1 = (f1 a1) in  (if d1 d1 (let d2 = (f2 a2) in d2))) in o1
(defun normexp_or (recv env ncx psloc)
  (assert_msg "check or recv" (is_a recv class_src_or))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  (debug_msg recv "normexp_or recv")
  (let ( 
	(boxorcount (make_integerbox discr_integer (the_callcount)))
	(sloc (unsafe_get_field :src_loc recv))
	(sdisj (unsafe_get_field :sor_disj recv))
	(:long nbdisj (multiple_length sdisj))
	(:long ix (-i nbdisj 1))
	(norbox (make_box discr_box (the_null)))
	(nbindorbox (make_box discr_box (make_list discr_list)))
	(ctyporbox (make_box discr_box ctype_void))
	(newenv (fresh_env env))
	)
    (multiple_backward_every 
     sdisj
     (lambda (scur :long six)
       (debug_msg scur "normexp scur" (get_int boxorcount))
       (multicall
	(ncur nbind)
	(normal_exp scur env ncx sloc)
	(debug_msg ncur "normexp ncur" (get_int boxorcount))
	(list_every ncur
		    (lambda (bnd) (put_env newenv bnd)))
	(if (null (box_content norbox))
	    (progn
	      (box_put nbindorbox nbind)
	      (box_put norbox ncur) 
	      (box_put ctyporbox (get_ctype ncur newenv))
	      (the_null)
	      )
	  (let ( (ctypcur (get_ctype ncur newenv))
		 )
	    (assert_msg "check ctypcur" (is_a ctypcur class_ctype))
	    (if (!= ctypcur (box_content ctyporbox))
		(error_plain  sloc "disjuncts' type mismatch in OR | COND"))
	    (let (
		  ;; ncur is normal, so simple
		  (nifor (make_instance
			  class_nrep_if
			  :nrep_loc sloc
			  :nif_test ncur
			  :nif_then ncur
			  :nif_else (wrap_normal_let1 (box_content norbox) (box_content nbindorbox) sloc)
			  :nif_ctyp ctypcur
			  )
			 )
		  (csymor (clone_symbol 'or_))
		  (corbind (make_instance 
			    class_normlet_binding
			    :binder csymor
			    :letbind_loc sloc
			    :letbind_type ctypcur
			    :letbind_expr nifor))
		  (corocc (make_instance
			   class_nrep_locsymocc
			   :nrep_loc sloc
			   :nocc_ctyp ctypcur
			   :nocc_symb csymor
			   :nocc_bind corbind))
		  )
	      (box_put nbindorbox (make_list discr_list))
	      (list_append2list (box_content nbindorbox) nbind)
	      (list_append (box_content nbindorbox) corbind)
	      (box_put norbox corocc)
	      (the_null)
	      )
	    )
	  )
	)
       )
     )
    (debug_msg (box_content norbox) "normexp_or result nor")
    (debug_msg (box_content nbindorbox) "normexp_or result nbindor")
    (return (box_content norbox) (box_content nbindorbox))
    )
  )
(install_method class_src_or normal_exp normexp_or)

;;;;;; normalize a PROGN
;;;; (PROGN a1 a2 ... an) is based upon the normalization of (LET () a1 a2 ... an)
(defun normexp_progn (recv env ncx psloc)
  (assert_msg "check progn recv" (is_a recv class_src_progn))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  (debug_msg recv "normexp_progn recv")
  (let ( (sloc (unsafe_get_field :src_loc recv))
	 (sbody (unsafe_get_field :sprogn_body recv))
	 (:long lnbody (multiple_length sbody)) 
	 (boxlnbody (make_integerbox discr_integer lnbody))
	 )
    (if (<=i lnbody 0)
	(let ( (onull (make_instance class_nrep_nil :nrep_loc sloc)) )
	  (error_plain sloc "empty PROGN")
	  (debug_msg onull "normexp_progn return empty onull")
	  (return onull)))
    (multicall
     (nbody nbind)
     (normalize_tuple sbody env ncx sloc)
     (debug_msg nbody "normexp_progn nbody")
     (debug_msg nbind "normexp_progn nbind")
     (let ( (nlast (multiple_nth nbody -1)) 
	    (:long lenbody (multiple_length nbody))
	    (nallbutlast (if (>i lenbody 0) (make_multiple discr_multiple (-i lenbody 1))))
	    )
       ;; fill nallbutlast 
       (let ( (:long ix (-i lenbody 1)) )
	 (forever bodyloop
		  (if (<i ix 0) (exit bodyloop))
		  (multiple_put_nth nallbutlast ix (multiple_nth nbody ix))
		  (setq ix (-i ix 1))))
       (debug_msg nallbutlast "normexp_progn nallbutlast")
       (if (null nbind) (setq nbind (make_list discr_list)))
       (let (
	     (csym (clone_symbol 'progn_))
	     (lastctyp (get_ctype nlast env))
	     (cbind (make_instance class_normlet_binding
				   :binder csym
				   :letbind_loc sloc
				   :letbind_type lastctyp
				   :letbind_expr (make_instance class_nrep_progn
								:nrep_loc sloc
								:nprogn_seq nallbutlast
								:nprogn_last nlast)))
	     (clocc (make_instance class_nrep_locsymocc
				   :nrep_loc sloc
				   :nocc_ctyp lastctyp
				   :nocc_symb csym
				   :nocc_bind cbind))
	     )
	 (list_append nbind cbind)
	 (debug_msg clocc "normexp_progn return clocc")
	 (debug_msg nbind "normexp_progn return nbind")
	 (return clocc nbind)
	 )))))
(install_method class_src_progn normal_exp normexp_progn)
(install_method class_nrep_progn get_ctype 
		(lambda (recv env) (get_ctype (unsafe_get_field :nprogn_last recv) env)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
;;;;;; normalize a LET
(defun normexp_let (recv  env ncx psloc)
  (assert_msg "check let recv" (is_a recv class_src_let))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  (debug_msg recv "normexp_let recv")
  (let ( (sloc (unsafe_get_field :src_loc recv))
	 (sbindings (unsafe_get_field :slet_bindings recv))
	 (sbody (unsafe_get_field :slet_body recv)) 
	 (newenv (fresh_env env))
	 (bindlist (make_list discr_list))
	 )
    (multiple_every 
     sbindings
     (lambda (sb :long sbix)
       (assert_msg "check sb" (is_a sb class_src_letbinding))
       (let ( (sbloc (unsafe_get_field :src_loc sb))
	      (sbtyp (unsafe_get_field :sletb_type sb))
	      (sbinder (unsafe_get_field :sletb_binder sb))
	      (sbexpr (unsafe_get_field :sletb_expr sb)) 
	      )
	 (multicall
	  (nbdexpr nbindings)
	  (normal_exp sbexpr newenv ncx sbloc)
	  (let ( (lastnbinding (pair_head (list_last nbindings))) )
	    ;; common case of a normalized apply or primitive, hence a
	    ;; gensymed variable which is the last in the nbindings
	    (if (and
		 (is_a lastnbinding class_normlet_binding)
		 (is_a nbdexpr class_nrep_locsymocc)
		 (== (unsafe_get_field :binder lastnbinding) 
		     (unsafe_get_field :nocc_symb nbdexpr))
		 )
		(let ( (lastnormexp (unsafe_get_field :letbind_expr nbdexpr)) )
		  (list_every
		   nbindings
		   (lambda (b)
		     (if (!= b lastnbinding)
			 (list_append bindlist b))))
		  (let ( (newcbnd
			  (make_instance class_normlet_binding
					 :binder sbinder
					 :letbind_type (unsafe_get_field :letbind_type lastnbinding)
					 :letbind_expr (unsafe_get_field :letbind_expr lastnbinding)
					 :letbind_loc (unsafe_get_field :letbind_loc lastnbinding)))
			 )
		    (list_append bindlist newcbnd)
		    (put_env newenv newcbnd)
		    )
		  )
	      (progn
;;; otherwise, eg a plain constant, a complex if...
		(list_append2list bindlist  nbindings)
		(let ( (newpbnd 
			(make_instance class_normlet_binding
				       :binder sbinder
				       :letbind_type sbtyp
				       :letbind_expr nbdexpr
				       :letbind_loc sbloc)) )
		  (list_append bindlist newpbnd)
		  (put_env newenv newpbnd)
		  ))
	      ))))
       ))
;;; end of loop on source bindings
    (multicall
     (nbody nbodbindings)
     (normalize_tuple sbody newenv ncx sloc)
     (list_append2list bindlist  nbodbindings)
     (assert_msg "normexp_let check bindlist" (is_list_or_null bindlist))
     (list_every
      bindlist
      (lambda (cbnd) 
	(assert_msg "normexp_let check cbnd" (is_a cbnd class_normlet_binding))))
;;; remove every locallly bound symbol from the symbol cache map
     (let ( (sycmap (unsafe_get_field :nctx_symbcachemap ncx)) )
       (list_every bindlist 
		   (lambda (bnd)
		     (mapobject_remove sycmap (unsafe_get_field :binder bnd))
		     )))
;;;; make the result
     (let (
	   (nlastbody (multiple_nth nbody -1))
	   ;; the type of a let with empty body is void
	   (nlastyp (or (get_ctype nlastbody newenv) ctype_void))
	   (csym (clone_symbol 'let_))
	   (nlet
	    (make_instance class_nrep_let
			   :nrep_loc sloc
			   :nlet_bindings (list_to_multiple bindlist discr_multiple)
			   :nlet_body nbody))
	   (cbind (make_instance class_normlet_binding
				 :binder csym
				 :letbind_loc sloc
				 :letbind_type nlastyp
				 :letbind_expr nlet))
	   (clocc (make_instance class_nrep_locsymocc
				 :nrep_loc sloc
				 :nocc_ctyp nlastyp
				 :nocc_bind cbind))
	   (resbinds (make_list discr_list))
	   )
       (list_append resbinds cbind)
       (debug_msg clocc "normexp_let result clocc")
       (debug_msg resbinds "normexp_let result resbinds")
       (return clocc resbinds)
       )
     )))
(install_method class_src_let normal_exp normexp_let)
(install_method class_nrep_let get_ctype 
		(lambda (recv env)
		  (let ( (lbod (unsafe_get_field :nlet_body recv))
			 (:long lenb (multiple_length lbod)) )
		    (if (<=i lenb 0) ctype_void
		      (get_ctype (multiple_nth lbod (-i lenb 1)) env)))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; normalize an UNSAFE_GET_FIELD
(defun normexp_unsafe_get_field (recv env ncx psloc)
  (assert_msg "check unsafegetfield recv" (is_a recv class_src_unsafe_get_field))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  (debug_msg recv "normexp unsafeget recv")
  (let ( (sloc   (unsafe_get_field :src_loc recv))
	 (sobj   (unsafe_get_field :suget_obj recv))
	 (sfld   (unsafe_get_field :suget_field recv)) 
	 ) 
    (assert_msg "check sfld" (is_a sfld class_field))
    (multicall
     (nobj nbind)
     (normal_exp sobj env ncx sloc)
     (if (null nbind) (setq nbind (make_list discr_list)))
     (let ( (csym (clone_symbol (unsafe_get_field :named_name sfld)))
	    (cbind (make_instance class_normlet_binding
				  :binder csym
				  :letbind_loc sloc
				  :letbind_type ctype_value
				  :letbind_expr 
				  (make_instance class_nrep_unsafe_get_field
						 :nrep_loc sloc
						 :nuget_obj nobj
						 :nuget_field sfld)))
	    (clocc (make_instance  class_nrep_locsymocc
				   :nrep_loc sloc
				   :nocc_ctyp ctype_value
				   :nocc_symb csym
				   :nocc_bind cbind))
	    )
       (list_append nbind cbind)
       (debug_msg clocc "normexp unsafeget result clocc")
       (debug_msg nbind "normexp unsafeget result nbind")
       (return 	clocc nbind
		)))))
(install_method class_src_unsafe_get_field normal_exp normexp_unsafe_get_field)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; normalize an UNSAFE_PUT_FIELDS
(defun normexp_unsafe_put_fields (recv env ncx psloc)
  (assert_msg "check unsafeputfields recv" (is_a recv class_src_unsafe_put_fields))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  (debug_msg recv "normexp_unsafe_put_fields recv")
  (let ( (sloc   (unsafe_get_field :src_loc recv))
	 (sobj   (unsafe_get_field :suput_obj recv))
	 (sfields (unsafe_get_field :suput_fields recv))
	 (:long nbfields (multiple_length sfields))
	 (nfields (make_multiple discr_multiple nbfields))
	 (nbindlist (make_list discr_list)) 
	 (csym (clone_symbol 'unsafput_))
	 (cbind (make_instance class_normlet_binding
			       :binder csym
			       :letbind_loc sloc
			       :letbind_type ctype_void
			       ;; letbind_expr filled later
			       :letbind_expr ()))
	 (clocc (make_instance  class_nrep_locsymocc
				:nrep_loc sloc
				:nocc_ctyp ctype_void
				:nocc_symb csym
				:nocc_bind cbind))
	 )
    (multicall
     (nobj nobjbind)
     (normal_exp sobj env ncx sloc)
     (list_append2list nbindlist  nobjbind)
     (multiple_every 
      sfields
      (lambda (fla :long ix) 
	(assert_msg "check fla" (is_a fla class_src_fieldassign))
	(let ( (fld (unsafe_get_field :sfla_field fla))
	       (exp (unsafe_get_field :sfla_expr fla)) )
	  (assert_msg "check fld" (is_a fld class_field))
	  (multicall
	   (nexp nexpbind)
	   (normal_exp exp env ncx sloc)
	   (list_append2list nbindlist  nexpbind)
	   (let ( (nfla (make_instance class_nrep_fieldassign
				       :nrep_loc sloc
				       :nfla_field fld
				       :nfla_val nexp)) )
	     (multiple_put_nth nfields ix nfla)
	     )))))
     (let ( (npuf (make_instance class_nrep_unsafe_put_fields
				 :nrep_loc sloc
				 :nuput_obj nobj
				 :nuput_fields nfields)) )
       (unsafe_put_fields cbind :letbind_expr npuf)
       (list_append nbindlist cbind)
       (debug_msg clocc "normexp_unsafe_put_fields result clocc")
       (debug_msg nbindlist "normexp_unsafe_put_fields result nbindlist")
       (return clocc nbindlist)
       ))))
(install_method class_src_unsafe_put_fields normal_exp normexp_unsafe_put_fields)
(install_method class_nrep_unsafe_put_fields get_ctype (lambda (recv env) ctype_void))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; normalize a setq
(defun normexp_setq (recv env ncx psloc)
  (assert_msg "check setq recv" (is_a recv class_src_setq))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  (debug_msg recv "normexp setq recv")
  (let ( (sloc   (unsafe_get_field :src_loc recv))
	 (svar   (unsafe_get_field :sstq_var recv))
	 (sexp   (unsafe_get_field :sstq_expr recv)) ) 
    (assert_msg "check svar" (is_a svar class_symbol))
    (let ( (nvar (normexp_symbol svar env ncx sloc)) 
	   (varctyp (get_ctype nvar env))
	   )
      (multicall
       (nexp nbind)
       (normal_exp sexp env ncx sloc)
       (if (null nbind) (setq nbind (make_list discr_list)))
       (if (!= varctyp (get_ctype nexp env))
	   (error_strv sloc "incompatible type for SETQ"
		       (unsafe_get_field :named_name svar)))
       (let ( (csym (clone_symbol 'setq_)) 
	      (cbind  (make_instance class_normlet_binding
				     :binder csym
				     :letbind_loc sloc
				     :letbind_type varctyp
				     :letbind_expr
				     (make_instance class_nrep_setq
						    :nrep_loc sloc
						    :nstq_var nvar
						    :nstq_exp nexp)))
	      (clocc (make_instance class_nrep_locsymocc
				    :nrep_loc sloc
				    :nocc_ctyp varctyp
				    :nocc_symb csym
				    :nocc_bind cbind))
	      )
	 (list_append nbind cbind)
	 (return clocc nbind)
	 )))))
(install_method class_src_setq normal_exp normexp_setq)
(install_method class_nrep_setq get_ctype 
		(lambda (recv env)
		  (get_ctype (unsafe_get_field :nstq_var recv) env)))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; normalize a make_instance
(defun normexp_make_instance (recv env ncx psloc)
  (assert_msg "check make_instance recv" (is_a recv class_src_make_instance))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  (debug_msg recv "normexp_make_instance recv" )
  (let ( (sloc (unsafe_get_field :src_loc recv))
	 (sclass (unsafe_get_field :smins_class recv))
	 (sclabind (unsafe_get_field :smins_clabind recv))
	 (sfields (unsafe_get_field :smins_fields recv))
	 (sclasym (if (is_a sclabind class_any_binding) (unsafe_get_field :binder sclabind)))
	 (cladata (if (is_a sclasym class_symbol) 
		      (normal_exp sclasym env ncx sloc)))
	 (bindlist (make_list discr_list))
	 )
    (if (not (is_a cladata class_nrep))
	(progn
	  (error_strv sloc "invalid class in make_instance" (unsafe_get_field :named_name sclass))
	  (return (the_null))))
    (let ( (nfields 
	    (multiple_map 
	     sfields 
	     (lambda (curflda :long curk)
	       (assert_msg "check curflda" (is_a curflda class_src_fieldassign))
	       (let ( (curfloc (unsafe_get_field :src_loc curflda))
		      (curfield (unsafe_get_field :sfla_field curflda))
		      (curexp (unsafe_get_field :sfla_expr curflda)) )
		 (if (null curfloc) (setq curfloc sloc))
		 (multicall
		  (nexp nbind)
		  (normal_exp curexp env ncx curfloc)
		  (assert_msg "check nbind" (is_list_or_null nbind))
		  (list_append2list bindlist  nbind)
		  (make_instance class_nrep_fieldassign
				 :nrep_loc curfloc
				 :nfla_field curfield
				 :nfla_val nexp)
		  )))))
	   (nmkins 
	    (make_instance class_nrep_make_instance
			   :nrep_loc sloc
			   :nmins_class sclass
			   :nmins_cladata cladata
			   :nmins_fields nfields))
	   (csym (clone_symbol 'inst_))
	   (cbind (make_instance class_normlet_binding
				 :binder csym
				 :letbind_loc sloc
				 :letbind_type ctype_value
				 :letbind_expr nmkins))
	   (clocc (make_instance class_nrep_locsymocc
				 :nrep_loc sloc
				 :nocc_ctyp ctype_value
				 :nocc_symb csym
				 :nocc_bind cbind))
	   )
      (list_append bindlist cbind)
      (debug_msg clocc "normexp_make_instance result clocc")
      (debug_msg bindlist "normexp_make_instance result bindlist")
      (return clocc bindlist)
      )
    )
  )
(install_method class_src_make_instance normal_exp normexp_make_instance)
(install_method class_src_make_instance get_ctype 
		(lambda (recv env) ctype_value))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; normalize a forever

(defun normexp_forever (recv env ncx psloc)
  (assert_msg "check forever recv" (is_a recv class_src_forever))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  (debug_msg recv "normexp_forever recv" )
  (let ( (sloc   (unsafe_get_field :src_loc recv))
	 (slbind (unsafe_get_field :slabel_bind recv))
	 (sbody (unsafe_get_field :sfrv_body recv))
	 (newenv (fresh_env env))
	 )
    (assert_msg "check slbind" (is_a slbind class_label_binding))
    (put_env newenv slbind)
    (let ( (resy (clone_symbol (unsafe_get_field :binder slbind))) )
      (debug_msg resy "normexp_forever putting resy..")
      (debug_msg slbind "..normexp_forever in slbind")
      (assert_msg "check resy obj1" (is_object resy))
      (unsafe_put_fields slbind :labind_clonsy resy)
      (debug_msg slbind "normexp_forever updated slbind")
      (debug_msg resy "normexp_forever clonsy put resy")
      (assert_msg "check resy" (is_a resy class_clonedsymbol))
      (debug_msg (unsafe_get_field :labind_clonsy slbind) "normexp_forever got1 clonsy")
      (assert_msg "check did1 put resy" (== (unsafe_get_field :labind_clonsy slbind) resy))
      (assert_msg "check resy obj2" (is_object resy))
      (multicall
       (nbody nbodbindings)
       (normalize_tuple sbody newenv ncx sloc)
       (debug_msg slbind "normexp_forever again slbind")
       (assert_msg "check did2 put resy" (== (unsafe_get_field :labind_clonsy slbind) resy))
       (debug_msg (unsafe_get_field :labind_clonsy slbind) "normexp_forever got2 clonsy")
       (assert_msg "check size slbind" (<i (get_int labind_clonsy) (object_length slbind)))
       (let (
	     (resbody (make_tuple1 discr_multiple 
				   (wrap_normal_letseq nbody nbodbindings sloc)))
	     (csym (clone_symbol 'forever_))
	     (nforever (make_instance class_nrep_forever
				      :nrep_loc sloc
				      :nforever_bind slbind
				      :nforever_body resbody
				      :nforever_result resy)) 
	     (cbind (make_instance class_normlet_binding
				   :binder csym
				   :letbind_loc sloc
				   :letbind_type ctype_value
				   :letbind_expr nforever))
	     (clocc (make_instance class_nrep_locsymocc
				   :nrep_loc sloc
				   :nocc_ctyp ctype_value
				   :nocc_symb csym
				   :nocc_bind cbind))
	     (nforbindings (make_list discr_list))
	     )
	 (list_append nforbindings cbind)
	 (debug_msg clocc "normexp_forever return nforever")
	 (debug_msg clocc "normexp_forever return nforever")
	 (return clocc nforbindings)
	 )
       ))))
(install_method class_src_forever normal_exp normexp_forever)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; normalize an exit
;;; the normalization of an exit is a local variable of ctype_void
;;; this enables detection of applications like (foo (exit 2))
(defun normexp_exit (recv env ncx psloc)
  (assert_msg "check exit recv" (is_a recv class_src_exit))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  (debug_msg recv "normexp_exit recv")
  (let ( (sloc   (unsafe_get_field :src_loc recv))
	 (slbind (unsafe_get_field :slabel_bind recv))
	 (sbody (unsafe_get_field :sexi_body recv))
	 (newenv (fresh_env env))
	 )
    (assert_msg "check slbind" (is_a slbind class_label_binding))
    (put_env newenv slbind)
    (multicall
     (nbody nbodbindings)
     (normalize_tuple sbody newenv ncx sloc)
     (if (null nbodbindings)
	 (setq nbodbindings (make_list discr_list)))
     ;; the only interesting value of nbody is the last one
     (let ( (nexit (make_instance class_nrep_exit
				  :nrep_loc sloc
				  :nexit_bind slbind
				  :nexit_val (multiple_nth nbody (-i (multiple_length nbody) 1)))) 
	    (csym (clone_symbol 'exit_))
	    (cbind (make_instance class_normlet_binding
				  :binder csym
				  :letbind_loc sloc
				  :letbind_type ctype_void
				  :letbind_expr nexit))
	    (clocc (make_instance class_nrep_locsymocc
				  :nrep_loc sloc
				  :nocc_ctyp ctype_void
				  :nocc_symb csym
				  :nocc_bind cbind))
	    )
       (list_append nbodbindings cbind)
       (debug_msg nexit "normexp_exit nexit")
       (debug_msg nbodbindings "normexp_exit nbodbindings")
       (return clocc nbodbindings)
       ))))
(install_method class_src_exit normal_exp normexp_exit)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; replace in a tupe of normalized stuff the last with a return 
;;;;;; for normalization of defun-s or lambda-s
(defun replace_last_by_return (tup env sloc)
  (assert_msg "check tup" (is_multiple tup))
  (assert_msg "check env" (is_a env class_environment))
  (let ( (:long tuplen (multiple_length tup)) 
	 (lastcomp (if (>i tuplen 0) (multiple_nth tup (-i tuplen 1)))) )
    (cond 
;;; last expression is already a return - do nothing
     ( (is_a lastcomp class_nrep_return)
       (return tup)
       )
;;; last expression is a symbol occurrence (closed or local) - return it if it is a value 
     ( (is_a lastcomp class_nrep_symocc)
       (if (== (unsafe_get_field :nocc_ctyp lastcomp) ctype_value)
	   (multiple_put_nth 
	    tup  (-i tuplen 1)
	    (make_instance class_nrep_return
			   :nrep_loc sloc
			   :nret_main lastcomp)))
       (return tup)
       )
;;; last expression is a normal data, return it
     ( (is_a lastcomp class_nrep_data)
       (multiple_put_nth 
	tup  (-i tuplen 1)
	(make_instance class_nrep_return
		       :nrep_loc sloc
		       :nret_main lastcomp))
       (return tup)
       )
;;; no last expression - don't bother to return
     ( (null lastcomp)
       (return tup)
       )
;;; last expression is a normalized let, recurse on the body within a new env
     ( (is_a lastcomp class_nrep_let)
       (let ( (lbody (unsafe_get_field :nlet_body lastcomp)) 
	      (lbinding (unsafe_get_field :nlet_bindings lastcomp))
	      (lloc (unsafe_get_field :nrep_loc lastcomp))
	      (newenv (fresh_env env))
	      )
	 (multiple_every
	  lbinding
	  (lambda (bnd :long ix)
	    (put_env newenv bnd)
	    ))
	 (if (is_multiple lbody) 
	     (replace_last_by_return lbody newenv lloc))
	 (return tup)
	 ))
;;; last expression is some more complex normalized stuff
;;; if it is a value wrap it into a normalized let with return 
     ( (is_a lastcomp class_nrep)
       (let ( (lastyp (get_ctype lastcomp env)) 
	      (loc (unsafe_get_field :nrep_loc lastcomp))
	      )
	 (if (== lastyp ctype_value)
	     (let ( (rclosym (clone_symbol '_retval_))
		    (rclocc (make_instance class_nrep_locsymocc 
					   :nrep_loc loc
					   :nocc_symb rclosym
					   :nocc_ctyp ctype_value))
		    (retn (make_instance class_nrep_return
					 :nrep_loc loc
					 :nret_main rclocc
					 ))
		    (rbind (make_instance class_normlet_binding
					  :binder rclosym
					  :letbind_type ctype_value
					  :letbind_expr lastcomp
					  :letbind_loc loc
					  ))
		    (rbintup (make_tuple1 discr_multiple rbind))
		    (rlet (make_instance class_nrep_let
					 :nrep_loc loc
					 :nlet_bindings rbintup
					 :nlet_body (make_tuple1 discr_multiple retn)))
		    )
	       (unsafe_put_fields rclocc :nocc_bind rbind)
	       (multiple_put_nth 
		tup  (-i tuplen 1)
		rlet)
	       (return tup)
	       )))))
    (return tup)			; returns the original tuple
;;; general case, do nothing 
    )
  )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; normalize a DEFUN
(defun normexp_defun (recv  env ncx psloc)
  (assert_msg "check defun recv" (is_a recv class_src_defun))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  (debug_msg recv "normexp_defun recv")
  (let ( (sloc (unsafe_get_field :src_loc recv))
	 (snam (unsafe_get_field :sdef_name recv))
	 (sformals (unsafe_get_field :sformal_args recv))
	 (sbody (unsafe_get_field :sfun_body recv))
	 (sfubind (find_env env snam))
	 (newenv (fresh_env env))
	 (oldproc (unsafe_get_field :nctx_curproc ncx))
	 (oldsymbcache (unsafe_get_field :nctx_symbcachemap ncx))
	 (closblis (make_list discr_list))
	 (nproc (make_instance class_nrep_routproc
;;; dont forget to put the nil fields at end
			       :nrep_loc sloc
			       :nproc_body (the_null) ;filled later
			       :nrpro_name snam
			       :nrpro_argb sformals
			       :nrpro_closedb closblis
			       :nrpro_const (make_list discr_list)
			       :nrpro_thunklist (make_list discr_list)
			       :nrpro_datarout (the_null) ; filled below
			       :nrpro_dataclos (the_null) ; filled below
			       ))
	 (ndatarout (make_instance class_nrep_dataroutine
				   :ndata_name snam
				   :ndata_discrx (normal_predef discr_routine ncx sloc "discr_routine")
				   :ndrou_proc nproc
				   ))
	 (ndataclos (make_instance class_nrep_dataclosure
				   :ndata_name snam
				   :ndata_discrx  (normal_predef discr_closure ncx sloc "discr_closure")
				   :ndclo_proc nproc
				   :ndclo_closv (the_null) ;filled below
				   ))
	 )
    (unsafe_put_fields ncx 
		       :nctx_curproc nproc
		       :nctx_symbcachemap (make_mapobject discr_mapobjects 40))
    (add_nctx_data ncx ndatarout)
    (add_nctx_data ncx ndataclos)
    (assert_msg "check sfubind" (is_a sfubind class_function_binding))
    (unsafe_put_fields nproc :nrpro_datarout ndatarout :nrpro_dataclos ndataclos)
    (multiple_every 
     sformals
     (lambda (fbi :long ix)
       (assert_msg "check fbi" (is_a fbi class_formal_binding))
       (put_env newenv fbi)))
    (unsafe_put_fields newenv :env_proc nproc)
    ;; add nproc into ncx
    (list_append (unsafe_get_field :nctx_proclist ncx) nproc)
    (multicall
     (nbody nbindings)
     (normalize_tuple sbody newenv ncx sloc)
     (debug_msg nbody "normexp_defun nbody before replace_last_by_return")
     (multiple_every
      nbindings
      (lambda (nbi :long ix)
	(put_env newenv nbi)))
     (let ( (nrbody (replace_last_by_return nbody newenv sloc)) 
	    (npbody (wrap_normal_letseq nrbody nbindings sloc))
	    )
       (unsafe_put_fields nproc  :nproc_body npbody)
       (debug_msg npbody "normexp_defun npbody after replace_last_by_return")
       )
     (unsafe_put_fields ncx :nctx_curproc oldproc :nctx_symbcachemap oldsymbcache)
     (let ( (clovtup 
	     (list_to_multiple 
	      closblis
	      discr_multiple
	      (lambda (bnd)
		(assert_msg "normexp_defun check bnd" (is_a bnd class_any_binding))
		(let ( (sy (unsafe_get_field :binder bnd)) 
		       ;; since sy is a symbol, its normalized form does not add any binding
		       ;; we normalize it in the *old* environment, not the new one
		       (nsy (normal_exp sy env ncx sloc))
		       )
		  nsy
		  )))) )
       (unsafe_put_fields ndataclos :ndclo_closv clovtup)
       )
     (unsafe_put_fields sfubind :fubind_fundata ndataclos)
     (debug_msg nproc "normexp_defun return nproc")
     (return nproc ())
     )
    ))
(install_method class_src_defun normal_exp normexp_defun)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; normalize a LAMBDA
(defun normexp_lambda (recv env ncx psloc)
  (assert_msg "check lambda recv" (is_a recv class_src_lambda))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  (debug_msg recv "normexp_lambda recv")
  (let ( (sloc (unsafe_get_field :src_loc recv))
	 (sargs (unsafe_get_field :slam_argbind recv))
	 (sbody (unsafe_get_field :slam_body recv))
	 (savedcachemap (unsafe_get_field :nctx_symbcachemap ncx))
	 (csym (clone_symbol 'lambda_))
	 (clocc (make_instance class_nrep_locsymocc
			       :nrep_loc sloc
			       :nocc_ctyp ctype_value
			       :nocc_symb csym)) 
	 (newenv (fresh_env env))
	 (oldproc (unsafe_get_field :nctx_curproc ncx))
	 (closedblist (make_list discr_list))
	 (nproc (make_instance class_nrep_routproc
			       :nrep_loc sloc
			       :nproc_body (the_null) ;filled later
			       :nrpro_name csym
			       :nrpro_argb sargs
			       :nrpro_closedb closedblist
			       :nrpro_const (make_list discr_list)
			       :nrpro_datarout (the_null) ; filled below
			       :nrpro_dataclos (the_null) ; not filled
			       :nrpro_thunklist (make_list discr_list)
			       ))
	 (ndatarout (make_instance class_nrep_dataroutine
				   :ndata_name csym
				   :ndata_discrx (normal_predef discr_routine ncx sloc "discr_routine")
				   :ndrou_proc nproc
				   ))
	 )
    (add_nctx_data ncx ndatarout)
    ;; update the context for the new proc & a fresh symbol cache map
    (unsafe_put_fields ncx 
		       :nctx_curproc nproc
		       :nctx_symbcachemap (make_mapobject discr_mapobjects 40))
    (unsafe_put_fields nproc :nrpro_datarout ndatarout)
    (multiple_every
     sargs
     (lambda (fbi :long ix)
       (assert_msg "check fbi" (is_a fbi class_formal_binding))
       (put_env newenv fbi)))
    (unsafe_put_fields newenv :env_proc nproc)
    ;; add nproc into ncx
    (list_append (unsafe_get_field :nctx_proclist ncx) nproc)
    (multicall
     (nbody nbindings)
     (normalize_tuple sbody newenv ncx sloc)
     (multiple_every
      nbindings
      (lambda (nbi :long ix)
	(put_env newenv nbi)))
     (unsafe_put_fields 
      nproc
      :nproc_body (wrap_normal_letseq (replace_last_by_return nbody newenv sloc) nbindings sloc)
      )
     ;; restore the previous symbol cache map & the old proc and return the normalized lambda
     (unsafe_put_fields ncx 
			:nctx_symbcachemap savedcachemap
			:nctx_curproc oldproc
			)
     (let ( 
	   ;; we make an anonymous constant for the routine unless in toplevel
	   (:long insideflag (is_a oldproc class_nrep_routproc))
	   (krout (if insideflag
		      (make_instance class_nrep_constant
				     :nrep_loc sloc
				     :nconst_sval recv
				     :nconst_data ndatarout
				     :nconst_proc oldproc)))
	   (clovtup 
	    (list_to_multiple closedblist
			      discr_multiple
			      (lambda (bnd)
				(assert_msg "normexp_lambda check bnd" (is_a bnd class_any_binding))
				(let ( (sy (unsafe_get_field :binder bnd)) 
				       ;; since sy is a symbol, its normalized form does not add any binding
				       ;; we normalize it in the *old* environment, not the new one
				       (nsy (normal_exp sy env ncx sloc))
				       )
				  nsy))))
	   (nlambda (make_instance class_nrep_lambda 
				   :nrep_loc sloc
				   :nlambda_proc nproc
				   :nlambda_constrout (if insideflag krout ndatarout)
				   :nlambda_closedv clovtup
				   ))
	   (cbind (make_instance class_normlet_binding
				 :letbind_loc sloc
				 :binder csym
				 :letbind_type ctype_value
				 :letbind_expr nlambda))
	   (nbindlist (make_list discr_list))
	   )
       (unsafe_put_fields clocc :nocc_bind cbind)
       (list_append nbindlist cbind)
       (if insideflag
	   (list_append (unsafe_get_field :nrpro_const oldproc) ndatarout))
       (debug_msg clocc "normexp_lambda return clocc")
       (debug_msg nbindlist "normexp_lambda return nbindlist")
       (return clocc nbindlist)
       ))))
(install_method class_src_lambda normal_exp normexp_lambda)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun normexp_multicall (recv env ncx psloc)
  (assert_msg "check multicall recv" (is_a recv class_src_multicall))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  (debug_msg recv "normexp_multicall recv")
  (let ( (sloc (unsafe_get_field :src_loc recv))
	 (sresbind (unsafe_get_field :smulc_resbind recv))
	 (scall (unsafe_get_field :smulc_call recv))
	 (sbody (unsafe_get_field :smulc_body recv))
	 (newenv (fresh_env env))
	 )
    (multicall
     (ncall ncallbindings)
     (normal_exp scall env ncx sloc)
     (debug_msg ncall "normexp_multicall ncall")
     (debug_msg ncallbindings "normexp_multicall ncallbindings")
;;; since ncall is normalized, it is a class_nrep_locsymocc and
;;; the last binding in ncallbindings is a class_normlet_binding
;;; whose binder is the nocc_symb of the ncall
     (assert_msg "normexp_multicall check ncall" (is_a ncall class_nrep_locsymocc))
     (let ( (ncallsym (unsafe_get_field :nocc_symb ncall)) 
	    (nboxcall (make_box discr_box ())) ;box to contain the real normalized call
	    (nrealcall ())		       ;the real call
	    (nincallbindings (make_list discr_list)) ;list of internal bindings to the call
	    )
       (list_iterate_test	;loop exited when cbnd is for ncallsym
	ncallbindings
	(lambda (cbnd)
	  (assert_msg "normexp_multicall check cbnd" (is_a cbnd class_normlet_binding))
	  (if (== ncallsym (unsafe_get_field :binder cbnd))
	      (let ( (nrealcall (unsafe_get_field :letbind_expr cbnd)) )
		(box_put nboxcall nrealcall)
		())
	    (progn (list_append nincallbindings cbnd) cbnd))))
       (setq nrealcall (box_content nboxcall))
       (debug_msg nrealcall "normexp_multicall got nrealcall")
       (multiple_every
	sresbind
	(lambda (bnd :long ix)
	  (put_env newenv bnd)))
       (multicall
	(nbody nbodybindings)
	(normalize_tuple sbody newenv ncx sloc)
	(debug_msg nbody "normexp_multicall nbody")
	(debug_msg nbodybindings "normexp_multicall nbodybindings")
	(let ( (wnbodylet (wrap_normal_letseq nbody nbodybindings sloc)) )
;;; remove every locally bound symbol from the symbol cache map
	  (let ( (sycmap (unsafe_get_field :nctx_symbcachemap ncx)) )
	    (multiple_every sresbind
			    (lambda (bnd)
			      (mapobject_remove sycmap (unsafe_get_field :binder bnd))
			      )))
	  (let ( 
		(lastnbody (multiple_nth nbody -1))
		(lastntype (if lastnbody (get_ctype lastnbody newenv) ctype_void))
		(csym (clone_symbol 'multi_))
		(cbind (make_instance class_normlet_binding
				      :binder csym
				      :letbind_loc sloc
				      :letbind_type lastntype
					; :letbind_expr  filled below
				      ))
		(clocc (make_instance class_nrep_locsymocc
				      :nrep_loc sloc
				      :nocc_ctyp lastntype
				      :nocc_symb csym
				      :nocc_bind cbind))
		)
;;; handle differently apply & sends
	    (cond
	     ( (is_a scall class_src_apply)
	       (assert_msg "normexp_multicall check nrealcall apply" (is_a nrealcall class_nrep_apply))
	       (let ( (nres (make_instance class_nrep_multiapply
					   :nrep_loc sloc
					   :napp_fun (unsafe_get_field :napp_fun nrealcall)
					   :napp_args (unsafe_get_field :napp_args nrealcall)
					   :nmulapp_bindings sresbind
					   :nmulapp_body wnbodylet)) )
		 (unsafe_put_fields cbind :letbind_expr nres)
		 (list_append nincallbindings cbind)
		 (debug_msg clocc "normexp_multicall multiapply result clocc")
		 (debug_msg nincallbindings "normexp_multicall multiapply result nincallbindings")
		 (return clocc nincallbindings)
		 )
	       )
	     ( (is_a scall class_src_msend)
	       (debug_msg nrealcall "normexp_multicall multicall nrealcall")
	       (assert_msg "normexp_multicall check nrealcall send" (is_a nrealcall class_nrep_msend))
	       (let ( (nres (make_instance class_nrep_multimsend
					   :nrep_loc sloc
					   :nsend_sel (unsafe_get_field :nsend_sel nrealcall)
					   :nsend_recv (unsafe_get_field :nsend_recv nrealcall)
					   :nsend_args (unsafe_get_field :nsend_args nrealcall)
					   :nmulsend_bindings sresbind
					   :nmulsend_body wnbodylet)) )
		 (unsafe_put_fields cbind :letbind_expr nres)
		 (list_append nincallbindings cbind)
		 (debug_msg clocc "normexp_multicall multisend result clocc")
		 (debug_msg nincallbindings "normexp_multicall multisend result nincallbindings")
		 (return clocc nincallbindings)
		 )
	       )
	     ( :else
	       (error_plain sloc "multi-called expression neither apply nor send")
	       (return (the_null))
	       )
	     ))))))))
       
(install_method class_src_multicall normal_exp normexp_multicall)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;; create the normal predef (or fail with a msg) 
(defun normal_predef (pred ncx sloc msg)
  (assert_msg "check pred" (is_object pred))
  (assert_msg "check nctxt"  (is_a ncx class_normcontext))
  (let ( (predefmap (unsafe_get_field :nctx_predefmap ncx)) 
	 (brk (mapobject_get predefmap pred)) )
    (if (or (is_integerbox brk) (is_a brk class_symbol))
	(make_instance class_nrep_predef
		       :nrep_loc sloc
		       :nrpredef brk)
      (if (is_string msg) 
	  (progn
	    (debug_msg predefmap "normalpredef predefmap")
	    (debug_msg pred "normalpredef pred")
	    (error_strv sloc "not a predef:" msg)
	    (the_null)
	    )))))


;; retrieve or create the normalized datasym for a symbol
(defun normal_symbol_data (sym ncx sloc)
  ;; sym should be strictly a symbol (not be in a subclass of class_symbol!)
  (assert_msg "check symb" (== (discrim sym) class_symbol))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  (debug_msg sym "normal_symbol_data start sym")
  (let ( (valmap  (unsafe_get_field :nctx_valmap ncx))
	 (osydata (mapobject_get valmap sym)) )
    (if osydata
	(progn
	  (debug_msg osydata "normal_symbol_data found osydata")
	  (return osydata))
	(let ( (:long syhash (obj_hash sym))
	       (synamstr (unsafe_get_field :named_name sym))
	       ;; make the datastring from synamstr
	       (synamstrdata 
		(make_instance class_nrep_datastring 
			       :ndata_discrx (normal_predef discr_string ncx sloc "discr_string") 
			       :nstr_string synamstr
					    ))
	       (syslots (make_multiple discr_multiple
				       (multiple_length (unsafe_get_field :class_fields class_symbol))))
	       (sydata (make_instance class_nrep_datasymbol
				      :ndata_name sym
				      :ndata_discrx (normal_predef class_symbol ncx sloc "class_symbol")
				      :ninst_hash (make_integerbox discr_integer syhash)
				      :ninst_slots syslots
				      :ndsy_namestr synamstr))
	       )
	  (multiple_put_nth syslots (obj_num named_name) synamstrdata)
	  (add_nctx_data ncx sydata)
	  (add_nctx_data ncx synamstrdata)
	  (mapobject_put valmap sym sydata)
	  (mapstring_putstr (unsafe_get_field :nctx_symbmap ncx) synamstr sydata)
	  (debug_msg sydata "normal_symbol_data return sydata")
	  (return sydata)
	  ))))



;; retrieve or create the normalized datakeyword for a keyword
(defun normal_keyword_data (keyw ncx sloc)
  ;; keyw should be strictly a keyword (not be in a subclass of class_keyword!)
  (assert_msg "check keywb" (== (discrim keyw) class_keyword))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  (let ( (valmap  (unsafe_get_field :nctx_valmap ncx))
	 (osydata (mapobject_get valmap keyw)) )
    (if osydata osydata
	(let ( (:long syhash (obj_hash keyw))
	       (synamstr (unsafe_get_field :named_name keyw))
	       ;; make the datastring from synamstr
	       (synamstrdata 
		(make_instance class_nrep_datastring 
			       :ndata_discrx (normal_predef discr_string ncx sloc "discr_string") 
			       :nstr_string synamstr
					    ))
	       (syslots (make_multiple discr_multiple
				       (multiple_length (unsafe_get_field :class_fields class_keyword))))
	       (sydata (make_instance class_nrep_datakeyword
				      :ndata_name keyw
				      :ndata_discrx (normal_predef class_keyword ncx sloc "class_keyword")
				      :ninst_hash (make_integerbox discr_integer syhash)
				      :ninst_slots syslots
				      :ndsy_namestr synamstr))
	       )
	  (multiple_put_nth syslots (obj_num named_name) synamstrdata)
	  (add_nctx_data ncx sydata)
	  (add_nctx_data ncx synamstrdata)
	  (mapobject_put valmap keyw sydata)
	  (mapstring_putstr (unsafe_get_field :nctx_keywmap ncx) synamstr sydata)
	  (return sydata)
	  ))))


;; create the tuples of slots of a datainstance for a particular class
(defun create_data_slots (cla)
  (assert_msg "check cla" (is_a cla class_class)) 
  (debug_msg cla "create_data_slots cla")
  (let ( (tupslo 
	  (make_multiple discr_multiple  (multiple_length (unsafe_get_field :class_fields cla)))) 
	 )
    (debug_msg tupslo "create_data_slots tupslo")
    tupslo
    ))

;; fill a slot of a datainstance
(defun fill_data_slot (di field val)
  (assert_msg "check di" (is_a di class_nrep_datainstance))
  (assert_msg "check field" (is_a field class_field))
  (let ( (:long fix (obj_num field))
	 (slots (unsafe_get_field :ninst_slots di)) )
    (multiple_put_nth slots fix val)
))

;;;;;; normalize a QUOTE-d symbol

(defun normexp_quote (recv env ncx psloc)
  (assert_msg "check quote recv" (is_a recv class_src_quote))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  ;(debug_msg ncx "normexp_quote ncx")
  (debug_msg recv "normexp_quote recv")
  (let ( (sloc   (unsafe_get_field :src_loc recv))
	 (quotedsy (unsafe_get_field :squoted recv)) )
    (assert_msg "check quotedsy" (== (discrim quotedsy) class_symbol))
    (let ( (sdata (normal_symbol_data quotedsy ncx psloc))
	   (curproc (unsafe_get_field :nctx_curproc ncx))
	   )
      (if (is_a curproc class_nrep_routproc)
	  (let ( 
		(nconst (make_instance class_nrep_constant
				       :nrep_loc sloc
				       :nconst_sval quotedsy
				       :nconst_data sdata
				       :nconst_proc curproc
				       )) )
	    (list_append (unsafe_get_field :nrpro_const curproc) sdata)
	    (debug_msg nconst "normexp_quote in routine nconst")
	    (return nconst))
	(progn
	  (debug_msg sdata "normexp_quote in init sdata")
	  (return sdata)
	  )))))
(install_method class_src_quote normal_exp normexp_quote)

;;;;;; normalize a COMMENT
(defun normexp_comment (recv env ncx psloc)
  (assert_msg "check comment recv" (is_a recv class_src_comment))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  (debug_msg recv "normexp_comment start recv")
  (let ( (sloc (unsafe_get_field :src_loc recv))
	 (scomm (unsafe_get_field :scomm_str recv))
	 (ncomm (make_instance class_nrep_comment
			       :nrep_loc sloc
			       :ncomm_string scomm
			     ))  
	 (csym (clone_symbol 'comment_)) 
	 (cbind (make_instance class_normlet_binding
			       :letbind_loc sloc
			       :binder csym
			       :letbind_type ctype_void
			       :letbind_expr ncomm))
	 (clocc (make_instance class_nrep_locsymocc
			       :nrep_loc sloc
			       :nocc_ctyp ctype_void
			       :nocc_symb csym
			       :nocc_bind cbind))
	 (bindlist (make_list discr_list))
	 )
    (if scomm (assert_msg "check scomm" (is_string scomm)))
    (list_append bindlist cbind)
    (debug_msg ncomm "normexp_comment end ncomm")
    (debug_msg clocc "normexp_comment return clocc")
    (debug_msg bindlist "normexp_comment return bindlist")
    (return clocc bindlist)
))
(install_method class_src_comment normal_exp normexp_comment)

;;;;;; normalize a keyword
(defun normexp_keyword (recv env ncx psloc)
  (assert_msg "check keyword recv" (is_a recv class_keyword))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  ;;(debug_msg ncx "normexp_keyword ncx")
  (debug_msg recv "normexp_keyword recv")
  (let ( (kdata (normal_keyword_data recv ncx psloc)) 
	 (curproc (unsafe_get_field :nctx_curproc ncx)) 
	 )
    (assert_msg "check curproc" (is_a curproc class_nrep_anyproc))
    (if (is_a curproc class_nrep_routproc)
	(let (
	      (constlist (unsafe_get_field :nrpro_const curproc))
	      (nconst (make_instance class_nrep_constant
				     :nrep_loc psloc
				     :nconst_sval recv
				     :nconst_data kdata
				     :nconst_proc curproc))
	      )
	  (debug_msg curproc "normexp_keyword routine curproc")
	  (list_append constlist kdata)
	  (debug_msg nconst "normexp_keyword result nconst")
	  (return nconst)
	  )
      (progn
	(debug_msg kdata "normexp_keyword routineinit result kdata")
	(return kdata)
	))))
(install_method class_keyword normal_exp normexp_keyword)



;;;;;; normalize a DEFPRIMITIVE
(defun normexp_defprimitive (recv env ncx psloc)
  (assert_msg "check defprimitive recv" (is_a recv class_src_defprimitive))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  (let ( (sloc   (unsafe_get_field :src_loc recv))
	 (sname  (unsafe_get_field :sdef_name recv))
	 (sargs  (unsafe_get_field :sformal_args recv))
	 (stype  (unsafe_get_field :sprim_type recv))
	 (sexp   (unsafe_get_field :sprim_expansion recv))
	 (sprimbind (find_env env sname))
	 ;; we compile to the making of an instance of class_primitive
	 (nslotuple (create_data_slots class_primitive))
	 (nexptuple (make_multiple discr_multiple
				   (multiple_length sexp)))
	 (nargtuple (make_multiple discr_multiple
				   (multiple_length sargs)))
	 (nexpdata (make_instance class_nrep_datatuple
				  :nrep_loc sloc
				  :ndata_name sname
				  :ndata_discrx (normal_predef discr_multiple ncx sloc "discr_multiple")
				  :ntup_comp nexptuple))
	 (nargdata (make_instance class_nrep_datatuple
				  :nrep_loc sloc
				  :ndata_name sname
				  :ndata_discrx (normal_predef discr_multiple ncx sloc "discr_multiple")
				  :ntup_comp nargtuple))
	 (nprimdata (make_instance class_nrep_datainstance
				   :nrep_loc sloc
				   :ndata_name sname
				   :ndata_discrx (normal_predef class_primitive ncx sloc "class_primitive")
				   :ninst_hash (make_integerbox discr_integer (nonzero_hash))
				   :ninst_slots nslotuple)) 
	 (nsymdata (normal_symbol_data sname ncx sloc))
	 ;; map of formal symbol -> data of formal_binding
	 (formsymbmap (make_mapobject discr_mapobjects (*i (multiple_length sargs) 2)))
	 )
    (add_nctx_data ncx nprimdata)
    (add_nctx_data ncx nexpdata)
    (add_nctx_data ncx nargdata)
    ;; dont add nsymdata, it has already been added
    ;; fill the formal arguments of the data
    (multiple_every
     sargs
     (lambda (fargb :long ix)
       (assert_msg "check fargb" (is_a fargb class_formal_binding))
       (let ( (ftyp (unsafe_get_field :fbind_type fargb)) 
	      (fsymb (unsafe_get_field :binder fargb))
	      (fdataslot (create_data_slots class_formal_binding))
	      (fargdata 
	       (make_instance 
		class_nrep_datainstance
		:nrep_loc sloc
		:ndata_discrx (normal_predef class_formal_binding ncx sloc "class_formal_binding") 
		:ninst_hash (make_integerbox discr_integer (nonzero_hash))
		:ninst_slots fdataslot
		:ninst_objnum (make_integerbox discr_integer ix)
		))
	      (fsymbdata (normal_symbol_data fsymb ncx sloc))
	      (ftypdata (normal_predef ftyp ncx sloc "primitive arg type"))
	      )
	 (assert_msg "check ftyp" (is_a ftyp class_ctype))
	 (add_nctx_data ncx fargdata)
	 (fill_data_slot fargdata binder fsymbdata)
	 (fill_data_slot fargdata fbind_type ftypdata)
	 (multiple_put_nth nargtuple ix fargdata)
	 (mapobject_put formsymbmap fsymb fargdata)
	 )))
    ;; fill the expansion of the data
    (multiple_every
     sexp
     (lambda (expcomp :long ix)
       (debug_msg expcomp "normexp_defprimitive expcomp")
       (let ( (discrcomp (discrim expcomp)) 
	      (compdata 
	       (cond ( (== discrcomp discr_verbatimstring)
		       (add_nctx_data ncx
				      (make_instance 
				       class_nrep_datastring
				       :ndata_discrx (normal_predef discr_verbatimstring ncx sloc "discr_verbatimstring") 
				       :nstr_string expcomp
				       )))
		     ( (== discrcomp class_symbol)
		       (normal_symbol_data expcomp ncx sloc)
		       )
		     ( :else 
		       (error_plain sloc "unexpected component in primitive expansion"))))
	      )
	 (multiple_put_nth nexptuple ix compdata)
	 )))
;;; fill the primitive data    
    (fill_data_slot nprimdata named_name 
		    (add_nctx_data 
		     ncx
		     (make_instance 
		      class_nrep_datastring
		      :ndata_discrx (normal_predef discr_string ncx sloc "discr_string") 
		      :nstr_string (unsafe_get_field :named_name sname))))
    (fill_data_slot nprimdata prim_formals nargdata)
    (fill_data_slot nprimdata prim_expansion nexpdata)
;;; put the data into the primitive binding
    (if (is_a sprimbind class_primitive_binding)
	(unsafe_put_fields sprimbind :pbind_primdata nprimdata))
    (return (the_null))			     ;normalized defprimitive is empty
    ))
(install_method class_src_defprimitive normal_exp normexp_defprimitive)




;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; normalize a DEFCLASS
(defun normexp_defclass (recv env ncx psloc)
  (assert_msg "check defclass recv" (is_a recv class_src_defclass))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  (let ( (sloc   (unsafe_get_field :src_loc recv))
	 (sname  (unsafe_get_field :sdef_name recv))
	 (spredef (unsafe_get_field :sobj_predef recv))
	 (sclabind (unsafe_get_field :sclass_clabind recv))
	 (superbind (unsafe_get_field :sclass_superbind recv))
	 (sfldbinds (unsafe_get_field :sclass_fldbinds recv))
	 )
    (assert_msg "check sclabind" (is_a sclabind class_class_binding))
    (let ( (claobj (unsafe_get_field :cbind_class sclabind)) 
	   (namsymdata (normal_symbol_data sname ncx sloc))
	   (namstrdata
	    (make_instance class_nrep_datastring
			   :ndata_discrx (normal_predef discr_string ncx sloc "discr_string") 
			   :nstr_string (unsafe_get_field :named_name sname)
			   ))
	   (claslots (make_multiple discr_multiple (obj_len claobj)))
	   (cladata 
	    (make_instance class_nrep_datainstance
			   :nrep_loc sloc
			   :ndata_name sname
			   :ndata_discrx (normal_predef class_class ncx sloc "class_class")
			   :ninst_hash  (make_integerbox discr_integer (obj_hash claobj))
			   :ninst_predef spredef
			   :ninst_slots claslots
			   :ninst_objnum 'OBMAG_OBJECT
			   )) 
	   (ancseq (unsafe_get_field :class_ancestors claobj))
	   (:long nbanc (multiple_length ancseq))
	   (anctup (make_multiple discr_multiple nbanc))
	   (ancdata (make_instance 
		     class_nrep_datatuple
		     :nrep_loc sloc
		     :ndata_name sname
		     :ndata_discrx (normal_predef discr_seqclass ncx sloc "discr_seqclass")
		     :ntup_comp anctup
		     ))
	   (fldseq (unsafe_get_field :class_fields claobj))
	   (:long nbfld (multiple_length fldseq)) ;total number of fields
	   (:long nbownfld (multiple_length sfldbinds)) ;number of own fields
	   (:long nbsupfld (-i nbfld nbownfld))	;number of super(ie inherited) fields
	   (:long ix 0)				;temporary index
	   (fldtup (make_multiple discr_multiple nbfld))
	   (flddata (make_instance 
		     class_nrep_datatuple
		     :nrep_loc sloc
		     :ndata_name sname
		     :ndata_discrx (normal_predef discr_seqfield ncx sloc "discr_seqfield")
		     :ntup_comp fldtup
		     ))
	   ;; the data representing the superclass
	   (superdata (if (is_a superbind class_any_binding) 
			  (normal_exp (unsafe_get_field :binder superbind) env ncx sloc)))
	   )
      (assert_msg "check claobj" (is_a claobj class_class))
      (add_nctx_data ncx cladata)
      (add_nctx_data ncx namstrdata)
      (add_nctx_data ncx ancdata)
      (add_nctx_data ncx flddata)
      (fill_data_slot cladata named_name namstrdata)
      (fill_data_slot cladata class_ancestors ancdata)
      (fill_data_slot cladata class_fields flddata)
      (assert_msg "check sclabind" (is_a sclabind class_class_binding))
      (unsafe_put_fields sclabind :cbind_cladata cladata)
      ;; for each field which is not own, make a data to copy it from the superclass
      (setq ix 0)
      (forever loopsuperfield
	       (if (>=i ix nbsupfld) (exit loopsuperfield))
	       (let ( (supfldata 
		       (make_instance class_nrep_multacc
				      :nrep_loc sloc
				      :naccm_mul
				      (make_instance class_nrep_fieldacc
						     :nrep_loc sloc
						     :naccf_obj superdata
						     :naccf_fld class_fields
						     )
				      :naccm_ix (make_integerbox discr_integer ix)	      
				      )) 
		      )
		 (multiple_put_nth fldtup ix supfldata)
		 )
	       (setq ix (+i ix 1))
	       )
      (setq ix 0)
      ;; for each own field, make an instance of it
      (forever loopownfield
	       (if (>=i ix nbownfld) (exit loopownfield))
	       (let ( (ownfldbind (multiple_nth sfldbinds ix)) )
		 (assert_msg "check ownfldbind" (is_a ownfldbind class_field_binding))
		 (let ( (ownfldsym (unsafe_get_field :binder ownfldbind))
			(ownfld (unsafe_get_field :flbind_field ownfldbind))
			)
		   (assert_msg "check ownfldsym" (is_a ownfldsym class_symbol))
		   (assert_msg "check ownfld" (is_a ownfld class_field))
		   (let ( (ownfldsymdata (normal_symbol_data ownfldsym ncx sloc)) 
			  (ownfldslots (make_multiple discr_multiple (obj_len ownfld)))
			  (ownflstrdata 
			   (make_instance class_nrep_datastring
					  :ndata_discrx (normal_predef discr_string ncx sloc "discr_string") 
					  :nstr_string  (unsafe_get_field :named_name ownfld)
					  ))
			  (ownfldata (make_instance class_nrep_datainstance
						    :nrep_loc sloc
						    :ndata_name ownfldsym
						    :ndata_discrx (normal_predef class_field ncx sloc "class_field")
						    :ninst_hash (make_integerbox discr_integer (obj_hash ownfld))
						    :ninst_objnum (make_integerbox discr_integer (obj_num ownfld))
						    :ninst_slots ownfldslots))
			  )
		     (add_nctx_data ncx ownfldata)
		     (add_nctx_data ncx ownflstrdata)
		     (fill_data_slot ownfldata named_name ownflstrdata)
		     (fill_data_slot ownfldata fld_ownclass cladata)
		     (multiple_put_nth fldtup (+i ix nbsupfld) ownfldata)
		     ;; fill the field binding with its compiled data
		     (unsafe_put_fields ownfldbind :flbind_fdata ownfldata)
		     )))
	       (setq ix (+i ix 1))
	       )
      ;; set the disc_super field to the superclass
      (if superdata (fill_data_slot cladata disc_super superdata))
      ;; compute the class_ancestors into anctup
      (setq ix 0)
      ;; loop on the ancestors of the superclass
      (forever loopancestorsuper
	       (if (>=i ix (-i nbanc 1)) (exit loopancestorsuper))
	       (let ( (supancdata
		       (make_instance class_nrep_multacc
				      :nrep_loc sloc
				      :naccm_mul
				      (make_instance class_nrep_fieldacc
						     :nrep_loc sloc
						     :naccf_obj superdata
						     :naccf_fld class_ancestors)
				      :naccm_ix (make_integerbox discr_integer ix))) )
		 (multiple_put_nth anctup ix supancdata)
		 )
	       (setq ix (+i ix 1))
	       )
      ;; add the superdata as the last component of anctup
      (if superdata (multiple_put_nth anctup (-i nbanc 1) superdata))
      ;; the normalized form of the defclass is the classdata
      cladata
      )))
(install_method class_src_defclass normal_exp normexp_defclass)




;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; normalize a DEFINSTANCE
(defun normexp_definstance (recv env ncx psloc)
  (assert_msg "check definstance recv" (is_a recv class_src_definstance))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  (debug_msg recv "normexp_definstance recv")
  (let ( (sloc   (unsafe_get_field :src_loc recv))
	 (sname  (unsafe_get_field :sdef_name recv))
	 (spredef (unsafe_get_field :sobj_predef recv))
	 (sdocstr (unsafe_get_field :sobj_docstr recv))
	 (sinstclass (unsafe_get_field :sinst_class recv))
	 (sinstclabnd (unsafe_get_field :sinst_clabind recv))
	 (sinstclasym (if (is_a sinstclabnd class_any_binding) (unsafe_get_field :binder sinstclabnd)))
	 (sinstobjnum (unsafe_get_field :sinst_objnum recv))
	 (sinstfields (unsafe_get_field :sinst_fields recv))
	 (nbindlist (make_list discr_list))
	 (nbindbox (make_box discr_box nbindlist))
	 (bindins (find_env env sname))
	 (namdata (normal_symbol_data sname ncx sloc))
	 ;; data representing the class
	 (icladata (if (is_a sinstclasym class_symbol) 
		       (normal_exp sinstclasym env ncx sloc)))
	 )
    (debug_msg bindins "normexp_definstance bindins")
    (assert_msg "check bindins" (is_a  bindins class_instance_binding))
    (if (not (is_a icladata class_nrep))
	(progn
	  (error_strv sloc "invalid class in definstance" (unsafe_get_field :named_name sname))
	  (return (the_null))))
    (cond
     ( (null spredef) () )
     ( (is_integerbox spredef) () )
     ( (is_a spredef class_symbol) () )
     (:else
      (error_strv sloc "bad predef in DEFINSTANCE"  (unsafe_get_field :named_name sname))
      (return (the_null))))
    (assert_msg "check sinstclass" (is_a sinstclass class_class))
    (assert_msg "check sinstclasym" (is_a sinstclasym class_symbol))
    (let (
	  (slotup (make_multiple discr_multiple
				 (multiple_length (unsafe_get_field :class_fields sinstclass))))
	  (insdata (make_instance class_nrep_datainstance
				  :nrep_loc sloc
				  :ndata_name sname
				  :ndata_discrx icladata
				  :ninst_hash (make_integerbox discr_integer (nonzero_hash))
				  :ninst_predef spredef
				  :ninst_slots slotup
				  :ninst_objnum sinstobjnum
				  )) 
	  )
      (add_nctx_data ncx insdata)
      (put_env env bindins)
      (unsafe_put_fields bindins :ibind_data insdata)
      ;; scan the fields initialization
      (multiple_every
       sinstfields
       (lambda (flda :long ix)
	 (debug_msg flda "normexp_definstance flda")
	 (assert_msg "check flda" (is_a flda class_src_fieldassign))
	 (let ( (curfld (unsafe_get_field :sfla_field flda))
		(curexp (unsafe_get_field :sfla_expr flda))
		(:long curoff (obj_num curfld))
		)
	   (assert_msg "check curfld" (is_a curfld class_field))
	   (assert_msg "good curfld"
		       (== (multiple_nth (unsafe_get_field :class_fields sinstclass) curoff) 
			   curfld))  
	   (debug_msg curexp "normexp_definstance field curexp")
	   (multicall
	    (ncur nbindcur)
	    (normal_exp curexp env ncx sloc)
	    (debug_msg ncur "normexp_definstance field ncur")
	    (multiple_put_nth slotup curoff ncur)
	    (if (is_list nbindcur)
		(let ( (nbindlist (box_content nbindbox)))
		  (setq nbindlist (list_append2list nbindlist nbindcur))
		  (box_put nbindbox nbindlist)))))))
;;; put the binding into the data
      (let ( (nbindlist (box_content nbindbox)) 
	     (nbindtup (list_to_multiple nbindlist discr_multiple))
	     )
	(if (>i (multiple_length nbindtup) 0) 
	    (unsafe_put_fields insdata :ndata_locbind nbindtup))
	;; return the data
	(debug_msg insdata "normexp_definstance return insdata")
	insdata
	))))
(install_method class_src_definstance normal_exp normexp_definstance)


;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; normalize a DEFSELECTOR
(defun normexp_defselector (recv env ncx psloc)
  (assert_msg "check defselector recv" (is_a recv class_src_defselector))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normcontext))
  (debug_msg recv "normexp defselector recv")
  (let ( 
	(sloc (unsafe_get_field :src_loc recv))
	(sname (unsafe_get_field :sdef_name recv))
	(spredef (unsafe_get_field :sobj_predef recv))
	(sdocstr (unsafe_get_field :sobj_docstr recv))
	(sinstclass (unsafe_get_field :sinst_class recv))
	(sinstclabnd (unsafe_get_field :sinst_clabind recv))
	(sinstclasym (if (is_a sinstclabnd class_any_binding) (unsafe_get_field :binder sinstclabnd)))
	(sinstobjnum (unsafe_get_field :sinst_objnum recv))
	(sinstfields (unsafe_get_field :sinst_fields recv))
	(nbindlist (make_list discr_list))
	(nbindbox (make_box discr_box nbindlist))
	(bindsel (find_env env sname))
	(namdata (normal_symbol_data sname ncx sloc))
	;; data representing the class
	(icladata (if (is_a sinstclasym class_symbol) 
		      (normal_exp sinstclasym env ncx sloc)))
	)
    (assert_msg "check bindsel" (is_a bindsel class_selector_binding))
    (if (not (is_a icladata class_nrep))
	(progn
	  (error_strv sloc "invalid class in defselector" (unsafe_get_field :named_name sname))
	  (return (the_null))))
    (if spredef
	(if (not (or (is_integerbox spredef) (is_a spredef class_symbol)))
	    (progn (error_strv sloc "bad predef in defselector"  (unsafe_get_field :named_name sname))
		   (return (the_null)))))
    (assert_msg "check sinstclass" (is_a sinstclass class_class))
    (assert_msg "check sinstclasym" (is_a sinstclasym class_symbol))
    (assert_msg "check sname" (is_a sname class_symbol))
    (let (
	  (slotup (make_multiple discr_multiple
				 (multiple_length (unsafe_get_field :class_fields sinstclass))))
	  (namstrdata (make_instance class_nrep_datastring
				     :nrep_loc sloc
				     :ndata_discrx (normal_predef discr_string ncx sloc "discr_string") 
				     :nstr_string (unsafe_get_field :named_name sname)))
	  (insdata (make_instance class_nrep_datainstance
				  :nrep_loc sloc
				  :ndata_name sname
				  :ndata_discrx icladata
				  :ninst_hash (make_integerbox discr_integer (nonzero_hash))
				  :ninst_predef spredef
				  :ninst_slots slotup
				  :ninst_objnum sinstobjnum
				  )) 
	  )
      (add_nctx_data ncx insdata)
      (add_nctx_data ncx namstrdata)
      (unsafe_put_fields bindsel :ibind_data insdata)
      ;; scan the fields initialization
      (multiple_every
       sinstfields
       (lambda (flda :long ix)
	 (assert_msg "check flda" (is_a flda class_src_fieldassign))
	 (let ( (curfld (unsafe_get_field :sfla_field flda))
		(curexp (unsafe_get_field :sfla_expr flda))
		(:long curoff (obj_num curfld))
		)
	   (assert_msg "check curfld" (is_a curfld class_field))
	   (assert_msg "good curfld"
		       (== (multiple_nth (unsafe_get_field :class_fields sinstclass) curoff) 
			   curfld))  
	   (multicall
	    (ncur nbindcur)
	    (normal_exp curexp env ncx sloc)
	    (multiple_put_nth slotup curoff ncur)
	    (if (is_list nbindcur)
		(let ( (nbindlist (box_content nbindbox)))
		  (setq nbindlist (list_append2list nbindlist nbindcur))
		  (box_put nbindbox nbindlist)))))))
;;; put the binding into the data
      (let ( (nbindlist (box_content nbindbox)) 
	     (nbindtup (list_to_multiple nbindlist discr_multiple))
	     )
	(if (>i (multiple_length nbindtup) 0) 
	    (unsafe_put_fields insdata :ndata_locbind nbindtup))
	;; force the name of the selectordata
	(multiple_put_nth slotup (get_int named_name) namstrdata)
	;; return the data
	(debug_msg insdata "normexp_defselector return insdata")
	insdata
	))))
(install_method class_src_defselector normal_exp normexp_defselector)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;; selector to compile a normalized stuff into an object
;;; reciever: the normalized stuff
;;; arguments: 
;;;; * GCX the code generation context
;;; result = the obj instruction or value

(defselector compile_obj class_selector
)
;; a catchall method for nrep-s (normal representations) each should
;; be separately compiled with its own method so this should never be
;; called
(defun compilobj_catchall_nrep (recv gcx)
  (debug_msg gcx "class_rep compile_obj gcx")
  (displaydebugmsg recv "class_rep compile_obj recv")
  (outcstring_err "* compilobj unimplemented reciever class ")
  (let ( (discr (discrim recv)) ) (outstr_err (unsafe_get_field :named_name discr)))
  (outnewline_err)
  (assert_msg "@@compile_obj should be implemented in nrep-s subclasses" ())
  )
(install_method class_nrep compile_obj compilobj_catchall_nrep)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; selector to put a destination into an objcode
;;; reciever: the objcode
;;; argument: the destination value
;;; result: the (modified) recieving objcode or its replacement
(defselector put_objdest class_selector
)

(defun putobjdest_catchall_objcode (recv desto)
  (debug_msg recv "putobjdest_catchall_objcode recv@@  " )
  (debug_msg desto "putobjdest_catchall_objcode desto@@  " )
  (outcstring_err "* putobjdest unimplemented reciever class ")
  (let ( (discr (discrim recv)) ) (outstr_err (unsafe_get_field :named_name discr)))
  (outnewline_err)
  (assert_msg "@@ unexpected catchall putobjdest objcod" ()))
(install_method class_objcode put_objdest putobjdest_catchall_objcode)


(defun putobjdest_catchall_anydiscr (recv desto)
  (debug_msg recv "putobjdest_catchall_anydiscr recv@@  " )
  (debug_msg desto "putobjdest_catchall_anydiscr desto@@  " )
  (outcstring_err "* putobjdest unimplemented reciever discriminant ")
  (let ( (discr (discrim recv)) ) (outstr_err (unsafe_get_field :named_name discr)))
  (outnewline_err)
  (assert_msg "@@ unexpected catchall putobjdest anydiscr" ()))
(install_method discr_anyrecv put_objdest putobjdest_catchall_anydiscr)


(defun getctype_objvalue (recv env)
  (assert_msg "check recv objvalue" (is_a recv class_objvalue))
  (unsafe_get_field :obv_type recv))
(install_method class_objvalue get_ctype getctype_objvalue)


;;;; selector to generate the declaration of an initial
;;; reciever some objinielem
;;; argument strbuf
(defselector output_c_declinit class_selector
)
(defun outdeclinit_root (recv sbuf)
  (debug_msg recv "outdeclinit_root recv")
  (assert_msg "outdeclinit_root unimplemented catchall" ())
)
(install_method class_root output_c_declinit outdeclinit_root)


;;; selector to generate the c code for an object
;;; reciever: the object to output
;;; arguments: 
;;;; * DECLBUF the stringbuffer for the declarations
;;;; * IMPLBUF the stringbuffer for implementations
;;;; * DEPTH an unboxed integer for indentation...
;;; result is not used

(defselector output_c_code class_selector
)


(defun outpucod_objinielem (obielem  declbuf implbuf :long depth)
  (assert_msg "check obelem" (is_a obielem class_objinitelem))
  ;;(debug_msg obielem "outpucod_objinielem obielem")
  (let ( (olocvar (unsafe_get_field :oie_locvar obielem))
	 (cnam (unsafe_get_field :oie_cname obielem)) )
    (assert_msg "check cnam" (is_string cnam))
    (assert_msg "check olocvar"  olocvar)
    (add2sbuf_strconst implbuf "/*obielem ")
    (add2sbuf_string implbuf cnam)
    (add2sbuf_strconst implbuf "*/ ")
    (output_c_code olocvar declbuf implbuf depth)
    )
)
(install_method class_objinitelem output_c_code outpucod_objinielem)

;;;; selector to generate the initial fill of some objinit
;;; reciever some objinitelem
;;; argument a stringbuffer
(defselector output_c_initfill class_selector
)
(defun outcinitfill_root (recv declbuf implbuf :long depth)
  (debug_msg recv "outcinitfill_root recv")
  (assert_msg "outcinitfill_root unimplemented catchall" ())
)
(install_method class_root output_c_initfill outcinitfill_root)


;;;; selector to generate the predef fill of some objinit
;;; reciever some objinitelem
;;; argument a stringbuffer
(defselector output_c_initpredef class_selector
)

(defun outcinitpredef_root (recv declbuf implbuf :long depth)
  (debug_msg recv "outcinitfill_root recv")
  (return)
)
(install_method class_root output_c_initpredef outcinitpredef_root)

;;; output a predef
(defun outpucod_predef (obpred declbuf implbuf :long depth)
  (assert_msg "check obpredef" (is_a obpred class_objpredef))
  (let ( (obpr (unsafe_get_field :obpredef obpred)) )
    (cond 
     ( (is_integerbox obpr)
       (add2sbuf_strconst implbuf "basilys_globpredef(")
       (add2sbuf_longdec implbuf (get_int obpr))
       (add2sbuf_strconst implbuf ")")
       )
     ( (is_a obpr class_symbol)
       (add2sbuf_strconst implbuf "((void*)(BASILYSG(")
       (add2sbuf_string implbuf (unsafe_get_field :named_name obpr))
       (add2sbuf_strconst implbuf ")))")
       )
     ( :else
       (debug_msg obpredef "bad obpredef")
       (assert_msg "invalid obpredef" ())
       )
     )))
(install_method class_objpredef output_c_code outpucod_predef)

;;;; output a nil
(defun outpucod_nil (obnil  declbuf implbuf :long depth)
  (assert_msg "check obnil" (is_a obnil class_objnil))
  (add2sbuf_strconst implbuf "(/*nil*/NULL)"))
(install_method class_objnil output_c_code outpucod_nil)


;; nil are ctype_value
(defun gectyp_objnil (recv env)  
  (debug_msg recv "gectyp_objnil recv")
  ctype_value)
(install_method class_objnil get_ctype gectyp_objnil)

(defun outdeclinit_objinitobject (recv sbuf)
  (add2sbuf_strconst sbuf " struct BASILYS_OBJECT_STRUCT(")
  (add2sbuf_longdec sbuf (get_int recv))
  (add2sbuf_strconst sbuf ") ")
  (add2sbuf_string sbuf (unsafe_get_field :named_name recv))
  (add2sbuf_strconst sbuf ";")		;
)
(install_method class_objinitobject output_c_declinit outdeclinit_objinitobject)


(defun outcinitfill_objinitobject (recv sbuf)
  (assert_msg "outcinitfill_objinitobject check recv" (is_a recv class_objinitobject))
  (debug_msg recv "outcinitfill_objinitobject recv")
  (let ( (odata (unsafe_get_field :oie_data recv)) 
	 (odiscr (unsafe_get_field :oie_discr recv))
	 (oname (unsafe_get_field :oie_cname recv))
	 (olocvar (unsafe_get_field :oie_locvar recv))
	 (oiopredef (unsafe_get_field :oio_predef recv))
	 )
    (assert_msg "check odata" (is_a odata class_nrep_datainstance))
    (let ( (odloc (unsafe_get_field :nrep_loc odata))
	   (odhash (unsafe_get_field :ninst_hash odata))
	   (odslots (unsafe_get_field :ninst_slots odata))
	   (odobnum (unsafe_get_field :ninst_objnum odata))
	   )
      (output_location odloc sbuf 1 "iniobj")
      (add2sbuf_strconst sbuf "/*iniobj ")
      (add2sbuf_string sbuf oname)
      (add2sbuf_strconst sbuf "*/")
      (add2sbuf_indentnl sbuf 1)
      (if olocvar
	  (progn
	    (add2sbuf_strconst sbuf "/*inioblocvar*/ ")
	    (output_c_code olocvar (the_null) sbuf 1)
	    (add2sbuf_strconst sbuf " = (void*)&cdat->")
	    (add2sbuf_string sbuf oname)
	    (add2sbuf_strconst sbuf ";")
	    (add2sbuf_indentnl sbuf 1)
	    ))
      ;;generate the check that odiscr is non-null 
      (add2sbuf_strconst sbuf " basilys_assertmsg(\"iniobj checkdiscr ")
      (add2sbuf_string sbuf oname)
      (add2sbuf_strconst sbuf "\", NULL != (void*)")
      (output_c_code odiscr (the_null) sbuf 1)
      (add2sbuf_strconst sbuf ");")
      (add2sbuf_indentnl sbuf 1)
      (add2sbuf_strconst sbuf " cdat->")
      (add2sbuf_string sbuf oname)
      (add2sbuf_strconst sbuf ".obj_class = ")
      (output_c_code odiscr (the_null) sbuf 1)
      (add2sbuf_strconst sbuf ";")
      (add2sbuf_indentnl sbuf 1)
      (if odobnum
	  (progn
	    (add2sbuf_strconst sbuf " cdat->")
	    (add2sbuf_string sbuf oname)
	    (add2sbuf_strconst sbuf ".obj_num = ")
	    (cond ( (is_integerbox odobnum)
		    (add2sbuf_longdec sbuf (get_int odobnum)))
		  ( (is_a odobnum class_symbol)
		    (add2sbuf_string sbuf (unsafe_get_field :named_name odobnum)))
		  (:else 
		   (debug_msg odobnum "outcinitfill_objinitobject unexpected odobnum")
		   (assert_msg "outcinitfill_objinitobject unexpected odobnum" ())
		   ))
	    (add2sbuf_strconst sbuf ";")
	    (add2sbuf_indentnl sbuf 1)
	    ))
      (add2sbuf_strconst sbuf " cdat->")
      (add2sbuf_string sbuf oname)
      (add2sbuf_strconst sbuf ".obj_hash = ")
      (add2sbuf_longdec sbuf (get_int odhash))
      (add2sbuf_strconst sbuf ";")
      (add2sbuf_indentnl sbuf 1)
      (add2sbuf_strconst sbuf " cdat->")
      (add2sbuf_string sbuf oname)
      (add2sbuf_strconst sbuf ".obj_len = ")
      (add2sbuf_longdec sbuf (multiple_length odslots))
      (add2sbuf_strconst sbuf ";")
      (add2sbuf_indentnl sbuf 1)
      (add2sbuf_strconst sbuf " cdat->")
      (add2sbuf_string sbuf oname)
      (add2sbuf_strconst sbuf ".obj_vartab = ")
      (add2sbuf_strconst sbuf " cdat->")
      (add2sbuf_string sbuf oname)
      (add2sbuf_strconst sbuf ".obj__tabfields;")
      (add2sbuf_indentnl sbuf 1)
      ;; output the fill
      )
    )
  )
(install_method class_objinitobject output_c_initfill outcinitfill_objinitobject)




(defun outcinitpredef_objinitobject (recv sbuf)
  (assert_msg "outcinitpredef_objinitobject check recv" (is_a recv class_objinitobject))
  (assert_msg "outcinitpredef_objinitobject check sbuf" (is_strbuf sbuf))
  (debug_msg recv "outcinitpredef_objinitobject recv")
  (let ( (odata (unsafe_get_field :oie_data recv)) 
	 (odiscr (unsafe_get_field :oie_discr recv))
	 (oname (unsafe_get_field :oie_cname recv))
	 (olocvar (unsafe_get_field :oie_locvar recv))
	 (oiopredef (unsafe_get_field :oio_predef recv))
	 )
    (assert_msg "check odata" (is_a odata class_nrep_datainstance))
    (debug_msg oiopredef "outcinitpredef_objinitobject oiopredef")
    (if (null oiopredef) (return (the_null)))
    (if (is_a oiopredef class_nrep_nil) (return (the_null)))
    (let ( (odloc (unsafe_get_field :nrep_loc odata))
	   )
      (output_location odloc sbuf 1 "inipredef")
      (add2sbuf_strconst sbuf "/*inipredef ")
      (add2sbuf_string sbuf oname)
      (add2sbuf_strconst sbuf "*/")
      (add2sbuf_indentnl sbuf 1)
      (cond
       ( (is_a oiopredef class_symbol)
	 (add2sbuf_strconst sbuf "/*inipredefsym*/ BASILYSG(")
	 (add2sbuf_string sbuf (unsafe_get_field :named_name oiopredef))
	 (add2sbuf_strconst sbuf ") = (void*)&cdat->")
	 (add2sbuf_string sbuf oname)
	 (add2sbuf_strconst sbuf ";")
	 (add2sbuf_indentnl sbuf 1)
	 )
       ( (is_integerbox oiopredef)
	 (add2sbuf_strconst sbuf "/*inipredefnum*/ basilys_globarr[")
	 (add2sbuf_longdec sbuf (get_int oiopredef))
	 (add2sbuf_strconst sbuf "] = (void*)&cdat->")
	 (add2sbuf_string sbuf oname)
	 (add2sbuf_strconst sbuf ";")
	 (add2sbuf_indentnl sbuf 1)
	 )
       ( (null oiopredef)
	 (return (the_null)))
       ( :else
	 (debug_msg oiopredef "outcinitpredef_objinitobject unexpected oiopredef")
	 (assert_msg "outcinitpredef_objinitobject unexpected oiopredef" ())
	 )))
    )
  )
  
(install_method class_objinitobject output_c_initpredef outcinitpredef_objinitobject)



(defun outdeclinit_objinitmultiple (recv sbuf)
  (add2sbuf_strconst sbuf " struct BASILYS_MULTIPLE_STRUCT(")
  (add2sbuf_longdec sbuf (get_int recv))
  (add2sbuf_strconst sbuf ") ")
  (add2sbuf_string sbuf (unsafe_get_field :named_name recv))
  (add2sbuf_strconst sbuf ";")
)
(install_method class_objinitmultiple output_c_declinit outdeclinit_objinitmultiple)


(defun outcinitfill_objinitmultiple (recv sbuf)
  (assert_msg "outcinitfill_objinitmultiple check recv" (is_a recv class_objinitmultiple))
  (debug_msg recv "outcinitfill_objinitmultiple recv")
  (let ( (cnam (unsafe_get_field :oie_cname recv)) 
	 (olocvar (unsafe_get_field :oie_locvar recv))
	 )
    (add2sbuf_strconst sbuf "/*inimult ")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf "*/")
    (add2sbuf_indentnl sbuf 1)
    (if olocvar
	(progn
	  (output_c_code olocvar (the_null) sbuf 1)
	  (add2sbuf_strconst sbuf " = (void*)&cdat->")
	  (add2sbuf_string sbuf cnam)
	  (add2sbuf_strconst sbuf ";")
	  (add2sbuf_indentnl sbuf 1)
	  ))
    (add2sbuf_strconst sbuf " cdat->")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf ".discr = ")
    (output_c_code (unsafe_get_field :oie_discr recv) (the_null) sbuf 1)
    (add2sbuf_strconst sbuf ";")
    (add2sbuf_indentnl sbuf 1)
    (add2sbuf_strconst sbuf " cdat->")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf ".nbval = ")
    (add2sbuf_longdec sbuf (get_int recv))
    (add2sbuf_strconst sbuf ";")
    ))
(install_method class_objinitmultiple output_c_initfill outcinitfill_objinitmultiple)

(defun outdeclinit_objinitclosure (recv sbuf)
  (add2sbuf_strconst sbuf " struct BASILYS_CLOSURE_STRUCT(")
  (add2sbuf_longdec sbuf (get_int recv))
  (add2sbuf_strconst sbuf ") ")
  (add2sbuf_string sbuf (unsafe_get_field :oie_cname recv))
  (add2sbuf_strconst sbuf ";")
)
(install_method class_objinitclosure output_c_declinit outdeclinit_objinitclosure)

(defun outcinitfill_objinitclosure (recv sbuf)
  (assert_msg "outcinitfill_objinitclosure check recv" (is_a recv class_objinitclosure))
  (debug_msg recv "outcinitfill_objinitclosure recv")
  (let ( (cnam (unsafe_get_field :oie_cname recv)) 
	 (olocvar (unsafe_get_field :oie_locvar recv))
	 )
    (add2sbuf_strconst sbuf "/*iniclos ")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf "*/")
    (add2sbuf_indentnl sbuf 1)
    (if olocvar
	(progn
	  (add2sbuf_strconst sbuf "/*inicloslocvar*/ ")
	  (output_c_code olocvar (the_null) sbuf 1)
	  (add2sbuf_strconst sbuf " = (void*)&cdat->")
	  (add2sbuf_string sbuf cnam)
	  (add2sbuf_strconst sbuf ";")
	  (add2sbuf_indentnl sbuf 1)
	  ))
    (add2sbuf_strconst sbuf " cdat->")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf ".discr = ")
    (output_c_code (unsafe_get_field :oie_discr recv) (the_null) sbuf 1)
    (add2sbuf_strconst sbuf ";")
    (add2sbuf_indentnl sbuf 1)
    (add2sbuf_strconst sbuf " cdat->")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf ".nbval = ")
    (add2sbuf_longdec sbuf (get_int recv))
    (add2sbuf_strconst sbuf ";")
    (add2sbuf_indentnl sbuf 1)
    ))
(install_method class_objinitclosure output_c_initfill outcinitfill_objinitclosure)


(defun outdeclinit_objinitroutine (recv sbuf)
  (add2sbuf_strconst sbuf " struct BASILYS_ROUTINE_STRUCT(")
  (add2sbuf_longdec sbuf (get_int recv))
  (add2sbuf_strconst sbuf ") ")
  (add2sbuf_string sbuf (unsafe_get_field :oie_cname recv))
  (add2sbuf_strconst sbuf ";")
)
(install_method class_objinitroutine output_c_declinit outdeclinit_objinitroutine)


(defun outcinitfill_objinitroutine (recv sbuf)
  (assert_msg "outcinitfill_objinitroutine check recv" (is_a recv class_objinitroutine))
  (debug_msg recv "outcinitfill_objinitroutine recv")
  (let ( (cnam (unsafe_get_field :oie_cname recv)) 
	 (ipro (unsafe_get_field :oir_procroutine recv))
	 (olocvar (unsafe_get_field :oie_locvar recv))
	 (ndatr (unsafe_get_field :oie_data recv))
	 )
    (add2sbuf_strconst sbuf "/*inirout ")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf "*/")
    (add2sbuf_indentnl sbuf 1)
    (if olocvar
	(progn
	  (add2sbuf_strconst sbuf "/*iniroutlocvar*/ ")
	  (output_c_code olocvar (the_null) sbuf 1)
	  (add2sbuf_strconst sbuf " = (void*)&cdat->")
	  (add2sbuf_string sbuf cnam)
	  (add2sbuf_strconst sbuf ";")
	  (add2sbuf_indentnl sbuf 1)
	  ))
    (add2sbuf_strconst sbuf " cdat->")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf ".discr = ")
    (output_c_code (unsafe_get_field :oie_discr recv) (the_null) sbuf 1)
    (add2sbuf_strconst sbuf ";")
    (add2sbuf_indentnl sbuf 1)
    (add2sbuf_strconst sbuf " strncpy(cdat->")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf ".routdescr, \"")
    (if (is_a ndatr class_nrep_dataroutine)
	(let ( (dnam (unsafe_get_field :ndata_name ndatr))
	       (dpro (unsafe_get_field :ndrou_proc ndatr))
	       )
	  (debug_msg ndatr "outcinitfill_objinitroutine ndatr")
	  (debug_msg dpro "outcinitfill_objinitroutine dpro")
	  (if (is_a dnam class_named)
	      (add2sbuf_cencstring sbuf (unsafe_get_field :named_name dnam)))
	  (if (is_a dpro class_nrep_routproc)
	      (let (  (dloc (unsafe_get_field :nrep_loc dpro))
		      (locfil (mixint_val dloc)) )
		(add2sbuf_strconst sbuf " @")
		(add2sbuf_cencstring sbuf locfil)
		(add2sbuf_strconst sbuf ":")
		(add2sbuf_longdec sbuf (get_int dloc))
		)
	    )
	  )
      (add2sbuf_cencstring sbuf cnam))
    (add2sbuf_strconst sbuf "\",  BASILYS_ROUTDESCR_LEN - 1);")
    (add2sbuf_indentnl sbuf 1)
    (add2sbuf_strconst  sbuf " cdat->")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf ".nbval = ")
    (add2sbuf_longdec sbuf (get_int recv))
    (add2sbuf_strconst sbuf ";")
    (add2sbuf_indentnl sbuf 1)
    (if ipro
	(progn
	  (debug_msg ipro "outcinitfill_objinitroutine ipro")
	  (assert_msg "check ipro" (is_a ipro class_named))
	  (add2sbuf_strconst sbuf "*(basilysroutfun_t **) (cdat->")
	  (add2sbuf_string sbuf cnam)
	  (add2sbuf_strconst sbuf ".routaddr) = ")
	  (add2sbuf_string sbuf (unsafe_get_field :named_name ipro))
	  (add2sbuf_strconst sbuf ";")
	  (add2sbuf_indentnl sbuf 1)
	  )
      (progn
	(debug_msg recv "outcinitfill_objinitroutine (noipro) recv" )
	(add2sbuf_strconst sbuf "#warning no procedure in objinitroutine ")
	(add2sbuf_string sbuf cnam)
	(add2sbuf_indentnl sbuf 1)
	)
      )
    ))
(install_method class_objinitroutine output_c_initfill outcinitfill_objinitroutine)

(defun outdeclinit_objinitstring (recv sbuf)
  (add2sbuf_strconst sbuf " struct BASILYS_STRING_STRUCT(")
  (add2sbuf_longdec sbuf (get_int recv))
  (add2sbuf_strconst sbuf ") ")
  (add2sbuf_string sbuf (unsafe_get_field :named_name recv))
  (add2sbuf_strconst sbuf ";")
)
(install_method class_objinitstring output_c_declinit outdeclinit_objinitstring)


(defun outcinitfill_objinitstring (recv sbuf)
  (assert_msg "outcinitfill_objinitstring check recv" (is_a recv class_objinitstring))
  (debug_msg recv "outcinitfill_objinitstring recv")
  (let ( (cnam (unsafe_get_field :oie_cname recv)) 
	 (olocvar (unsafe_get_field :oie_locvar recv))
	 )
    (add2sbuf_strconst sbuf "/*inistring ")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf "*/")
    (add2sbuf_indentnl sbuf 1)
    (if olocvar
	(progn
	  (output_c_code olocvar (the_null) sbuf 1)
	  (add2sbuf_strconst sbuf " = (void*)&cdat->")
	  (add2sbuf_string sbuf cnam)
	  (add2sbuf_strconst sbuf ";")
	  (add2sbuf_indentnl sbuf 1)
	  ))
    (add2sbuf_strconst sbuf " cdat->")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf ".discr = ")
    (output_c_code (unsafe_get_field :oie_discr recv) (the_null) sbuf 1)
    (add2sbuf_strconst sbuf ";")
    (add2sbuf_indentnl sbuf 1)
    (add2sbuf_strconst sbuf " strcpy(cdat->")
    (add2sbuf_string sbuf cnam)
    (add2sbuf_strconst sbuf ".val, \"")
    (add2sbuf_cencstring sbuf (unsafe_get_field :oie_data recv))
    (add2sbuf_strconst sbuf "\");")
    (add2sbuf_indentnl sbuf 1)
    ))
(install_method class_objinitstring output_c_initfill outcinitfill_objinitstring)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; in the debug output routineobj-s make huge output, so print the detail only when at toplevel
(defun dbgout_routineobj (self dbgi :long depth)
  (if (<=i depth 0)
      (dbgout_namedobject_method self dbgi 0)
    (dbgout_namedobject_method self dbgi 30))
)
(install_method class_routineobj dbg_output dbgout_routineobj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;; common put destination of objdestinstr....
(defun putobjdest_objdestinstr (recv desto)
  (assert_msg "putobjdest_objdestinstr check recv" (is_a recv class_objdestinstr))
  (debug_msg recv "putobjdest_objdestinstr recv")
  (debug_msg desto "putobjdest_objdestinstr desto@@  " )
  (let ( (destl (unsafe_get_field :obdi_destlist recv)) )
    (if (not (is_list destl))
	(progn 
	  (setq destl (make_list discr_list))
	  (unsafe_put_fields recv :obdi_destlist destl)))
    (let ( (firstd (pair_head (list_first destl))) )
      (if (== firstd desto)
	  (return recv)
	(progn
	  (list_append destl desto)
	  (return recv)
	  )))))
(install_method class_objdestinstr put_objdest putobjdest_objdestinstr)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; notes about code generation
;;;
;;; in addition of the code structure generated by cold-basilys we
;;; need to be able to import values (hence bindings) from a start
;;; environment which is the only argument given to the generated
;;; start routine of the module

(defun outpucod_anydiscr (any declbuf implbuf :long depth)
  (debug_msg any "outpucod_anydiscr any")
  (outcstring_err "* output_c_code unimplemented reciever discriminator ")
  (let ( (discr (discrim any)) ) (outstr_err (unsafe_get_field :named_name discr)))
  (outnewline_err)
  (assert_msg "@@ outpucod_anydiscr not able to output" ())
)
(install_method discr_anyrecv output_c_code outpucod_anydiscr)

(defun outpucod_null (nul declbuf implbuf :long depth)
  (add2sbuf_strconst implbuf "NULL")
)
(install_method discr_nullrecv output_c_code outpucod_null)

;;; catchall for outputting any stuff
(defun outpucod_catchall_root (anyr declbuf implbuf :long depth)
  (debug_msg anyr "outpucod_catchall_root anyr")
  (displaydebugmsg anyr "outpucod_catchall_root anyr")
  (outcstring_err "* output_c_code unimplemented reciever class ")
  (let ( (discr (discrim anyr)) ) (outstr_err (unsafe_get_field :named_name discr)))
  (outnewline_err)
  (assert_msg "@@ outpucod_catchall_root not able to output" ())
)
(install_method class_root output_c_code outpucod_catchall_root)

;;; common code to output a location

;;; just output the #line directive
(defun output_raw_location (loc implbuf :long depth :cstring msg)
  (if loc
      (progn
	(add2sbuf_indentnl implbuf 0)
	(add2sbuf_strconst implbuf "#ifndef MELTGCC_NOLINENUMBERING")
	(add2sbuf_indentnl implbuf 0)
	(add2sbuf_strconst implbuf "#line 0 ")
	(add2sbuf_strconst implbuf " \"")
	(if (is_mixint loc) 
	    (progn
	      (add2sbuf_string implbuf (mixint_val loc))
	      (add2sbuf_strconst implbuf ":")
	      (add2sbuf_longdec implbuf (get_int loc))))
	(if msg (progn
		  (add2sbuf_strconst implbuf ": @")
		  (add2sbuf_strconst implbuf msg)
		  ))
	(add2sbuf_strconst implbuf "\"")
	(add2sbuf_indentnl implbuf 0)
	(add2sbuf_strconst implbuf "#endif /*MELTGCC_NOLINENUMBERING*/")
	(add2sbuf_indentnl implbuf depth)
	)))

;; output the location & set the frame's location
(defun output_location (loc implbuf :long depth :cstring msg)
  (output_raw_location loc implbuf depth msg)
  (if (is_mixint loc) 
      (progn
	(add2sbuf_strconst implbuf "BASILYS_LOCATION(\"")
	(add2sbuf_string implbuf (mixint_val loc))
	(add2sbuf_strconst implbuf ":")
	(add2sbuf_longdec implbuf (get_int loc))
	(if msg (progn
		  (add2sbuf_strconst implbuf ": @")
		  (add2sbuf_strconst implbuf msg)
		  ))
	(add2sbuf_strconst implbuf "\");")
	(add2sbuf_indentnl implbuf depth)
	))
  )

;;; output the code for declaring and initializing the current frame 
(defun output_curframe_init (rou implbuf)
  (debug_msg rou "output_curframe_init rou")
  (let (
	(obody (unsafe_get_field :obrout_body rou))
	(onbval (unsafe_get_field :obrout_nbval rou))
	(onblong (unsafe_get_field :obrout_nblong rou))
	(:long nbval (get_int onbval))
	(:long nblong (get_int onblong))
	(:long isinitial (is_a rou class_initialroutineobj))
	(others (unsafe_get_field :obrout_others rou))
	)       
    ;; output call counter for debugging
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#if ENABLE_CHECKING")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf " static long call_counter__;")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf " long thiscallcounter__ ATTRIBUTE_UNUSED = ++ call_counter__;")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#define callcount thiscallcounter__")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#else")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#define callcount 0L")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#endif")
    ;; output the current frame
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf " struct ")
    (if (is_a rou class_named)
	(progn
	  (add2sbuf_strconst implbuf "frame_")
	  (add2sbuf_string implbuf (unsafe_get_field :named_name rou))
	  (add2sbuf_strconst implbuf "_st ")))
    (add2sbuf_strconst implbuf "{ unsigned nbvar;")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#if ENABLE_CHECKING")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "  const char* flocs;")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#endif")
    (add2sbuf_indentnl implbuf 0)
    ;; we declare a noinitialclos to be sure to never use clos in the
    ;; generated code; if we do, the generated code is invalid C
    (if isinitial
	(add2sbuf_strconst implbuf "  struct basilysclosure_st *noinitialclos;")
      (add2sbuf_strconst implbuf "  struct basilysclosure_st *clos;"))
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "  struct excepth_basilys_st *exh;")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "  struct callframe_basilys_st *prev;")
    (add2sbuf_indentnl implbuf 0)
    (if (>i nbval 0) 
	(progn
	  (add2sbuf_strconst implbuf "#define CURFRAM_NBVARPTR ")
	  (add2sbuf_longdec implbuf nbval)
	  (add2sbuf_indentnl implbuf 0)
	  (add2sbuf_strconst implbuf "  void* varptr[")
	  (add2sbuf_longdec implbuf nbval)
	  (add2sbuf_strconst implbuf "];")
	  (add2sbuf_indentnl implbuf 0))
      (progn
	(add2sbuf_strconst implbuf "/*no varptr*/")
	(add2sbuf_indentnl implbuf 0)
	(add2sbuf_strconst implbuf "#define CURFRAM_NBVARPTR /*none*/0")
	(add2sbuf_indentnl implbuf 0)))
    (if (>i nblong 0)
	(progn
	  (add2sbuf_strconst implbuf "#define CURFRAM_NBVARNUM ")
	  (add2sbuf_longdec implbuf nblong)
	  (add2sbuf_indentnl implbuf 0)
	  (add2sbuf_strconst implbuf "  long varnum[")
	  (add2sbuf_longdec implbuf nblong)
	  (add2sbuf_strconst implbuf "];")
	  (add2sbuf_indentnl implbuf 0))
      (progn
	(add2sbuf_strconst implbuf "/*no varnum*/")
	(add2sbuf_indentnl implbuf 0)
	(add2sbuf_strconst implbuf "#define CURFRAM_NBVARNUM /*none*/0")
	(add2sbuf_indentnl implbuf 0)))
    (if others 
	(progn
	  (debug_msg others "output_curframe_init others")
	  (add2sbuf_strconst implbuf "/*others*/")
	  (add2sbuf_indentnl implbuf 0)
	  (list_every 
	   others
	   (lambda (oloc)
	     (assert_msg "check other oloc" (is_a oloc class_objlocv))
	     (let ( (octyp (unsafe_get_field :obv_type oloc))
		    (oname (unsafe_get_field :obl_cname oloc))
		    )
	       (assert_msg "check octyp" (is_a octyp class_ctype))
	       (add2sbuf_string implbuf (unsafe_get_field :ctype_cname octyp))
	       (add2sbuf_strconst implbuf " ")
	       (add2sbuf_string implbuf oname)
	       (add2sbuf_strconst implbuf ";")
	       (add2sbuf_indentnl implbuf 0))
	     ))
	  )
      (progn
	(add2sbuf_strconst implbuf "/*no others*/")
	(add2sbuf_indentnl implbuf 0))
      )
    ;; end of curframe
    (add2sbuf_strconst implbuf "  long _spare_; } curfram__ = {")
    (add2sbuf_longdec implbuf nbval)
    (add2sbuf_strconst implbuf ", ")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#if ENABLE_CHECKING")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf " (const char *)0, ")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#endif")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf " (struct basilysclosure_st *)0, ")
    (add2sbuf_strconst implbuf " (struct excepth_basilys_st *)0, ")
    (add2sbuf_strconst implbuf " (struct callframe_basilys_st *) 0, ")
    (if (>i nbval 0) 
	(let ( (:long ix 0) )
	  (add2sbuf_indentnl implbuf 0)
	  (add2sbuf_strconst implbuf " /*ptrvars*/{")
	  (forever ptrloop
		   (if (>=i ix nbval) (exit ptrloop))
		   (if (>i ix 0) (add2sbuf_strconst implbuf ","))
		   (if (==i 0 (%iraw ix 8)) 
		       (add2sbuf_indentnl implbuf 2))
		   (add2sbuf_strconst implbuf " (void*)0")
		   (setq ix (+i ix 1))
		   )
	  (add2sbuf_strconst implbuf "},") ;
	  ))
    (if (>i nblong 0) 
	(let ( (:long ix 0) )
	  (add2sbuf_indentnl implbuf 0)
	  (add2sbuf_strconst implbuf " /*numvars*/{")
	  (forever ptrloop
		   (if (>=i ix nblong) (exit ptrloop))
		   (if (>i ix 0) (add2sbuf_strconst implbuf ","))
		   (if (==i 0 (%iraw ix 8)) 
		       (add2sbuf_indentnl implbuf 2))
		   (add2sbuf_strconst implbuf " 0L")
		   (setq ix (+i ix 1))
		   )
	  (add2sbuf_strconst implbuf "},") ;
	  ))
    (list_every 
     others
     (lambda (oloc)
       (add2sbuf_strconst implbuf " (void*)0,")))
    (add2sbuf_strconst implbuf " 0L };")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf " curfram__.prev = (void*) basilys_topframe;")
    (add2sbuf_indentnl implbuf 0)
    (if  (is_a rou class_initialroutineobj)
	(progn
	  (add2sbuf_strconst implbuf " curfram__.noinitialclos = NULL /*since initroutine*/;")
	  (add2sbuf_indentnl implbuf 0)
	  )
      (progn
	(add2sbuf_strconst implbuf " curfram__.clos = closp_;")
	(add2sbuf_indentnl implbuf 0)
	))
    (add2sbuf_strconst implbuf " basilys_topframe = (void*) &curfram__;")
    (add2sbuf_indentnl implbuf 0)
    ))

;;; output code for a procroutine
(defun outpucod_procroutine (prou declbuf implbuf :long depth)
  (assert_msg "check prou" (is_a prou class_procroutineobj))
  (let ( (onam (unsafe_get_field :named_name prou)) 
	 (obody (unsafe_get_field :obrout_body prou))
	 (onbval (unsafe_get_field :obrout_nbval prou))
	 (onblong (unsafe_get_field :obrout_nblong prou))
	 (:long nbval (get_int onbval))
	 (:long nblong (get_int onblong))
	 (others (unsafe_get_field :obrout_others prou))
	 (ogargs (unsafe_get_field :oprout_getargs prou))
	 (oretval (unsafe_get_field :obrout_retval prou))
	 (orloc (unsafe_get_field :oprout_loc prou))
	 (ofunam (unsafe_get_field :oprout_funam prou))
	 )
    (debug_msg prou "outpucod_procroutine prou")
    (if (not (is_string ofunam)) 
	(setq ofunam (make_stringconst discr_string "**")))
    ;; output the declaration
    (add2sbuf_indentnl declbuf 0)
    (add2sbuf_indentnl declbuf 0)
    (output_raw_location orloc implbuf 0 "proc")
    (add2sbuf_indentnl declbuf 0)
    (if (is_mixint orloc)
	(output_raw_location orloc declbuf 0 "procdecl")
	)
    (add2sbuf_strconst declbuf "static basilys_ptr_t ")
    (add2sbuf_string declbuf onam)
    (add2sbuf_strconst declbuf "(basilysclosure_ptr_t closp_,")
    (add2sbuf_strconst declbuf " basilys_ptr_t firstargp_,")
    (add2sbuf_strconst declbuf " const char xargdescr_[],")
    (add2sbuf_strconst declbuf " union basilysparam_un *xargtab_,")
    (add2sbuf_strconst declbuf " const char xresdescr_[],")
    (add2sbuf_strconst declbuf " union basilysparam_un *xrestab_);")
    (add2sbuf_indentnl declbuf 0)
    ;; output the implementation
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "static basilys_ptr_t")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_string implbuf onam)
    (add2sbuf_strconst implbuf "(basilysclosure_ptr_t closp_,")
    (add2sbuf_strconst implbuf " basilys_ptr_t firstargp_,")
    (add2sbuf_strconst implbuf " const char xargdescr_[],")
    (add2sbuf_strconst implbuf " union basilysparam_un *xargtab_,")
    (add2sbuf_indentnl implbuf 5)
    (add2sbuf_strconst implbuf " const char xresdescr_[],")
    (add2sbuf_strconst implbuf " union basilysparam_un *xrestab_) {")
    (output_curframe_init prou implbuf)
    (add2sbuf_strconst implbuf "basilys_trace_start(\"")
    (add2sbuf_string implbuf ofunam)
    (add2sbuf_strconst implbuf "\", callcount);")
    (add2sbuf_indentnl implbuf 0)
    ;; output the argument getting
    (add2sbuf_strconst implbuf "/*getargs*/")
    (add2sbuf_indentnl implbuf 0)
    (debug_msg ogargs "outpucod_procroutine output ogargs")
    (assert_msg "check ogargs" (is_multiple ogargs))
    (multiple_every
     ogargs
     (lambda (curget :long curank) 
       (add2sbuf_indentnl implbuf 1)
       (add2sbuf_strconst implbuf "/*getarg#")
       (add2sbuf_longdec implbuf curank)
       (add2sbuf_strconst implbuf "*/")
       (add2sbuf_indentnl implbuf 1)
       (output_c_code curget declbuf implbuf 1)
       ))
    (add2sbuf_strconst implbuf ";")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf " goto lab_endgetargs;")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "lab_endgetargs:;")
    (add2sbuf_indentnl implbuf 0)
    ;; output the body
    (debug_msg obody "outpucod_procroutine output obody")
    (assert_msg "check obody" (is_list obody))
    (add2sbuf_strconst implbuf "/*body*/")
    (add2sbuf_indentnl implbuf 0)
    (list_every
     obody
     (lambda (curbody)
       (if (and curbody (not (is_a curbody class_objpurevalue)))
	   (progn
	     (output_c_code curbody declbuf implbuf 0)
	     (add2sbuf_indentnl implbuf 0)))))
    ;; end of implementation
    (add2sbuf_strconst implbuf ";")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf " goto labend_rout;")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "labend_rout:")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "basilys_trace_end(\"")
    (add2sbuf_string implbuf ofunam)
    (add2sbuf_strconst implbuf "\", callcount);")
    (add2sbuf_strconst implbuf "  basilys_topframe = (void *) curfram__.prev;")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf " return ")
    (if oretval 
	(output_c_code oretval declbuf implbuf 1)
      (add2sbuf_strconst implbuf "/*noretval*/ NULL"))
    (add2sbuf_strconst implbuf ";")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#undef callcount")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#undef CURFRAM_NBVARNUM")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#undef CURFRAM_NBVARPTR")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "} /*end ")
    (add2sbuf_string implbuf onam)
    (add2sbuf_strconst implbuf "*/")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_indentnl implbuf 0)
    ))
(install_method class_procroutineobj output_c_code outpucod_procroutine)



;;;;;;;;;;;;;;;;
;; output at start of initial routine the get of symbols or keywords
(defun output_code_getsymkw (curpdat implbuf)
  (let ( (odat (unsafe_get_field :oie_data curpdat))
	 (oloc (unsafe_get_field :oie_locvar curpdat)) 
	 )
    (cond 
     ;; first check for keywords, since they are also symbols (so order is important)
     ( (is_a odat class_nrep_datakeyword)
       (let ( (nsy (unsafe_get_field :ndsy_namestr odat)) )
	 (output_location (unsafe_get_field :nrep_loc odat) implbuf 2 "getkeywd")
	 (add2sbuf_strconst implbuf "{ basilys_ptr_t kw_")
	 (add2sbuf_cident implbuf nsy)
	 (add2sbuf_strconst implbuf " = basilysgc_named_keyword(\"")
	 (add2sbuf_string implbuf nsy)
	 (add2sbuf_strconst implbuf "\", BASILYS_GET);")
	 (add2sbuf_indentnl implbuf 2)
	 (add2sbuf_strconst implbuf "if (kw_")
	 (add2sbuf_cident implbuf nsy)
	 (add2sbuf_strconst implbuf ") ")
	 (output_c_code oloc (the_null) implbuf 2)
	 (add2sbuf_strconst implbuf " = (void*) kw_")
	 (add2sbuf_cident implbuf nsy)
	 (add2sbuf_strconst implbuf "; }")
	 (add2sbuf_indentnl implbuf 1)
	 )) 
     ( (is_a odat class_nrep_datasymbol)
       (let ( (nsy (unsafe_get_field :ndsy_namestr odat)) )
	 (output_location (unsafe_get_field :nrep_loc odat) implbuf 2 "getsymbol")
	 (add2sbuf_strconst implbuf "{ basilys_ptr_t sy_")
	 (add2sbuf_cident implbuf nsy)
	 (add2sbuf_strconst implbuf " = basilysgc_named_symbol(\"")
	 (add2sbuf_string implbuf nsy)
	 (add2sbuf_strconst implbuf "\", BASILYS_GET);")
	 (add2sbuf_indentnl implbuf 2)
	 (add2sbuf_strconst implbuf "if (sy_")
	 (add2sbuf_cident implbuf nsy)
	 (add2sbuf_strconst implbuf ") ")
	 (output_c_code oloc (the_null) implbuf 2)
	 (add2sbuf_strconst implbuf " = (void*) sy_")
	 (add2sbuf_cident implbuf nsy)
	 (add2sbuf_strconst implbuf "; }")
	 (add2sbuf_indentnl implbuf 1)
	 ))
     ))
  )

;; output at end of initial routine the interning of symbols & keywords
(defun output_code_internsymkw (curpdat implbuf)
  (let ( (odat (unsafe_get_field :oie_data curpdat))
	 (oloc (unsafe_get_field :oie_locvar curpdat)) 
	 )
    (cond 
     ;; first check for keywords, since they are also symbols (so order is important)
     ( (is_a odat class_nrep_datakeyword)
       (let ( (nsy (unsafe_get_field :ndsy_namestr odat)) )
	 (output_location (unsafe_get_field :nrep_loc odat) implbuf 1 "internkeywd")
	 (add2sbuf_strconst implbuf "/*")
	 (add2sbuf_string implbuf nsy)
	 (add2sbuf_strconst implbuf "*/ (void) basilysgc_intern_keyword(")
	 (output_c_code oloc (the_null) implbuf 1)
	 (add2sbuf_strconst implbuf ");")
	 (add2sbuf_indentnl implbuf 1)))
     ( (is_a odat class_nrep_datasymbol)
       (let ( (nsy (unsafe_get_field :ndsy_namestr odat)) )
	 (output_location (unsafe_get_field :nrep_loc odat) implbuf 1 "internsymb")
	 (add2sbuf_strconst implbuf "/*")
	 (add2sbuf_string implbuf nsy)
	 (add2sbuf_strconst implbuf "*/ (void) basilysgc_intern_symbol(")
	 (output_c_code oloc (the_null) implbuf 1)
	 (add2sbuf_strconst implbuf ");")
	 (add2sbuf_indentnl implbuf 1))
       ))))

;; output code for the initial routine
(defun outpucod_initialroutine (pini declbuf implbuf :long depth)
  (assert_msg "check pini" (is_a pini class_initialroutineobj))
  (add2sbuf_indentnl declbuf 0)
  (add2sbuf_indentnl declbuf 0)
  (add2sbuf_strconst declbuf "void* start_module_basilys(void*);")
  (add2sbuf_indentnl declbuf 0)
  (add2sbuf_indentnl implbuf 0)
  (add2sbuf_indentnl implbuf 0)
  (add2sbuf_indentnl implbuf 0)
  (add2sbuf_strconst implbuf "void* start_module_basilys(void* modatap_) {")
  (add2sbuf_indentnl implbuf 0)
  (debug_msg pini "outpucod_initialroutine pini")
  ;; generate the initial data structure
  (let ( 
	(idatup (unsafe_get_field :oirout_data pini)) 
	(irfill (unsafe_get_field :oirout_fill pini))
	(oretval (unsafe_get_field :obrout_retval pini))
	) 
    (debug_msg idatup "outpucod_initialroutine start idatup")
    (debug_msg irfill "outpucod_initialroutine start irfill")
    (add2sbuf_indentnl implbuf 1)
    (add2sbuf_strconst implbuf "struct cdata_st {")
    (multiple_every
     idatup
     (lambda (curdat :long curk) 
       (debug_msg curdat "outpucod_initialroutine curdat")
       (add2sbuf_indentnl implbuf 1)
       (output_c_declinit curdat implbuf)))
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf " long spare_;")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "} *cdat = NULL;")
    (add2sbuf_indentnl implbuf 1)
    ;; generate the initial frame
    (output_curframe_init pini implbuf)
    ;; generate the allocation of cdat
    (add2sbuf_strconst implbuf " cdat = basilysgc_allocate(sizeof(*cdat),0);")
    (add2sbuf_indentnl implbuf 1)
    (add2sbuf_strconst implbuf " basilys_prohibit_garbcoll = TRUE;")
    (add2sbuf_indentnl implbuf 1)
;;;
;;; generate the initial predef of cdat
    (add2sbuf_strconst implbuf "/*initial routine predef*/")
    (add2sbuf_indentnl implbuf 1)
    (multiple_every
     idatup
     (lambda (curpdat :long curk) 
       (debug_msg curpdat "outpucod_initialroutine curpdat inipredef")
       (output_c_initpredef curpdat implbuf)))
;;;
;;; generate the initial filling of cdat
    (add2sbuf_strconst implbuf "/*initial routine fill*/")
    (add2sbuf_indentnl implbuf 1)
    (multiple_every
     idatup
     (lambda (curfil :long curk) 
       (debug_msg curfil "outpucod_initialroutine curfil")
       (add2sbuf_indentnl implbuf 1)
       (output_c_initfill curfil implbuf)))
;;;
;;; generate the get of symbols & keywords
    (add2sbuf_strconst implbuf "/*initial routine get symbol & keyword*/")
    (add2sbuf_indentnl implbuf 1)
    (add2sbuf_strconst implbuf "if (BASILYSG(TOKENIZER)) {")
    (add2sbuf_indentnl implbuf 2)
    (multiple_every
     idatup
     (lambda (curpdat :long curk) 
       (debug_msg curpdat "outpucod_initialroutine curpdat getsymkey")
       (if (is_a curpdat class_objinitobject)
	   (output_code_getsymkw curpdat implbuf)
	 )
       ))
    (add2sbuf_strconst implbuf "}; /*end get symbols & keywords */")
    (add2sbuf_indentnl implbuf 1)
;;;;;;;
;;; initialize the variables
;;;
    (debug_msg irfill "outpucod_initialroutine irfill")
;;; clear the cdat for safety and renable GC
    (add2sbuf_strconst implbuf " cdat = NULL;")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf " basilys_prohibit_garbcoll = FALSE;")
    (add2sbuf_indentnl implbuf 0)
;;; output the body
;;;
    (add2sbuf_strconst implbuf "/*initial routine body*/")
    (add2sbuf_indentnl implbuf 0)
    (let ( (ibody (unsafe_get_field :obrout_body pini)) 
	   )
      (debug_msg ibody "outpucod_initialroutine ibody")
      (list_every
       ibody
       (lambda (curbody)
	 (debug_msg curbody "outpucod_initialroutine curbody")
	 (if (and curbody (not (is_a curbody class_objpurevalue)))
	     (progn
	       (output_c_code curbody declbuf implbuf 1)
	       (add2sbuf_indentnl implbuf 1))))))
;;; ouput the interning of symbols & keywwords
    (add2sbuf_strconst implbuf "/*initial routine interning of symbol & keyword*/")
    (add2sbuf_indentnl implbuf 1)
    (multiple_every
     idatup
     (lambda (curpdat :long curk) 
       (debug_msg curpdat "outpucod_initialroutine curpdat internkeysym")
       (if (is_a curpdat class_objinitobject)
	   (output_code_internsymkw curpdat implbuf)
	 )
       ))
    (add2sbuf_strconst implbuf "/*end interning of symbols & keywords */")
    (add2sbuf_indentnl implbuf 1)
;;; end of implementation
;;;
    (add2sbuf_strconst implbuf ";")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf " goto labend_rout;")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "labend_rout:  basilys_topframe = (void *) curfram__.prev;")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf " return ")
    (if oretval 
	(output_c_code oretval declbuf implbuf 1)
      (add2sbuf_strconst implbuf "/*noretval*/ NULL"))
    (add2sbuf_strconst implbuf ";")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#undef callcount")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#undef CURFRAM_NBVARNUM")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "#undef CURFRAM_NBVARPTR")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_strconst implbuf "} /* end start_module_basilys */")
    (add2sbuf_indentnl implbuf 0)
    (add2sbuf_indentnl implbuf 0)
    ))
(install_method class_initialroutineobj output_c_code outpucod_initialroutine)



;; output code for argument getter
(defun outpucod_getarg (garg declbuf implbuf :long depth)
  (assert_msg "check garg" (is_a garg class_objgetarg))
  (debug_msg garg "outpucod_getarg garg")
  (let ( (oloc (unsafe_get_field :obarg_obloc garg)) 
	 (nloc (unsafe_get_field :obi_loc garg))
	 (obind (unsafe_get_field :obarg_bind garg))
	 (:long rkbind (get_int obind))
	 (ctybind (unsafe_get_field :fbind_type obind))
	 )
    (assert_msg "check obind" (is_a obind class_formal_binding))
    (output_location nloc implbuf depth "getarg")
    (assert_msg "check oloc" (is_a oloc class_objlocv))
    (assert_msg "check ctybind" (is_a ctybind class_ctype))
    (if (==i rkbind 0)
	(progn
	  (assert_msg "check ctybind first" (== ctybind ctype_value))
	  (output_c_code oloc declbuf implbuf depth)
	  (add2sbuf_strconst implbuf " = firstargp_;")
	  (add2sbuf_indentnl implbuf depth)
	  )
      (let (
	    ;; use the ctype_parchar ctype_argfield
	    (parc (unsafe_get_field :ctype_parchar ctybind))
	    (argf (unsafe_get_field :ctype_argfield ctybind)) 
	    )
	(if (not (is_string parc)) 
	    (error_strv oloc "impossible argument ctype" 
			(unsafe_get_field :named_name ctybind)))
	(add2sbuf_strconst implbuf "if (xargdescr_[")
	(add2sbuf_longdec implbuf (-i rkbind 1))
	(add2sbuf_strconst implbuf "] != ")
	(add2sbuf_string implbuf parc)
	(add2sbuf_strconst implbuf ") goto lab_endgetargs;")	
	(add2sbuf_indentnl implbuf depth)
	(if (== ctybind ctype_value)
	    (progn
	      (output_c_code oloc declbuf implbuf depth)
	      (add2sbuf_strconst implbuf " = (xargtab_[")
	      (add2sbuf_longdec implbuf (-i rkbind 1))
	      (add2sbuf_strconst implbuf "].bp_aptr) ? (*(xargtab_[")
	      (add2sbuf_longdec implbuf (-i rkbind 1))
	      (add2sbuf_strconst implbuf "].bp_aptr)) : NULL;")		
	      (add2sbuf_indentnl implbuf depth)
	      (add2sbuf_strconst implbuf "gcc_assert(basilys_discr(")
	      (output_c_code oloc declbuf implbuf depth)
	      (add2sbuf_strconst implbuf ") != NULL);")	
	      (add2sbuf_indentnl implbuf depth)
	      )
	  (progn
	    (output_c_code oloc declbuf implbuf depth)
	    (add2sbuf_strconst implbuf " = xargtab_[")
	    (add2sbuf_longdec implbuf (-i rkbind 1))
	    (add2sbuf_strconst implbuf "].")
	    (add2sbuf_string implbuf argf)
	    (add2sbuf_strconst implbuf ";")
	    )
	  )
	(add2sbuf_indentnl implbuf depth)
	))
    (debug_msg garg "outpucod_getarg done garg")
    ))
(install_method class_objgetarg output_c_code outpucod_getarg)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; output code for objlocv
(defun outpucod_objlocv (locv declbuf implbuf :long depth)
  (assert_msg "check locv" (is_a locv class_objlocv))
  ;; (debug_msg locv "outpucod_objlocv locv")
  (let ( 
	(ltyp (unsafe_get_field :obv_type locv))
	(loff (unsafe_get_field :obl_off locv))
	(lcnam (unsafe_get_field :obl_cname locv))
	)
    (cond 
     ( (== ltyp ctype_value)
       (add2sbuf_strconst implbuf "/*_.")
       (add2sbuf_string implbuf lcnam)
       (add2sbuf_strconst implbuf "*/ curfptr[")
       (add2sbuf_longdec implbuf (get_int loff))
       (add2sbuf_strconst implbuf "]") )
     ( (== ltyp ctype_long)
       (add2sbuf_strconst implbuf "/*_#")
       (add2sbuf_string implbuf lcnam)
       (add2sbuf_strconst implbuf "*/ curfnum[")
       (add2sbuf_longdec implbuf (get_int loff))
       (add2sbuf_strconst implbuf "]") )
     (:else
      (add2sbuf_strconst implbuf "/*_?*/ curfram__.")
      (add2sbuf_string implbuf lcnam)))
    )
  )
(install_method class_objlocv output_c_code outpucod_objlocv)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; output code for object closed occurrence
(defun outpucod_objcloccv (occv  declbuf implbuf :long depth)
  (assert_msg "check occv" (is_a occv class_objcloccv))
  (let ( (ooff (unsafe_get_field :obc_off occv))
	 (onam (unsafe_get_field :obc_name occv)) )
    (assert_msg "check valueness of closed occurrence" 
		(== (unsafe_get_field :obv_type occv) ctype_value))
    (add2sbuf_strconst implbuf "(/*~")
    (add2sbuf_string implbuf onam)
    (add2sbuf_strconst implbuf "*/ curfclos->tabval[")
    (add2sbuf_longdec implbuf (get_int ooff))
    (add2sbuf_strconst implbuf "])")
))
(install_method class_objcloccv output_c_code outpucod_objcloccv)


;;;;;;;;;;;;;;;;
;; output code for object const [closed] occurrence
(defun outpucod_objconstv (ocnstv  declbuf implbuf :long depth)
  (assert_msg "check ocnstv" (is_a ocnstv class_objconstv))
  (debug_msg ocnstv "outpucod_objconstv ocnstv")
  (let ( (ooff (unsafe_get_field :obc_off ocnstv))
	 (onam (unsafe_get_field :obc_name ocnstv)) )
    (assert_msg "check valueness of const occurrence" 
		(== (unsafe_get_field :obv_type ocnstv) ctype_value))
    (add2sbuf_strconst implbuf "(/*!")
    (add2sbuf_string implbuf onam)
    ;; was for debug
    (add2sbuf_strconst implbuf "*/ curfrout->tabval[")
    (add2sbuf_longdec implbuf (get_int ooff))
    (add2sbuf_strconst implbuf "])")
))
(install_method class_objconstv output_c_code outpucod_objconstv)



;; output code for objblock
(defun outpucod_objblock (oblo declbuf implbuf :long depth)
  (assert_msg "check oblo" (is_a oblo class_objblock))
  (debug_msg oblo "outpucod_objblock oblo")
  (output_location (unsafe_get_field :obi_loc oblo) implbuf depth "block")
  (let ( (bodyl (unsafe_get_field :oblo_bodyl oblo))
	 (epil (unsafe_get_field :oblo_epil oblo)) 
	 (boxdepthp1 (make_integerbox discr_integer (+i depth 1)))
	 )
    (add2sbuf_strconst implbuf "/*block*/{")
    (if (is_list bodyl)
	(progn
	  (add2sbuf_indentnl implbuf (+i depth 1))
	  (list_every 
	   bodyl
	   (lambda (curbody)
	     (let ( (:long depthp1 (get_int boxdepthp1)) )
	       (if (and curbody (not (is_a curbody class_objpurevalue)))
		   (progn
		     (output_c_code curbody declbuf implbuf depthp1)
		     (add2sbuf_strconst implbuf ";")
		     (add2sbuf_indentnl implbuf depthp1))))))))
    (if (is_list epil)
	(progn
	  (add2sbuf_strconst implbuf "/*epilog*/")
	  (add2sbuf_indentnl implbuf (+i depth 1))
	  (list_every
	   epil
	   (lambda (curepil)
	     (let ( (:long depthp1 (get_int boxdepthp1)) )
	       (if (and curepil (not (is_a curepil class_objpurevalue)))
		   (progn
		     (output_c_code curepil declbuf implbuf depthp1)
		     (add2sbuf_strconst implbuf ";")
		     (add2sbuf_indentnl implbuf depthp1))))))))
    (add2sbuf_strconst implbuf "}")
    (add2sbuf_indentnl implbuf depth)
    )
  (debug_msg oblo "outpucod_objblock done oblo")
  )
(install_method class_objblock output_c_code outpucod_objblock)


;;; add a cname for a cloned identifier into a buffer
(defun add2sbuf_clonsym (sbuf csy)
  (assert_msg "check sbuf" (is_strbuf sbuf))
  (assert_msg "check csy" (is_a csy class_clonedsymbol))
  (let ( (cnam (unsafe_get_field :named_name csy))
	 (:long rk (get_int (unsafe_get_field :csym_urank csy))) )
    (add2sbuf_cident sbuf cnam)
    (add2sbuf_strconst sbuf "_")
    (add2sbuf_longdec sbuf rk)
))

;;; output code for objloop
(defun outpucod_objloop (oblo declbuf implbuf :long depth)
  (assert_msg "check oblo" (is_a oblo class_objloop))
  (debug_msg oblo "outpucod_objloop oblo")
  (let ( (bodyl (unsafe_get_field :oblo_bodyl oblo))
	 (epil (unsafe_get_field :oblo_epil oblo)) 
	 (lab (unsafe_get_field :obloop_label oblo))
	 (oloc (unsafe_get_field :obi_loc oblo))
	 (boxdepthp1 (make_integerbox discr_integer (+i depth 1)))
	 )
    (assert_msg "check lab" (is_a lab class_clonedsymbol))
    (output_location oloc implbuf depth "loop")
    (add2sbuf_strconst implbuf "/*loop*/{ labloop_")
    (add2sbuf_clonsym implbuf lab)
    (add2sbuf_strconst implbuf ":;")
    (if (is_list bodyl)
	(progn
	  (output_location oloc implbuf depth "loopbody")
	  (add2sbuf_indentnl implbuf (+i depth 1))
	  (list_every
	   bodyl
	   (lambda (curbody)
	     (let ( (:long depthp1 (get_int boxdepthp1)) )
	       (if (and curbody (not (is_a curbody class_objpurevalue)))
		   (output_c_code curbody declbuf implbuf depthp1))
	       (add2sbuf_strconst implbuf ";")
	       (add2sbuf_indentnl implbuf depthp1))))))
    (add2sbuf_strconst implbuf ";")
    (add2sbuf_indentnl implbuf (+i depth 1))
    (add2sbuf_strconst implbuf " goto labloop_")
    (add2sbuf_clonsym implbuf lab)
    (add2sbuf_strconst implbuf ";")
    (add2sbuf_indentnl implbuf (+i depth 1))
    (add2sbuf_strconst implbuf " labexit_")
    (add2sbuf_clonsym implbuf lab)
    (add2sbuf_strconst implbuf ":;")
    (if (is_list epil)
	(progn
	  (output_location oloc implbuf depth "loopepilog")
	  (add2sbuf_strconst implbuf "/*loopepilog*/")
	  (add2sbuf_indentnl implbuf (+i depth 1))
	  (list_every
	   epil
	   (lambda (curepil)
	     (let ( (:long depthp1 (get_int boxdepthp1)) )
	       (if (and curepil (not (is_a curepil class_objpurevalue)))
		   (output_c_code curepil declbuf implbuf depthp1))
	       (add2sbuf_strconst implbuf ";")
	       (add2sbuf_indentnl implbuf depthp1))))))
    (add2sbuf_strconst implbuf "}")
    (add2sbuf_indentnl implbuf depth)
    )
  (debug_msg oblo "outpucod_objloop done oblo")
  )
(install_method class_objloop output_c_code outpucod_objloop)


;;; output code for objexit
(defun outpucod_objexit (obxi declbuf implbuf :long depth)
  (assert_msg "check obxi" (is_a obxi class_objexit))
  (debug_msg obxi "outpucod_objexit obxi")
  (let ( (olab (unsafe_get_field :obexit_label obxi))
	 (loc (unsafe_get_field :obi_loc obxi))
	 )
    (assert_msg "check olab" (is_a olab class_clonedsymbol))
    (output_location loc implbuf depth "exit")
    (add2sbuf_strconst implbuf "/*exit*/{")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf " goto labexit_")
    (add2sbuf_clonsym implbuf olab)	
    (add2sbuf_strconst implbuf ";}")
    (add2sbuf_indentnl implbuf depth)    
    ))
(install_method class_objexit output_c_code outpucod_objexit)

;;; output code for objcompute
(defun outpucod_objcompute (obcomp declbuf implbuf :long depth)
  (assert_msg "check obcomp" (is_a obcomp class_objcompute))
  (let ( (cdest (unsafe_get_field :obdi_destlist obcomp)) ; destination list
	 (cloc (unsafe_get_field :obi_loc obcomp))
	 (cexp (unsafe_get_field :obcpt_expr obcomp)) 
	 (boxdepthp1 (make_integerbox discr_integer (+i depth 1)))
	 )
    (debug_msg obcomp "outpucod_objcompute obcomp")
    (output_location cloc implbuf depth "compute")
    (if (is_list cdest)
	(list_every
	 cdest
	 (lambda (destcur) 
	   (output_c_code destcur declbuf implbuf (get_int boxdepthp1))
	   (add2sbuf_strconst implbuf " = ")
	   ())))
    (if (is_list cexp)
	(list_every
	 cexp 
	 (lambda (expcur) 
	   (output_c_code expcur declbuf implbuf (get_int boxdepthp1))))
      (output_c_code cexp declbuf implbuf (+i depth 1))
      )
    (add2sbuf_strconst implbuf ";")
    ))
(install_method class_objcompute output_c_code outpucod_objcompute)


;; output a conditional
(defun outpucod_objcond (ocond declbuf implbuf :long depth)
  (assert_msg "check ocond" (is_a ocond class_objcond))
  (debug_msg ocond "outpucod_objcond ocond")
  (let ( (cloc (unsafe_get_field :obi_loc ocond))
	 (ctest (unsafe_get_field :obcond_test ocond))
	 (cthen (unsafe_get_field :obcond_then ocond))
	 (celse (unsafe_get_field :obcond_else ocond)) 
	 )
    (assert_msg "check ctest" (notnull ctest))
    (output_location cloc implbuf depth "cond")
    (add2sbuf_strconst implbuf "/*cond*/ if (")
    (output_c_code ctest declbuf implbuf (+i depth 1))
    (add2sbuf_strconst implbuf ") /*then*/ {")
    (add2sbuf_indentnl implbuf depth)
    (if (and cthen (not (is_a cthen class_objpurevalue)))
	(progn
	  (output_location cloc implbuf depth "cond.then")
	  (output_c_code cthen declbuf implbuf (+i depth 1))
	  (add2sbuf_strconst implbuf ";")
	  ))
    (add2sbuf_indentnl implbuf depth)
    (if (and celse (not (is_a celse class_objpurevalue)))
	(progn
	  (output_location cloc implbuf depth "cond.else")
	  (add2sbuf_strconst implbuf "} else {")
	  (add2sbuf_indentnl implbuf (+i depth 1))
	  (output_c_code celse declbuf implbuf (+i depth 1))
	  (add2sbuf_strconst implbuf ";")
	  (add2sbuf_indentnl implbuf (+i depth 1))
	  (add2sbuf_strconst implbuf "}") ;
	  )
      (add2sbuf_strconst implbuf "} /*noelse*/")
      )
    (add2sbuf_indentnl implbuf depth)
    ) 
  (debug_msg ocond "outpucod_objcond end ocond")
  )
(install_method class_objcond output_c_code outpucod_objcond)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; output a cppif
(defun outpucod_objcppif (opif declbuf implbuf :long depth)
  (assert_msg "check opif" (is_a opif class_objcppif))
  (debug_msg opif "outpucod_objcppif opif")
  (let ( (cloc (unsafe_get_field :obi_loc opif))
	 (ccond (unsafe_get_field :obifp_cond opif))
	 (cthen (unsafe_get_field :obifp_then opif))
	 (celse (unsafe_get_field :obifp_else opif))
	 (:long depthp1 (+i 1 depth))
	 )
    (assert_msg "check ccond" (is_string ccond))
    (output_raw_location cloc implbuf depth "cppif")
    (add2sbuf_strconst implbuf "#if ")
    (add2sbuf_string implbuf ccond)
    (add2sbuf_indentnl implbuf depthp1)
    (output_location cloc implbuf depth "cppif.then")
    (output_c_code cthen declbuf implbuf depthp1)
    (add2sbuf_indentnl implbuf depthp1)
    (add2sbuf_strconst implbuf "#else /*")
    (add2sbuf_string implbuf ccond)
    (add2sbuf_strconst implbuf "*/")
    (add2sbuf_indentnl implbuf depthp1)
    (output_location cloc implbuf depth "cppif.else")
    (output_c_code celse declbuf implbuf depthp1)
    (add2sbuf_indentnl implbuf depthp1)
    (add2sbuf_strconst implbuf "#endif /*")
    (add2sbuf_string implbuf ccond)
    (add2sbuf_strconst implbuf "*/")
    (add2sbuf_indentnl implbuf depthp1)
))
(install_method class_objcppif output_c_code outpucod_objcppif)


;; output an application
(defun outpucod_objapply (oapp declbuf implbuf :long depth)
  (assert_msg "check oapp" (is_a oapp class_objapply))
  (debug_msg oapp "outpucod_objapply oapp")
  (let (
	(aloc (unsafe_get_field :obi_loc oapp))
	(adest (unsafe_get_field :obdi_destlist oapp))
	(oclos (unsafe_get_field :obapp_clos oapp))
	(oargs (unsafe_get_field :obapp_args oapp))
	(:long nbarg (multiple_length oargs))
	(paramdesclist (make_list discr_list))
	(boxdepthp1 (make_integerbox discr_integer (+i 1 depth)))
	)
    (output_location aloc implbuf depth "apply")
    (add2sbuf_strconst implbuf "/*apply*/{")
    (add2sbuf_indentnl implbuf (+i 1 depth))
    (if (>i nbarg 1)
	(progn
	  (add2sbuf_strconst implbuf "union basilysparam_un argtab[")
	  (add2sbuf_longdec implbuf (-i nbarg 1))
	  (add2sbuf_strconst implbuf "];")
	  (add2sbuf_indentnl implbuf (+i 1 depth))
	  (add2sbuf_strconst implbuf "memset(&argtab, 0, sizeof(argtab));")
	  (add2sbuf_indentnl implbuf (+i 1 depth))
	  ;; output the initialization of argtab and fill the paramdesclist
	  (multiple_every
	   oargs
	   (lambda (curarg :long curank)
	     (debug_msg curarg "outputcod_objapply curarg")
	     (assert_msg "outputcod_objapply check curarg not objinstr" (not (is_a curarg class_objinstr)))
	    ; (cbreak_msg "outputcod_objapply curarg")
	     (if (>i curank 0)
		 (let ( (curctyp (get_ctype curarg (the_null))) )
		   (debug_msg curctyp "outputcod_objapply curctyp")
		   (assert_msg "check curctyp" (is_a curctyp class_ctype))
		   (output_location aloc implbuf (get_int boxdepthp1) "apply.arg")
		   (add2sbuf_strconst implbuf "argtab[")
		   (add2sbuf_longdec implbuf  (-i curank 1))
		   (add2sbuf_strconst implbuf "].")
		   (list_append paramdesclist (unsafe_get_field :ctype_parstring curctyp))
		   (cond ( (null curarg)
			   (add2sbuf_strconst implbuf "bp_aptr = (basilys_ptr_t*)NULL"))
			 ( (== curctyp ctype_value)
			   (add2sbuf_strconst implbuf "bp_aptr = (basilys_ptr_t*) &")
			   (output_c_code curarg declbuf implbuf (get_int boxdepthp1))
			 )
		     (:else 
		      (add2sbuf_string implbuf (unsafe_get_field :ctype_argfield curctyp))
		      (add2sbuf_strconst implbuf " = ")
		      (output_c_code curarg declbuf implbuf (get_int boxdepthp1))
		      ))
		   (add2sbuf_strconst implbuf ";")
		   ))))
	  (add2sbuf_indentnl implbuf (get_int boxdepthp1))
	  ))
;;; output the destination(s)
    (list_every 
     adest
     (lambda (curdest) 
       (output_c_code curdest declbuf implbuf (get_int boxdepthp1))
       (add2sbuf_strconst implbuf " = ")))
    ;; output the apply and the closure
    (add2sbuf_strconst implbuf " basilys_apply ((void*)(")
    (output_c_code oclos declbuf implbuf (+i 1 depth))
    (add2sbuf_strconst implbuf "), (")
    ;; output the first argument
    (let ( (firstarg (multiple_nth oargs 0)) )
      (output_c_code firstarg declbuf implbuf (+i 1 depth))
      )
    (add2sbuf_strconst implbuf "), (")
    ;; output the argdescr string
    (list_every
     paramdesclist
     (lambda (pard)
       (add2sbuf_string implbuf pard)
       (add2sbuf_strconst implbuf " ")))
    (add2sbuf_strconst implbuf "\"\"), ")
    ;; output the argtab (or null if none)
    (if (>i nbarg 1)
	(add2sbuf_strconst implbuf "argtab,")
      (add2sbuf_strconst implbuf "(union basilysparam_un*)0,"))
    ;; no extra results
    (add2sbuf_strconst implbuf " \"\", (union basilysparam_un*)0")
    (add2sbuf_strconst implbuf ");")
    (add2sbuf_indentnl implbuf (+i 1 depth))
    (add2sbuf_strconst implbuf "}")
    (add2sbuf_indentnl implbuf depth)
    )
  )
(install_method class_objapply output_c_code outpucod_objapply)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; output a message send
(defun outpucod_objmsend (omsend declbuf implbuf :long depth)
  (assert_msg "check omsend" (is_a omsend class_objmsend))
  (debug_msg omsend "outpucod_objmsend omsend")
  (let ( (oloc (unsafe_get_field :obi_loc omsend))
	 (odest (unsafe_get_field :obdi_destlist omsend))
	 (osel (unsafe_get_field :obmsnd_sel omsend))
	 (orecv (unsafe_get_field :obmsnd_recv omsend))
	 (oargs (unsafe_get_field :obmsnd_args omsend))
	 (:long nbarg (multiple_length oargs))
	 (paramdesclist (make_list discr_list))
	 (boxdepthp1 (make_integerbox discr_integer (+i 1 depth)))
	 )
    (output_location oloc implbuf depth "msend")
    (add2sbuf_strconst implbuf "/*msend*/{")
    (add2sbuf_indentnl implbuf (+i 1 depth))
    (if (>i nbarg 0)
	;; the code below is very similar to code inside
	;; outpucod_objapply except that we do not shift arguments by
	;; one
	(progn
	  (add2sbuf_strconst implbuf "union basilysparam_un argtab[")
	  (add2sbuf_longdec implbuf nbarg)
	  (add2sbuf_strconst implbuf "];")
	  (add2sbuf_indentnl implbuf (+i 1 depth))
	  (add2sbuf_strconst implbuf "memset(&argtab, 0, sizeof(argtab));")
	  (add2sbuf_indentnl implbuf (+i 1 depth))
	  ;; output the initialization of argtab and fill the paramdesclist
	  (multiple_every
	   oargs
	   (lambda (curarg :long curank)
	     (debug_msg curarg "outputcod_objapply curarg")
		 (let ( (curctyp (get_ctype curarg (the_null))) )
		   (debug_msg curctyp "outputcod_objmsend curctyp")
		   (assert_msg "check curctyp" (is_a curctyp class_ctype))
		   (output_location oloc implbuf (get_int boxdepthp1) "ojbmsend.arg")
		   (add2sbuf_strconst implbuf "argtab[")
		   (add2sbuf_longdec implbuf  curank)
		   (add2sbuf_strconst implbuf "].")
		   (list_append paramdesclist (unsafe_get_field :ctype_parstring curctyp))
		   (cond ( (null curarg)
			   (add2sbuf_strconst implbuf "bp_aptr = (basilys_ptr_t*)NULL")
			   )
			 ( (== curctyp ctype_value)
			   (add2sbuf_strconst implbuf "bp_aptr = (basilys_ptr_t*) &")
			   (output_c_code curarg declbuf implbuf (get_int boxdepthp1))
			   )
		     (:else
		      (add2sbuf_string implbuf (unsafe_get_field :ctype_argfield curctyp))
		      (add2sbuf_strconst implbuf " = ")
		      (output_c_code curarg declbuf implbuf (get_int boxdepthp1))
		      ))
		   (add2sbuf_strconst implbuf ";")
		   )))
	  (add2sbuf_indentnl implbuf (get_int boxdepthp1))
	  ))
;;; output the destination(s)
    (list_every 
     odest
     (lambda (curdest) 
       (output_c_code curdest declbuf implbuf (get_int boxdepthp1))
       (add2sbuf_strconst implbuf " = ")))
    (add2sbuf_strconst implbuf "basilysgc_send((")
    (output_c_code orecv declbuf implbuf (+i depth 1))
    (add2sbuf_strconst implbuf "), (")
    (output_c_code osel declbuf implbuf (+i depth 1))
    (add2sbuf_strconst implbuf "), (")
    ;; output the argdescr string
    (list_every
     paramdesclist
     (lambda (pard)
       (add2sbuf_string implbuf pard)
       (add2sbuf_strconst implbuf " ")))
    (add2sbuf_strconst implbuf "\"\"), ")
    (if (>i nbarg 0)
	(add2sbuf_strconst implbuf "argtab,")
      (add2sbuf_strconst implbuf "(union basilysparam_un*)0,"))
    ;; no extra results
    (add2sbuf_strconst implbuf " \"\", (union basilysparam_un*)0")
    (add2sbuf_strconst implbuf ");")
    (add2sbuf_indentnl implbuf (+i 1 depth))
    (add2sbuf_strconst implbuf "}")
    (add2sbuf_indentnl implbuf depth)
))
(install_method class_objmsend output_c_code outpucod_objmsend)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; output a multiresult application

(defun outpucod_objmultiapply (oapp declbuf implbuf :long depth)
  (assert_msg "check oapp" (is_a oapp class_objmultiapply))
  (debug_msg oapp "outpucod_objmultiapply oapp")
  (let (
	(aloc (unsafe_get_field :obi_loc oapp))
	(adest (unsafe_get_field :obdi_destlist oapp))
	(oclos (unsafe_get_field :obapp_clos oapp))
	(oargs (unsafe_get_field :obapp_args oapp))
	(oxres (unsafe_get_field :obmultapp_xres oapp))
	(:long nbarg (multiple_length oargs))
	(:long nbxres (multiple_length oxres))
	(paramdesclist (make_list discr_list))
	(resdesclist (make_list discr_list))
	(boxdepthp1 (make_integerbox discr_integer (+i 1 depth)))
	)
    (assert_msg "check oargs" (is_multiple_or_null oargs))
    (assert_msg "check oxres" (is_multiple_or_null oxres))
    (output_location aloc implbuf depth "multiapply")
    (add2sbuf_strconst implbuf "/*multiapply ")
    (add2sbuf_longdec implbuf nbarg)
    (add2sbuf_strconst implbuf "args, ")
    (add2sbuf_longdec implbuf nbxres)
    (add2sbuf_strconst implbuf "x.res*/ ")
    (add2sbuf_strconst implbuf "{")
    (add2sbuf_indentnl implbuf (+i 1 depth))
    (if (>i nbarg 1)
	(progn
	  (add2sbuf_strconst implbuf "union basilysparam_un argtab[")
	  (add2sbuf_longdec implbuf (-i nbarg 1))
	  (add2sbuf_strconst implbuf "];")
	  (add2sbuf_indentnl implbuf (+i 1 depth))
	  ))
    (if (>i nbxres 0)
	(progn
	  (add2sbuf_indentnl implbuf (+i 1 depth))
	  (add2sbuf_strconst implbuf "union basilysparam_un restab[")
	  (add2sbuf_longdec implbuf nbxres)
	  (add2sbuf_strconst implbuf "];")
	  (add2sbuf_indentnl implbuf (+i 1 depth))
	  ))
    (if (>i nbxres 0)
	(progn
	  (add2sbuf_strconst implbuf "memset(&restab, 0, sizeof(restab));")
	  (add2sbuf_indentnl implbuf (+i 1 depth))
	  ;; fill the resdesclist
	  (multiple_every 
	   oxres
	   (lambda (cures :long curank)
		 (let ( (curctyp (get_ctype cures (the_null))) )
	     (list_append resdesclist (unsafe_get_field :ctype_parstring curctyp)))))))
    (if (>i nbarg 1)
	(progn
	  (add2sbuf_strconst implbuf "memset(&argtab, 0, sizeof(argtab));")
	  (add2sbuf_indentnl implbuf (+i 1 depth))
	  ;; output the initialization of argtab and fill the paramdesclist
	  (multiple_every
	   oargs
	   (lambda (curarg :long curank)
	     (debug_msg curarg "outpucod_objmultiapply curarg")
	     (if (>i curank 0)
		 (let ( (curctyp (get_ctype curarg (the_null))) )
		   (debug_msg curctyp "outpucod_objmultiapply curctyp")
		   (assert_msg "check curctyp" (is_a curctyp class_ctype))
		   (output_location aloc implbuf (get_int boxdepthp1) "multiapply.arg")
		   (add2sbuf_strconst implbuf "argtab[")
		   (add2sbuf_longdec implbuf  (-i curank 1))
		   (add2sbuf_strconst implbuf "].")
		   (list_append paramdesclist (unsafe_get_field :ctype_parstring curctyp))
		   (cond
		    ( (null curarg)
		      (add2sbuf_strconst implbuf "bp_aptr = (basilys_ptr_t*)NULL"))
		    ( (== curctyp ctype_value)
		      (add2sbuf_strconst implbuf "bp_aptr = (basilys_ptr_t*) &")
		      (output_c_code curarg declbuf implbuf (get_int boxdepthp1))
		      )
		    (:else
		     (add2sbuf_string implbuf (unsafe_get_field :ctype_argfield curctyp))
		     (add2sbuf_strconst implbuf " = ")
		     (output_c_code curarg declbuf implbuf (get_int boxdepthp1))
		     ))
		   (add2sbuf_strconst implbuf ";")
		   ))))
	  (add2sbuf_indentnl implbuf (get_int boxdepthp1))
	  ))
    ;; output the initialization of restab
    (if (>i nbxres 0)
	(progn
	  (multiple_every
	   oxres
	   (lambda (cures :long curank)
	     (let ( (curestyp (get_ctype cures (the_null))) )
	       (debug_msg curestyp "outpucod_objmultiapply curestyp")
	       (assert_msg "check curestyp" (is_a curestyp class_ctype))
	       (output_location aloc implbuf (get_int boxdepthp1) "multiapply.xres")
	       (add2sbuf_strconst implbuf "restab[")
	       (add2sbuf_longdec implbuf  curank)
	       (add2sbuf_strconst implbuf "].")
	       (cond
		( (null cures)
		  (add2sbuf_strconst implbuf "bp_aptr = (basilys_ptr_t*)NULL"))
		( (== curestyp ctype_value)
		  (add2sbuf_strconst implbuf "bp_aptr = (basilys_ptr_t*) &")
		  (output_c_code cures declbuf implbuf (get_int boxdepthp1))
		  )
		(:else
		 (add2sbuf_string implbuf (unsafe_get_field :ctype_resfield curestyp))
		 (add2sbuf_strconst implbuf " = ")
		 (output_c_code cures declbuf implbuf (get_int boxdepthp1))
		 ))
	       (add2sbuf_strconst implbuf ";")
	       )
	     ))
	  ))
    (output_location aloc implbuf (get_int boxdepthp1) "multiapply.appl")
;;; output the destination(s)
    (list_every
     adest
     (lambda (curdest) 
       (output_c_code curdest declbuf implbuf (get_int boxdepthp1))
       (add2sbuf_strconst implbuf " = ")))
    ;; output the apply and the closure
    (add2sbuf_strconst implbuf " basilys_apply ((void*)(")
    (output_c_code oclos declbuf implbuf (+i 1 depth))
    (add2sbuf_strconst implbuf "), (")
    ;; output the first argument
    (let ( (firstarg (multiple_nth oargs 0)) )
      (output_c_code firstarg declbuf implbuf (+i 1 depth))
      )
    (add2sbuf_strconst implbuf "), (")
    ;; output the argdescr string
    (list_every 
     paramdesclist
     (lambda (pard)
       (add2sbuf_string implbuf pard)
       (add2sbuf_strconst implbuf " ")))
    (add2sbuf_strconst implbuf "\"\"), ")
    ;; output the argtab (or null if none)
    (if (>i nbarg 1)
	(add2sbuf_strconst implbuf "argtab, (")
      (add2sbuf_strconst implbuf "(union basilysparam_un*)0, ("))
    ;; output the resdescr string
    (list_every
     resdesclist
     (lambda (resd)
       (add2sbuf_string implbuf resd)
       (add2sbuf_strconst implbuf " ")))
    (add2sbuf_strconst implbuf "\"\"), ")
    ;; output the extra results
    (if (>i nbxres 0)
	(add2sbuf_strconst implbuf "restab")
      (add2sbuf_strconst implbuf "(union basilysparam_un*)0"))
    (add2sbuf_strconst implbuf ");")
    (add2sbuf_indentnl implbuf (+i 1 depth))
    (add2sbuf_strconst implbuf "}")
    (add2sbuf_indentnl implbuf depth)
    ))
  
(install_method class_objmultiapply output_c_code outpucod_objmultiapply)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; output a multiresult message send
(defun outpucod_objmultimsend (omsnd  declbuf implbuf :long depth)
  (assert_msg "check omsnd" (is_a omsnd class_objmultimsend))
  (debug_msg omsnd "outpucod_objmultimsend omsnd")
  (let ( (oloc (unsafe_get_field :obi_loc omsnd))
	 (odest (unsafe_get_field :obdi_destlist omsnd))
	 (osel (unsafe_get_field :obmsnd_sel omsnd))
	 (orecv (unsafe_get_field :obmsnd_recv omsnd))
	 (oargs (unsafe_get_field :obmsnd_args omsnd))
	 (oxres (unsafe_get_field :obmultsnd_xres omsnd))
	 (:long nbarg (multiple_length oargs))
	 (:long nbxres (multiple_length oxres))
	 (paramdesclist (make_list discr_list))
	 (resdesclist (make_list discr_list))
	 (boxdepthp1 (make_integerbox discr_integer (+i 1 depth)))
	 )
    (output_location oloc implbuf depth "multimsend")
    (add2sbuf_strconst implbuf "/*multimsend*/{")
    (add2sbuf_indentnl implbuf (+i 1 depth))
    (if (>i nbarg 0)
	(progn
	  (add2sbuf_strconst implbuf "union basilysparam_un argtab[")
	  (add2sbuf_longdec implbuf nbarg)
	  (add2sbuf_strconst implbuf "];")
	  (add2sbuf_indentnl implbuf (+i 1 depth))
	  ))
    (if (>i nbxres 0)
	(progn
	  (add2sbuf_strconst implbuf "union basilysparam_un restab[")
	  (add2sbuf_longdec implbuf nbxres)
	  (add2sbuf_strconst implbuf "];")
	  (add2sbuf_indentnl implbuf (+i 1 depth))
	  ;; fill the resdesclist
	  (multiple_every 
	   oxres
	   (lambda (cures :long curank)
	     (let ( (curestyp (get_ctype cures (the_null))) )
	       (list_append resdesclist (unsafe_get_field :ctype_parstring curestyp)))))
	  ))
    (if (>i nbarg 0)
	(progn
	  (add2sbuf_strconst implbuf "memset(&argtab, 0, sizeof(argtab));")
	  (add2sbuf_indentnl implbuf (+i 1 depth))))
    (if (>i nbxres 0)
	(progn
	  (add2sbuf_strconst implbuf "memset(&restab, 0, sizeof(restab));")
	  (add2sbuf_indentnl implbuf (+i 1 depth))))
    ;; output the initialization of argtab and fill paramdesclist
    (if (>i nbarg 0)
	(progn
	  ;; output the initialization of argtab and fill the paramdesclist
	  (multiple_every
	   oargs
	   (lambda (curarg :long curank)
	     (debug_msg curarg "outpucod_objmultimsend curarg")
	     (let ( (curctyp (get_ctype curarg (the_null))) )
	       (debug_msg curctyp "outpucod_objmultimsend curctyp")
	       (assert_msg "check curctyp" (is_a curctyp class_ctype))
	       (output_location oloc implbuf (get_int boxdepthp1) "multimsend.arg")
	       (add2sbuf_strconst implbuf "argtab[")
	       (add2sbuf_longdec implbuf   curank)
	       (add2sbuf_strconst implbuf "].")
	       (list_append paramdesclist (unsafe_get_field :ctype_parstring curctyp))
	       (cond
		( (null curarg)
		  (add2sbuf_strconst implbuf "bp_aptr = (basilys_ptr_t*)NULL"))
		( (== curctyp ctype_value)
		  (add2sbuf_strconst implbuf "bp_aptr = (basilys_ptr_t*) &")
		  (output_c_code curarg declbuf implbuf (get_int boxdepthp1))
		  )
		(:else
		 (add2sbuf_string implbuf (unsafe_get_field :ctype_argfield curctyp))
		 (add2sbuf_strconst implbuf " = ")
		 (output_c_code curarg declbuf implbuf (get_int boxdepthp1))
		 ))
	       (add2sbuf_strconst implbuf ";")
	       )))
	  (add2sbuf_indentnl implbuf (get_int boxdepthp1))
	  ))
    ;; output the initialization of restab
    (if (>i nbxres 0)
	(progn
	  (multiple_every
	   oxres
	   (lambda (cures :long curank)
	     (let ( (curestyp (get_ctype cures (the_null))) )
	       (debug_msg curestyp "outpucod_objmultimsend curestyp")
	       (assert_msg "check curestyp" (is_a curestyp class_ctype))
	       (output_location oloc implbuf (get_int boxdepthp1) "multimsend.xres")
	       (add2sbuf_strconst implbuf "restab[")
	       (add2sbuf_longdec implbuf  curank)
	       (add2sbuf_strconst implbuf "].")
	       (cond
		( (null cures)
		  (add2sbuf_strconst implbuf "bp_aptr = (basilys_ptr_t*)NULL")
		  )
		( (== curestyp ctype_value)
		  (add2sbuf_strconst implbuf "bp_aptr = (basilys_ptr_t*) &")
		  (output_c_code cures declbuf implbuf (get_int boxdepthp1))
		  )
		(:else
		 (add2sbuf_string implbuf (unsafe_get_field :ctype_resfield curestyp))
		 (add2sbuf_strconst implbuf " = ")
		 (output_c_code cures declbuf implbuf (get_int boxdepthp1))
		 ))
	       (add2sbuf_strconst implbuf ";")
	       )
	     ))
	  ))
    (output_location oloc implbuf (get_int boxdepthp1) "multimsend.send")
;;; output the destination(s)
    (list_every
     odest
     (lambda (curdest) 
       (output_c_code curdest declbuf implbuf (get_int boxdepthp1))
       (add2sbuf_strconst implbuf " = ")))
    ;; output the send and the reciever
    (add2sbuf_strconst implbuf " basilysgc_send ((void*)(")
    (output_c_code orecv declbuf implbuf (+i 1 depth))
    (add2sbuf_strconst implbuf "), ((void*)(")
    ;; output the selector
    (output_c_code osel declbuf implbuf (+i 1 depth))
    (add2sbuf_strconst implbuf ")), (")
    ;; output the argdescr string
    (list_every 
     paramdesclist
     (lambda (pard)
       (add2sbuf_string implbuf pard)
       (add2sbuf_strconst implbuf " ")))
    (add2sbuf_strconst implbuf "\"\"), ")
    ;; output the argtab (or null if none)
    (if (>i nbarg 0)
	(add2sbuf_strconst implbuf "argtab, (")
      (add2sbuf_strconst implbuf "(union basilysparam_un*)0, ("))
    ;; output the resdescr string
    (list_every
     resdesclist
     (lambda (resd)
       (add2sbuf_string implbuf resd)
       (add2sbuf_strconst implbuf " ")))
    (add2sbuf_strconst implbuf "\"\"), ")
    ;; output the extra results
    (if (>i nbxres 0)
	(add2sbuf_strconst implbuf "restab")
      (add2sbuf_strconst implbuf "(union basilysparam_un*)0"))
    (add2sbuf_strconst implbuf ");")
    (add2sbuf_indentnl implbuf (+i 1 depth))
    (add2sbuf_strconst implbuf "}")
    (add2sbuf_indentnl implbuf depth)
    ))
(install_method class_objmultimsend output_c_code outpucod_objmultimsend)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; output a clear
(defun outpucod_objclear (oclear declbuf implbuf :long depth)
  (assert_msg "check oclear" (is_a oclear class_objclear))
  (debug_msg oclear "outpucod_objclear oclear")
  (let ( (cloc (unsafe_get_field :obi_loc oclear))
	 (cvl (unsafe_get_field :oclr_vloc oclear))
	 )
    (output_location cloc implbuf depth "clear")
    (add2sbuf_strconst implbuf "/*clear*/ ")
    (output_c_code cvl declbuf implbuf (+i depth 1))
    (add2sbuf_strconst implbuf " = 0 ")
    )
  )
(install_method class_objclear output_c_code outpucod_objclear)

;; output a raw object allocation
(defun outpucod_objrawallocobj (oralob declbuf implbuf :long depth)
  (assert_msg "check oralob" (is_a oralob class_objrawallocobj))
  (debug_msg oralob "outpucod_objrawallocobj oralob")
  (let ( (iloc (unsafe_get_field :obi_loc oralob))
	 (iclass (unsafe_get_field :obrallobj_class oralob))
	 (ilen (unsafe_get_field :obrallobj_len oralob))
	 (destlist (unsafe_get_field :obdi_destlist oralob)) 
	 (boxdepthp1 (make_integerbox discr_integer (+i depth 1)))
	 )
    (assert_msg "outpucod_objrawallocobj check iclass" (is_a iclass class_objvalue))
    (output_location iloc implbuf depth "rawallocobj")
    (add2sbuf_strconst implbuf "/*rawallocobj*/ ")
    (list_every
     destlist
     (lambda (dst) 
       (output_c_code dst declbuf implbuf (get_int boxdepthp1))
       (add2sbuf_strconst implbuf " =")))
    (add2sbuf_indentnl implbuf (+i depth 1))
    (add2sbuf_strconst implbuf "basilysgc_new_raw_object((void*)(")
    (output_c_code iclass declbuf implbuf (get_int boxdepthp1))
    (add2sbuf_strconst implbuf "), (")
    (output_c_code ilen  declbuf implbuf (get_int boxdepthp1))
    (add2sbuf_strconst implbuf "));")
    (add2sbuf_indentnl implbuf depth)
))
(install_method class_objrawallocobj output_c_code outpucod_objrawallocobj)


;; output a closure allocation
(defun outpucod_objnewclosure (obnclo declbuf implbuf :long depth)
  (assert_msg "check oralob" (is_a obnclo class_objnewclosure))
  (debug_msg obnclo "outpucod_objnewclosure obnclo") 
  (let ( (iloc (unsafe_get_field :obi_loc obnclo))
	 (odiscr (unsafe_get_field :obnclo_discr obnclo))
	 (orout (unsafe_get_field :obnclo_rout obnclo))
	 (olen (unsafe_get_field :obnclo_len obnclo))
	 (destlist (unsafe_get_field :obdi_destlist obnclo))
	 (boxdepthp1 (make_integerbox discr_integer (+i depth 1)))
	 )
    (output_location iloc implbuf depth "newclosure")
    (add2sbuf_strconst implbuf " /*newclosure*/ ")
    (list_every
     destlist
     (lambda (dst) 
       (output_c_code dst declbuf implbuf (get_int boxdepthp1))
       (add2sbuf_strconst implbuf " =")))
    (add2sbuf_indentnl implbuf (+i depth 1))
    (add2sbuf_strconst implbuf "basilysgc_new_closure((basilysobject_ptr_t)(")
    (output_c_code odiscr declbuf implbuf (get_int boxdepthp1))
    (add2sbuf_strconst implbuf "), (basilysroutine_ptr_t)(")
    (output_c_code orout declbuf implbuf (get_int boxdepthp1))
    (add2sbuf_strconst implbuf "), (")
    (output_c_code olen declbuf implbuf (get_int boxdepthp1))
    (add2sbuf_strconst implbuf "));")
    (add2sbuf_indentnl implbuf depth)
))
(install_method class_objnewclosure  output_c_code outpucod_objnewclosure)

;; output a touch
(defun outpucod_objtouch (otouch declbuf implbuf :long depth)
  (assert_msg "check oclear" (is_a otouch class_objtouch))
  (let ( (iloc (unsafe_get_field :obi_loc otouch)) 
	 (touched (unsafe_get_field :otouch_val otouch)) 
	 (comm (unsafe_get_field :otouch_comment otouch))
	 )
    (output_location iloc implbuf depth "touch")
    (if comm 
	(progn 
	       (add2sbuf_strconst implbuf "/*touch:")
	       (add2sbuf_cident implbuf comm)
	       (add2sbuf_strconst implbuf "*/")))
    (add2sbuf_strconst implbuf " basilysgc_touch(")
    (output_c_code touched declbuf implbuf depth)
    (add2sbuf_strconst implbuf ");")
    (add2sbuf_indentnl implbuf depth)
    )
)
(install_method class_objtouch output_c_code outpucod_objtouch)



;;; output a put tuple (mostly used in initial data content filling)
(defun outpucod_objputuple (optup declbuf implbuf :long depth)
  (assert_msg "check optyp" (is_a optup class_objputuple))
  (debug_msg optup "outpucod_objputuple optup")
  (let ( (iloc (unsafe_get_field :obi_loc optup))
	 (otup (unsafe_get_field :oputu_tupled optup))
	 (ooff (unsafe_get_field :oputu_offset optup))
	 (oval (unsafe_get_field :oputu_value optup)) )
    (output_location iloc implbuf depth "putuple")
    (add2sbuf_strconst implbuf "/*putupl checktup*/ basilys_assertmsg(\"putupl checktup\", basilys_magic_discr(")
    (output_c_code otup declbuf implbuf depth)
    (add2sbuf_strconst implbuf ")== OBMAG_MULTIPLE);")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "/*putupl checkoff*/ basilys_assertmsg(\"putupl checkoff\", (")
    (output_c_code ooff declbuf implbuf depth)
    (add2sbuf_strconst implbuf ">=0 && ")
    (output_c_code ooff declbuf implbuf depth)
    (add2sbuf_strconst implbuf "< basilys_multiple_length(")
    (output_c_code otup declbuf implbuf depth)
    (add2sbuf_strconst implbuf ")));")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "/*putuple*/ ((basilysmultiple_ptr_t)(")
    (output_c_code otup declbuf implbuf depth)
    (add2sbuf_strconst implbuf "))->tabval[")
    (output_c_code ooff declbuf implbuf depth)
    (add2sbuf_strconst implbuf "] = ")
    (output_c_code oval declbuf implbuf depth)
    (add2sbuf_strconst implbuf ";")
    (add2sbuf_indentnl implbuf depth)
    )
  )
(install_method class_objputuple output_c_code outpucod_objputuple)


(defun outpucod_objgetslot (ogsl declbuf implbuf :long depth)
  (assert_msg "check ogsl" (is_a ogsl class_objgetslot))
  (let ( (oloc (unsafe_get_field :obi_loc ogsl))
	 (destlist (unsafe_get_field :obdi_destlist ogsl))
	 (oobj (unsafe_get_field :ogetsl_obj ogsl))
	 (ofield (unsafe_get_field :ogetsl_field ogsl))
	 (boxdepthp1 (make_integerbox discr_integer (+i depth 1)))
	 )
    (assert_msg "check ofield" (is_a ofield class_field))
    (debug_msg ogsl "outpucod_objgetslot ogsl")
    (output_location oloc implbuf depth "getslot")
    (list_every
     destlist
     (lambda (dst) 
       (output_c_code dst declbuf implbuf (get_int boxdepthp1))
       (add2sbuf_strconst implbuf " = ")))
    (add2sbuf_strconst implbuf "basilys_getfield_object((")
    (output_c_code oobj declbuf implbuf depth)
    (add2sbuf_strconst implbuf "), ")
    (add2sbuf_longdec implbuf (get_int ofield))
    (add2sbuf_strconst implbuf ", \"")
    (add2sbuf_string implbuf (unsafe_get_field :named_name ofield))
    (add2sbuf_strconst implbuf "\");")
    (add2sbuf_indentnl implbuf depth)
    ))
(install_method class_objgetslot output_c_code outpucod_objgetslot)

;;; output a put slot (mostly used in initial data content filling)
(defun outpucod_objputslot (opslo declbuf implbuf :long depth)
  (assert_msg "check opslo" (is_a opslo class_objputslot))
  (debug_msg opslo "outpucod_objputslot opslo")
  (let ( (iloc (unsafe_get_field :obi_loc opslo))
	 (odata (unsafe_get_field :oslot_odata opslo))
	 (ooff (unsafe_get_field :oslot_offset opslo))
	 (ofield (unsafe_get_field :oslot_field opslo))
	 (oval (unsafe_get_field :oslot_value opslo))
	 )
    (assert_msg "outpucod_objputslot check oval not nrep" (not (is_a oval class_nrep)))
    (output_location iloc implbuf depth "putslot")
    (add2sbuf_strconst implbuf "/*putslot checkobj*/ basilys_assertmsg(\"putslot checkobj")
    (if (is_a odata class_named)
	(progn
	  (add2sbuf_strconst implbuf " ")
	  (add2sbuf_string implbuf (unsafe_get_field :named_name odata))))
    (add2sbuf_strconst implbuf "\", basilys_magic_discr(")
    (output_c_code odata declbuf implbuf depth)
    (add2sbuf_strconst implbuf ") == OBMAG_OBJECT);")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "/*putslot checkoff*/ basilys_assertmsg(\"putslot checkoff\", (")
    (output_c_code ooff declbuf implbuf depth)
    (add2sbuf_strconst implbuf ">=0 && ")
    (output_c_code ooff declbuf implbuf depth)
    (add2sbuf_strconst implbuf "< basilys_object_length(")
    (output_c_code odata declbuf implbuf depth)
    (add2sbuf_strconst implbuf ")));")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "/*putslot*/ ((basilysobject_ptr_t)(")
    (output_c_code odata declbuf implbuf depth)
    (add2sbuf_strconst implbuf "))->obj_vartab[")
    (output_c_code ooff declbuf implbuf depth)
    (if (is_a ofield class_field)
	(progn
	  (add2sbuf_strconst implbuf " /*")
	  (add2sbuf_string implbuf (unsafe_get_field :named_name ofield))
	  (add2sbuf_strconst implbuf "*/")))
    (add2sbuf_strconst implbuf "] =")
    (add2sbuf_indentnl implbuf (+i 1 depth))
    (output_c_code oval declbuf implbuf (+i 1 depth))
    (add2sbuf_strconst implbuf ";")
    (add2sbuf_indentnl implbuf depth)
    ))
(install_method class_objputslot output_c_code outpucod_objputslot)
  

;;; output the putting of the routine in a closure
(defun outpucod_objputclosurout (opclor  declbuf implbuf :long depth)
  (assert_msg "check opclor" (is_a opclor class_objputclosurout))
  (debug_msg opclor "outpucod_objputclosurout opclor")
  (let ( (oloc (unsafe_get_field :obi_loc opclor))
	 (oclos (unsafe_get_field :opclor_clos opclor))
	 (orout (unsafe_get_field :opclor_rout opclor)) )
    (output_location oloc implbuf depth "putclosurout")
    (add2sbuf_strconst implbuf "/*putclosrout checkclo*/ basilys_assertmsg(\"putclosrout checkclo\", basilys_magic_discr(")
    (output_c_code oclos declbuf implbuf depth)
    (add2sbuf_strconst implbuf ") == OBMAG_CLOSURE);")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "/*putclosrout checkrout*/ basilys_assertmsg(\"putclosrout checkrout\", basilys_magic_discr(")
    (output_c_code orout declbuf implbuf depth)
    (add2sbuf_strconst implbuf ") == OBMAG_ROUTINE);")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "/*putclosrout*/ ((basilysclosure_ptr_t)")
    (output_c_code oclos declbuf implbuf depth)
    (add2sbuf_strconst implbuf ")->rout = ")
    (output_c_code orout declbuf implbuf depth)
    (add2sbuf_strconst implbuf ";")
    (add2sbuf_indentnl implbuf depth)
    )
)
(install_method class_objputclosurout output_c_code outpucod_objputclosurout)

;;; output the putting of a closed value
(defun outpucod_objputclosedv (opclov declbuf implbuf :long depth)
  (assert_msg "check opclor" (is_a opclov class_objputclosedv))
  (debug_msg opclov "outpucod_objputclosedv")
  (let ( (oloc (unsafe_get_field :obi_loc opclov))
	 (oclos (unsafe_get_field :opclov_clos opclov))
	 (ooff (unsafe_get_field :opclov_off opclov))
	 (ocval (unsafe_get_field :opclov_cval opclov)) )
    (output_location oloc implbuf depth "putclosedv")
    (add2sbuf_strconst implbuf "/*putclosv checkclo*/ basilys_assertmsg(\"putclosv checkclo\", basilys_magic_discr(")
    (output_c_code oclos declbuf implbuf depth)
    (add2sbuf_strconst implbuf ") == OBMAG_CLOSURE);")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "/*putclosv checkoff*/ basilys_assertmsg(\"putclosv checkoff\", ")
    (output_c_code ooff declbuf implbuf depth)
    (add2sbuf_strconst implbuf ">= 0 && ")
    (output_c_code ooff declbuf implbuf depth)
    (add2sbuf_strconst implbuf "< basilys_closure_size( ")
    (output_c_code oclos declbuf implbuf depth)
    (add2sbuf_strconst implbuf "));")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "/*putclosval*/ ((basilysclosure_ptr_t)")
    (output_c_code oclos declbuf implbuf depth)
    (add2sbuf_strconst implbuf ")->tabval[")
    (output_c_code ooff declbuf implbuf depth)
    (add2sbuf_strconst implbuf "] = ")
    (output_c_code ocval declbuf implbuf depth)
    (add2sbuf_strconst implbuf ";")
    (add2sbuf_indentnl implbuf depth)
    ))
(install_method class_objputclosedv output_c_code outpucod_objputclosedv)


;; output the putting of a constant value inside a routine
(defun outpucod_objputroutconst (oprconst declbuf implbuf :long depth)
  (assert_msg "check oprconst" (is_a oprconst class_objputroutconst))
  (let ( (oloc (unsafe_get_field :obi_loc oprconst))
	 (orout (unsafe_get_field :oprconst_rout oprconst))
	 (ooff (unsafe_get_field :oprconst_off oprconst))
	 (ocval (unsafe_get_field :oprconst_cval oprconst)) )
    (output_location oloc implbuf depth "putroutconst")
    (add2sbuf_strconst implbuf "/*putroutconst checkrout*/ basilys_assertmsg(\"putroutconst checkrout\", basilys_magic_discr(")
    (output_c_code orout declbuf implbuf depth)
    (add2sbuf_strconst implbuf ") == OBMAG_ROUTINE);")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "/*putroutconst*/ ((basilysroutine_ptr_t)")
    (output_c_code orout declbuf implbuf depth)
    (add2sbuf_strconst implbuf ")->tabval[")
    (output_c_code ooff declbuf implbuf depth)
    (add2sbuf_strconst implbuf "] = ")
    (output_c_code ocval declbuf implbuf depth)
    (add2sbuf_strconst implbuf ";")
    (add2sbuf_indentnl implbuf depth)
    )
  )
(install_method class_objputroutconst output_c_code outpucod_objputroutconst)



;;; output the put of an extra returned result
(defun outpucod_objputxtraresult (oputx declbuf implbuf :long depth)
  (assert_msg "check oputx" (is_a oputx class_objputxtraresult))
  (let (  (oloc (unsafe_get_field :obi_loc oputx))
	  (orank (unsafe_get_field :obxres_rank oputx))
	  (ovloc (unsafe_get_field :obxres_obloc oputx))
	  (octyp (get_ctype ovloc (the_null)))
	  )
    (output_location oloc implbuf depth "putxtraresult")
    (assert_msg "check octyp" (is_a octyp class_ctype))
    (assert_msg "check orank" (is_integerbox orank))
    (add2sbuf_strconst implbuf "if (!xrestab_ || !xresdescr_) goto labend_rout;")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "if (xresdescr_[")
    (add2sbuf_longdec implbuf (get_int orank))
    (add2sbuf_strconst implbuf "] != ")
    (add2sbuf_string implbuf (unsafe_get_field :ctype_parchar octyp))
    (add2sbuf_strconst implbuf ") goto labend_rout;")
    (add2sbuf_indentnl implbuf depth)
    (add2sbuf_strconst implbuf "if (xrestab_[")
    (add2sbuf_longdec implbuf (get_int orank))
    (add2sbuf_strconst implbuf "].")
    (add2sbuf_string implbuf (unsafe_get_field :ctype_resfield octyp))
    (add2sbuf_strconst implbuf ") *(xrestab_[")
    (add2sbuf_longdec implbuf (get_int orank))
    (add2sbuf_strconst implbuf "].")
    (add2sbuf_string implbuf (unsafe_get_field :ctype_resfield octyp))
    (add2sbuf_strconst implbuf ") = ")
    (output_c_code ovloc declbuf implbuf depth)
    (add2sbuf_strconst implbuf ";")
    (add2sbuf_indentnl implbuf depth)
    ))
(install_method class_objputxtraresult output_c_code  outpucod_objputxtraresult)

;;; output an expression
(defun outpucod_objexpv (oexp declbuf implbuf :long depth)
  (assert_msg "check oexp" (is_a oexp class_objexpv))
  (let ( (cont (unsafe_get_field :obx_cont oexp)) 
	 (boxdepthp1 (make_integerbox discr_integer (+i depth 1)))
	 )
    (assert_msg "check cont" (is_multiple cont))
    (multiple_every
     cont
     (lambda (comp :long ix)
       (output_c_code comp declbuf implbuf (get_int boxdepthp1)))))
)
(install_method class_objexpv output_c_code outpucod_objexpv)

;;; output a located expression
(defun outpucod_objlocatedexpv (oexp declbuf implbuf :long depth)
  (assert_msg "check oexp" (is_a oexp class_objlocatedexpv))
  (let ( (cont (unsafe_get_field :obx_cont oexp)) 
	 (oloc (unsafe_get_field :obcx_loc oexp))
	 (boxdepthp1 (make_integerbox discr_integer (+i depth 1)))
	 )
    (assert_msg "check cont" (is_multiple cont))
    (if (is_mixint oloc)
	(output_raw_location oloc implbuf depth "expr")
	)
    (multiple_every
     cont
     (lambda (comp :long ix)
       (output_c_code comp declbuf implbuf (get_int boxdepthp1)))))
)
(install_method class_objlocatedexpv output_c_code outpucod_objlocatedexpv)

;;; output a verbatim string
(defun outpucod_verbatimstring (vstr declbuf implbuf :long depth)
  (assert_msg "check vstr" (== (discrim vstr) discr_verbatimstring))
  (debug_msg vstr "outpucod_verbatimstring vstr")
  (add2sbuf_string implbuf vstr)
)
(debug_msg discr_verbatimstring "discr_verbatimstring @@before installmeth warmbasilys")

(install_method discr_verbatimstring output_c_code outpucod_verbatimstring)

(debug_msg discr_verbatimstring "discr_verbatimstring @@toplev warmbasilys")

;; output a string (cstring constant)
(defun outpucod_string (vstr declbuf implbuf :long depth)
  (if (== (discrim vstr) discr_verbatimstring)
      (progn
	;;; @@@ UGLY HACK - should never be used. But something wrong
	;;; in sending output_c_code to discr_verbatimstring
	(debug_msg vstr "outpucod_string bad verbatim vstr")
	(debug_msg class_discr "outpucod_string class_discr")
	(debug_msg discr_string "outpucod_string discr_string")
	(debug_msg (unsafe_get_field :disc_methodict discr_string) "outpucod_string discr_string methodict")
	(debug_msg discr_namestring "outpucod_string discr_namestring")
	(debug_msg (unsafe_get_field :disc_methodict discr_namestring) "outpucod_string discr_namestring methodict")
	(debug_msg discr_verbatimstring "outpucod_string discr_verbatimstring")
	(debug_msg  (unsafe_get_field :disc_methodict discr_verbatimstring) "outpucod_string discr_verbatimstring methodict")
	(install_method discr_verbatimstring output_c_code outpucod_verbatimstring)
	(return (outpucod_verbatimstring vstr declbuf implbuf depth))
;;; never reached!
	(assert_msg "outpucod_string check vstr not verbatim" (!= (discrim vstr) discr_verbatimstring)
		    )))
  (if (!= (discrim vstr) discr_string)
      (debug_msg vstr "outpucod_string strange vstr"))
  (assert_msg "check vstr" (== (discrim vstr) discr_string)) 
  (add2sbuf_strconst implbuf " \"")
  (add2sbuf_cencstring implbuf vstr)
  (add2sbuf_strconst implbuf "\"")
  )
(install_method discr_string output_c_code outpucod_string)

(debug_msg discr_string "discr_string @@toplev warmbasilys")


;;; output an integer
(defun outpucod_integer (vint declbuf implbuf :long depth)
  (assert_msg "check vint" (is_integerbox vint))
  (add2sbuf_longdec implbuf (get_int vint))
)
(install_method discr_integer output_c_code outpucod_integer)

;;; output a finalreturn
(defun outpucod_finalreturn (fret declbuf implbuf :long depth)
  (assert_msg "check fret" (is_a fret class_objfinalreturn))
  (output_location (unsafe_get_field :obi_loc fret) implbuf depth "finalreturn")
  (add2sbuf_strconst implbuf ";")
  (add2sbuf_indentnl implbuf depth)
  (add2sbuf_strconst implbuf "/*finalret*/ goto labend_rout ")
)
(install_method class_objfinalreturn output_c_code outpucod_finalreturn)


;; for some reason, final returns are sometimes putobjdest-ed - a NOP here
(defun putobjdest_objfinalreturn (recv desto)
  (assert_msg "check recv" (is_a recv class_objfinalreturn))
  recv
)
(install_method class_objfinalreturn put_objdest putobjdest_objfinalreturn)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; compile a single procedure
(defun compile2obj_procedure (pro compicache :long num)
  (debug_msg pro "compilproc pro")
  ;;(debug_msg compicache "compilproc compicache")
  (assert_msg "check pro" (is_a pro class_nrep_routproc))
  (assert_msg "check compicache" (is_mapobject compicache))
  (let ( (namsbuf (make_strbuf discr_strbuf)) 
	 (routfunam (the_null))
	 )
    (add2sbuf_strconst namsbuf "rout_")
    (add2sbuf_longdec namsbuf num)
    (if (is_a pro class_nrep_routproc)
	(let ( (pronam (unsafe_get_field :nrpro_name pro)) 
	       )
	  (if (is_a pronam class_named)
	      (progn
		(setq routfunam (unsafe_get_field :named_name pronam))
		(add2sbuf_strconst namsbuf "_")
		(add2sbuf_cident namsbuf (unsafe_get_field :named_name pronam)))
	    )))
    (let ( 
	  (nbody (unsafe_get_field :nproc_body pro))
	  (nloc (unsafe_get_field :nrep_loc pro))
	  (nargb (if (is_a pro class_nrep_routproc) (unsafe_get_field :nrpro_argb pro)))
	  (obodylist (make_list discr_list))
	  (obrout (make_instance class_procroutineobj
				 :named_name (strbuf2string discr_string namsbuf)
				 :obrout_proc pro
				 :obrout_body obodylist
				 :obrout_nbval (make_integerbox discr_integer 0)
				 :obrout_nblong (make_integerbox discr_integer 0)
				 :obrout_others (make_list discr_list)
				 :oprout_loc nloc
				 :oprout_funam routfunam
				 )) 
	  (locmap (make_mapobject discr_mapobjects (+i 20 (*i 3 (multiple_length nargb)))))
	  (gcx (make_instance class_genercontext
			      :gncx_objrout obrout
			      :gncx_locmap locmap
			      :gncx_freeptrlist (make_list discr_list)
			      :gncx_freelonglist (make_list discr_list)
			      :gncx_freeothermaps (make_mapobject discr_mapobjects 20)
			      :gncx_compicache compicache
			      ))
	  (retloc 
	   (let ( (retl (get_free_objlocptr gcx '_retval_)) )
	     (unsafe_put_fields gcx :gncx_retloc retl)
	     retl))
	  (gtatup 
	   (multiple_map 
	    nargb
	    (lambda (bnd :long ix)
	      (assert_msg "check bnd" (is_a bnd class_formal_binding))
					;	      (debug_msg bnd "compilproc bnd")
	      (let ( (bctyp (unsafe_get_field :fbind_type bnd)) 
		     (bnam (unsafe_get_field :binder bnd))
		     (oloc 
		      (cond ( (== bctyp ctype_value)
			      (get_free_objlocptr gcx bnam) )
			    ( (== bctyp ctype_long)
			      (get_free_objloclong gcx bnam) )
			    (:else
			     (get_free_objloctyped gcx bnam bctyp)))
		      ) 
		     (ogarg
		      (make_instance class_objgetarg
				     :obi_loc nloc
				     :obarg_obloc oloc
				     :obarg_bind bnd))
		     )
		(mapobject_put locmap bnd oloc)
		ogarg
		))
	    ))
	  )
      ;; associate the procedure with its objroutine in the compiler cache
      (mapobject_put compicache pro obrout)
      (unsafe_put_fields obrout :oprout_getargs gtatup)
      (debug_msg obrout "compile2obj_procedure obrout")
      (debug_msg nbody "compile2obj_procedure nbody")
      (assert_msg "check nbody" (is_a nbody class_nrep))
      (if (is_a pro class_nrep_routproc)
	  (let ( (pthuls (unsafe_get_field :nrpro_thunklist pro)) )
	    (debug_msg pthuls "compile2obj_procedure pthuls")
	    (list_every 
	     pthuls
	     (lambda (pthu) 
	       (debug_msg pthu "compile2obj_procedure pthu")
	       (assert_msg "compile2obj_procedure check pthu" (is_closure pthu))
	       (pthu gcx)
	       )
	    )))
      (let ( (obody (compile_obj nbody gcx)) 
	     )
	(debug_msg obody "compile2obj_procedure obody")
	(list_append obodylist obody)
	)
      (debug_msg obrout "compile2obj_procedure return obrout")
      obrout
      )))

;;;; compile the initial procedure into an object
(defun compile2obj_initproc (ipro idata compicache)
  (assert_msg "check ipro" (is_a ipro class_nrep_initproc))
  (assert_msg "check idata" (is_list idata))
  (assert_msg "check compicache" (is_mapobject compicache))
  (debug_msg ipro "compile2obj_initproc ipro")
  (debug_msg compicache "compile2obj_initproc compicache")
  (let ( (locmap (make_mapobject discr_mapobjects 50))
	 (oinibody (make_list discr_list))
	 (oinitrout
	  (make_instance class_initialroutineobj
			 :named_name (make_stringconst discr_string "start_module_basilys")
			 :obrout_proc ipro
			 :obrout_body oinibody
			 :obrout_nbval (make_integerbox discr_integer 0)
			 :obrout_nblong (make_integerbox discr_integer 0)
			 :obrout_others (make_list discr_list)
			 :oirout_fill (make_list discr_list)
			 ))
	 (gcx (make_instance class_genercontext
			     :gncx_objrout oinitrout
			     :gncx_locmap locmap
			     :gncx_freeptrlist (make_list discr_list)
			     :gncx_freelonglist (make_list discr_list)
			     :gncx_freeothermaps (make_mapobject discr_mapobjects 20)
			     :gncx_compicache compicache
			     ))
	 (retloc 
	  (let ( (retl (get_free_objlocptr gcx '_retinit_)) )
	    (unsafe_put_fields gcx :gncx_retloc retl)
	    retl))
	 (odatatup 
	  (list_to_multiple
	   idata discr_multiple
	   (lambda (curdat)
	     ;;(debug_msg curdat "compile2obj_initproc curdat")
	     (assert_msg "check curdat" (is_a curdat class_nrep_data))
	     (let ( (curobd (compile_obj curdat gcx)) )
	       ;;(debug_msg curobd "compile2obj_initproc curobd")
	       curobd))))
	 (toplis (unsafe_get_field :ninit_topl ipro)) 
	 )
    (unsafe_put_fields oinitrout
		       :oirout_data odatatup)
    (assert_msg "check toplis" (is_list_or_null toplis))
    (list_every 
     toplis
     (lambda (curtop)
       (let ( (otop (compile_obj curtop gcx)) )
	 (debug_msg otop "compile2obj_initproc otop")
	 (list_append oinibody otop))))
    (debug_msg gcx "compile2obj_initproc final gcx")
    (debug_msg oinitrout "compile2obj_initproc final oinitrout")
    (return oinitrout)
    ))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;function to get a free local value pointer for some name
;; any free ptr is only reused for its offset. the objlocv is not reused...
(defun get_free_objlocptr (gcx nam)
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  ;;(debug_msg nam "get_free_objlocptr start nam")
  (let ( (orout (unsafe_get_field :gncx_objrout gcx))
	 (freeli (unsafe_get_field :gncx_freeptrlist gcx)) 
	 (pfree (list_popfirst freeli))
	 (:long off -1)
	 )
    ;;    (debug_msg pfree "get_free_objlocptr start pfree")
    ;;    (debug_msg freeli "get_free_objlocptr popped freeli")
    (if (not (is_a orout class_routineobj))
	(debug_msg orout "get_free_objlocptr bad orout"))
    (assert_msg "check orout" (is_a orout class_routineobj))
    (if (is_a pfree  class_objlocv)
	(let ( (offpfree (unsafe_get_field :obl_off pfree)) )
	  (assert_msg "get_free_objlocptr check offpfree" (is_integerbox offpfree))
	  (setq off (get_int offpfree)))
      (let ( (nbvalorout (unsafe_get_field :obrout_nbval orout)) )
	(setq off (get_int nbvalorout))
      ))
    (assert_msg "check off" (>=i off 0))
    (let ( (nbvalbox (unsafe_get_field :obrout_nbval orout)) 
	   (:long nbval (get_int nbvalbox))  
	   (nambuf (make_strbuf discr_strbuf))
	   )
      (cond ( (is_a nam class_named)
	      (let ( (namstr (unsafe_get_field :named_name nam)) )
		(add2sbuf_cident nambuf namstr)))
	    ( (is_string nam)
	      (add2sbuf_cident nambuf nam)))
      (add2sbuf_strconst nambuf "__V")
      (add2sbuf_longdec nambuf (+i nbval 1))
      (put_int nbvalbox (+i nbval 1))
      (let ( (namstr (strbuf2string discr_string nambuf))
	     (oldnbvalbox (make_integerbox discr_integer nbval))
	     (nloc (make_instance class_objlocv
				  :obv_type ctype_value
				  :obl_off (make_integerbox discr_integer off)
				  :obl_proc orout
				  :obl_cname namstr)) 
	     )
	(return nloc)
	))))



;;; function to get a free local long for some name
(defun get_free_objloclong (gcx nam)
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (let ( (orout (unsafe_get_field :gncx_objrout gcx))
	 (freeli (unsafe_get_field :gncx_freelonglist gcx)) 
	 (pfree (list_popfirst freeli))
	 (:long off -1)
	 )
    (assert_msg "check orout" (is_a orout class_routineobj))
    (if (is_a pfree  class_objlocv)
	(let ( (offpfree (unsafe_get_field :obl_off pfree)) )
	  (assert_msg "check offpfree" (is_integerbox offpfree))
	  (setq off (get_int offpfree)))
      (let ( (nblongorout (unsafe_get_field :obrout_nblong orout)) )
	(assert_msg "check nblongorout" (is_integerbox nblongorout))
	(setq off (get_int nblongorout))))
    (assert_msg "check off" (>=i off 0))
    (let ( (nblongbox (unsafe_get_field :obrout_nblong orout)) 
	   (:long nblong (get_int nblongbox))  
	   (nambuf (make_strbuf discr_strbuf))
	   )
      (cond ( (is_a nam class_named)
	      (add2sbuf_cident nambuf (unsafe_get_field :named_name nam)))
	    ( (is_string nam)
	      (add2sbuf_cident nambuf nam))
	    )
      (add2sbuf_strconst nambuf "__L")
      (add2sbuf_longdec nambuf (+i nblong 1))
      (put_int nblongbox (+i nblong 1))
      (let ( (nloc (make_instance class_objlocv
				  :obv_type ctype_long
				  :obl_off (make_integerbox discr_integer off)
				  :obl_cname (strbuf2string discr_string nambuf))) )
	(return nloc)
	))))

;;; function to get a free local otherstuff for some name and ctype
(defun get_free_objloctyped (gcx nam ctyp)
  (debug_msg nam "get_free_objloctyped nam")
  (debug_msg ctyp "get_free_objloctyped ctyp")
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (assert_msg "check ctyp" (is_a ctyp class_ctype))
  (cond ( (== ctyp ctype_long)
	  (get_free_objloclong gcx nam))
	( (== ctyp ctype_value)
	  (get_free_objlocptr gcx nam))
	;; return null for the void ctype
	( (== ctyp ctype_void)
	  (return (the_null)))
	(:else 
	 (debug_msg nam "getfreeobjloctyped nam")
	 (debug_msg ctyp "getfreeobjloctyped ctyp")
	 (let ( (freemap (unsafe_get_field :gncx_freeothermaps gcx)) 
		(orout (unsafe_get_field :gncx_objrout gcx))
		(:long off -1)
		)
	   (assert_msg "check freemap" (is_mapobject freemap))
	   (assert_msg "check orout" (is_a orout class_routineobj))
	   (let ( (freeli (mapobject_get freemap ctyp)) )
	     (if (null freeli) 
		 (progn
		   (setq freeli (make_list discr_list))
		   (mapobject_put freemap ctyp freeli)))
	     (let ( (pfree (list_popfirst freeli)) )
	       (if (is_a pfree  class_objlocv)
		   (setq off (get_int (unsafe_get_field :obl_off pfree)))
		 (setq off  (list_length (unsafe_get_field :obrout_others orout))))
	       (let ( 
		     (nambuf (make_strbuf discr_strbuf)) 
		     (others (unsafe_get_field :obrout_others orout))
		     (:long nbothers (list_length others))
		     )
		 (assert_msg "check others" (is_list others))
		 (add2sbuf_strconst nambuf "loc_")
		 (add2sbuf_cident nambuf  (unsafe_get_field :named_name ctyp))
		 (add2sbuf_strconst nambuf "__o")
		 (add2sbuf_longdec nambuf nbothers)
		 (let ( (nloc (make_instance class_objlocv
					     :obv_type ctyp
					     :obl_off (make_integerbox discr_integer off)
					     :obl_cname (strbuf2string discr_string nambuf))) )
		   (list_append others nloc)
		   (return nloc)
		   )
		 )))))))
  


;; function to dispose, i.e. mark as free, a binding 
(defun dispose_bnd_obj (bnd gcx)
  (assert_msg "check bnd" (is_a bnd class_any_binding))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg bnd "dispose_bnd_obj start bnd")
  (let ( (locmap (unsafe_get_field :gncx_locmap gcx))
	 (oldloc (mapobject_get locmap bnd)) )
    ;;(debug_msg locmap "dispose_bnd_obj start locmap")
    (if (null oldloc)
	(progn
	  ;; special hack to dispose a void let binding - return immediately in that case
	  (and (is_a bnd class_let_binding)
	       (== (unsafe_get_field :letbind_type bnd) ctype_void)
	       (return))
	  (debug_msg bnd "dispose_bnd_obj nulloldloc bnd")
	  ))
    (assert_msg "check oldloc" (is_a oldloc class_objlocv))
    ;;(debug_msg oldloc "dispose_bnd_obj oldloc")
    (mapobject_remove locmap bnd)
    ;;(debug_msg locmap "dispose_bnd_obj after remove locmap")
    (let ( (oldcty (unsafe_get_field :obv_type oldloc)) )
      (cond ( (== oldcty ctype_value)
	      (let  ( (freepl (unsafe_get_field :gncx_freeptrlist gcx)) )
		(list_append freepl oldloc)))
	    ( (== oldcty ctype_long)
	      (let  ( (freenl (unsafe_get_field :gncx_freelonglist gcx)) )
		(list_append freenl oldloc)))
	    (:else
	     (let ( (freemap (unsafe_get_field :gncx_freeothermaps gcx)) 
		    (orout (unsafe_get_field :gncx_objrout gcx))
		    )
	       (assert_msg "check freemap" (is_mapobject freemap))
	       (assert_msg "check orout" (is_a orout class_routineobj))
	       (let ( (freeli (mapobject_get freemap oldcty)) )
		 ;; since we are freeing, freeli should exist
		 (assert_msg "check freeli" (is_list freeli))
		 (list_append freeli oldloc))))))
    (debug_msg bnd "dispose_bnd_obj end bnd")
    ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_chunk (nchk gcx)
  (assert_msg "check nchk" (is_a nchk class_nrep_chunk))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg nchk "compilobj nrepchunk nchk")
;  (debug_msg gcx "compilobj nrepchunk gcx")
;  (debug_msg env "compilobj nrepchunk env")
  (let ( (loc (unsafe_get_field :nrep_loc nchk))
	 (nexp (unsafe_get_field :nchunk_expansion nchk))
	 (nprim (unsafe_get_field :nchunk_primitive nchk))
	 )
    (assert_msg "check nprim" (is_a nprim class_primitive))
    (assert_msg "check nexp" (is_multiple nexp))
    (let (  (otup (multiple_map
		   nexp
		   (lambda (comp :long ix)
		     (debug_msg comp "compobj nrepchunk comp")
		     (if (== (discrim comp) discr_verbatimstring)
			 comp
		       (compile_obj comp gcx)))
		   ))
	    (primty (unsafe_get_field :prim_type nprim))
	    (oexp (if (is_mixint loc)
		      (make_instance class_objlocatedexpv
				 :obv_type primty
				 :obx_cont otup
				 :obcx_loc loc
				 )
		    (make_instance class_objexpv
				 :obv_type primty
				 :obx_cont otup)
		    ))      
	    )
      (assert_msg "check primty" (is_a primty class_ctype))
      (debug_msg oexp "compiobj nrepchunk oexp")
      oexp)
    ))
(install_method class_nrep_chunk compile_obj compilobj_nrep_chunk)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_nil (nilo gcx)
  (assert_msg "check nilo" (is_a nilo class_nrep_nil))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg nilo "compilobj_nrep_nil nilo")
  (let ( (obnil (make_instance class_objnil
			       :obv_type ctype_value)) )
    (return obnil))
)

(install_method class_nrep_nil compile_obj compilobj_nrep_nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_comment (ncomm gcx)
  (assert_msg "check ncomm" (is_a ncomm class_nrep_comment))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg ncomm "compilobj_nrep_comment start")
  (let ( (coms (unsafe_get_field :ncomm_string ncomm))
	 (nloc (unsafe_get_field :nrep_loc ncomm))
	 (sbuf (make_strbuf discr_strbuf)) )
    (add2sbuf_strconst sbuf "/**!* ")
    (add2sbuf_ccomstring sbuf coms)
    (add2sbuf_strconst sbuf " *!**/")
    (let ( (ostr (strbuf2string discr_verbatimstring sbuf)) 
	   (res  (make_instance class_objcompute
				:obi_loc nloc
				:obdi_destlist ()
				:obcpt_expr ostr))
	   )  
      (debug_msg ostr "compilobj_nrep_comment ostr")
      (debug_msg res "compilobj_nrep_comment res")
      (return res)
      )))
(install_method class_nrep_comment compile_obj compilobj_nrep_comment)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_locsymocc (lsyo gcx)
  (assert_msg "check nchk" (is_a lsyo class_nrep_locsymocc))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (let ( (loc (unsafe_get_field :nrep_loc lsyo))
	 (locmap (unsafe_get_field :gncx_locmap gcx))
	 (sym (unsafe_get_field :nocc_symb lsyo))
	 (oty (unsafe_get_field :nocc_ctyp lsyo))
	 (sbnd (unsafe_get_field :nocc_bind lsyo))
	 (ovar (mapobject_get locmap sbnd))
	 )
;    (debug_msg gcx "compilobj locsymocc gcx")
;    (debug_msg lsyo "compilobj locsymocc begin lsyo")
;    (debug_msg sbnd "compilobj locsymocc sbnd")
;    (debug_msg oty "compilobj locsymocc oty")
;    (debug_msg ovar "compilobj locsymocc ovar")
    (if (null sbnd)
	(progn
	  (debug_msg lsyo "compilobj locsymocc null sbnd; lsyo=")
	  (debug_msg sym "compilobj locsymocc null sbnd; sym=")
	  ; (shortbacktrace_dbg "compilobj locsymocc  null sbnd" 16)
	  (assert_msg "locsymocc without binding" ())
	  ))
    (if (null ovar) 
	(progn
	  (debug_msg sbnd "compilobj locsymocc null ovar sbnd")
	  ;;(debug_msg gcx "compilobj locsymocc null ovar gcx")
	  ;;(debug_msg locmap "compilobj locsymocc null ovar locmap")
	  (debug_msg lsyo "compilobj locsymocc null ovar lsyo")
	  (assert_msg "compilobj locsymocc null ovar without ctype_void" (== oty ctype_void))
	  )
      (assert_msg "compilobj locsymocc check ovar"  (is_a ovar class_objlocv)))
;    (debug_msg ovar "compilobj locsymocc return ovar")
    (return ovar)
))
(install_method class_nrep_locsymocc compile_obj compilobj_nrep_locsymocc)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_closedocc (nclo gcx)
  (assert_msg "check nclo" (is_a nclo class_nrep_closedocc))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg nclo "compilobj closedocc nclo")
  ;;(debug_msg gcx "compilobj closedocc gcx")
  (let ( 
	(orout (unsafe_get_field :gncx_objrout gcx))
	(osym (unsafe_get_field :nocc_symb nclo))
	(obind (unsafe_get_field :nocc_bind nclo))
	(cprocs (unsafe_get_field :ncloc_procs nclo))
	(lastcproc (pair_head (list_last cprocs)))
	(nloc (unsafe_get_field :nrep_loc nclo))
	)
    ;;(debug_msg orout "compilobj closedocc orout")
    ;;(debug_msg nclo "compilobj closedocc nclo")
    ;;(debug_msg lastcproc "compilobj closedocc lastcproc")
    (assert_msg "check lastcproc" (is_a lastcproc class_nrep_routproc))
    (let ( (cloblis (unsafe_get_field :nrpro_closedb lastcproc)) 
	   (:long clorank -1)
	   )
      (assert_msg "check cloblis" (is_list cloblis))
      (let ( (curpair (list_first cloblis)) 
	     (:long curank 0)
	     )
	(forever 
	 looplis
	 (if (not (is_pair curpair)) (exit looplis))
	 (let ( (curbind (pair_head curpair)) )
	   (if (== curbind obind)
	       (progn
		 (setq clorank curank)
		 (exit looplis)))
	   (setq curpair (pair_tail curpair))
	   (setq curank (+i curank 1))
	   ))
	(assert_msg "check good closed rank" (>=i clorank 0))
	(let ( 
	      (nclotyp (unsafe_get_field :nocc_ctyp nclo))
	      (ocloccv 
		(make_instance class_objcloccv
			       :obv_type nclotyp
			       :obc_off (make_integerbox discr_integer
							 clorank)
			       :obc_proc lastcproc
			       :obc_name (unsafe_get_field :named_name osym)))
	      )
	  (assert_msg "check nclotyp" (is_a nclotyp class_ctype))
	  (debug_msg ocloccv "compilobj closedocc result ocloccv")
	  ocloccv
	  )))))
  
(install_method class_nrep_closedocc compile_obj compilobj_nrep_closedocc)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_constocc (ncnst gcx)
  (assert_msg "check ncnst" (is_a ncnst class_nrep_constocc))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg ncnst "compilobj constocc ncnst")
  ;;(debug_msg gcx "compilobj constocc gcx")
  (let ( 
	(orout (unsafe_get_field :gncx_objrout gcx))
	(osym (unsafe_get_field :nocc_symb ncnst))
	(cprocs (unsafe_get_field :ncloc_procs ncnst))
	(lastcproc (pair_head (list_last cprocs)))
	(nloc (unsafe_get_field :nrep_loc ncnst))
	)
    ;;(debug_msg orout "compilobj constocc orout")
    ;;(debug_msg nloc "compilobj constocc nloc")
    ;;(debug_msg lastcproc "compilobj constocc lastcproc")
    (assert_msg "check lastcproc" (is_a lastcproc class_nrep_routproc))
    (let ( (cnstlis (unsafe_get_field :nrpro_const lastcproc)) 
	   (:long cnstrank -1)
	   )
      (assert_msg "check cnstlis" (is_list cnstlis))
      (let ( (curpair (list_first cnstlis)) 
	     (:long curank 0)
	     )
	(forever 
	 looplis
	 (if (not (is_pair curpair)) (exit looplis))
	 (let ( (curelem (pair_head curpair)) )
	   (if (== curelem ncnst)
	       (progn
		 (setq cnstrank curank)
		 (exit looplis)))
	   (setq curpair (pair_tail curpair))
	   (setq curank (+i curank 1))
	   ))
	(assert_msg "check good const rank" (>=i cnstrank 0))
	(let ( 
	      (cnstyp (unsafe_get_field :nocc_ctyp ncnst))
	      (oconstv 
		(make_instance class_objconstv
			       :obv_type cnstyp
			       :obc_off (make_integerbox discr_integer
							 cnstrank)
			       :obc_proc lastcproc
			       :obc_name (unsafe_get_field :named_name osym))) )
	  (assert_msg "check cnstyp" (is_a cnstyp class_ctype))
	  (debug_msg oconstv "compilobj constocc result oconstv")
	  oconstv
	  )))))
  
(install_method class_nrep_constocc compile_obj compilobj_nrep_constocc)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a constant
(defun compilobj_nrep_constant (nconst gcx)
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (assert_msg "check nconst" (is_a nconst class_nrep_constant))
  (debug_msg nconst "compilobj constant nconst")
  (let ( (nloc (unsafe_get_field :nrep_loc nconst))
	 (sval (unsafe_get_field :nconst_sval nconst))
	 (data (unsafe_get_field :nconst_data nconst))
	 (proc (unsafe_get_field :nconst_proc nconst))
	 )
    (if (is_a proc class_nrep_routproc)
	(let ( (constlist (unsafe_get_field :nrpro_const proc)) 
	       (curpair (list_first constlist))
	       (:long coff -1)
	       (:long curank 0)
	       (nambuf (make_strbuf discr_strbuf))
	       )
	  (forever 
	   constloop
	   (if (is_pair curpair)
	       (let ((curconst (pair_head curpair)))
		 (if (== curconst data)
		     (progn
		       (setq coff curank)
		       (exit constloop)))
		 )
	     (exit constloop))
	   (setq curpair (pair_tail curpair))
	   (setq curank (+i curank 1))
	   )
	  (assert_msg "check coff" (>=i coff 0))
	  (add2sbuf_strconst nambuf "konst_")
	  (add2sbuf_longdec nambuf coff)
	  (if (is_a sval class_named)
	      (progn
		(add2sbuf_strconst nambuf "_")
		(add2sbuf_cident nambuf (unsafe_get_field :named_name sval))
		)
	    )
	  (let ( (constv 
		  (make_instance class_objconstv
				 :obv_type ctype_value
				 :obc_off (make_integerbox discr_integer coff)
				 :obc_proc proc
				 :obc_name (strbuf2string discr_string nambuf)
				 )) )
	    (debug_msg constv "compilobj constant constv")
	    (return constv)
	    )
	  )
      (let ( (odata (compile_obj data gcx)) )
	;; not inside a proc, just return the compiled data
	(debug_msg odata "compilobj constant odata")
	(return odata)
	)
      )
    )
  )
(install_method class_nrep_constant compile_obj compilobj_nrep_constant)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a forever
(defun compilobj_nrep_forever (nfor gcx)
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (assert_msg "check nfor" (is_a nfor class_nrep_forever))
  (debug_msg nfor "compilobj_nrep_forever nfor")
  ;;(debug_msg gcx "compilobj_nrep_forever gcx")
  (let ( (nloc (unsafe_get_field :nrep_loc nfor))
	 (nbind (unsafe_get_field :nforever_bind nfor))
	 (nbody (unsafe_get_field :nforever_body nfor))
	 (nres (unsafe_get_field :nforever_result nfor)) 
	 (oresv (get_free_objlocptr gcx nres))
;;;; the 99bis are useless - just for devbugging! should be removed later
	 (nbind99bis (unsafe_get_field :nforever_bind nfor))
	 (oresv99bis oresv)
	 )
    (debug_msg nbind "compilobj_nrep_forever initial nbind")
    (debug_msg (discrim nbind) "compilobj_nrep_forever initial nbind's class")
    (debug_msg (unsafe_get_field :labind_clonsy nbind) ":labind_clonsy in nbind")
    (assert_msg "check nbind" (is_a nbind class_label_binding))
    (debug_msg oresv "compilobj_nrep_forever oresv")
    (assert_msg "check oresv" (is_a oresv class_objlocv))
    (unsafe_put_fields nbind :labind_res oresv)
    (assert_msg "check again nbind" (is_object nbind))
    (debug_msg (unsafe_get_field :labind_clonsy nbind99bis) ":labind_clonsy in nbind99bis")
    (assert_msg "check 99bis nbind" (== nbind99bis nbind))
    (assert_msg "check 99bis oresv" (== oresv99bis oresv))
    (debug_msg nbind "compilobj_nrep_forever updated nbind")
    (let ( (closy (unsafe_get_field :labind_clonsy nbind)) 
	   (bodyl (make_list discr_list))
	   (epilogl (make_list discr_list))
	   (oloop (make_instance class_objloop
				 :obi_loc nloc
				 :oblo_bodyl bodyl
				 :oblo_epil epilogl
				 :obloop_label closy
				 :obloop_resv oresv))
	   )
      (assert_msg "check closy" (is_a closy class_clonedsymbol))
      (multiple_every
       nbody
       (lambda (ncomp :long ix)
	 (list_append bodyl (compile_obj ncomp gcx))))
      (debug_msg oloop "compilobj forever result oloop")
      oloop
      )
    )  
)
(install_method class_nrep_forever compile_obj compilobj_nrep_forever)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile an exit
(defun compilobj_nrep_exit (nexi gcx)
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (assert_msg "check nexi" (is_a nexi class_nrep_exit))
  (debug_msg nexi "compilobj_nrep_exit nexi")
  ;;(debug_msg gcx "compilobj_nrep_exit gcx")
  (let ( 
	(nloc (unsafe_get_field :nrep_loc nexi))
	(nbindx (unsafe_get_field :nexit_bind nexi))
	(nval (unsafe_get_field :nexit_val nexi)) )
    (assert_msg "check nbindx" (is_a nbindx class_label_binding))
    (let ( 
	  (inslist (make_list discr_list)) 
	  (epilist (make_list discr_list)) 
	  (destlist (make_list discr_list))
	  (oval (compile_obj nval gcx))
	  (bxres (unsafe_get_field :labind_res nbindx))
	  (obloc (make_instance class_objblock
				:obi_loc nloc
				:oblo_bodyl inslist
				:oblo_epil epilist
				))
	  (obex (make_instance class_objexit
			       :obi_loc nloc
			       :obexit_label (unsafe_get_field :labind_clonsy nbindx)
			       )) 
	  (obcom (make_instance class_objcompute
				:obi_loc nloc
				:obdi_destlist destlist
				:obcpt_expr oval))
	  )
      (list_append inslist obcom)
      (list_append epilist obex)
      (list_append destlist bxres)
      (debug_msg obloc "compilobj_nrep_exit return obloc")
      (return obloc)
      )))
(install_method class_nrep_exit compile_obj compilobj_nrep_exit)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_discrany (anyv gcx)
  (assert_msg "check gcx" (is_a gcx class_genercontext))
;  (debug_msg anyv "compilobj_discrany anyv")
  anyv
)
(install_method discr_anyrecv compile_obj compilobj_discrany)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_let (rlet gcx)
  (assert_msg "check rlet" (is_a rlet class_nrep_let))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (let ( (loc (unsafe_get_field :nrep_loc rlet))
	 (bnds (unsafe_get_field :nlet_bindings rlet))
	 (bdy (unsafe_get_field :nlet_body rlet))
	 (locmap (unsafe_get_field :gncx_locmap gcx))
	 (obodl (make_list discr_list))
	 (oepil (make_list discr_list))
	 (oblock (make_instance class_objblock
				:obi_loc loc
				:oblo_bodyl obodl
				:oblo_epil oepil))
	 )
    (debug_msg rlet "compilobj_nrep_let initial rlet")
    (debug_msg loc "compilobj_nrep_let initial loc")
    ;;(debug_msg locmap "compilobj_nrep_let initial locmap")
    ;;(debug_msg bdy "compilobj_nrep_let initial bdy")
    ;;    (debug_msg gcx "compilobj_nrep_let gcx")
    ;;    (debug_msg bnds "compilobj_nrep_let bnds")
    ;; for each normalexp in the bnds tuple
    ;; add the binding and the setting in the body and the clear in the epilogue
    (assert_msg "compilobj_nrep_let check bnds multiple" (is_multiple_or_null bnds))
    ;;(debug_msg loc "compilobj_nrep_let before iterate normbind loc")
    ;; iterate on normal bindings
    (multiple_every
     bnds
     (lambda (nlbnd :long ix)
       (debug_msg loc "compilobj_nrep_let current normbinding loc")
       (debug_msg nlbnd "compilobj_nrep_let current normbinding nlbnd")
       (debug_msg locmap "compilobj_nrep_let current normbinding locmap")
       (assert_msg "check nlbnd in compilobj_nrep_let" (is_a nlbnd class_normlet_binding))
       (let ( (bder (unsafe_get_field :binder nlbnd))
	      (cty (unsafe_get_field :letbind_type nlbnd))
	      (nexp (unsafe_get_field :letbind_expr nlbnd))
	      (obva (get_free_objloctyped gcx bder cty))
	      )
	 (debug_msg obva "compilobj_nrep_let current normbinding obva")
	 (debug_msg nexp "compilobj_nrep_let current normbinding nexp")
	 (let ( (obnx (compile_obj nexp gcx)) )
	   (debug_msg obnx "compilobj_nrep_let current normbinding obnx")
	   (if (is_a nexp class_sexpr) 
	       (if (not (is_object obnx))
		   (progn 
		     (debug_msg nexp "compilobj_nrep_let current normbinding faulty nexp")
		     (debug_msg obnx "compilobj_nrep_let current normbinding faulty obnx")
		     (assert_msg "compilobj_nrep_let check obnx" (is_object obnx)))))
	   (if obva
	       ;; non void cty
	       (progn
		 (mapobject_put locmap nlbnd obva)
		 (let ( (obpd (put_objdest obnx obva)) 
			(obmy (or obpd obnx))
			)
		   (debug_msg obpd "compilobj_nrep_let current obpd")
		   (debug_msg obmy "compilobj_nrep_let append obmy")
		   (list_append obodl obmy)
		 ))
	     (progn
	       ;; obva is nil when cty is void type 
	       (debug_msg obnx "compilobj_nrep_let append obnx")
	       (list_append obodl obnx)
	       ))
	   ;; add clearing of obva to epilogue part of oblock
	   (if obva 
	       (let ( (obcl (make_instance class_objclear
					   :obi_loc loc
					   :oclr_vloc obva)) 
		      )
		 (list_append oepil obcl)
		 ))))))
    (debug_msg loc "compilobj_nrep_let after iterate normbind loc")
    (debug_msg locmap "compilobj_nrep_let updated locmap")
    ;; compile each body component
    (multiple_every
     bdy
     (lambda (bdycomp :long ix)
       (debug_msg loc "compilobj_nrep_let body loc")
       (debug_msg bdycomp "compilobj_nrep_let body bdycomp")
       (let ( (objcomp  (compile_obj bdycomp gcx)) 
	      )
	 (debug_msg objcomp "compilobj_nrep_let body objcomp")
	 ;; objcomp is null when compiling a locvar of ctype_void;
	 ;; this happens with primitive of :void type
	 (if (null objcomp) (return objcomp)) ;return from the inner lambda
	 (list_append obodl objcomp))))
    (debug_msg loc "compilobj_nrep_let after iterate body loc")
    ;; dispose each binding
    (multiple_every
     bnds
     (lambda (obnd :long ix)
       (debug_msg loc "compilobj_nrep_let dispose loc")
       (debug_msg obnd "compilobj_nrep_let disposing obnd")
       (dispose_bnd_obj obnd gcx)))
    (debug_msg loc "compilobj_nrep_let quasifinal loc")
    (debug_msg locmap "compilobj_nrep_let final locmap")
    (debug_msg loc "compilobj_nrep_let final loc")
    (debug_msg oblock  "compilobj_nrep_let return oblock")
    (return oblock)			;return it
    ))

(install_method class_nrep_let compile_obj compilobj_nrep_let)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a setq
(defun compilobj_nrep_setq (nsq gcx)
  (assert_msg "check nsq" (is_a nsq class_nrep_setq))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg nsq "compilobj_nrep_setq nsq")
  (let ( (loc (unsafe_get_field :nrep_loc nsq))
	 (var (unsafe_get_field :nstq_var nsq))
	 (exp (unsafe_get_field :nstq_exp nsq))
	 (cexp (compile_obj exp gcx))
	 (cvar (compile_obj var gcx))
	 (cres (put_objdest cexp cvar))
	 )
    (and (is_a cres class_objinstr)
	 (null (unsafe_get_field :obi_loc cres))
	 (unsafe_put_fields cres :obi_loc loc))
    (debug_msg cres "compilobj_nrep_setq cres")
    cres
    ))
(install_method class_nrep_setq compile_obj compilobj_nrep_setq)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a progn
(defun compilobj_nrep_progn (npro gcx)
  (assert_msg "check npro" (is_a npro class_nrep_progn))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg npro "compilobj_nrep_progn npro")
  (let ( (loc (unsafe_get_field :nrep_loc npro))
	 (nseq (unsafe_get_field :nprogn_seq npro))
	 (nlast (unsafe_get_field :nprogn_last npro))
	 (bodyl (make_list discr_list))
	 (oblock (make_instance class_objblock
				:obi_loc loc
				:oblo_bodyl bodyl
				;; :oblo_epil is left null
				))
	 )
    (multiple_every
     nseq
     (lambda (ncomp :long ix)
       (let ( (ocomp (compile_obj ncomp gcx)) )
	 (list_append bodyl ocomp)
	 )))
    (let ( (olast (compile_obj nlast gcx)) )
      (list_append bodyl olast))
    (debug_msg oblock "compilobj_nrep_progn oblock")
    (return oblock)
    ))
(install_method class_nrep_progn compile_obj compilobj_nrep_progn)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a multacc [data multiple accessor]
(defun compilobj_nrep_multacc (nma gcx)
  (assert_msg "check nma" (is_a nma class_nrep_multacc))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg nma "compilobj_nrep_multacc nma")
  (let ( (loc (unsafe_get_field :nrep_loc nma))
	 (mul (unsafe_get_field :naccm_mul nma))
	 (ix (unsafe_get_field :naccm_ix nma))
	 (cmul (compile_obj mul gcx))
	 ;; we factor the case when the tuple access cannot be done at
	 ;; compile time
	 (makecompute 
	  (lambda ()
	    (let (
		  (tcont 
		   (make_tuple5 
		    discr_multiple
		    (make_stringconst discr_verbatimstring "/*multacc*/(basilys_multiple_nth((")
		    cmul
		    (make_stringconst discr_verbatimstring "), (")
		    ix
		    (make_stringconst discr_verbatimstring ")))")
		    ))
		  (res 
		   (make_instance class_objexpv
				  :obv_type ctype_value
				  :obx_cont tcont))
		  )
	      (debug_msg res "compilobj_nrep_multacc makecompute res")
	      res
	      ))
	  )
	 )
    (debug_msg cmul "compilobj_nrep_multacc cmul")
    (debug_msg nma "compilobj_nrep_multacc again nma")
    (if (and
	 (is_a cmul class_objinitmultiple)
	 (is_integerbox ix))
	(let ( (comptup (unsafe_get_field :oim_tupval cmul)) )
	  (if (is_multiple comptup)
	      (let (
		    (curval (multiple_nth comptup (get_int ix))) 
		    )
		(debug_msg curval "compilobj_nrep_multacc returning curval")
		(return curval)
		)
	    (makecompute)
	    ))
      (makecompute)
      )))
(install_method class_nrep_multacc compile_obj compilobj_nrep_multacc)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a fieldacc [data field accessor]
(defun compilobj_nrep_fieldacc (nfa gcx)
  (assert_msg "check nfa" (is_a nfa class_nrep_fieldacc))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg nfa "compilobj_nrep_fieldacc nfa")
  (let ( (loc (unsafe_get_field :nrep_loc nfa))
	 (obj (unsafe_get_field :naccf_obj nfa))
	 (fld (unsafe_get_field :naccf_fld nfa))
	 (:long fldoff (get_int fld))
	 (boxfldoff (make_integerbox discr_integer fldoff))
	 (cobj (compile_obj obj gcx))
	 ;; we factor the case when the field access cannot be done at
	 ;; compile time
	 (makecompute 
	  (lambda ()
	    (let ( 
		  (tcont 
		    (make_tuple5 discr_multiple  
				 (make_stringconst discr_verbatimstring "/*fieldacc*/(basilys_field_object((")
				 cobj
				 (make_stringconst discr_verbatimstring "),")
				 boxfldoff
				 (make_stringconst discr_verbatimstring "))")
				 )) 
		   (res 
		    (make_instance class_objexpv
				   :obv_type ctype_value
				   :obx_cont tcont))
		   )
	      (debug_msg res "compilobj_nrep_fieldacc makecompute res")
	      res
	      )))
	 )
    (assert_msg "compilobj_nrep_fieldacc check fld" (is_a fld class_field))
    (debug_msg cobj "compilobj_nrep_fieldacc cobj")
    (debug_msg fld "compilobj_nrep_fieldacc fld")
    (if (is_a cobj class_objinitobject)
	(let ( (cdata (unsafe_get_field :oie_data cobj)) 
	       )
	  (if (is_a cdata class_nrep_datainstance)
	      (let ( (slotup (unsafe_get_field :ninst_slots cdata)) 
		     (ourslot (multiple_nth slotup fldoff)) 
		     )
		(if (is_a ourslot class_nrep_data)
		    (let ( (cslot (compile_obj ourslot gcx)) )
		      (debug_msg cslot "compilobj_nrep_fieldacc returning cslot")
		      (return cslot))
		  (return (makecompute))))
	    (return (makecompute)))
	  )
      (return (makecompute))
      )))
(install_method class_nrep_fieldacc compile_obj compilobj_nrep_fieldacc)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile an unsafe get field access
(defun compilobj_nrep_unsafe_get_field (nugf gcx)
  (assert_msg "check nugf" (is_a nugf class_nrep_unsafe_get_field))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg nugf "compilobj_nrep_unsafe_get_field nugf")
  (let ( (loc (unsafe_get_field :nrep_loc nugf)) 
	 (nobj (unsafe_get_field :nuget_obj nugf))
	 (nfield (unsafe_get_field :nuget_field nugf))
	 (dlist (make_list discr_list))
	 (oobj (compile_obj nobj gcx))
	 (ogetslot (make_instance class_objgetslot
				  :obi_loc loc
				  :obdi_destlist dlist
				  :ogetsl_obj oobj
				  :ogetsl_field nfield))
	 )
    (return ogetslot)
))
(install_method class_nrep_unsafe_get_field compile_obj compilobj_nrep_unsafe_get_field)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile an unsafe put fields
(defun compilobj_nrep_unsafe_put_fields (nupf gcx)
  (assert_msg "check nupf" (is_a nupf class_nrep_unsafe_put_fields))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg nupf "compilobj_nrep_unsafe_put_fields nupf")
  (let ( (loc (unsafe_get_field :nrep_loc nupf)) 
	 (nobj (unsafe_get_field :nuput_obj nupf))
	 (nfldass (unsafe_get_field :nuput_fields nupf))
	 (obodl (make_list discr_list))
	 (oepil (make_list discr_list))
	 (oblock (make_instance class_objblock
				:obi_loc loc
				:oblo_bodyl obodl
				:oblo_epil oepil))
	 (oobj (compile_obj nobj gcx))
	 )
    (multiple_every 
     nfldass
     (lambda (nfa :long ix)
       (assert_msg "check nfa" (is_a nfa class_nrep_fieldassign))
       (let ( (aloc (unsafe_get_field :nrep_loc nfa)) 
	      (afield (unsafe_get_field :nfla_field nfa))
	      (aval (unsafe_get_field :nfla_val nfa))
	      (:long aoff (get_int afield))
	      )
	 (assert_msg "check afield" (is_a afield class_field))
	 (let ( 
	       (oval (compile_obj aval gcx)) 
	       (opuf (make_instance class_objputslot
				    :obi_loc (if aloc aloc loc)
				    :oslot_odata oobj
				    :oslot_field afield
				    :oslot_offset (make_integerbox discr_integer aoff)
				    :oslot_value oval)) )
	   (assert_msg "compilobj_nrep_unsafe_put_fields check oval not nrep" (not (is_a oval class_nrep)))
	   (list_append obodl opuf))
	 )))
    (list_append obodl (make_instance class_objtouch
				      :obi_loc loc
				      :otouch_val oobj))
    ;; add the touched obj to the block
    (list_append obodl oobj)
    (return oblock)
    ))
(install_method class_nrep_unsafe_put_fields compile_obj compilobj_nrep_unsafe_put_fields)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a simple application
(defun compilobj_nrep_apply (napp gcx)
  (assert_msg "check napp" (is_a napp class_nrep_apply))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (let ( (loc (unsafe_get_field :nrep_loc napp))
	 (fun (unsafe_get_field :napp_fun napp))
	 (args (unsafe_get_field :napp_args napp))
	 )
    (debug_msg napp "compilobj_nrep_apply napp")
    (let ( (oclos (compile_obj fun gcx)) 
	   (oargs (multiple_map
		   args
		   (lambda (comp :long ix)
		     (let ( (ocomp (compile_obj comp gcx)) )
		       (assert_msg "compilobj_nrep_apply check ocomp not objinstr"
				   (not (is_a ocomp class_objinstr)))
		       ocomp))))
	   (dlist (make_list discr_list))
	   (oapp 
	    (make_instance 
	     class_objapply
	     :obi_loc loc
	     :obdi_destlist dlist
	     :obapp_clos oclos
	     :obapp_args oargs))
	   )
      (debug_msg oapp "compilobj_nrep_apply return oapp")
      oapp
      )))
(install_method class_nrep_apply compile_obj compilobj_nrep_apply)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_multiapply (nmapp gcx)
  (assert_msg "check napp" (is_a nmapp class_nrep_multiapply))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg nmapp "compilobj_nrep_multiapply nmapp")
  (let ( (loc (unsafe_get_field :nrep_loc nmapp))
	 (rbinds (unsafe_get_field :nmulapp_bindings nmapp))
	 (fun (unsafe_get_field :napp_fun nmapp))
	 (args (unsafe_get_field :napp_args nmapp))
	 (nbody (unsafe_get_field :nmulapp_body nmapp))
	 (locmap (unsafe_get_field :gncx_locmap gcx))
	 (:long nbres (multiple_length rbinds))
	 (reslocs 
	  (multiple_map
	   rbinds
	   (lambda (bind :long ix)
	     (debug_msg bind "compilobj_nrep_multiapply bind")
	     (assert_msg "compilobj_nrep_multiapply check bind" 
			 (is_a bind class_formal_binding))
	     (let ( (bder (unsafe_get_field :binder bind))
		    (cty (unsafe_get_field :fbind_type bind)) 
		    (obva (get_free_objloctyped gcx bder cty))
		    )
	       (assert_msg "compilobj_nrep_multiapply check cty" 
			   (is_a cty class_ctype))
	       ;; link nlbnd to obva in locmap
	       (if obva (mapobject_put locmap bind obva))
	       (debug_msg obva "compilobj_nrep_multiapply obva")
	       obva
	       ))))
	 (obodl (make_list discr_list))
	 (oepil (make_list discr_list))
	 (oblock (make_instance class_objblock
				:obi_loc loc
				:oblo_bodyl obodl
				:oblo_epil oepil))
	 (oxres (if (>i nbres 1) (make_multiple discr_multiple (-i nbres 1)) ()))
	 (firstres (multiple_nth reslocs 0))
	 (ofun (compile_obj fun gcx))
	 (reslist (make_list discr_list))
	 (oargs (multiple_map args
			      (lambda (comp :long ix)
				(compile_obj comp gcx))))
	 (obody (compile_obj nbody gcx))
	 (omapp (make_instance class_objmultiapply
			       :obi_loc loc
			       :obdi_destlist reslist
			       :obapp_clos (compile_obj fun gcx)
			       :obapp_args oargs
			       :obmultapp_xres oxres))
	 )
    (if firstres (list_append reslist firstres))
    ;; add every compiled argument to the resulting block unless it is a pure value
    (multiple_every 
     oargs
     (lambda (ocurarg :long ix)
       (debug_msg ocurarg "compilobj_nrep_multiapply ocurarg")
       (if (and ocurarg (is_not_a ocurarg class_objpurevalue))
	   (list_append obodl ocurarg))))
    ;; add the multiapply to the block
    (list_append obodl omapp)
    ;; add the compiled body to the block
    (debug_msg obody "compilobj_nrep_multiapply obody")
    (list_append obodl obody)
    ;; add the clearing of each result to epilog
    (multiple_every 
     reslocs
     (lambda (rloc :long ix)
       (if (>i ix 0) 
	   (let ( (oclear (make_instance class_objclear 
					 :obi_loc loc
					 :oclr_vloc rloc)) )
	     (list_append oepil oclear)
	     (multiple_put_nth oxres (-i ix 1) rloc)
	     ))))
    ;; dispose the local bindings
    (multiple_every 
     rbinds
     (lambda (bind :long ix) (dispose_bnd_obj bind gcx)))
    (debug_msg oblock "compilobj_nrep_multiapply final oblock")
    oblock
    ))
(install_method class_nrep_multiapply compile_obj compilobj_nrep_multiapply)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a simple message send
(defun compilobj_nrep_msend (nsnd gcx)
  (assert_msg "check nsnd" (is_a nsnd class_nrep_msend))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (let ( (loc (unsafe_get_field :nrep_loc nsnd))
	 (nsel (unsafe_get_field :nsend_sel nsnd))
	 (nrecv (unsafe_get_field :nsend_recv nsnd))
	 (nargs (unsafe_get_field :nsend_args nsnd))
	 )
    (debug_msg nsnd "compilobj_nrep_msend nsnd")
    (let ( (osel (compile_obj nsel gcx))
	   (orecv (compile_obj nrecv gcx))
	   (oargs (multiple_map nargs
				(lambda (comp :long ix)
				  (compile_obj comp gcx))))
	   (osend
	    (make_instance 
	     class_objmsend
	     :obi_loc loc
	     :obdi_destlist (make_list discr_list)
	     :obmsnd_sel osel
	     :obmsnd_recv orecv
	     :obmsnd_args oargs
	     ))
	   )
      (debug_msg osend "compilobj_nrep_msend osend")
      osend
      )))
(install_method class_nrep_msend compile_obj compilobj_nrep_msend)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a multiresult message send
(defun compilobj_nrep_multimsend (nmsnd gcx)
  (assert_msg "check nmsnd" (is_a nmsnd class_nrep_multimsend))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg nmsnd "compilobj_nrep_multimsend nmsnd")
  (let ( (loc (unsafe_get_field :nrep_loc nmsnd)) 
	 (rbinds (unsafe_get_field :nmulsend_bindings nmsnd))
	 (nbody (unsafe_get_field :nmulsend_body nmsnd))  ; a single normalized expression
	 (nsel (unsafe_get_field :nsend_sel nmsnd))
	 (nrecv (unsafe_get_field :nsend_recv nmsnd))
	 (nargs (unsafe_get_field :nsend_args nmsnd))
	 (locmap (unsafe_get_field :gncx_locmap gcx))
	 (:long nbres (multiple_length rbinds))
	 (reslocs 
	  (multiple_map
	   rbinds
	   (lambda (bind :long ix)
	     (debug_msg bind "compilobj_nrep_multimsend bind")
	     (assert_msg "compilobj_nrep_multimsend check bind" 
			 (is_a bind class_formal_binding))
	     (let ( (bder (unsafe_get_field :binder bind))
		    (cty (unsafe_get_field :fbind_type bind)) 
		    (obva (get_free_objloctyped gcx bder cty))
		    )
	       (assert_msg "compilobj_nrep_multimsend check cty" 
			   (is_a cty class_ctype))
	       ;; link nlbnd to obva in locmap
	       (if obva (mapobject_put locmap bind obva))
	       (debug_msg obva "compilobj_nrep_multimsend obva")
	       obva
	       ))))
	 (oxres (if (>i nbres 1) 
		    (make_multiple discr_multiple  (-i nbres 1))))
	 (firstres (multiple_nth reslocs 0))
	 (osel (compile_obj nsel gcx))
	 (reslist (make_list discr_list))
	 (orecv (compile_obj nrecv gcx))
	 (oargs (multiple_map nargs
			      (lambda (comp :long ix)
				(compile_obj comp gcx))))
	 (obody (compile_obj nbody gcx))
	 (obodl (make_list discr_list))
	 (oepil (make_list discr_list))
	 (oblock (make_instance class_objblock
				:obi_loc loc
				:oblo_bodyl obodl
				:oblo_epil oepil))
	 (omsend (make_instance class_objmultimsend
				:obi_loc loc
				:obdi_destlist reslist
				:obmsnd_sel osel
				:obmsnd_recv orecv
				:obmsnd_args oargs
				:obmultsnd_xres oxres))
	 )
    (debug_msg reslocs "compilobj_nrep_multimsend reslocs")
    (if firstres (list_append reslist firstres))
    ;; add every compiled argument to the resulting block unless it is a pure value
    (multiple_every 
     oargs
     (lambda (ocurarg :long ix)
       (debug_msg ocurarg "compilobj_nrep_multimsend ocurarg")
       (if (and ocurarg (is_not_a ocurarg class_objpurevalue))
	   (list_append obodl ocurarg))))
    ;; add the multisend to the block
    (list_append obodl omsend)
    ;; add the compiled body to the block
    (list_append obodl obody)
    ;; add the clearing of each result to epilog
    (multiple_every 
     reslocs
     (lambda (rloc :long ix)
       (if (>i ix 0)
	   (let ( (oclear (make_instance class_objclear 
					 :obi_loc loc
					 :oclr_vloc rloc)) )
	     (list_append oepil oclear)
	     (multiple_put_nth oxres (-i ix 1) rloc)))))
    ;; dispose the local bindings
    (multiple_every 
     rbinds
     (lambda (bind :long ix) (dispose_bnd_obj bind gcx)))
    (debug_msg oblock "compilobj_nrep_multimsend final oblock")
    oblock
    ))

(install_method class_nrep_multimsend compile_obj compilobj_nrep_multimsend)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; compile bindings
(defun compilobj_any_binding  (bind gcx)
  (assert_msg "check bind" (is_a bind class_any_binding))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg bind "compilobj_any_binding bind")
  (displaydebugmsg bind "class_bind compile_obj recv")
  (outcstring_err "* compilobj unimplemented reciever binding class ")
  (let ( (discr (discrim bind)) ) (outstr_err (unsafe_get_field :named_name discr)))
  (outnewline_err)
  (assert_msg "@@compile_obj should be implemented in anybinding-s subclasses" ())
)
(install_method class_any_binding compile_obj compilobj_any_binding)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; compile value bindings
(defun compilobj_value_binding  (bind gcx)
  (assert_msg "check bind" (is_a bind class_value_binding))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg bind "compilobj_value_binding bind")
  (assert_msg "@@unimplemented compilobj_value_binding" ())
)
(install_method class_value_binding compile_obj compilobj_value_binding )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; compile selector bindings
(defun compilobj_selector_binding  (bind gcx)
  (assert_msg "check bind" (is_a bind class_selector_binding))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg bind "compilobj_selector_binding bind")
  (let ( (sbdata (unsafe_get_field :sbind_selectordata bind)) 
	 (osdata (compile_obj sbdata gcx)) )
    (debug_msg osdata "compilobj_selector_binding osdata")
    (return osdata)
    )
)

(install_method class_selector_binding compile_obj compilobj_selector_binding)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; compile primitive bindings
(defun compilobj_primitive_binding  (bind gcx)
  (assert_msg "check bind" (is_a bind class_primitive_binding))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg bind "compilobj_primitive_binding bind")
  (let ( (pbdata (unsafe_get_field :pbind_primdata bind)) 
	 (opdata (compile_obj pbdata gcx)) )
    (debug_msg opdata "compilobj_primitive_binding opdata")
    (return opdata))
)
(install_method class_primitive_binding compile_obj compilobj_primitive_binding)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; compile function bindings
(defun compilobj_function_binding  (bind gcx)
  (assert_msg "check bind" (is_a bind class_function_binding))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg bind "compilobj_function_binding bind")
  (let ( (fbdata (unsafe_get_field :fubind_fundata bind))
	 (ofdata (compile_obj fbdata gcx)) )
    (debug_msg ofdata "compilobj_function_binding ofdata")
    (return ofdata))
)
(install_method class_function_binding compile_obj compilobj_function_binding)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; compile class bindings
(defun compilobj_class_binding  (bind gcx)
  (assert_msg "check bind" (is_a bind class_class_binding))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg bind "compilobj_class_binding bind")
  (let ( (cbdata (unsafe_get_field :cbind_cladata bind)) 
	 (ocdata (compile_obj cbdata gcx)) )
    (debug_msg ocdata "compilobj_class_binding ocdata")
    (return ocdata))
)
(install_method class_class_binding compile_obj compilobj_class_binding)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; compile field bindings
(defun compilobj_field_binding  (bind gcx)
  (assert_msg "check bind" (is_a bind class_field_binding))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg bind "compilobj_field_binding bind")
  (let ( (fbdata (unsafe_get_field :flbind_fdata bind))
	 (ofdata (compile_obj fbdata gcx)) )
    (debug_msg ofdata "compilobj_field_binding ofdata")
    (return ofdata))
)
(install_method class_field_binding compile_obj compilobj_field_binding)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; compile instance bindings
(defun compilobj_instance_binding  (bind gcx)
  (assert_msg "check bind" (is_a bind class_instance_binding))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg bind "compilobj_instance_binding bind")
  (let ( (ibdata (unsafe_get_field :ibind_data bind)) 
	 (oidata (compile_obj ibdata gcx)) )
    (debug_msg oidata "compilobj_instance_binding oidata" oidata)
    (return oidata))
)
(install_method class_instance_binding compile_obj compilobj_instance_binding)




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun putobjdest_objvalue (recv desto)
  (assert_msg "check recv" (is_a recv class_objvalue))
  (assert_msg "check desto" (is_a desto class_objlocv))
  (let ( (typrecv (unsafe_get_field :obv_type recv))
	 (typdesto (unsafe_get_field :obv_type desto)) 
	 )
    (cond
     ;; special case when reciver is void
     ( (== typrecv ctype_void)
       (if (== typdesto ctype_void)
	   (return recv)
	 ;; if recv is void we just create a block with recv and the
	 ;; clear of desto
	 (let ( 
	       (obodl (make_list discr_list))
	       (oblk (make_instance class_objblock
				    ;; dont fill :obi_loc
				    :oblo_bodyl obodl
				    :oblo_epil ()
				    )
		     )
	       (oclr (make_instance class_objclear
				    ;; dont fill :obi_loc
				    :oclr_vloc desto
				    ))
	       )
	   (list_append obodl recv)
	   (list_append obodl oclr)
	   ;; the last of the block is the destination location, to
	   ;; avoid latter putobjdest-s on the objclear
	   (list_append obodl desto)
	   (return oblk)
	   )))
     ;; common case when desto & recv have same type
     ( (== typrecv typdesto)
       (assert_msg "check same typrecv&rtpdesto" (is_a typrecv class_ctype))
       (let ( (destlis (make_list discr_list))
	      (explis (make_list discr_list))
	      (obc (make_instance class_objcompute
				  ;; dont fill :obi_loc
				  :obdi_destlist destlis
				  :obcpt_expr explis
				  )) 
	      )
	 (list_append destlis desto)
	 (list_append explis recv)
	 (return obc)))
     ;; error case: type mismatch
     (:else
      (debug_msg recv "putobjdest_objvalue mismatching recv")
      (debug_msg typrecv "putobjdest_objvalue mismatching typrecv")
      (debug_msg desto "putobjdest_objvalue mismatching desto")
      (debug_msg typdesto "putobjdest_objvalue mismatching typdesto")
      (outcstring_err "putobjdest_objvalue type mismatch : recv <")
      (let ( (discr (discrim recv)) ) (outstr_err (unsafe_get_field :named_name discr)))
      (outcstring_err "> & desto<") 
      (let ( (discr (discrim desto)) ) (outstr_err (unsafe_get_field :named_name discr)))
      (outcstring_err ">")
      (outnewline_err)
      (assert_msg "putobjdest_objvalue type mismatch" ())
      (return recv)))
    ))

(install_method class_objvalue  put_objdest  putobjdest_objvalue)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun putobjdest_integer (recv desto)
  (assert_msg "check recv" (is_integerbox recv))
  (assert_msg "check desto" (is_a desto class_objlocv))
  (debug_msg recv "putobjdest_integer recv")
  (debug_msg desto "putobjdest_integer desto")
  (let ( (destlis (make_list discr_list))
	 (explis (make_list discr_list))
	 (typdesto (unsafe_get_field :obv_type desto))
	 (obc (make_instance class_objcompute
			     ;; dont fill :obi_loc
			     :obdi_destlist destlis
			     :obcpt_expr explis
			     )) 
	 )
    (assert_msg "check typdesto" (== typdesto ctype_long))
    (list_append destlis desto)
    (list_append explis recv)
    (debug_msg obc "putobjdest_integer return obc")
    obc
    ))
(install_method discr_integer put_objdest putobjdest_integer)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun putobjdest_null (recv desto)
  (assert_msg "check recv" (null recv))
  (assert_msg "check desto" (is_a desto class_objlocv))
  (debug_msg recv "putobjdest_integer recv")
  (debug_msg desto "putobjdest_integer desto")
  (let ( (destlis (make_list discr_list))
	 (explis (make_list discr_list))
	 (typdesto (unsafe_get_field :obv_type desto))
	 (obc (make_instance class_objcompute
			     ;; dont fill :obi_loc
			     :obdi_destlist destlis
			     :obcpt_expr explis
			     )) 
	 )
	(list_append destlis desto)
    (if (== typdesto ctype_long)
	(list_append explis (make_integerbox discr_integer 0))
      (list_append explis recv))
    (debug_msg obc "putobjdest_null return obc")
    obc
    ))
(install_method discr_nullrecv put_objdest putobjdest_null)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun putobjdest_objblock (recv desto)
  (assert_msg "check recv" (is_a recv class_objblock))
  (assert_msg "check desto" (is_a desto class_objlocv))
;  (debug_msg recv "putobjdest block recv")
;  (debug_msg desto "putobjdest block desto")
  (let ( (obl (unsafe_get_field :oblo_bodyl recv))
	 (oep (unsafe_get_field :oblo_epil recv))
	 )
    (assert_msg "check obl" (is_list_or_null obl))
    (assert_msg "check oep" (is_list_or_null oep))
    ;; maybe we should remove in the epilogue any clear of same ctype & offset
    (let ( (lpby (list_last obl))
	   (lasbp (pair_head lpby))
	   )
      (if lasbp 
	  (let ( (uplasb (put_objdest lasbp desto)) )
	    (pair_set_head lpby uplasb)
	    )
	)
      )
;    (debug_msg recv "putobjdest block updated recv")
    recv
    ))

(install_method class_objblock  put_objdest  putobjdest_objblock)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun putobjdest_objloop (recv desto)
  (assert_msg "check recv" (is_a recv class_objloop))
  (assert_msg "check desto" (is_a desto class_objlocv))
  (let ( (epil (unsafe_get_field :oblo_epil recv)) 
	 (resv (unsafe_get_field :obloop_resv recv))
	 (destlist (make_list discr_list))
	 (obc (make_instance class_objcompute
			     ;; dont fill :obi_loc
			     :obdi_destlist destlist
			     :obcpt_expr resv
			     ))
	 )
    (list_append destlist desto)
    (assert_msg "check epil" (is_list epil))
    (assert_msg "check resv" (is_a resv class_objlocv))
    (list_append epil obc)
    )
  (debug_msg recv "putobjdest loop updated recv")
  recv
  )
(install_method class_objloop  put_objdest  putobjdest_objloop)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; do nothing when puting a destination into an objexit
(defun putobjdest_objexit (recv desto)
  (assert_msg "check recv" (is_a recv class_objexit))
  (assert_msg "check desto" (is_a desto class_objlocv))
    recv
)
(install_method class_objexit put_objdest putobjdest_objexit)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_if (rif gcx)
  (assert_msg "check rif" (is_a rif class_nrep_if))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg rif "compilobj_nrep_if rif")
  (let ( (loc (unsafe_get_field :nrep_loc rif))
	 (ntest (unsafe_get_field :nif_test rif))
	 (nthen (unsafe_get_field :nif_then rif))
	 (nelse (unsafe_get_field :nif_else rif))
	 (nctyp (unsafe_get_field :nif_ctyp rif))
	 )
    (assert_msg "check nctyp" (is_a nctyp class_ctype))
    (let ( (otest (compile_obj ntest gcx))
	   (othen (compile_obj nthen gcx))
	   (oelse (if (is_not_a nelse class_nrep_nil) 
		      (compile_obj nelse gcx)))
	   (obif (make_instance class_objcond
				:obi_loc loc
				:obcond_test otest
				:obcond_then othen
				:obcond_else oelse))
	   )
      (assert_msg "check otest" (notnull otest))
      (debug_msg obif "compilobj_nrep_if obif")
      obif
      )))
(install_method class_nrep_if compile_obj compilobj_nrep_if)

;;;;;;;;;;;;;
(defun putobjdest_objcond (recv desto)
;  (debug_msg recv "putobjdest objcond recv")
;  (debug_msg desto "putobjdest objcond desto")
  (assert_msg "check recv" (is_a recv class_objcond))
  (assert_msg "check desto" (is_a desto class_objlocv))
  (let ( (othen (unsafe_get_field :obcond_then recv))
	 (oelse (unsafe_get_field :obcond_else recv)) 
	 )
 ;   (debug_msg othen "putobjdest objcond othen")
 ;   (debug_msg oelse "putobjdest objcond oelse")
    (let ( (dthen (put_objdest othen desto))
	   (delse (put_objdest oelse desto)) )
;      (debug_msg dthen "putobjdest objcond dthen")
;      (debug_msg delse "putobjdest objcond delse")
      (unsafe_put_fields recv
			 :obcond_then dthen
			 :obcond_else delse)
;      (debug_msg recv "putobjdest objcond updated recv")
      recv
      )))

(install_method class_objcond  put_objdest  putobjdest_objcond)
;;;;;;;;;;;;;;;;

(defun compilobj_nrep_cppif (pif gcx)
  (assert_msg "check pif" (is_a pif class_nrep_cppif))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg pif "compilobj_nrep_cppif pif")
  (let ( (loc (unsafe_get_field :nrep_loc pif))
	 (ncond (unsafe_get_field :nifp_cond pif))
	 (nthen (unsafe_get_field :nifp_then pif))
	 (nelse (unsafe_get_field :nifp_else pif))
	 (ctyp (unsafe_get_field :nifp_ctyp pif))
	 (scond (cond
		 ( (is_a ncond class_symbol) (unsafe_get_field :named_name ncond))
		 ( (is_string ncond) ncond)
		 (:else (assert_msg "invalid ncond in nrep_cppif" ()))))
	 (othen (compile_obj nthen gcx))
	 (oelse (compile_obj nelse gcx))
	 (res (make_instance class_objcppif
			     :obi_loc loc
			     :obifp_cond scond
			     :obifp_then othen
			     :obifp_else oelse))
	 )
    (debug_msg res "compilobj_nrep_cppif result")
    (return res)
    ))
(install_method class_nrep_cppif compile_obj compilobj_nrep_cppif)


;;;;;;;;;;;;;
(defun putobjdest_objcppif (recv desto)
;  (debug_msg recv "putobjdest objcppif recv")
;  (debug_msg desto "putobjdest objcppif desto")
  (assert_msg "check recv" (is_a recv class_objcppif))
  (assert_msg "check desto" (is_a desto class_objlocv))
  (let ( (othen (unsafe_get_field :obifp_then recv))
	 (oelse (unsafe_get_field :obifp_else recv)) 
	 )
 ;   (debug_msg othen "putobjdest objcppif othen")
 ;   (debug_msg oelse "putobjdest objcppif oelse")
    (let ( (dthen (put_objdest othen desto))
	   (delse (put_objdest oelse desto)) )
;      (debug_msg dthen "putobjdest objcppif dthen")
;      (debug_msg delse "putobjdest objcppif delse")
      (unsafe_put_fields recv
			 :obifp_then dthen
			 :obifp_else delse)
;      (debug_msg recv "putobjdest objcppif updated recv")
      recv
      )))

(install_method class_objcppif  put_objdest  putobjdest_objcppif)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
(defun compilobj_nrep_return (nret gcx)
  (assert_msg "check nret" (is_a nret class_nrep_return))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
;  (debug_msg gcx "compilobj_nrep_return gcx")
  (debug_msg nret "compilobj_nrep_return nret")
  (let ( (rloc (unsafe_get_field :nrep_loc nret))
	 (rmain (unsafe_get_field :nret_main nret))
	 (rrest (unsafe_get_field :nret_rest nret)) ;; a tuple or nil
	 (retloc (unsafe_get_field :gncx_retloc gcx))
	 (orout (unsafe_get_field :gncx_objrout gcx))
	 (olis (make_list discr_list))
	 (oblock (make_instance class_objblock
				:obi_loc rloc
				:oblo_bodyl olis))
	 (omainv (compile_obj rmain gcx))
	 )
    (assert_msg "check orout" (is_a orout class_routineobj))
    (debug_msg rrest "compilobj_nrep_return rrest")
    (assert_msg "check rrest" (is_multiple_or_null rrest))
    (if (null (unsafe_get_field :obrout_retval orout))
	(unsafe_put_fields orout :obrout_retval retloc))
    (list_append olis (put_objdest omainv retloc))
    (multiple_every
     rrest
     (lambda (rxtra :long ix)
;       (debug_msg rxtra "compilobj_nrep_return rxtra")
       (let ( (oxres 
	       (make_instance class_objputxtraresult
			      :obi_loc rloc
			      :obxres_rank (make_integerbox discr_integer ix)
			      :obxres_obloc (compile_obj rxtra gcx))) )
	 ;; maybe we need to compute the ctype of the extra result....
;	 (debug_msg oxres "compilobj_nrep_return oxres")
	 (list_append olis oxres))))
    (list_append olis 
		 (make_instance class_objfinalreturn
				:obi_loc rloc))
    (debug_msg oblock "compilobj_nrep_return final oblock")
    oblock
    )
  )
(install_method class_nrep_return compile_obj compilobj_nrep_return)

(install_method class_nrep_return get_ctype 
		(lambda (recv env) ctype_value))
;; all the closures generated by lambda share the same ...
(definstance discrclosure_objpredef class_objpredef
  :obv_type ctype_value
  :obpredef 'DISCR_CLOSURE
  )

(defun compilobj_nrep_lambda (nlam gcx)
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (assert_msg "check nlam" (is_a nlam class_nrep_lambda))
  (debug_msg nlam "compilobj_nrep_lambda nlam")
  (let ( (nloc (unsafe_get_field :nrep_loc nlam))
	 (npro (let 
		   ( (checkpro (unsafe_get_field :nlambda_proc nlam)) )
		 (assert_msg "check checkpro" (is_a checkpro class_nrep_routproc))
		 checkpro))
	 (nam (unsafe_get_field :nrpro_name npro))
	 (nclovtup (unsafe_get_field :nlambda_closedv nlam))
	 (:long nbclosed (multiple_length nclovtup))
	 (locv (get_free_objlocptr gcx nam))
	 (nrou (unsafe_get_field :nlambda_constrout nlam))
	 (orout (unsafe_get_field :gncx_objrout gcx))
	 (olis (make_list discr_list))
	 (oblock (make_instance class_objblock
				:obi_loc nloc
				:oblo_bodyl olis))
	 (destlist (make_list discr_list))
	 )
    (list_append destlist locv)
    (list_append olis 
		 (make_instance 
		  class_objnewclosure
		  :obi_loc nloc
		  :obnclo_discr discrclosure_objpredef
		  :obnclo_rout 
		  (progn 
		    (debug_msg nrou "compilobj_nrep_lambda should use nrpro_thunklist nrou")
		    (let ( (crou (compile_obj nrou gcx)) )
		      (debug_msg crou "compilobj_nrep_lambda crou")
		      crou)
		  )
		  :obnclo_len (make_integerbox discr_integer nbclosed)
		  :obdi_destlist destlist))
    (multiple_every
     nclovtup
     (lambda (clov :long ix)
       (debug_msg clov "compilobj_nrep_lambda clov")
       (list_append 
	olis
	(make_instance class_objputclosedv
		       :obi_loc nloc
		       :opclov_clos locv
		       :opclov_off (make_integerbox discr_integer ix)
		       :opclov_cval (compile_obj clov gcx)))))
    ;; we don't need to add any objtouch because the nlam was normalized!
    (list_append olis locv) ;;; last instruction is just the value, which can be set to some dest
    (debug_msg oblock "compilobj_nrep_lambda result oblock")
    oblock
    ))
(install_method class_nrep_lambda compile_obj compilobj_nrep_lambda)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_makeinst (nmki gcx)
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (assert_msg "check nmki" (is_a nmki class_nrep_make_instance))
  (debug_msg nmki "compilobj_nrep_makeinst nmki")
  ;; (debug_msg gcx "compilobj_nrep_makeinst gcx")
  (let ( (nloc (unsafe_get_field :nrep_loc nmki))
	 (ncla (unsafe_get_field :nmins_class nmki))
	 (ncladat (unsafe_get_field :nmins_cladata nmki))
	 (nfields (unsafe_get_field :nmins_fields nmki)) 
	 )
    (assert_msg "check ncla" (is_a ncla class_class))
    (let ( (:long nbfld (multiple_length (unsafe_get_field :class_fields ncla)))
	   (destlist (make_list discr_list))
	   (locv (get_free_objlocptr gcx 'inst))
	   (olis (make_list discr_list))
	   (ocladat (compile_obj ncladat gcx))
	   (oblock (make_instance class_objblock
				  :obi_loc nloc
				  :oblo_bodyl olis))
	   (orallobj (make_instance class_objrawallocobj
				    :obi_loc nloc
				    :obrallobj_class ocladat
				    :obrallobj_len (make_integerbox discr_integer nbfld)
				    :obdi_destlist destlist))
	   )
      (list_append destlist locv)
      (list_append olis orallobj)
      ;; handle each field assign
      (multiple_every
       nfields
       (lambda (cfla :long ix)
	 (assert_msg "compilobj_nrep_makeinst check cfla" (is_a cfla class_nrep_fieldassign))
	 (let ( (cfloc (unsafe_get_field :nrep_loc cfla))
		(cfield (unsafe_get_field :nfla_field cfla))
		(cval (unsafe_get_field :nfla_val cfla)) )
	   (assert_msg "compilobj_nrep_makeinst check cfield" (is_a cfield class_field))
	   (list_append 
	    olis
	    (let ( (oval (compile_obj cval gcx)) )
	      (assert_msg "compilobj_nrep_makeinst check oval not nrep" (not (is_a oval class_nrep)))
	      (make_instance class_objputslot 
			     :obi_loc (if cfloc cfloc nloc)
			     :oslot_odata locv
			     :oslot_field cfield
			     :oslot_offset (make_integerbox discr_integer (get_int cfield))
			     :oslot_value oval)
	      )))))
      ;; we don't need to add any objtouch because the nmki was normalized!
      (list_append olis locv) ;;; last instruction is just the value, which can be set to some dest
      (debug_msg oblock "compilobj_nrep_makeinst result oblock")
      oblock
      ))
  )
(install_method class_nrep_make_instance compile_obj compilobj_nrep_makeinst)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a procedure should not be called
(defun compilobj_routproc (npro gcx)
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (assert_msg "check npro" (is_a npro class_nrep_routproc))
  (debug_msg gcx "compilobj_routproc gcx")
  (debug_msg npro "compilobj_routproc npro")
  (assert_msg "UNEXPECTED CALL TO compilobj_routproc" ())
)
(install_method class_nrep_routproc compile_obj compilobj_routproc)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
(defun compilobj_predef (npr gcx)
  (assert_msg "check gcx" (is_a gcx class_genercontext))
;  (debug_msg npr "compilobj_predef npr")
  (let ( (opr (make_instance class_objpredef
			     :obv_type ctype_value
			     :obpredef (unsafe_get_field :nrpredef npr))) )
;    (debug_msg opr "compilobj_predef opr")
    opr)
)

(install_method class_nrep_predef compile_obj compilobj_predef)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; common code to compilobj_datasymbol & compilobj_datainstance
;;; to add the initial data fill and the slots filling
;;; return a tuple of bindings to be disposed
(defun compil_data_and_slots_fill (ndat obj odiscr irout gcx)
  (assert_msg "compil_data_and_slots_fill check ndat" (is_a ndat class_nrep_data))
  (assert_msg "compil_data_and_slots_fill check obj" (is_a obj class_objinitobject))
  (assert_msg "compil_data_and_slots_fill check odiscr" (is_a odiscr class_objvalue))
  (assert_msg "compil_data_and_slots_fill check irout" (is_a irout class_initialroutineobj))
  (assert_msg "compil_data_and_slots_fill check gcx" (is_a gcx class_genercontext))
  (debug_msg ndat "compil_data_and_slots_fill start ndat")
  (debug_msg obj "compil_data_and_slots_fill start obj")
  (debug_msg odiscr "compil_data_and_slots_fill odiscr")
  (debug_msg irout "compil_data_and_slots_fill irout un")
  (let (
	(ibodylis (unsafe_get_field :obrout_body irout))
	(ifilllis (unsafe_get_field :oirout_fill irout))
	(locvar (get_free_objlocptr gcx '_valdata_))
	(comm (unsafe_get_field :named_name '_valuedata_))
	(nloc (unsafe_get_field :nrep_loc ndat))
	(dlocbind (unsafe_get_field :ndata_locbind ndat))
	(locmap (unsafe_get_field :gncx_locmap gcx))
	;; a tuple to store the objvar for localbinds to be able to clear them later
	(tupvar (make_multiple discr_multiple (multiple_length locmap)))
	)
    (assert_msg "compil_data_and_slots_fill check ibodylis" (is_list ibodylis))
    (assert_msg "compil_data_and_slots_fill check fresh obj" (null (unsafe_get_field :oie_locvar obj)))
    (unsafe_put_fields obj :oie_locvar locvar)
    (assert_msg "compil_data_and_slots_fill check ifilllis" (is_list ifilllis))
    (assert_msg "compil_data_and_slots_fill check ibodylis" (is_list ibodylis))
					; (debug_msg dlocbind "compil_data_and_slots_fill dlocbind")
    (multiple_every
     dlocbind
     (lambda (lbind :long bindrk)
					; (debug_msg lbind "compil_data_and_slots_fill lbind")
       (assert_msg "compil_data_and_slots_fill check lbind" (is_a lbind class_normlet_binding))
       (let ( (bder (unsafe_get_field :binder lbind))
	      (cty (unsafe_get_field :letbind_type lbind))
	      (nexp (unsafe_get_field :letbind_expr lbind))
	      (obva (get_free_objloctyped gcx bder cty))
	      (obnx (compile_obj nexp gcx)) 
	      )
	 (if obva (mapobject_put locmap lbind obva))
	 (let ( (obmy (if obva (put_objdest obnx obva) obnx)) )
	   ;; add the modified obmy in the ibodylis
	   (list_append ibodylis obmy)
	   )
	 (if obva (multiple_put_nth tupvar bindrk obva))
	 )))
    ;; for every non nil slot, append its initialization to the body of irout
    (multiple_every
     (unsafe_get_field :ninst_slots ndat)
     (lambda (sloval :long slork)
					;(debug_msg sloval "compil_data_and_slots_fill sloval")
       (if sloval
;;; add to list inifill the filling in dai of slot#slork by slobj
	   (let ( (slobj (compile_obj sloval gcx)) 
		  )
					;(debug_msg slobj "compil_data_and_slots_fill slobj")
	     (assert_msg "compil_data_and_slots_fill check slobj not nrep" (not (is_a slobj class_nrep)))
	     (let (
		   (ooff (make_integerbox discr_integer slork))
		   (oput 
		    (make_instance class_objputslot
				   :obi_loc  nloc
				   :oslot_odata obj
				   :oslot_offset ooff
				   :oslot_value slobj
				   )) 
		   )
	       (list_append ibodylis oput)
	       )))))
    ;; touch the object
    (list_append ibodylis 
		 (make_instance class_objtouch
				:obi_loc (if nloc nloc (unsafe_get_field :nrep_loc ndat))
				:otouch_comment comm
				:otouch_val obj))
    ;; for every non nil local obvar, clear it
    (multiple_every
     tupvar
     (lambda (obva :long ix)
       (if obva
	   (progn
	     (list_append ibodylis
			  (make_instance class_objclear 
					 :obi_loc nloc
					 :oclr_vloc obva))
	     ))))
    ;;; add the obj as the last instr of the block
    (list_append ibodylis obj)
    ;;
    (debug_msg dlocbind "compil_data_and_slots_fill final dlocbind")
    ;; the caller is supposed to do
    ;; dispose_dlocbind_after_data_and_slots_fill with the result if
    ;; needed but in practice this is never needed
    (return dlocbind)
    )
  (return)				;force a nil return
  )


;; probably useless function
(defun dispose_dlocbind_after_data_and_slots_fill (dlocbind gcx)
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (debug_msg dlocbind "dispose_dlocbind_after_data_and_slots_fill dlocbind")
  (multiple_every
   dlocbind
   (lambda (bnd :long ix) (dispose_bnd_obj bnd gcx)))
  )
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_datasymbol (syv gcx)
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  (assert_msg "check syv" (is_a syv class_nrep_datasymbol))
  (debug_msg syv "compilobj_datasymbol syv")
  (let ( (compicache (unsafe_get_field :gncx_compicache gcx)) 
	 (chobj (mapobject_get compicache syv))
	 (inirout (unsafe_get_field :gncx_objrout gcx))
	 )
    ;; datasymbol compiled only in initial routines
    (assert_msg "check inirout" (is_a inirout class_initialroutineobj))
    (if chobj
	(progn
	  (debug_msg chobj "compilobj_datasymbol found chobj")
	  (return chobj)))
    (let (
	  (odiscr  (compile_obj (unsafe_get_field :ndata_discrx syv) gcx))
	  (obsym 
	   (make_instance class_objinitobject
			  :obv_type ctype_value
			  :oie_data syv
			  :oie_discr odiscr
			  )) 
	  )
      (mapobject_put compicache syv obsym)
      (debug_msg inirout "compilobj_datasymbol inirout")
      ;; make a cname
      (let ( (nambuf (make_strbuf discr_strbuf))
	     (:long syrk (get_int (unsafe_get_field :ndata_rank syv)))
	     )
	(add2sbuf_strconst nambuf "dsym_")
	(add2sbuf_longdec nambuf syrk)
	(add2sbuf_strconst nambuf "__")
	(add2sbuf_cident nambuf (unsafe_get_field :ndsy_namestr syv))
	(unsafe_put_fields obsym
			   :oie_cname (strbuf2string discr_string nambuf)))
      ;; put the length as obj_num of obsym
      (put_int obsym (multiple_length (unsafe_get_field :ninst_slots syv)))
      ;(debug_msg gcx "compilobj_datasymbol gcx")
      ;(debug_msg obsym "compilobj_datasymbol obsym beforfill")
      (let ( (dlocbind (compil_data_and_slots_fill syv obsym odiscr inirout gcx)) ) 
	(debug_msg dlocbind "compilobj_datasymbol dlocbind")
	;(dispose_dlocbind_after_data_and_slots_fill dlocbind gcx)
	)
      (debug_msg obsym "compilobj_datasymbol obsym final")
      (return obsym)
      )))
(install_method class_nrep_datasymbol compile_obj compilobj_datasymbol)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;; compilobj of datainstance
(defun compilobj_datainstance (dai gcx)
  (assert_msg "check gcx" (is_a gcx class_genercontext))
;  (debug_msg gcx "compilobj_datainstance gcx")
  (debug_msg dai "compilobj_datainstance dai")
  (let ( (compicache (unsafe_get_field :gncx_compicache gcx)) 
	 (chobj (mapobject_get compicache dai))
	 (inirout (unsafe_get_field :gncx_objrout gcx))
	 )
    ;; datainstance compiled only in initial routines
    (assert_msg "check inirout" (is_a inirout class_initialroutineobj))
    (if chobj
	(progn
	  (debug_msg chobj "compilobj_datainstance return found chobj")
	  (return chobj)))
    (let ( (loc (unsafe_get_field :nrep_loc dai))
	   (nam (unsafe_get_field :ndata_name dai))
	   ;; nam is a symbol, not a string
	   (disx (unsafe_get_field :ndata_discrx dai))
	   (drank (unsafe_get_field :ndata_rank dai))
	   (dhash (unsafe_get_field :ninst_hash dai))
	   (dpredef (unsafe_get_field :ninst_predef dai))
	   (dslots (unsafe_get_field :ninst_slots dai)) 
	   (ininsl (unsafe_get_field :ninit_topl inirout))
	   (inifill (unsafe_get_field :oirout_fill inirout))
	   )
      ;; if the drank is invalid or nil, the data has never been added
      ;; with add_nctx_data (should not happen)
      (assert_msg "compilobj_datainstance check drank" (is_integerbox drank))
      ;(debug_msg disx "compilobj_datainstance disx")
      ;(debug_msg gcx "compilobj_datainstance avant gcx")
      (debug_msg loc "compilobj_datainstance loc before cdisx")
      (let ( (cdisx (compile_obj disx gcx)) 
	     )
	(debug_msg loc "compilobj_datainstance loc after cdisx")
	;(debug_msg cdisx "compilobj_datainstance cdisx")
	(let (
	      ;; make a cname
	      (oini (make_instance class_objinitobject
				   :obv_type ctype_value
				   :oie_data dai
				   :oie_discr cdisx
				   :oio_predef dpredef
				   ))
	      (nambuf (make_strbuf discr_strbuf))
	      (:long drk (get_int drank))
	      )
	  (mapobject_put compicache dai oini)
	  (debug_msg loc "compilobj_datainstance loc after put compicache")
	  (add2sbuf_strconst nambuf "dobj_")
	  (add2sbuf_longdec nambuf drk)
	  (if nam (progn
		    (add2sbuf_strconst nambuf "__")
		    (add2sbuf_cident nambuf (unsafe_get_field :named_name nam))))
	  (let ( (cnam (strbuf2string discr_string nambuf)) )
	    (unsafe_put_fields oini :oie_cname cnam)
	    (debug_msg cnam "compilobj_datainstance cnam")
	    )
	  (put_int oini (multiple_length dslots))
	  ;(debug_msg gcx "compilobj_datainstance apres gcx")
	  (debug_msg oini "compilobj_datainstance oini before data&slots")
	  (debug_msg loc "compilobj_datainstance loc before data&slots")
	  (let ( (dlocbind (compil_data_and_slots_fill dai oini cdisx inirout gcx)) )
	    (debug_msg dlocbind "compilobj_datainstance dlocbind")
	    ;(dispose_dlocbind_after_data_and_slots_fill dlocbind gcx)
	    )
	  (debug_msg loc "compilobj_datainstance loc after data&slots")
	  (debug_msg oini "compilobj_datainstance final oini")
	  oini
	  )  
	)
      )
    )
  )
(install_method class_nrep_datainstance compile_obj compilobj_datainstance)
  

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;; compile a data tuple
(defun compilobj_datatuple (nti gcx)
  (assert_msg "check nti" (is_a nti class_nrep_datatuple))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  ;;(debug_msg gcx "compilobj_datatuple gcx")
  (debug_msg nti "compilobj_datatuple nti")
  (let ( (compicache (unsafe_get_field :gncx_compicache gcx)) 
	 (chobj (mapobject_get compicache nti))
	 (inirout (unsafe_get_field :gncx_objrout gcx))
	 )
    ;; datatuples compiled only in initial routines
    (assert_msg "check inirout" (is_a inirout class_initialroutineobj))
    (if chobj
	(progn
	  (debug_msg chobj "compilobj_datatuple found chobj")
	  (return chobj)))
    (let ( (ncompi (unsafe_get_field :ntup_comp nti))
	   (ocompi (multiple_map 
		    ncompi
		    (lambda (c :long ix) (if c (compile_obj c gcx)))))
	   (disx (unsafe_get_field :ndata_discrx nti))
	   (drank (unsafe_get_field :ndata_rank nti))
	   (odiscr (compile_obj disx gcx)) 
	   (nam (unsafe_get_field :ndata_name nti))
	   (nambuf (make_strbuf discr_strbuf))
	   (locvar (get_free_objlocptr gcx '_valtup_))
	   (:long drk (get_int drank))
	   (inibody (unsafe_get_field :obrout_body inirout))
	   (comm (unsafe_get_field :named_name '_initup_))
	   )
      (add2sbuf_strconst nambuf "dtup_")
      (add2sbuf_longdec nambuf drk)
      (if nam (progn
		(add2sbuf_strconst nambuf "__")
		(add2sbuf_cident nambuf (unsafe_get_field :named_name nam))))
      (let ( (otup (make_instance class_objinitmultiple
				  :obv_type ctype_value
				  :oie_discr odiscr
				  :oie_locvar locvar
				  :oie_cname (strbuf2string discr_string nambuf)
				  :oim_tupval ocompi
				  ))
	     )
	(mapobject_put compicache nti otup)
	(put_int otup (multiple_length ncompi))
	(multiple_every
	 ncompi
	 (lambda (scomp :long srk)
	   (if scomp 
	       (let ( (ocomp (multiple_nth ocompi srk)) )
		 (list_append inibody
			      (make_instance class_objputuple
					     :oputu_tupled otup
					     :oputu_offset (make_integerbox discr_integer srk)
					     :oputu_value ocomp)))
	     )))
	(list_append inibody
		     (make_instance class_objtouch
				    :otouch_val otup
				    :otouch_comment comm))
	(debug_msg otup "compilobj datatuple otup")
	(return otup)
	)
      )
    )
  )
  
(install_method class_nrep_datatuple compile_obj compilobj_datatuple)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;; compile a data string
(defun compilobj_datastring (nds gcx)
  (assert_msg "check nds" (is_a nds class_nrep_datastring))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  ; (debug_msg gcx "compilobj_datastring gcx")
  (debug_msg nds "compilobj_datastring nds")
  (let ( (compicache (unsafe_get_field :gncx_compicache gcx)) 
	 (inirout (unsafe_get_field :gncx_objrout gcx))
	 (chobj (mapobject_get compicache nds))
	 )
    ;; datastring compiled only in initial routines
    (assert_msg "check inirout" (is_a inirout class_initialroutineobj))
    (if chobj
	(progn
	  (debug_msg chobj "compilobj_datastring found chobj")
	  (return chobj)))
    (let (
	  (nambuf (make_strbuf discr_strbuf))
	  (ndisx (unsafe_get_field :ndata_discrx nds))
	  (odiscr (compile_obj ndisx gcx))
	  (odata (unsafe_get_field :nstr_string nds))
	  (drank (unsafe_get_field :ndata_rank nds))
	  (nam (unsafe_get_field :ndata_name nds))
	  (locvar (get_free_objlocptr gcx '_valstr_))
	  (:long drk (get_int drank))
	  (ostr (make_instance class_objinitstring
			       :oie_data odata
			       :oie_discr odiscr
			       :oie_locvar locvar
			       )) 
	  )
      (mapobject_put compicache nds ostr)
      (add2sbuf_strconst nambuf "dstr_")
      (add2sbuf_longdec nambuf drk)
      (add2sbuf_strconst nambuf "__")
      (add2sbuf_cidentprefix nambuf odata 16)
      (put_int ostr (string_length odata))
      (if nam 
	  (progn
	    (add2sbuf_strconst nambuf "__")
	    (add2sbuf_cident nambuf (unsafe_get_field :named_name nam))))
      (unsafe_put_fields ostr :oie_cname (strbuf2string discr_string nambuf))
      (debug_msg ostr "compilobj_datastring ostr")
      ostr
      )
    ))
(install_method class_nrep_datastring compile_obj compilobj_datastring)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;; compile a data closure
(defun compilobj_dataclosure (ncl gcx)
  (assert_msg "check ncl" (is_a ncl class_nrep_dataclosure))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  ;(debug_msg gcx "compilobj_dataclosure gcx")
  (debug_msg ncl "compilobj_dataclosure ncl")
  (let ( (compicache (unsafe_get_field :gncx_compicache gcx)) 
	 (inirout (unsafe_get_field :gncx_objrout gcx))
	 (inibody (unsafe_get_field :obrout_body inirout))
	 (chobj (mapobject_get compicache ncl))
	 )
    (assert_msg  "check inirout" (is_a inirout class_initialroutineobj))
    (if chobj
	(progn
	  (debug_msg chobj "compilobj_dataclosure found chobj")
	  (return chobj)))
    (let ( 
	  (nam (unsafe_get_field :ndata_name ncl))
	  (discx (unsafe_get_field :ndata_discrx ncl))
	  (nrank (unsafe_get_field :ndata_rank ncl))
	  (nloc (unsafe_get_field :nrep_loc ncl))
	  (npro (unsafe_get_field :ndclo_proc ncl))
	  (nclov (unsafe_get_field :ndclo_closv ncl))
	  (:long nbclos (multiple_length nclov))
	  (nambuf (make_strbuf discr_strbuf))
	  (odiscr (compile_obj discx gcx))
	  (locvar (get_free_objlocptr gcx '_valclo_))
	  (comm (unsafe_get_field :named_name '_dataclosure_))
	  )
      (assert_msg "check npro" (is_a npro class_nrep_routproc))
      (add2sbuf_strconst nambuf "dclo_")
      (add2sbuf_longdec nambuf (get_int nrank))
      (if nam (progn
		(add2sbuf_strconst nambuf "__")
		(add2sbuf_cident nambuf (unsafe_get_field :named_name nam))))
					;    (debug_msg ncl "compilobj_dataclosure encore ncl")
      (let (
	    (ndatarou (unsafe_get_field :nrpro_datarout npro))
	    (oiclo
	     (make_instance class_objinitclosure
			    :obv_type ctype_value
			    :oie_discr odiscr
			    :oie_data ncl
			    :oie_locvar locvar
			    :oie_cname (strbuf2string discr_string nambuf)
			    )) 
	    )
	(put_int oiclo nbclos)
	(mapobject_put compicache ncl oiclo)
	(assert_msg "check ndatarou" (is_a ndatarou class_nrep_dataroutine))
	(let (
	      ;; npro should already have been compiled, so should be in the compiler cache
	      (ocrout (mapobject_get compicache npro))
	      (odatrout (compile_obj ndatarou gcx))
	      (ocputrout (make_instance  class_objputclosurout
					 :obi_loc nloc
					 :opclor_clos oiclo
					 :opclor_rout odatrout
					 ;;@@OLDBUGGY :opclor_rout (mapobject_get compicache ndatarou)
					 ))
	      (bxoff (make_integerbox discr_integer 0))
	      )
	  (assert_msg "check ocrout" (is_a ocrout class_procroutineobj))
	  (list_append inibody ocputrout)
	  (debug_msg nclov "compilobj_dataclosure nclov")
	  (debug_msg ocrout "compilobj_dataclosure ocrout")
	  (multiple_every
	   nclov
	   (lambda (clov :long ix)
	     (let ( (cloval (compile_obj clov gcx)) 
		    (ocputclos (make_instance class_objputclosedv
					      :obi_loc nloc
					      :opclov_clos oiclo
					      :opclov_off (make_integerbox discr_integer (get_int bxoff))
					      :opclov_cval cloval))
		    )
	       (list_append inibody ocputclos)
	       )
	     (put_int bxoff (+i (get_int bxoff) 1))))
	  (list_append inibody (make_instance class_objtouch
					      :obi_loc nloc
					      :otouch_comment comm
					      :otouch_val oiclo))
	  oiclo
	  ))
      ))
  )
(install_method class_nrep_dataclosure compile_obj compilobj_dataclosure)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;; compile a data routine
(defun compilobj_dataroutine (ndrou gcx)
  (assert_msg "check ndrou" (is_a ndrou class_nrep_dataroutine))
  (assert_msg "check gcx" (is_a gcx class_genercontext))
  ;;(debug_msg gcx "compilobj_dataroutine+ gcx" )
  (debug_msg ndrou "compilobj_dataroutine+ ndrou")
  (let ( (compicache (unsafe_get_field :gncx_compicache gcx)) 
	 (inirout (unsafe_get_field :gncx_objrout gcx))
	 (chobj (mapobject_get compicache ndrou))
	 (unused_stuff ())	  ;to circumvent a bug in cold-basilys
	 )
    ;; dataroutine compiled only in initial routines
    (assert_msg "check inirout" (is_a inirout class_initialroutineobj))
    (if chobj
	(progn
	  (debug_msg chobj "compilobj_dataroutine+ found chobj")
	  (return chobj)))
    (let ( (nam (unsafe_get_field :ndata_name ndrou))
	   (disx (unsafe_get_field :ndata_discrx ndrou))
	   (nloc (unsafe_get_field :nrep_loc ndrou))
	   (drank (unsafe_get_field :ndata_rank ndrou))
	   (nam (unsafe_get_field :ndata_name ndrou))
	   (npro (unsafe_get_field :ndrou_proc ndrou))
	   (inibody (unsafe_get_field :obrout_body inirout))
	   (locvar (get_free_objlocptr gcx '_valrout_))
	   )
      (if (null nloc)
	  (if (is_a npro class_nrep)
	      (setq nloc (unsafe_get_field :nrep_loc npro))))
      (assert_msg "check compicache" (is_mapobject compicache))
      (let (
	    (nambuf (make_strbuf discr_strbuf))
	    (:long drk (get_int drank))
	    (odiscr (compile_obj disx gcx))
	    )
	(add2sbuf_strconst nambuf "drout_")
	(add2sbuf_longdec nambuf drk)
	(if nam (progn
		  (add2sbuf_strconst nambuf "__")
		  (add2sbuf_cident nambuf (unsafe_get_field :named_name nam))))
	;(debug_msg ndrou "compilobj_dataroutine encore ndrou")
	(let (
	      (oirout 
	       (make_instance class_objinitroutine
			      :obv_type ctype_value
			      :oie_discr odiscr
			      :oie_data ndrou
			      :oie_locvar locvar
			      :oie_cname (strbuf2string discr_string nambuf)
			      :oir_procroutine (mapobject_get compicache npro)
			      )) 
	      )
	  (mapobject_put compicache ndrou oirout)
	  (if (is_a npro class_nrep_routproc)
	      (let ( (pconstl (unsafe_get_field :nrpro_const npro)) 
		     (:long nbconst (list_length pconstl))
		     (bxoff (make_integerbox discr_integer 0))
		     (comm (unsafe_get_field :named_name '_iroutval_))
		     )
		(debug_msg pconstl "compilobj_dataroutine pconstl")
		(put_int oirout nbconst)
		(list_every
		 pconstl
		 (lambda (constx)
		   (debug_msg constx "compilobj_dataroutine constx")
		   (cond
		    ( (is_a constx class_nrep_constocc)
		      (let ( (cnstbind (unsafe_get_field :nocc_bind constx)) )
			(assert_msg "compilobj_dataroutine check cnstbind" (is_a cnstbind class_any_binding))
			(let ( 
			      (oconstx (compile_obj cnstbind gcx)) 
			      (:long off (get_int bxoff))
			      ) 
			  (if oconstx 
			      (let ( (iput (make_instance class_objputroutconst
							  :obi_loc nloc
							  :oprconst_rout oirout
							  :oprconst_off (make_integerbox discr_integer off)
							  :oprconst_cval oconstx)) ) 
				(list_append inibody iput)
				(put_int bxoff (+i off 1))))))
		      )
		    ( (is_a constx class_nrep_data)
		      (debug_msg constx "compilobj_dataroutine constx data")
		      (let ( 
			    (oconstx (compile_obj constx gcx)) 
			    (:long off (get_int bxoff))
			    ) 
			(if oconstx 
			    (let ( (iput (make_instance class_objputroutconst
							:obi_loc nloc
							:oprconst_rout oirout
							:oprconst_off (make_integerbox discr_integer off)
							:oprconst_cval oconstx)) ) 
			      (list_append inibody iput)
			      (put_int bxoff (+i off 1))))))
		    (:else
		     (debug_msg constx  "compilobj_dataroutine unexpected constx")
		     (assert_msg "compilobj_dataroutine unexepected constx" ())
		     )
		    )
		   )
		 )
		(if (>i (get_int bxoff) 0)
		    (list_append inibody (make_instance class_objtouch
							:obi_loc nloc
							:otouch_val oirout
							:otouch_comment comm
							)))
		(debug_msg npro "compilobj_dataroutine here npro")
		(debug_msg oirout "compilobj_dataroutine here fresh oirout")
		oirout)
	    ))))
    )
  )
(install_method class_nrep_dataroutine compile_obj compilobj_dataroutine)








;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; compile a list of sexpressions as a module starting from a given environment
(defun compile_list_sexpr (lsexp inienv modnamstr)
  (message_dbg "starting  compile_list_sexpr")
  (debug_msg lsexp "\n\n\n*%*%* compile_list_sexpr lsexp" ) ;list of sexpr
  (debug_msg inienv "compile_list_sexpr inienv") ;initial environment
  (debug_msg modnamstr "compile_list_sexpr modnamstr") ;module name
  (assert_msg "check lsexp" (is_list lsexp))
  (assert_msg "check modnamstr" (is_string modnamstr))
  (assert_msg "check inienv" (is_a inienv class_environment))
  (let ( (ncx (create_normcontext)) )
    (debug_msg ncx "compile_list_sexpr initial ncx")
    (assert_msg "check ncx" (is_a ncx class_normcontext))
    (let ( (xlist (macroexpand_toplevel_list lsexp inienv)) 
	   (iniproc (unsafe_get_field :nctx_initproc ncx))
	   (declbuf (make_strbuf discr_strbuf))
	   (implbuf (make_strbuf discr_strbuf)) 
	   )
      (debug_msg xlist "after macroexpansion compile_list_sexpr seq")
      (debug_msg inienv "after macroexpansion compile_list_sexpr inienv")
      (assert_msg "check iniproc" (is_a iniproc class_nrep_initproc))
      (assert_msg "check xlist" (is_list xlist))
      (list_every
       xlist
       (lambda (sexp :long ix)
	 (debug_msg sexp "compile_list_sexpr sexp")
	 (let (
	       (psloc (if (is_a sexp class_located) (unsafe_get_field :loca_location sexp)))
	       )
	   ;; special hack to handle toplevel comment specially; the generated comment goes into the declbuf
	   (if (is_a sexp class_src_comment)
	       (let ( (sloc (unsafe_get_field :src_loc sexp))
		      (scomm (unsafe_get_field :scomm_str sexp)) 
		      )
		 (add2sbuf_indentnl declbuf 0)
		 (add2sbuf_strconst declbuf "/**!!** ")
		 (add2sbuf_ccomstring declbuf scomm)
		 (add2sbuf_strconst declbuf "**!!**/")
		 (add2sbuf_indentnl declbuf 0)
		 )
	     ;;; otherwise, normalize etc.
	   (multicall 
	    (nexp nbind)
	    (normal_exp sexp inienv ncx psloc)	    
	    (debug_msg nexp "compile_list_sexpr nexp")    
	    (debug_msg nbind "compile_list_sexpr nbind")
	    (if (and (is_a nexp class_nrep)
		     (not (is_a nexp class_nrep_anyproc)))
		(let ( (wnexp (wrap_normal_let1 nexp nbind psloc)) )
		  (debug_msg wnexp "compile_list_sexpr wnexp")
		  (list_append (unsafe_get_field :ninit_topl iniproc) 
			       wnexp)
		  )))))))
      (let ( (prolist (unsafe_get_field :nctx_proclist ncx)) 
	     (objlist (make_list discr_list))
	     (compicache (make_mapobject discr_mapobjects (+i 10 (*i 20 (list_length xlist)))))
	     (countbox (make_integerbox discr_integer 0))
	     ) 
	(debug_msg prolist "compile_list_sexpr prolist")  
	(assert_msg "check prolist" (is_list prolist))
	(list_every
	 prolist
	 (lambda (pro)
	   (assert_msg "check pro" (is_a pro class_nrep_anyproc))
	   (debug_msg pro "compile_list_sexpr pro")
	   (put_int countbox (+i (get_int countbox) 1))
	   (let ( (objpro (compile2obj_procedure pro compicache (get_int countbox))) )
	     (debug_msg objpro "compile_list_sexpr objpro")
	     (debug_msg pro "compile_list_sexpr done pro")
	     (list_append objlist objpro)
	     ;;(debug_msg compicache "compile_list_sexpr compicache")
	     )))
	(debug_msg objlist "compile_list_sexpr objlist")  
	(assert_msg "check objlist" (is_list objlist))
	(let ( (inipro (unsafe_get_field :nctx_initproc ncx)) 
	       (inidata (unsafe_get_field :nctx_datalist ncx))
	       )
	  (assert_msg "check inipro" (is_a inipro class_nrep_initproc))
	  (let ( (iniobj (compile2obj_initproc inipro inidata compicache)) )
	    (debug_msg iniobj "compile_list_sexpr iniobj")
	    (outnum_err "** warm-basilys generated " (list_length objlist) " routines into ")
	    (outstr_err modnamstr)
	    (outnewline_err)
	    (outcstring_err "** from ")
	    (out_cplugin_compiled_timestamp_err)
	    (outnewline_err)
	    (outcstring_err "** of checksum ")
	    (out_cplugin_md5_checksum_err)
	    (outnewline_err)
;;;
	    (list_every
	     objlist
	     (lambda (obel)
	       (debug_msg obel "compile_list_sexpr obel")
	       (output_c_code obel declbuf implbuf 0)))
	    (debug_msg modnamstr "compile_list_sexpr final modnamstr") 
	    (debug_msg iniobj "compile_list_sexpr outputting iniobj")
	    (output_c_code iniobj declbuf implbuf 0)
	    (output_cfile_decl_impl modnamstr declbuf implbuf)
	    )))))
  (message_dbg "ended compile_list_sexpr")
  )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;; initial commands
(definstance initial_command_dispatcher class_command_dispatcher
  :predef INITIAL_COMMAND_DISPATCHER
  :named_name (stringconst2val discr_namestring "INITIAL_COMMAND_DISPATCHER")
  :cmd_fundict  (make_mapstring discr_mapstrings 40)
)

(defun install_initial_command (nam fun)
  (messageval_dbg "install_initial_command @@ fun" fun)
  (messageval_dbg "install_initial_command @@ nam" nam)
  (debug_msg fun "install_initial_command fun")
  (if (is_closure fun)
      (if (is_string nam)
	  (mapstring_putstr (unsafe_get_field :cmd_fundict initial_command_dispatcher) 
			    nam fun))))
;;;;
(defun readseq_command (dispatcher arg)
  (message_dbg "starting readseq")
  (debug_msg arg "start readseq_command")
  (let ( (rlist (read_file arg)) )
    (message_dbg "ending readseq")
    (debug_msg rlist "done readseq_command")
))

(install_initial_command  (stringconst2val discr_string "readseq") readseq_command)

;;;;

;;;;;
(defun compilefile_command (dispatcher arg secarg)
  (message_dbg "starting compilefile_command")
  (debug_msg arg "start compilefile_command arg")
  (debug_msg secarg "start compilefile_command secarg")
  (debug_msg discr_string "compilefile_command discr_string")
  (debug_msg discr_verbatimstring "compilefile_command discr_verbatimstring")
  (debug_msg initial_environment "before read compilefile_command initial_environment")
  (debug_msg 'defun "before read compilefile_command defun symbol")
  (debug_msg 'if "before read compilefile_command if symbol")
  (debug_msg tokenizer "before read compilefile_command tokenizer")
  (debug_msg ':value "before read compilefile_command :value keyword")
  (debug_msg ':void "before read compilefile_command :void keyword")
  (debug_msg ':long "before read compilefile_command :long keyword")
  (debug_msg ctype_value "before read compilefile_command ctype_value")
  (debug_msg ctype_void "before read compilefile_command ctype_void")
  (debug_msg ctype_long "before read compilefile_command ctype_long")
  (debug_msg class_selector "before read compilefile_command {class} class_selector")
  (debug_msg class_nrep_routproc "before read compilefile_command {class} class_nrep_routproc")
  (debug_msg class_label_binding "before read compilefile_command {class} class_label_binding")
  (debug_msg named_name "before read compilefile_command {field} named_name")
  (debug_msg labind_clonsy "before read compilefile_command {field} labind_clonsy")
  (debug_msg dbg_output "before read compilefile_command dbg_output")
  (debug_msg (unsafe_get_field :named_name dbg_output) "before read compilefile_command dbg_output's name")
  (assert_msg "check DBG_OUTPUT's name is string" (is_string (unsafe_get_field :named_name dbg_output)))
  (let ( (rlist (read_file arg)) 
	 (basnam (if (is_string secarg) secarg (make_string_nakedbasename discr_string arg)))
	 ) 
    (debug_msg rlist "after read compilefile_command rlist")
    (debug_msg tokenizer "after read compilefile_command tokenizer")
    (debug_msg initial_environment "after read compilefile_command initial_environment")
    (debug_msg class_nrep_datakeyword "compilefile_command class_nrep_datakeyword")
    (debug_msg class_nrep "compilefile_command class_nrep")
    (compile_list_sexpr rlist initial_environment basnam)
    ))

(install_initial_command  (stringconst2val discr_string "compilefile") compilefile_command)


(debug_msg initial_command_dispatcher "toplevel initial_command_dispatcher")

;;; eof warm-basilys.bysl