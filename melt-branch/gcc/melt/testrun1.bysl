;; file testrun1.bysl  -*- Lisp -*-
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;    Copyright 2008 Free Software Foundation, Inc.
;;    Contributed by Basile Starynkevitch <basile@starynkevitch.net>

;;    This file is part of GCC.

;;    GCC is free software; you can redistribute it and/or modify
;;    it under the terms of the GNU General Public License as published by
;;    the Free Software Foundation; either version 3, or (at your option)
;;    any later version.

;;    GCC is distributed in the hope that it will be useful,
;;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;    GNU General Public License for more details.

;;    You should have received a copy of the GNU General Public License
;;    along with GCC; see the file COPYING3.  If not see
;;    <http://www.gnu.org/licenses/>.

;;;;;;
;;    This file is a runnable test; it shares code with warm-basilys.bysl
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; root class
(defclass class_root 
  :predef CLASS_ROOT)

;; class of everything with a property table
(defclass class_proped 
 :predef CLASS_PROPED
 :super class_root 
 :fields (prop_table))


;; arbitrary container as class
(defclass class_container
  :super class_root
  :fields (container_value))

;; class of named objects
(defclass class_named  
  :predef CLASS_NAMED
  :super class_proped 
  :fields (named_name))
 
;; class of discriminants
(defclass class_discr 
  :predef CLASS_DISCR
  :super class_named 
  :fields (disc_methodict 
	   disc_sender 
	   disc_super))
 
;; class of classes
(defclass class_class
   :super class_discr
   :fields (class_ancestors class_fields class_objnumdescr class_data)
   :predef CLASS_CLASS)
 
;; class of fields
(defclass class_field
   :predef CLASS_FIELD
  ;; the fields' objnum is its offset
   :super class_named
   :fields (fld_ownclass fld_typinfo))
 
;; class of primitive
(defclass class_primitive
   :predef CLASS_PRIMITIVE
   :super class_named
   :fields (prim_formals prim_type prim_expansion))
 
;; class of symbols
(defclass class_symbol
  :predef CLASS_SYMBOL
  :super class_named
  :fields (symb_data))

;; class of keyword symbols
(defclass class_keyword
  :predef CLASS_KEYWORD
  :super class_symbol
  :fields ())
;; class of command dispatchers
(defclass class_command_dispatcher
  :predef CLASS_COMMAND_DISPATCHER
  :super class_named
  :fields (cmd_fundict			;stringmap for closures
	   ))

;; the (super-)class of any binding
(defclass class_any_binding
  :super class_root
  :fields (binder)
)

;;; superclass of exported bindings
(defclass class_exported_binding
  :super class_any_binding
  :fields ( )
)

;; macro binding
(defclass class_macro_binding
  :super class_exported_binding
  :fields (mbind_expanser))


;; value binding - as exported 
(defclass class_value_binding
  :super class_exported_binding
  :fields (vbind_value
))

; formal binding (used in generated defprimitive)
(defclass class_formal_binding
  :super class_any_binding
  :fields (fbind_type)
  ;;the obj_num is the argument rank
  :predef CLASS_FORMAL_BINDING)

;; class of command dispatchers
(defclass class_command_dispatcher
  :predef CLASS_COMMAND_DISPATCHER
  :super class_named
  :fields (cmd_fundict			;stringmap for closures
	   ))


;; primitive for converting a string constant into a string value
(defprimitive stringconst2val (discr :cstring strc) :value
  " basilysgc_new_string((" discr "), (" strc "))")

;; primitive for testing if an object is a (sub) instance of a class
(defprimitive is_a (obj cla) :long
  " basilys_is_instance_of((" obj "), (" cla "))")
  
;; primitive for testing objectness
(defprimitive is_object (obj) :long
  " (basilys_magic_discr(" obj ") == OBMAG_OBJECT)")
  

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; primitive to get the discriminant of a value
(defprimitive discrim (v) :value
  "(basilys_discr((" v ")))")

;; primitive to get the integer inside a boxed or mixed integer or objnum
(defprimitive get_int (v) :long
  "(basilys_get_int((" v ")))")
;; primitive to put the integer inside a boxed or mixed integer or objnum
(defprimitive put_int (v :long i) :void
  "basilys_put_int((" v "), (" i "))")

;; primitive to get the hashcode of an object (or 0)
(defprimitive obj_hash(v) :long
  "(basilys_obj_hash((" v ")))")
;; primitive to get the length of an object (or 0)
(defprimitive obj_len(v) :long
  "(basilys_obj_len((" v ")))")
;; primitive to get the number of an object (or 0)
(defprimitive obj_num(v) :long
  "(basilys_obj_num((" v ")))")
;; primitive to compue a nonzero hash
(defprimitive nonzero_hash () :long
  "(basilys_nonzerohash())")

;; primitive for identity and non-identity test
(defprimitive == (a b) :long "((" a ") == (" b "))")
(defprimitive != (a b) :long "((" a ") != (" b "))")

;; primitive always returning nil
(defprimitive the_null () :value "(NULL)")



;; runtime assertion with message
(defprimitive assert_msg (:cstring msg :long cond) :void
  "basilys_assertmsg(" msg ", ( " cond "))")
;;; less, lessorequal, greater, greaterorequal, equal, different number 
(defprimitive <i (:long a b) :long "((" a ") < (" b "))")
(defprimitive <=i (:long a b) :long "((" a ") <= (" b "))")
(defprimitive ==i (:long a b) :long "((" a ") == (" b "))")
(defprimitive >i (:long a b) :long "((" a ") > (" b "))")
(defprimitive >=i (:long a b) :long "((" a ") >= (" b "))")
(defprimitive !=i (:long a b) :long "((" a ") != (" b "))")
;;; integer arithmetic
(defprimitive +i (:long a b) :long "((" a ") + (" b "))")
(defprimitive -i (:long a b) :long "((" a ") - (" b "))")
(defprimitive *i (:long a b) :long "((" a ") * (" b "))")
(defprimitive andi (:long a b) :long "((" a ") & (" b "))")
(defprimitive ori (:long a b) :long "((" a ") | (" b "))")
(defprimitive xori (:long a b) :long "((" a ") ^ (" b "))")
(defprimitive negi (:long i) :long "(-(" i "))")
(defprimitive noti (:long i) :long "(~(" i "))")

(defprimitive /i (:long a b) :long "(basilys_idiv(" a "), (" b "))")
(defprimitive %i (:long a b) :long "(basilys_imod(" a "), (" b "))")
(defprimitive /iraw (:long a b)  :long "((" a ") / (" b "))")
(defprimitive %iraw (:long a b)  :long "((" a ") % (" b "))")
;; boolean not
(defprimitive not (:long i) :long "(!(" i "))")
;;; nullity test (for values)
(defprimitive null (v) :long "((" v ") == NULL)")
(defprimitive notnull (v) :long "((" v ") != NULL)")


;;; zero test (for numbers)
(defprimitive zerop (:long i) :long "((" i ") == OL)")
(defprimitive message_dbg (:cstring msg) :void
  "debugeputs((" msg "))")
(defprimitive messagenum_dbg (:cstring msg :long i) :void
  "debugnum((" msg "), (" i "))")
(defprimitive messageval_dbg (:cstring msg :value val) :void
  "debugvalue((" msg "), ((void*)(" val ")))")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; STRBUF primitives
;; primitive to make a strbuf
(defprimitive make_strbuf (discr) :value
  "basilysgc_new_strbuf((basilysobject_ptr_t)(" discr "), (char*)0)")
(defprimitive strbuf_usedlength (sbuf) :long
  "basilys_strbuf_usedlength((" sbuf "))")

(defprimitive is_strbuf (v) :long
  "(basilys_magic_discr((" v ")) == OBMAG_STRBUF)")
;; primitive to add a string const into a strbuf
(defprimitive add2sbuf_strconst (sbuf :cstring str) :void 
  "basilysgc_add_strbuf((" sbuf "), (" str "))")
;; primitive to add a string value into a strbuf
(defprimitive add2sbuf_string (sbuf str) :void 
  "basilysgc_add_strbuf((" sbuf "), basilys_string_str(" str "))")

;; primitive to add an indentation or space into a strbuf
(defprimitive add2sbuf_indent (sbuf :long depth) :void
  "basilysgc_strbuf_add_indent((" sbuf "), (" depth "), 72)")


;; primitive to add an indented newline into a strbuf
(defprimitive add2sbuf_indentnl (sbuf :long depth) :void
  "basilysgc_strbuf_add_indent((" sbuf "), (" depth "), 0)")


;; primitive to add a strbuf into a strbuf
(defprimitive add2sbuf_sbuf (sbuf asbuf) :void 
  "basilysgc_add_strbuf((" sbuf "), basilys_strbuf_str(" asbuf "))")

;; primitive to add a string value, C encoded, into a strbuf
(defprimitive add2sbuf_cencstring (sbuf str) :void 
  "basilysgc_add_strbuf_cstr((" sbuf "), basilys_string_str(" str "))")

;; primitive to add a strbuf, C encoded, into a strbuf
(defprimitive add2sbuf_cencstrbuf (sbuf asbuf) :void 
  "basilysgc_add_strbuf_cstr((" sbuf "), basilys_strbuf_str(" asbuf "))")

;; primitive to add a string value, Ccomment encoded, into a strbuf
(defprimitive add2sbuf_ccomstring (sbuf str) :void 
  "basilysgc_add_strbuf_ccomment((" sbuf "), basilys_string_str(" str "))")

;; primitive to add a strbuf, C encoded, into a strbuf
(defprimitive add2sbuf_ccomstrbuf (sbuf asbuf) :void 
  "basilysgc_add_strbuf_ccomment((" sbuf "), basilys_strbuf_str(" asbuf "))")


;; primitive to add into a strbuf a string as C ident (nonalphanum
;; replaced by _)
(defprimitive add2sbuf_cident (sbuf str) :void
  "basilysgc_add_strbuf_cident((" sbuf "), basilys_string_str(" str "))")

;; primitive to add into a strbuf the prefix of a string as C ident (nonalphanum
;; replaced by _) limited by a small length 
(defprimitive add2sbuf_cidentprefix  (sbuf str :long preflen) :void
  "basilysgc_add_strbuf_cidentprefix((" sbuf "), basilys_string_str(" str "), (" preflen "))")

;; primitive to add a long in decimal into a strbuf
(defprimitive add2sbuf_longdec (sbuf :long num) :void
  "basilysgc_add_strbuf_dec((" sbuf "), (" num "))")

;; primitive to add a long in hex into a strbuf
(defprimitive add2sbuf_longhex (sbuf :long num) :void
  "basilysgc_add_strbuf_hex((" sbuf "), (" num "))")

;; primitive to add a routine descr into a strbuf
(defprimitive add2sbuf_routinedescr (sbuf rout) :void
  "basilysgc_add_strbuf((" sbuf "), basilys_routine_descrstr(" rout "))")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; STRING primitives
;; primitive for testing if a value is a string
(defprimitive is_string (str) :long
  " (basilys_magic_discr(" str ") == OBMAG_STRING)")
;; string equal
(defprimitive ==s (s1 s2) :long
  "basilys_string_same((" s1 "), (" s2 "))")
;;; make a string
(defprimitive make_string (dis str) :value
  "(basilysgc_new_stringdup((void*)(" dis "), basilys_string_str((" str "))))")
(defprimitive make_stringconst (dis :cstring cstr) :value
  "(basilysgc_new_stringdup((void*)(" dis "), (" cstr ")))")

(defprimitive string_length (str) :long
  "basilys_string_length((" str "))")
;;; convert a strbuf into a string
(defprimitive strbuf2string (dis sbuf) :value
  "(basilysgc_new_stringdup((void*)(" dis "), basilys_strbuf_str((" sbuf "))))")
;;; compute the naked basename
(defprimitive make_string_nakedbasename (dis str) :value
 "(basilysgc_new_string_nakedbasename((basilysobject_ptr_t)(" dis "), basilys_string_str((" str "))))")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; OBJECT primitives
;; primitive to get an object length
(defprimitive object_length (ob) :long 
  "((long)basilys_object_length((" ob ")))")
;; primitive to get the nth field of an object
(defprimitive object_nth_field (ob :long n) :value
  "(basilys_field_object((" ob "), (" n ")))")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; MULTIPLEs primitives
;;;; test
(defprimitive is_multiple (mul) :long
 "(basilys_magic_discr((" mul  ")) == OBMAG_MULTIPLE)")
(defprimitive is_multiple_or_null (mul) :long
 "((" mul ") == NULL || (basilys_magic_discr((" mul  ")) == OBMAG_MULTIPLE))")
;;; make
(defprimitive make_multiple (discr :long ln) :value
  "(basilysgc_new_multiple((basilysobject_ptr_t)(" discr "), (" ln ")))")
(defprimitive make_tuple1 (discr v1) :value
  "(basilysgc_new_mult1((basilysobject_ptr_t)(" discr "),(" v1 ")))")
(defprimitive make_tuple2 (discr v1 v2) :value
  "(basilysgc_new_mult2((basilysobject_ptr_t)(" discr "),(" v1 "), (" v2 ")))")
(defprimitive make_tuple3 (discr v1 v2 v3) :value
  "(basilysgc_new_mult3((basilysobject_ptr_t)(" discr "),(" v1 "), (" v2  "), (" v3 ")))")
(defprimitive make_tuple4 (discr v1 v2 v3 v4) :value
  "(basilysgc_new_mult4((basilysobject_ptr_t)(" discr "),(" v1 "), (" v2  "), (" v3  "), (" v4 ")))")
(defprimitive make_tuple5 (discr v1 v2 v3 v4 v5) :value
  "(basilysgc_new_mult5((basilysobject_ptr_t)(" discr "),(" v1 "), (" v2  "), (" v3  "), (" v4  "), (" v5 ")))")
;; primitive to get the nth  in a multiple
(defprimitive multiple_nth (mul :long n) :value
    "(basilys_multiple_nth((void*)(" mul "), (" n ")))")
;; primitive to get the length of a multiple
(defprimitive multiple_length (v) :long
  "(basilys_multiple_length((void*)(" v ")))")
;; be careful to avoid circularities
(defprimitive multiple_put_nth (mul :long n :value v) :void
  " basilysgc_multiple_put_nth((void*)(" mul "), (" n "), (void*)(" v "))")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; MAPOBJECTs primitives
;;;; test
(defprimitive is_mapobject (map) :long
 "(basilys_magic_discr((" map  ")) == OBMAG_MAPOBJECTS)")
;; primitive to get the allocated size of a mapobject
(defprimitive mapobject_size (map) :long
  "(basilys_size_mapobjects((void*)(" map ")))")
;; primitive to get the attribute count of a mapobject
(defprimitive mapobject_count (map) :long
  "(basilys_count_mapobjects((void*)(" map ")))")
;; primitive to get the nth attribute of a mapobject
(defprimitive mapobject_nth_attr (map :long n) :value
  "(basilys_nthattr_mapobjects((void*)(" map "), (int)(" n ")))")
;; primitive to get the nth value of a mapobject
(defprimitive mapobject_nth_val (map :long n) :value
  "(basilys_nthval_mapobjects((void*)(" map "), (int)(" n ")))")
;; primitive to get the value of an attribute in a mapobject
(defprimitive mapobject_get (map attr) :value
  "(basilys_get_mapobjects((void*)(" map "), (" attr ")))")
;; primitive for making a new map of objects
(defprimitive make_mapobject (discr :long len) :value
  " (basilysgc_new_mapobjects( (void*) (" discr "), (" len ")))")
;; primitive for putting into a map of objects
(defprimitive mapobject_put (map key val) :void
 " basilysgc_put_mapobjects( (void*) (" map "), (" key "), (" val "))")
;; primivite for removing from a map of objects
(defprimitive mapobject_remove (map key) :void
  " basilysgc_remove_mapobjects( (void*) (" map "), (" key "))")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; MAPSTRINGs primitive
;; test
(defprimitive is_mapstring (map) :long
"(basilys_magic_discr((" map ")) == OBMAG_MAPSTRINGS)")
;; primitive to get the allocated size of a mapstring
(defprimitive mapstring_size (map) :long 
  "(basilys_size_mapstrings(" map "))")
;; primitive to get the attribute count of a mapstring
(defprimitive mapstring_count (map) :long
  "(basilys_count_mapstrings(" map "))")
;; get an entry in a mapstring from a C string
(defprimitive mapstring_rawget (map :cstring cstr) :value
  "(basilys_get_mapstrings((void*)(" map "), (" cstr ")))")
;; primitive for making a new map of strings
(defprimitive make_mapstring (discr :long len) :value
  " (basilysgc_new_mapstrings( (basilysobject_ptr_t) (" discr "), (" len ")))")
;; primitive for putting into a map of strings
(defprimitive mapstring_rawput (map :cstring key :value val) :void
 " basilysgc_put_mapstrings( (void*) (" map "), (" key "), (" val "))")
(defprimitive mapstring_putstr (map keystr val) :void
  " basilysgc_put_mapstrings((void*) (" map "), basilys_string_str(" keystr "), (" val "))")
(defprimitive mapstring_getstr (map keystr) :value
  "(basilys_get_mapstrings((void*)(" map "), basilys_string_str(" keystr ")))")
;; primivite for removing from a map of strings
(defprimitive mapstring_rawremove (map :cstring key) :void
  " basilysgc_remove_mapstrings( (void*) (" map "), (" key "))")

;; primitive to make the nth stringattr of a mapobject
(defprimitive mapstring_nth_attrstr (map sdicr :long n) :value
  "(basilysgc_new_stringdup((void*)(" sdicr "), basilys_nthattrraw_mapstrings((" map "), (int)(" n "))))")
;; primitive to get the nth value of a mapobject
(defprimitive mapstring_nth_val (map :long n) :value
  "(basilys_nthval_mapstrings((" map "), (int)(" n ")))")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; ROUTINEs primitives
;; test
(defprimitive is_routine (rou) :long
"(basils_magic_discr((" rou ")) == OBMAG_ROUTINE)")
;;; descriptive string of a routine
(defprimitive routine_descr (rou) :value
  "(basilysgc_new_stringdup(basilys_routine_descrstr((" rou "))))")
;;; size of a routine
(defprimitive routine_size  (rou) :long
  "(basilys_routine_size((" rou ")))")
;;; nth comp in routine
(defprimitive routine_nth (rou :long ix) :value
"(basilys_routine_nth((" rou "), (int) (" ix ")))")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; CLOSUREs primitives
;; test
(defprimitive is_closure (clo) :long
  " (basilys_magic_discr((" clo ")) == OBMAG_CLOSURE)")
(defprimitive closure_size (clo) :long
  " (basilys_closure_size((" clo ")))")
(defprimitive closure_routine (clo) :value
 " (basilys_closure_routine((" clo ")))")
(defprimitive closure_nth (clo :long ix) :value
  "(basilys_closure_nth((" clo "), (int)(" ix ")))")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; boxed INTEGERs primitives
;; test
(defprimitive is_integerbox (ib) :long
  "(basilys_magic_discr((void*)(" ib ")) == OBMAG_INT)")
;; to get the boxed integer use get_int
;; make
(defprimitive make_integerbox (discr :long n) :value
  "(basilysgc_new_int((void*)(" discr "), (" n ")))")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; BOX primitives (boxed values)
;; test
(defprimitive is_box (bx) :long
  "(basilys_magic_discr((" bx ")) == OBMAG_BOX)")
;; safe fetch content
(defprimitive box_content (box) :value
  "basilys_box_content((" box "))")
;; put into a box
(defprimitive box_put (box val) :void
  "basilysgc_box_put((" box "), (" val "))")
;; make a box
(defprimitive make_box (discr valb) :value
  "basilysgc_new_box((void*)(" discr "), (void*)(" valb "))")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; LIST primitives
;; test
(defprimitive is_list (li) :long
  "(basilys_magic_discr((" li ")) == OBMAG_LIST)")
(defprimitive is_list_or_null (li) :long
  "((" li ") == NULL || (basilys_magic_discr((" li ")) == OBMAG_LIST))")
;; first pair of list
(defprimitive list_first (li) :value
  "(basilys_list_first((" li ")))")
;; last pair of list
(defprimitive list_last (li) :value
"(basilys_list_last((" li ")))")
;; length of list
(defprimitive list_length (li) :long
"(basilys_list_length((" li ")))")
;; append into list
(defprimitive list_append (li el) :void
"basilysgc_append_list((" li "), (" el "))")
;; prepend into list
(defprimitive list_prepend (li el) :void
"basilysgc_prepend_list((" li "), (" el "))")
;; pop first from list
(defprimitive list_popfirst (li) :value
  "(basilysgc_popfirst_list((" li ")))")
;; make list
(defprimitive make_list (discr) :value
"(basilysgc_new_list((void*)(" discr ")))")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; PAIR primitives
;; test
(defprimitive is_pair (pa) :long
  "(basilys_magic_discr((" pa ")) == OBMAG_PAIR)")
;; head
(defprimitive pair_head (pa) :value
  "(basilys_pair_head((" pa ")))")
;; tail
(defprimitive pair_tail (pa) :value
  "(basilys_pair_tail((" pa ")))")
;; change the head of a pair
(defprimitive pair_set_head (pa hd) :void
  "basilysgc_pair_set_head((" pa "), (" hd "))")
;; length of a pair list
(defprimitive pair_listlength (pa) :long
  "(basilys_pair_listlength((" pa ")))")
;; make
(defprimitive pair_make (discr hd tl) :value
  "(basilysgc_new_pair((" discr "), (" hd "), (" tl ")))")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; MIXINT primitives (use get_int to get the integer)
;; test
(defprimitive is_mixint (mi) :long
  "(basilys_magic_discr((" mi ")) == OBMAG_MIXINT)")
;; get the value
(defprimitive mixint_val (mi) :value
  "(basilys_val_mixint((" mi ")))")

;;; debugging primitives
(defprimitive message_dbg (:cstring msg) :void
  "debugeputs((" msg "))")
(defprimitive messagenum_dbg (:cstring msg :long i) :void
  "debugnum((" msg "), (" i "))")
(defprimitive messageval_dbg (:cstring msg :value val) :void
  "debugvalue((" msg "), ((void*)(" val ")))")
(defprimitive debugprintval_dbg (:cstring msg :value val) :void
  "debugeprintvalue((" msg "), ((void*)(" val ")))")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; the discriminant for name strings
(definstance discr_namestring class_discr
 :predef DISCR_NAMESTRING
 :obj_num OBMAG_STRING
;;; :named_name (stringconst2val discr_namestring "DISCR_NAMESTRING")
;;; :disc_super discr_string   ;; forward reference not allowed
)

;;; the discriminant for strings
(definstance discr_string class_discr
 :predef DISCR_STRING
 :obj_num OBMAG_STRING
 :named_name (stringconst2val discr_namestring "DISCR_STRING"))

(unsafe_put_fields discr_namestring :disc_super discr_string)
(unsafe_put_fields discr_namestring :named_name
		   (stringconst2val discr_namestring "DISCR_NAMESTRING"))

;;; the discriminant for verbatim strings (used for defprimitive)
(definstance discr_verbatimstring class_discr
 :predef DISCR_VERBATIMSTRING
 :obj_num OBMAG_STRING
 :named_name (stringconst2val discr_namestring "DISCR_VERBATIMSTRING")
 :disc_super discr_string
)

;;; the discriminant for any reciever (used for sending to everything)
(definstance discr_anyrecv class_discr
  :named_name (stringconst2val discr_namestring "DISCR_ANYRECV")
)

(unsafe_put_fields discr_string :disc_super discr_anyrecv)

;;; the discriminant for null reciever (used for sending to nil)
(definstance discr_nullrecv class_discr
  :predef DISCR_NULLRECV
  :disc_super discr_anyrecv
  :named_name (stringconst2val discr_namestring "DISCR_NULLRECV"))

;;; the discriminant for strbuf
(definstance discr_strbuf class_discr
 :obj_num OBMAG_STRBUF  
 :disc_super discr_anyrecv
 :named_name (stringconst2val discr_namestring "DISCR_STRBUF"))

;;; the discriminant for integers
(definstance discr_integer class_discr
 :predef DISCR_INTEGER
 :obj_num OBMAG_INT 
 :disc_super discr_anyrecv
 :named_name (stringconst2val discr_namestring "DISCR_INTEGER"))

;;; the discriminant for lists
(definstance discr_list class_discr
  :predef DISCR_LIST
  :obj_num OBMAG_LIST 
  :disc_super discr_anyrecv
  :named_name (stringconst2val discr_namestring "DISCR_LIST"))

;;; the discriminant for pairs
(definstance discr_pair class_discr
  :predef DISCR_PAIR
  :obj_num OBMAG_PAIR 
  :disc_super discr_anyrecv
  :named_name (stringconst2val discr_namestring "DISCR_PAIR"))

;;; the discriminant for multiples
(definstance discr_multiple class_discr
  :predef DISCR_MULTIPLE
  :obj_num OBMAG_MULTIPLE
  :disc_super discr_anyrecv
  :named_name (stringconst2val discr_namestring "DISCR_MULTIPLE"))

;;; the discriminant for sequence of fields
(definstance discr_seqfield class_discr
  :predef DISCR_SEQFIELD
  :obj_num OBMAG_MULTIPLE
  :named_name (stringconst2val discr_namestring "DISCR_SEQFIELD")
  :disc_super discr_multiple
)

;;; the discriminant for boxes
(definstance discr_box class_discr
  :predef DISCR_BOX
  :obj_num OBMAG_BOX
  :disc_super discr_anyrecv
  :named_name (stringconst2val discr_namestring "DISCR_BOX"))

;;; the discriminant for maps of objects
(definstance discr_mapobjects class_discr
  :predef DISCR_MAPOBJECTS
  :obj_num OBMAG_MAPOBJECTS
  :disc_super discr_anyrecv
  :named_name (stringconst2val discr_namestring "DISCR_MAPOBJECTS"))

;;; the discriminant for maps of strings
(definstance discr_mapstrings class_discr
  :predef DISCR_MAPSTRINGS
  :obj_num OBMAG_MAPSTRINGS
  :disc_super discr_anyrecv
  :named_name (stringconst2val discr_namestring "DISCR_MAPSTRINGS"))

;;; the discriminant for sequence of classes 
(definstance discr_seqclass class_discr
  :predef DISCR_SEQCLASS
  :obj_num OBMAG_MULTIPLE
  :named_name (stringconst2val discr_namestring "DISCR_SEQCLASS")
  :disc_super discr_multiple
)


;;; the discriminant for method dictionnary maps
(definstance discr_methodmap class_discr
  :predef DISCR_METHODMAP
  :obj_num OBMAG_MAPOBJECTS
  :disc_super discr_mapobjects
  :named_name (stringconst2val discr_namestring "DISCR_METHODMAP"))

;;; the discriminant for charcode integers
(definstance discr_charinteger class_discr
 :predef DISCR_CHARINTEGER
 :obj_num OBMAG_INT
 :named_name (stringconst2val discr_namestring "DISCR_CHARINTEGER")
 :disc_super discr_integer
)


;;; the discriminant for mixedintegers
(definstance discr_mixedint class_discr
 :predef DISCR_MIXEDINT
 :obj_num OBMAG_MIXINT
 :disc_super discr_anyrecv
 :named_name (stringconst2val discr_namestring "DISCR_MIXEDINT"))


;;; the discriminant for closures
(definstance discr_closure class_discr
 :predef DISCR_CLOSURE
 :obj_num OBMAG_CLOSURE
 :disc_super discr_anyrecv
 :named_name (stringconst2val discr_namestring "DISCR_CLOSURE"))

;;; the discriminant for routines
(definstance discr_routine class_discr
 :predef DISCR_ROUTINE
 :obj_num OBMAG_ROUTINE
 :disc_super discr_anyrecv
 :named_name (stringconst2val discr_namestring "DISCR_ROUTINE"))

;;;;;;;;;;;;;;;;;;;; initial commands
(definstance initial_command_dispatcher class_command_dispatcher
  :predef INITIAL_COMMAND_DISPATCHER
  :named_name (stringconst2val discr_namestring "INITIAL_COMMAND_DISPATCHER")
  :cmd_fundict  (make_mapstring discr_mapstrings 40)
)

(defun install_initial_command (nam fun)
  (debugprintval_dbg "install_initial_command @@ fun" fun)
  (debugprintval_dbg "install_initial_command @@ nam" nam)
  (if (is_closure fun)
      (if (is_string nam)
	  (mapstring_putstr 
	   (unsafe_get_field :cmd_fundict initial_command_dispatcher) 
	   nam fun))))

;;; output on stderr
(defprimitive outnum_err (:cstring pref :long l :cstring suf) :void
  "basilys_putnum(stderr,(" pref "), (" l "), (" suf "))")
(defprimitive outcstring_err (:cstring s) :void
  "basilys_puts(stderr,(" s "))")
(defprimitive outstrbuf_err (sbuf) :void
  "basilys_putstrbuf(stderr,(" sbuf "))")
(defprimitive outnewline_err () :void
  "basilys_newlineflush(stderr)")
(defprimitive outstr_err (str) :void
  "basilys_putstr(stderr,(" str "))")

(defun say_command (dispatcher arg)
  (debugprintval_dbg "say_command" arg)
  (outstr_err arg)
  (outnewline_err)
)
(install_initial_command   (stringconst2val discr_string "say") say_command)
;; eof 