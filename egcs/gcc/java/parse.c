
/*  A Bison parser, made from /nfs/hoser/beer/java/egcs/gcc/java/parse.y
 by  GNU Bison version 1.25
  */

#define YYBISON 1  /* Identify Bison output.  */

#define yyparse java_parse
#define yylex java_lex
#define yyerror java_error
#define yylval java_lval
#define yychar java_char
#define yydebug java_debug
#define yynerrs java_nerrs
#define	PLUS_TK	258
#define	MINUS_TK	259
#define	MULT_TK	260
#define	DIV_TK	261
#define	REM_TK	262
#define	LS_TK	263
#define	SRS_TK	264
#define	ZRS_TK	265
#define	AND_TK	266
#define	XOR_TK	267
#define	OR_TK	268
#define	BOOL_AND_TK	269
#define	BOOL_OR_TK	270
#define	EQ_TK	271
#define	NEQ_TK	272
#define	GT_TK	273
#define	GTE_TK	274
#define	LT_TK	275
#define	LTE_TK	276
#define	PLUS_ASSIGN_TK	277
#define	MINUS_ASSIGN_TK	278
#define	MULT_ASSIGN_TK	279
#define	DIV_ASSIGN_TK	280
#define	REM_ASSIGN_TK	281
#define	LS_ASSIGN_TK	282
#define	SRS_ASSIGN_TK	283
#define	ZRS_ASSIGN_TK	284
#define	AND_ASSIGN_TK	285
#define	XOR_ASSIGN_TK	286
#define	OR_ASSIGN_TK	287
#define	PUBLIC_TK	288
#define	PRIVATE_TK	289
#define	PROTECTED_TK	290
#define	STATIC_TK	291
#define	FINAL_TK	292
#define	SYNCHRONIZED_TK	293
#define	VOLATILE_TK	294
#define	TRANSIENT_TK	295
#define	NATIVE_TK	296
#define	PAD_TK	297
#define	ABSTRACT_TK	298
#define	MODIFIER_TK	299
#define	DECR_TK	300
#define	INCR_TK	301
#define	DEFAULT_TK	302
#define	IF_TK	303
#define	THROW_TK	304
#define	BOOLEAN_TK	305
#define	DO_TK	306
#define	IMPLEMENTS_TK	307
#define	THROWS_TK	308
#define	BREAK_TK	309
#define	IMPORT_TK	310
#define	ELSE_TK	311
#define	INSTANCEOF_TK	312
#define	RETURN_TK	313
#define	VOID_TK	314
#define	CATCH_TK	315
#define	INTERFACE_TK	316
#define	CASE_TK	317
#define	EXTENDS_TK	318
#define	FINALLY_TK	319
#define	SUPER_TK	320
#define	WHILE_TK	321
#define	CLASS_TK	322
#define	SWITCH_TK	323
#define	CONST_TK	324
#define	TRY_TK	325
#define	FOR_TK	326
#define	NEW_TK	327
#define	CONTINUE_TK	328
#define	GOTO_TK	329
#define	PACKAGE_TK	330
#define	THIS_TK	331
#define	BYTE_TK	332
#define	SHORT_TK	333
#define	INT_TK	334
#define	LONG_TK	335
#define	CHAR_TK	336
#define	INTEGRAL_TK	337
#define	FLOAT_TK	338
#define	DOUBLE_TK	339
#define	FP_TK	340
#define	ID_TK	341
#define	REL_QM_TK	342
#define	REL_CL_TK	343
#define	NOT_TK	344
#define	NEG_TK	345
#define	ASSIGN_ANY_TK	346
#define	ASSIGN_TK	347
#define	OP_TK	348
#define	CP_TK	349
#define	OCB_TK	350
#define	CCB_TK	351
#define	OSB_TK	352
#define	CSB_TK	353
#define	SC_TK	354
#define	C_TK	355
#define	DOT_TK	356
#define	STRING_LIT_TK	357
#define	CHAR_LIT_TK	358
#define	INT_LIT_TK	359
#define	FP_LIT_TK	360
#define	TRUE_TK	361
#define	FALSE_TK	362
#define	BOOL_LIT_TK	363
#define	NULL_TK	364

#line 49 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

#include "config.h"
#include "tree.h"
#include "rtl.h"
#include "obstack.h"
#include "flags.h"
#include "java-tree.h"
#include "jcf.h"
#include "lex.h"
#include "parse.h"
#include "zipfile.h"

/* Number of error found so far. */
int java_error_count; 
/* Number of warning found so far. */
int java_warning_count;

/* The current parser context */
static struct parser_ctxt *ctxp;

/* binop_lookup maps token to tree_code. It is used where binary
   operations are involved and required by the parser. RDIV_EXPR
   covers both integral/floating point division. The code is changed
   once the type of both operator is worked out.  */

static enum tree_code binop_lookup[19] = 
  { 
    PLUS_EXPR, MINUS_EXPR, MULT_EXPR, RDIV_EXPR, TRUNC_MOD_EXPR,
    LSHIFT_EXPR, RSHIFT_EXPR, URSHIFT_EXPR, 
    BIT_AND_EXPR, BIT_XOR_EXPR, BIT_IOR_EXPR,
    TRUTH_ANDIF_EXPR, TRUTH_ORIF_EXPR,
    EQ_EXPR, NE_EXPR, GT_EXPR, GE_EXPR, LT_EXPR, LE_EXPR,
   };
#define BINOP_LOOKUP(VALUE) 						\
  binop_lookup [((VALUE) - PLUS_TK)%					\
		(sizeof (binop_lookup) / sizeof (binop_lookup[0]))]

/* Fake WFL used to report error message. It is initialized once if
   needed and reused with it's location information is overriden.  */
static tree wfl_operator = NULL_TREE;

/* The "$L" identifier we use to create labels.  */
static tree label_id;

#line 104 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
typedef union {
  tree node;
  int sub_token;
  struct {
    int token;
    int location;
  } operator;
  int value;
} YYSTYPE;
#ifndef YYDEBUG
#define YYDEBUG 1
#endif

#include <stdio.h>

#ifndef __cplusplus
#ifndef __STDC__
#define const
#endif
#endif



#define	YYFINAL		772
#define	YYFLAG		-32768
#define	YYNTBASE	110

#define YYTRANSLATE(x) ((unsigned)(x) <= 364 ? yytranslate[x] : 259)

static const char yytranslate[] = {     0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,
     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,
    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,
    56,    57,    58,    59,    60,    61,    62,    63,    64,    65,
    66,    67,    68,    69,    70,    71,    72,    73,    74,    75,
    76,    77,    78,    79,    80,    81,    82,    83,    84,    85,
    86,    87,    88,    89,    90,    91,    92,    93,    94,    95,
    96,    97,    98,    99,   100,   101,   102,   103,   104,   105,
   106,   107,   108,   109
};

#if YYDEBUG != 0
static const short yyprhs[] = {     0,
     0,     2,     4,     6,     8,    10,    12,    14,    16,    18,
    20,    22,    24,    26,    28,    30,    32,    34,    38,    42,
    46,    50,    54,    56,    58,    60,    64,    66,    67,    69,
    71,    73,    76,    79,    82,    86,    88,    91,    93,    96,
   100,   103,   107,   109,   111,   115,   118,   122,   128,   133,
   139,   141,   143,   145,   147,   149,   152,   153,   161,   162,
   169,   173,   176,   180,   185,   186,   189,   193,   196,   197,
   200,   203,   205,   209,   213,   216,   220,   222,   225,   227,
   229,   231,   233,   235,   237,   239,   241,   245,   250,   252,
   256,   260,   262,   266,   270,   275,   277,   281,   284,   288,
   292,   294,   296,   297,   301,   304,   308,   312,   317,   322,
   325,   329,   332,   336,   339,   343,   348,   352,   356,   360,
   362,   366,   370,   373,   377,   380,   384,   385,   388,   391,
   393,   397,   401,   403,   406,   408,   411,   415,   417,   421,
   426,   431,   437,   441,   446,   449,   453,   457,   462,   467,
   473,   481,   488,   490,   492,   493,   498,   499,   505,   506,
   512,   513,   520,   524,   529,   532,   536,   539,   543,   546,
   550,   552,   555,   557,   559,   561,   563,   565,   568,   571,
   574,   578,   582,   587,   589,   593,   597,   600,   601,   606,
   608,   611,   613,   615,   617,   620,   623,   627,   629,   631,
   633,   635,   637,   639,   641,   643,   645,   647,   649,   651,
   653,   655,   657,   659,   661,   663,   665,   667,   669,   671,
   673,   676,   679,   682,   685,   688,   691,   694,   697,   701,
   706,   711,   717,   722,   728,   735,   743,   750,   752,   754,
   756,   758,   760,   762,   764,   770,   773,   777,   782,   790,
   798,   804,   807,   811,   817,   820,   824,   828,   833,   835,
   838,   841,   843,   846,   850,   853,   856,   860,   863,   868,
   871,   874,   878,   883,   886,   888,   896,   904,   911,   915,
   921,   926,   934,   941,   944,   947,   951,   954,   955,   957,
   959,   962,   963,   965,   967,   971,   975,   978,   982,   985,
   989,   992,   996,   999,  1003,  1006,  1010,  1013,  1017,  1021,
  1024,  1028,  1034,  1040,  1043,  1048,  1052,  1054,  1058,  1062,
  1067,  1070,  1072,  1075,  1081,  1084,  1089,  1093,  1096,  1099,
  1101,  1103,  1105,  1107,  1111,  1113,  1115,  1117,  1119,  1123,
  1127,  1131,  1135,  1139,  1143,  1147,  1151,  1157,  1162,  1169,
  1175,  1180,  1186,  1192,  1199,  1203,  1207,  1212,  1218,  1221,
  1225,  1229,  1233,  1235,  1239,  1243,  1247,  1251,  1256,  1261,
  1266,  1271,  1275,  1279,  1281,  1284,  1288,  1292,  1295,  1298,
  1302,  1306,  1310,  1314,  1317,  1321,  1326,  1332,  1339,  1345,
  1352,  1357,  1362,  1367,  1372,  1376,  1381,  1385,  1390,  1392,
  1394,  1396,  1398,  1401,  1404,  1406,  1408,  1411,  1414,  1416,
  1419,  1422,  1425,  1428,  1431,  1434,  1436,  1439,  1442,  1444,
  1447,  1450,  1456,  1461,  1466,  1472,  1477,  1480,  1486,  1491,
  1497,  1499,  1503,  1507,  1511,  1515,  1519,  1523,  1525,  1529,
  1533,  1537,  1541,  1543,  1547,  1551,  1555,  1559,  1563,  1567,
  1569,  1573,  1577,  1581,  1585,  1589,  1593,  1597,  1601,  1605,
  1609,  1611,  1615,  1619,  1623,  1627,  1629,  1633,  1637,  1639,
  1643,  1647,  1649,  1653,  1657,  1659,  1663,  1667,  1669,  1673,
  1677,  1679,  1685,  1690,  1694,  1700,  1702,  1704,  1708,  1712,
  1714,  1716,  1718,  1720,  1722,  1724
};

static const short yyrhs[] = {   123,
     0,   104,     0,   105,     0,   108,     0,   103,     0,   102,
     0,   109,     0,   113,     0,   114,     0,    82,     0,    85,
     0,    50,     0,   115,     0,   118,     0,   119,     0,   115,
     0,   115,     0,   113,    97,    98,     0,   119,    97,    98,
     0,   118,    97,    98,     0,   113,    97,     1,     0,   118,
    97,     1,     0,   120,     0,   121,     0,   122,     0,   119,
   101,   122,     0,    86,     0,     0,   126,     0,   124,     0,
   125,     0,   126,   124,     0,   126,   125,     0,   124,   125,
     0,   126,   124,   125,     0,   127,     0,   124,   127,     0,
   130,     0,   125,   130,     0,    75,   119,    99,     0,    75,
     1,     0,    75,   119,     1,     0,   128,     0,   129,     0,
    55,   119,    99,     0,    55,     1,     0,    55,   119,     1,
     0,    55,   119,   101,     5,    99,     0,    55,   119,   101,
     1,     0,    55,   119,   101,     5,     1,     0,   132,     0,
   163,     0,    99,     0,     1,     0,    44,     0,   131,    44,
     0,     0,   131,    67,   122,   135,   136,   133,   138,     0,
     0,    67,   122,   135,   136,   134,   138,     0,   131,    67,
     1,     0,    67,     1,     0,    67,   122,     1,     0,   131,
    67,   122,     1,     0,     0,    63,   116,     0,    63,   116,
     1,     0,    63,     1,     0,     0,    52,   137,     0,    52,
     1,     0,   117,     0,   137,   100,   117,     0,   137,   100,
     1,     0,    95,    96,     0,    95,   139,    96,     0,   140,
     0,   139,   140,     0,   141,     0,   156,     0,   158,     0,
   176,     0,   142,     0,   147,     0,   132,     0,   163,     0,
   112,   143,    99,     0,   131,   112,   143,    99,     0,   144,
     0,   143,   100,   144,     0,   143,   100,     1,     0,   145,
     0,   145,    92,   146,     0,   145,    92,     1,     0,   145,
    92,   146,     1,     0,   122,     0,   145,    97,    98,     0,
   122,     1,     0,   145,    97,     1,     0,   145,    98,     1,
     0,   257,     0,   174,     0,     0,   149,   148,   155,     0,
   149,     1,     0,   112,   150,   153,     0,    59,   150,   153,
     0,   131,   112,   150,   153,     0,   131,    59,   150,   153,
     0,   112,     1,     0,   131,   112,     1,     0,    59,     1,
     0,   131,    59,     1,     0,   131,     1,     0,   122,    93,
    94,     0,   122,    93,   151,    94,     0,   150,    97,    98,
     0,   122,    93,     1,     0,   150,    97,     1,     0,   152,
     0,   151,   100,   152,     0,   151,   100,     1,     0,   112,
   145,     0,   131,   112,   145,     0,   112,     1,     0,   131,
   112,     1,     0,     0,    53,   154,     0,    53,     1,     0,
   116,     0,   154,   100,   116,     0,   154,   100,     1,     0,
   176,     0,   176,    99,     0,    99,     0,   157,   176,     0,
   157,   176,    99,     0,    44,     0,   159,   153,   160,     0,
   131,   159,   153,   160,     0,   159,   153,   160,    99,     0,
   131,   159,   153,   160,    99,     0,   120,    93,    94,     0,
   120,    93,   151,    94,     0,    95,    96,     0,    95,   161,
    96,     0,    95,   178,    96,     0,    95,   161,   178,    96,
     0,   162,    93,    94,    99,     0,   162,    93,   226,    94,
    99,     0,   119,   101,    65,    93,   226,    94,    99,     0,
   119,   101,    65,    93,    94,    99,     0,    76,     0,    65,
     0,     0,    61,   122,   164,   169,     0,     0,   131,    61,
   122,   165,   169,     0,     0,    61,   122,   168,   166,   169,
     0,     0,   131,    61,   122,   168,   167,   169,     0,    61,
   122,     1,     0,   131,    61,   122,     1,     0,    63,   117,
     0,   168,   100,   117,     0,    63,     1,     0,   168,   100,
     1,     0,    95,    96,     0,    95,   170,    96,     0,   171,
     0,   170,   171,     0,   172,     0,   173,     0,   132,     0,
   163,     0,   142,     0,   149,    99,     0,   149,     1,     0,
    95,    96,     0,    95,   175,    96,     0,    95,   100,    96,
     0,    95,   175,   100,    96,     0,   146,     0,   175,   100,
   146,     0,   175,   100,     1,     0,    95,    96,     0,     0,
    95,   177,   178,    96,     0,   179,     0,   178,   179,     0,
   180,     0,   182,     0,   132,     0,   181,    99,     0,   112,
   143,     0,   131,   112,   143,     0,   184,     0,   187,     0,
   191,     0,   192,     0,   201,     0,   205,     0,   184,     0,
   188,     0,   193,     0,   202,     0,   206,     0,   176,     0,
   185,     0,   189,     0,   194,     0,   204,     0,   212,     0,
   213,     0,   214,     0,   216,     0,   215,     0,   218,     0,
    99,     0,   122,    88,     0,   186,   182,     0,   122,     1,
     0,   186,   183,     0,   190,    99,     0,     1,    99,     0,
     1,    95,     0,     1,    96,     0,   162,    93,     1,     0,
   162,    93,    94,     1,     0,   162,    93,   226,     1,     0,
   162,    93,   226,    94,     1,     0,   119,   101,    65,     1,
     0,   119,   101,    65,    93,     1,     0,   119,   101,    65,
    93,   226,     1,     0,   119,   101,    65,    93,   226,    94,
     1,     0,   119,   101,    65,    93,    94,     1,     0,   254,
     0,   238,     0,   239,     0,   235,     0,   236,     0,   232,
     0,   224,     0,    48,    93,   257,    94,   182,     0,    48,
     1,     0,    48,    93,     1,     0,    48,    93,   257,     1,
     0,    48,    93,   257,    94,   183,    56,   182,     0,    48,
    93,   257,    94,   183,    56,   183,     0,    68,    93,   257,
    94,   195,     0,    68,     1,     0,    68,    93,     1,     0,
    68,    93,   257,    94,     1,     0,    95,    96,     0,    95,
   198,    96,     0,    95,   196,    96,     0,    95,   196,   198,
    96,     0,   197,     0,   196,   197,     0,   198,   178,     0,
   199,     0,   198,   199,     0,    62,   258,    88,     0,    47,
    88,     0,    62,     1,     0,    62,   258,     1,     0,    47,
     1,     0,    66,    93,   257,    94,     0,   200,   182,     0,
    66,     1,     0,    66,    93,     1,     0,    66,    93,   257,
     1,     0,   200,   183,     0,    51,     0,   203,   182,    66,
    93,   257,    94,    99,     0,   208,    99,   257,    99,   210,
    94,   182,     0,   208,    99,    99,   210,    94,   182,     0,
   208,    99,     1,     0,   208,    99,   257,    99,     1,     0,
   208,    99,    99,     1,     0,   208,    99,   257,    99,   210,
    94,   183,     0,   208,    99,    99,   210,    94,   183,     0,
    71,    93,     0,    71,     1,     0,    71,    93,     1,     0,
   207,   209,     0,     0,   211,     0,   181,     0,   211,     1,
     0,     0,   211,     0,   190,     0,   211,   100,   190,     0,
   211,   100,     1,     0,    54,    99,     0,    54,   122,    99,
     0,    54,     1,     0,    54,   122,     1,     0,    73,    99,
     0,    73,   122,    99,     0,    73,     1,     0,    73,   122,
     1,     0,    58,    99,     0,    58,   257,    99,     0,    58,
     1,     0,    58,   257,     1,     0,    49,   257,    99,     0,
    49,     1,     0,    49,   257,     1,     0,   217,    93,   257,
    94,   176,     0,   217,    93,   257,    94,     1,     0,   217,
     1,     0,   217,    93,     1,    94,     0,   217,    93,     1,
     0,    44,     0,    70,   176,   219,     0,    70,   176,   221,
     0,    70,   176,   219,   221,     0,    70,     1,     0,   220,
     0,   219,   220,     0,    60,    93,   152,    94,   176,     0,
    60,     1,     0,    60,    93,     1,    94,     0,    60,    93,
     1,     0,    64,   176,     0,    64,     1,     0,   223,     0,
   227,     0,   111,     0,    76,     0,    93,   257,    94,     0,
   224,     0,   231,     0,   232,     0,   233,     0,   119,   101,
    67,     0,   113,   101,    67,     0,    59,   101,    67,     0,
   119,   101,    76,     0,    93,   257,     1,     0,   119,   101,
     1,     0,   113,   101,     1,     0,    59,   101,     1,     0,
    72,   116,    93,   226,    94,     0,    72,   116,    93,    94,
     0,    72,   116,    93,   226,    94,   138,     0,    72,   116,
    93,    94,   138,     0,   225,   122,    93,    94,     0,   225,
   122,    93,    94,   138,     0,   225,   122,    93,   226,    94,
     0,   225,   122,    93,   226,    94,   138,     0,    72,     1,
    99,     0,    72,   116,     1,     0,    72,   116,    93,     1,
     0,    72,   116,    93,   226,     1,     0,   225,     1,     0,
   225,   122,     1,     0,   119,   101,    72,     0,   222,   101,
    72,     0,   257,     0,   226,   100,   257,     0,   226,   100,
     1,     0,    72,   113,   228,     0,    72,   115,   228,     0,
    72,   113,   228,   230,     0,    72,   115,   228,   230,     0,
    72,   115,   230,   174,     0,    72,   113,   230,   174,     0,
    72,     1,    98,     0,    72,     1,    97,     0,   229,     0,
   228,   229,     0,    97,   257,    98,     0,    97,   257,     1,
     0,    97,     1,     0,    97,    98,     0,   230,    97,    98,
     0,   230,    97,     1,     0,   222,   101,   122,     0,    65,
   101,   122,     0,    65,     1,     0,   119,    93,    94,     0,
   119,    93,   226,    94,     0,   222,   101,   122,    93,    94,
     0,   222,   101,   122,    93,   226,    94,     0,    65,   101,
   122,    93,    94,     0,    65,   101,   122,    93,   226,    94,
     0,    65,   101,     1,    94,     0,    65,   101,     1,   101,
     0,   119,    97,   257,    98,     0,   223,    97,   257,    98,
     0,   119,    97,     1,     0,   119,    97,   257,     1,     0,
   223,    97,     1,     0,   223,    97,   257,     1,     0,   222,
     0,   119,     0,   235,     0,   236,     0,   234,    46,     0,
   234,    45,     0,   238,     0,   239,     0,     3,   237,     0,
     4,   237,     0,   240,     0,     3,     1,     0,     4,     1,
     0,    46,   237,     0,    46,     1,     0,    45,   237,     0,
    45,     1,     0,   234,     0,    89,   237,     0,    90,   237,
     0,   241,     0,    89,     1,     0,    90,     1,     0,    93,
   113,   230,    94,   237,     0,    93,   113,    94,   237,     0,
    93,   257,    94,   240,     0,    93,   119,   230,    94,   240,
     0,    93,   113,    97,     1,     0,    93,     1,     0,    93,
   113,   230,    94,     1,     0,    93,   113,    94,     1,     0,
    93,   119,   230,    94,     1,     0,   237,     0,   242,     5,
   237,     0,   242,     6,   237,     0,   242,     7,   237,     0,
   242,     5,     1,     0,   242,     6,     1,     0,   242,     7,
     1,     0,   242,     0,   243,     3,   242,     0,   243,     4,
   242,     0,   243,     3,     1,     0,   243,     4,     1,     0,
   243,     0,   244,     8,   243,     0,   244,     9,   243,     0,
   244,    10,   243,     0,   244,     8,     1,     0,   244,     9,
     1,     0,   244,    10,     1,     0,   244,     0,   245,    20,
   244,     0,   245,    18,   244,     0,   245,    21,   244,     0,
   245,    19,   244,     0,   245,    57,   114,     0,   245,    20,
     1,     0,   245,    18,     1,     0,   245,    21,     1,     0,
   245,    19,     1,     0,   245,    57,     1,     0,   245,     0,
   246,    16,   245,     0,   246,    17,   245,     0,   246,    16,
     1,     0,   246,    17,     1,     0,   246,     0,   247,    11,
   246,     0,   247,    11,     1,     0,   247,     0,   248,    12,
   247,     0,   248,    12,     1,     0,   248,     0,   249,    13,
   248,     0,   249,    13,     1,     0,   249,     0,   250,    14,
   249,     0,   250,    14,     1,     0,   250,     0,   251,    15,
   250,     0,   251,    15,     1,     0,   251,     0,   251,    87,
   257,    88,   252,     0,   251,    87,    88,     1,     0,   251,
    87,     1,     0,   251,    87,   257,    88,     1,     0,   252,
     0,   254,     0,   255,   256,   253,     0,   255,   256,     1,
     0,   119,     0,   231,     0,   233,     0,    91,     0,    92,
     0,   253,     0,   257,     0
};

#endif

#if YYDEBUG != 0
static const short yyrline[] = { 0,
   251,   257,   259,   260,   261,   262,   263,   267,   269,   272,
   274,   275,   278,   280,   283,   287,   291,   295,   301,   303,
   305,   307,   312,   314,   317,   321,   326,   331,   333,   334,
   335,   336,   337,   338,   339,   342,   347,   353,   355,   358,
   361,   363,   367,   369,   372,   402,   404,   408,   421,   423,
   427,   433,   434,   436,   446,   451,   466,   470,   473,   476,
   479,   481,   483,   485,   489,   491,   493,   495,   499,   501,
   503,   510,   516,   521,   525,   528,   532,   534,   537,   539,
   540,   541,   544,   546,   547,   548,   552,   555,   567,   570,
   572,   576,   579,   586,   592,   600,   602,   606,   608,   610,
   614,   616,   621,   628,   640,   644,   647,   649,   651,   653,
   655,   657,   659,   661,   668,   671,   673,   678,   680,   684,
   689,   694,   698,   703,   708,   710,   717,   718,   719,   723,
   725,   726,   730,   732,   733,   738,   743,   749,   761,   766,
   772,   777,   786,   788,   791,   793,   794,   795,   799,   801,
   804,   805,   809,   816,   826,   830,   833,   836,   839,   842,
   845,   848,   851,   853,   857,   863,   868,   870,   874,   877,
   881,   883,   886,   888,   889,   890,   893,   897,   903,   908,
   913,   917,   921,   927,   929,   930,   935,   938,   941,   948,
   950,   953,   955,   957,   960,   964,   967,   971,   973,   975,
   977,   979,   981,   991,   993,   995,   997,   999,  1003,  1006,
  1008,  1010,  1012,  1014,  1016,  1018,  1019,  1021,  1023,  1027,
  1032,  1043,  1050,  1054,  1065,  1075,  1081,  1087,  1093,  1095,
  1097,  1099,  1101,  1103,  1105,  1107,  1109,  1113,  1115,  1119,
  1123,  1127,  1131,  1132,  1138,  1141,  1143,  1145,  1149,  1154,
  1159,  1161,  1163,  1165,  1169,  1171,  1172,  1173,  1176,  1178,
  1181,  1186,  1188,  1191,  1193,  1194,  1196,  1198,  1202,  1210,
  1213,  1215,  1217,  1221,  1226,  1235,  1240,  1243,  1250,  1252,
  1254,  1258,  1261,  1270,  1277,  1279,  1283,  1296,  1298,  1304,
  1310,  1314,  1316,  1320,  1323,  1325,  1329,  1332,  1334,  1336,
  1340,  1343,  1345,  1347,  1351,  1354,  1356,  1358,  1362,  1364,
  1366,  1370,  1372,  1374,  1376,  1378,  1382,  1389,  1391,  1392,
  1393,  1397,  1399,  1402,  1404,  1406,  1408,  1412,  1414,  1419,
  1421,  1424,  1426,  1428,  1430,  1431,  1432,  1433,  1437,  1438,
  1439,  1443,  1444,  1446,  1448,  1450,  1454,  1460,  1468,  1470,
  1475,  1476,  1477,  1478,  1479,  1481,  1483,  1485,  1487,  1489,
  1493,  1495,  1498,  1504,  1509,  1513,  1516,  1518,  1520,  1524,
  1526,  1528,  1530,  1534,  1537,  1541,  1547,  1549,  1557,  1560,
  1562,  1566,  1569,  1576,  1580,  1583,  1585,  1590,  1595,  1603,
  1615,  1617,  1621,  1624,  1626,  1631,  1636,  1641,  1648,  1650,
  1651,  1652,  1655,  1660,  1665,  1667,  1668,  1670,  1672,  1673,
  1675,  1679,  1682,  1686,  1689,  1693,  1695,  1697,  1699,  1700,
  1702,  1706,  1714,  1716,  1718,  1730,  1732,  1738,  1740,  1742,
  1746,  1748,  1753,  1758,  1763,  1765,  1767,  1771,  1773,  1778,
  1783,  1785,  1789,  1791,  1796,  1801,  1806,  1808,  1810,  1814,
  1816,  1821,  1826,  1831,  1836,  1837,  1839,  1841,  1843,  1845,
  1849,  1851,  1856,  1861,  1863,  1867,  1869,  1874,  1878,  1880,
  1885,  1889,  1891,  1896,  1900,  1902,  1907,  1911,  1913,  1918,
  1922,  1924,  1925,  1931,  1933,  1937,  1939,  1942,  1945,  1953,
  1955,  1956,  1959,  1961,  1964,  1968
};
#endif


#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)

static const char * const yytname[] = {   "$","error","$undefined.","PLUS_TK",
"MINUS_TK","MULT_TK","DIV_TK","REM_TK","LS_TK","SRS_TK","ZRS_TK","AND_TK","XOR_TK",
"OR_TK","BOOL_AND_TK","BOOL_OR_TK","EQ_TK","NEQ_TK","GT_TK","GTE_TK","LT_TK",
"LTE_TK","PLUS_ASSIGN_TK","MINUS_ASSIGN_TK","MULT_ASSIGN_TK","DIV_ASSIGN_TK",
"REM_ASSIGN_TK","LS_ASSIGN_TK","SRS_ASSIGN_TK","ZRS_ASSIGN_TK","AND_ASSIGN_TK",
"XOR_ASSIGN_TK","OR_ASSIGN_TK","PUBLIC_TK","PRIVATE_TK","PROTECTED_TK","STATIC_TK",
"FINAL_TK","SYNCHRONIZED_TK","VOLATILE_TK","TRANSIENT_TK","NATIVE_TK","PAD_TK",
"ABSTRACT_TK","MODIFIER_TK","DECR_TK","INCR_TK","DEFAULT_TK","IF_TK","THROW_TK",
"BOOLEAN_TK","DO_TK","IMPLEMENTS_TK","THROWS_TK","BREAK_TK","IMPORT_TK","ELSE_TK",
"INSTANCEOF_TK","RETURN_TK","VOID_TK","CATCH_TK","INTERFACE_TK","CASE_TK","EXTENDS_TK",
"FINALLY_TK","SUPER_TK","WHILE_TK","CLASS_TK","SWITCH_TK","CONST_TK","TRY_TK",
"FOR_TK","NEW_TK","CONTINUE_TK","GOTO_TK","PACKAGE_TK","THIS_TK","BYTE_TK","SHORT_TK",
"INT_TK","LONG_TK","CHAR_TK","INTEGRAL_TK","FLOAT_TK","DOUBLE_TK","FP_TK","ID_TK",
"REL_QM_TK","REL_CL_TK","NOT_TK","NEG_TK","ASSIGN_ANY_TK","ASSIGN_TK","OP_TK",
"CP_TK","OCB_TK","CCB_TK","OSB_TK","CSB_TK","SC_TK","C_TK","DOT_TK","STRING_LIT_TK",
"CHAR_LIT_TK","INT_LIT_TK","FP_LIT_TK","TRUE_TK","FALSE_TK","BOOL_LIT_TK","NULL_TK",
"goal","literal","type","primitive_type","reference_type","class_or_interface_type",
"class_type","interface_type","array_type","name","simple_name","qualified_name",
"identifier","compilation_unit","import_declarations","type_declarations","package_declaration",
"import_declaration","single_type_import_declaration","type_import_on_demand_declaration",
"type_declaration","modifiers","class_declaration","@1","@2","super","interfaces",
"interface_type_list","class_body","class_body_declarations","class_body_declaration",
"class_member_declaration","field_declaration","variable_declarators","variable_declarator",
"variable_declarator_id","variable_initializer","method_declaration","@3","method_header",
"method_declarator","formal_parameter_list","formal_parameter","throws","class_type_list",
"method_body","static_initializer","static","constructor_declaration","constructor_declarator",
"constructor_body","explicit_constructor_invocation","this_or_super","interface_declaration",
"@4","@5","@6","@7","extends_interfaces","interface_body","interface_member_declarations",
"interface_member_declaration","constant_declaration","abstract_method_declaration",
"array_initializer","variable_initializers","block","@8","block_statements",
"block_statement","local_variable_declaration_statement","local_variable_declaration",
"statement","statement_nsi","statement_without_trailing_substatement","empty_statement",
"label_decl","labeled_statement","labeled_statement_nsi","expression_statement",
"statement_expression","if_then_statement","if_then_else_statement","if_then_else_statement_nsi",
"switch_statement","switch_block","switch_block_statement_groups","switch_block_statement_group",
"switch_labels","switch_label","while_expression","while_statement","while_statement_nsi",
"do_statement_begin","do_statement","for_statement","for_statement_nsi","for_header",
"for_begin","for_init","for_update","statement_expression_list","break_statement",
"continue_statement","return_statement","throw_statement","synchronized_statement",
"synchronized","try_statement","catches","catch_clause","finally","primary",
"primary_no_new_array","class_instance_creation_expression","something_dot_new",
"argument_list","array_creation_expression","dim_exprs","dim_expr","dims","field_access",
"method_invocation","array_access","postfix_expression","post_increment_expression",
"post_decrement_expression","unary_expression","pre_increment_expression","pre_decrement_expression",
"unary_expression_not_plus_minus","cast_expression","multiplicative_expression",
"additive_expression","shift_expression","relational_expression","equality_expression",
"and_expression","exclusive_or_expression","inclusive_or_expression","conditional_and_expression",
"conditional_or_expression","conditional_expression","assignment_expression",
"assignment","left_hand_side","assignment_operator","expression","constant_expression", NULL
};
#endif

static const short yyr1[] = {     0,
   110,   111,   111,   111,   111,   111,   111,   112,   112,   113,
   113,   113,   114,   114,   115,   116,   117,   118,   118,   118,
   118,   118,   119,   119,   120,   121,   122,   123,   123,   123,
   123,   123,   123,   123,   123,   124,   124,   125,   125,   126,
   126,   126,   127,   127,   128,   128,   128,   129,   129,   129,
   130,   130,   130,   130,   131,   131,   133,   132,   134,   132,
   132,   132,   132,   132,   135,   135,   135,   135,   136,   136,
   136,   137,   137,   137,   138,   138,   139,   139,   140,   140,
   140,   140,   141,   141,   141,   141,   142,   142,   143,   143,
   143,   144,   144,   144,   144,   145,   145,   145,   145,   145,
   146,   146,   148,   147,   147,   149,   149,   149,   149,   149,
   149,   149,   149,   149,   150,   150,   150,   150,   150,   151,
   151,   151,   152,   152,   152,   152,   153,   153,   153,   154,
   154,   154,   155,   155,   155,   156,   156,   157,   158,   158,
   158,   158,   159,   159,   160,   160,   160,   160,   161,   161,
   161,   161,   162,   162,   164,   163,   165,   163,   166,   163,
   167,   163,   163,   163,   168,   168,   168,   168,   169,   169,
   170,   170,   171,   171,   171,   171,   172,   173,   173,   174,
   174,   174,   174,   175,   175,   175,   176,   177,   176,   178,
   178,   179,   179,   179,   180,   181,   181,   182,   182,   182,
   182,   182,   182,   183,   183,   183,   183,   183,   184,   184,
   184,   184,   184,   184,   184,   184,   184,   184,   184,   185,
   186,   187,   187,   188,   189,   189,   189,   189,   189,   189,
   189,   189,   189,   189,   189,   189,   189,   190,   190,   190,
   190,   190,   190,   190,   191,   191,   191,   191,   192,   193,
   194,   194,   194,   194,   195,   195,   195,   195,   196,   196,
   197,   198,   198,   199,   199,   199,   199,   199,   200,   201,
   201,   201,   201,   202,   203,   204,   205,   205,   205,   205,
   205,   206,   206,   207,   207,   207,   208,   209,   209,   209,
   209,   210,   210,   211,   211,   211,   212,   212,   212,   212,
   213,   213,   213,   213,   214,   214,   214,   214,   215,   215,
   215,   216,   216,   216,   216,   216,   217,   218,   218,   218,
   218,   219,   219,   220,   220,   220,   220,   221,   221,   222,
   222,   223,   223,   223,   223,   223,   223,   223,   223,   223,
   223,   223,   223,   223,   223,   223,   224,   224,   224,   224,
   224,   224,   224,   224,   224,   224,   224,   224,   224,   224,
   225,   225,   226,   226,   226,   227,   227,   227,   227,   227,
   227,   227,   227,   228,   228,   229,   229,   229,   230,   230,
   230,   231,   231,   231,   232,   232,   232,   232,   232,   232,
   232,   232,   233,   233,   233,   233,   233,   233,   234,   234,
   234,   234,   235,   236,   237,   237,   237,   237,   237,   237,
   237,   238,   238,   239,   239,   240,   240,   240,   240,   240,
   240,   241,   241,   241,   241,   241,   241,   241,   241,   241,
   242,   242,   242,   242,   242,   242,   242,   243,   243,   243,
   243,   243,   244,   244,   244,   244,   244,   244,   244,   245,
   245,   245,   245,   245,   245,   245,   245,   245,   245,   245,
   246,   246,   246,   246,   246,   247,   247,   247,   248,   248,
   248,   249,   249,   249,   250,   250,   250,   251,   251,   251,
   252,   252,   252,   252,   252,   253,   253,   254,   254,   255,
   255,   255,   256,   256,   257,   258
};

static const short yyr2[] = {     0,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     3,     3,     3,
     3,     3,     1,     1,     1,     3,     1,     0,     1,     1,
     1,     2,     2,     2,     3,     1,     2,     1,     2,     3,
     2,     3,     1,     1,     3,     2,     3,     5,     4,     5,
     1,     1,     1,     1,     1,     2,     0,     7,     0,     6,
     3,     2,     3,     4,     0,     2,     3,     2,     0,     2,
     2,     1,     3,     3,     2,     3,     1,     2,     1,     1,
     1,     1,     1,     1,     1,     1,     3,     4,     1,     3,
     3,     1,     3,     3,     4,     1,     3,     2,     3,     3,
     1,     1,     0,     3,     2,     3,     3,     4,     4,     2,
     3,     2,     3,     2,     3,     4,     3,     3,     3,     1,
     3,     3,     2,     3,     2,     3,     0,     2,     2,     1,
     3,     3,     1,     2,     1,     2,     3,     1,     3,     4,
     4,     5,     3,     4,     2,     3,     3,     4,     4,     5,
     7,     6,     1,     1,     0,     4,     0,     5,     0,     5,
     0,     6,     3,     4,     2,     3,     2,     3,     2,     3,
     1,     2,     1,     1,     1,     1,     1,     2,     2,     2,
     3,     3,     4,     1,     3,     3,     2,     0,     4,     1,
     2,     1,     1,     1,     2,     2,     3,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     2,     2,     2,     2,     2,     2,     2,     2,     3,     4,
     4,     5,     4,     5,     6,     7,     6,     1,     1,     1,
     1,     1,     1,     1,     5,     2,     3,     4,     7,     7,
     5,     2,     3,     5,     2,     3,     3,     4,     1,     2,
     2,     1,     2,     3,     2,     2,     3,     2,     4,     2,
     2,     3,     4,     2,     1,     7,     7,     6,     3,     5,
     4,     7,     6,     2,     2,     3,     2,     0,     1,     1,
     2,     0,     1,     1,     3,     3,     2,     3,     2,     3,
     2,     3,     2,     3,     2,     3,     2,     3,     3,     2,
     3,     5,     5,     2,     4,     3,     1,     3,     3,     4,
     2,     1,     2,     5,     2,     4,     3,     2,     2,     1,
     1,     1,     1,     3,     1,     1,     1,     1,     3,     3,
     3,     3,     3,     3,     3,     3,     5,     4,     6,     5,
     4,     5,     5,     6,     3,     3,     4,     5,     2,     3,
     3,     3,     1,     3,     3,     3,     3,     4,     4,     4,
     4,     3,     3,     1,     2,     3,     3,     2,     2,     3,
     3,     3,     3,     2,     3,     4,     5,     6,     5,     6,
     4,     4,     4,     4,     3,     4,     3,     4,     1,     1,
     1,     1,     2,     2,     1,     1,     2,     2,     1,     2,
     2,     2,     2,     2,     2,     1,     2,     2,     1,     2,
     2,     5,     4,     4,     5,     4,     2,     5,     4,     5,
     1,     3,     3,     3,     3,     3,     3,     1,     3,     3,
     3,     3,     1,     3,     3,     3,     3,     3,     3,     1,
     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
     1,     3,     3,     3,     3,     1,     3,     3,     1,     3,
     3,     1,     3,     3,     1,     3,     3,     1,     3,     3,
     1,     5,     4,     3,     5,     1,     1,     3,     3,     1,
     1,     1,     1,     1,     1,     1
};

static const short yydefact[] = {     0,
    54,    55,     0,     0,     0,     0,    53,     1,     0,     0,
     0,    36,    43,    44,    38,     0,    51,    52,    46,    27,
     0,    23,    24,    25,     0,    62,     0,    41,     0,     0,
    37,    39,     0,     0,    56,     0,     0,    47,    45,     0,
   163,     0,     0,   159,    63,     0,    69,    42,    40,     0,
     0,     0,    61,     0,    49,     0,    26,   167,    17,   165,
    15,     0,   156,     0,     0,    68,    16,     0,     0,    59,
   164,     0,   161,    64,    69,    50,    48,    12,     0,    10,
    11,   169,     0,     8,     9,    13,    14,    15,     0,   175,
   177,     0,   176,     0,   171,   173,   174,   168,   166,   160,
    67,    71,    72,    70,     0,   158,     0,    57,   112,     0,
   127,   110,     0,     0,    89,    92,   127,     0,     0,     0,
   114,     0,     0,   179,   178,   170,   172,     0,     0,    60,
   162,     0,     0,     0,     0,   107,    98,    87,     0,     0,
     0,     0,   106,    21,    18,    22,    20,    19,   113,   127,
   111,     0,   127,    74,    73,    55,   188,    75,    23,     0,
    85,     0,    77,    79,    83,    84,     0,    80,     0,    81,
   127,    86,    82,    58,   118,   115,     0,     0,     0,   120,
   129,   130,   128,   119,   117,    91,     0,    90,    94,     0,
     0,     0,     0,     0,     0,     0,   333,     0,     0,     0,
     0,     6,     5,     2,     3,     4,     7,   332,     0,   400,
     0,   102,   399,   330,   335,     0,   331,   336,   337,   338,
   416,   401,   402,   431,   405,   406,   409,   419,   438,   443,
   450,   461,   466,   469,   472,   475,   478,   481,   486,   495,
   487,     0,   101,    99,    97,   100,   109,    88,   108,   187,
     0,     0,   127,    76,    78,   105,     0,   136,     0,   125,
   123,     0,   116,     0,     0,   410,   400,   336,   338,   407,
   411,   408,   415,   414,   413,   412,     0,   384,     0,     0,
     0,    16,     0,   420,   417,   421,   418,   427,     0,   400,
     0,   180,     0,   184,     0,     0,     0,     0,     0,    95,
     0,     0,   359,     0,   404,   403,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,   493,   494,     0,
     0,    55,     0,     0,   275,     0,     0,     0,     0,     0,
     0,     0,     0,   333,     0,   220,     0,     8,   400,     0,
     0,   194,     0,   209,     0,   190,   192,     0,   193,   198,
   210,     0,   199,   211,     0,   200,   201,   212,     0,   202,
     0,   213,   203,   288,     0,   214,   215,   216,   218,   217,
     0,   219,   244,   243,     0,   241,   242,   239,   240,   238,
   143,     0,     0,   135,   104,   133,   137,     0,   139,   126,
   124,   122,   121,   132,   131,   346,   341,     0,   383,   373,
   372,   355,     0,   366,   374,     0,   367,     0,   356,     0,
     0,     0,     0,     0,     0,   343,   334,   182,   181,     0,
   345,   340,   385,     0,   363,   395,     0,   344,   339,   361,
   342,   362,   382,   397,     0,   360,     0,   435,   432,   436,
   433,   437,   434,   441,   439,   442,   440,   447,   444,   448,
   445,   449,   446,   457,   452,   459,   454,   456,   451,   458,
   453,   460,     0,   455,   464,   462,   465,   463,   468,   467,
   471,   470,   474,   473,   477,   476,   480,   479,   484,     0,
     0,   489,   488,   227,   228,   226,   246,     0,   310,     0,
   299,   297,     0,   307,   305,     0,   271,     0,   252,     0,
   321,     0,   285,     0,   303,   301,     0,     0,   196,     0,
     0,   223,   221,     0,     0,   189,   191,   195,   317,   400,
   222,   225,   270,     0,   400,     0,   290,   294,   287,     0,
     0,   314,     0,   144,   140,   134,   145,   400,     0,     0,
     0,   141,   391,   392,     0,   378,   379,     0,   375,   368,
     0,   371,   369,   370,   357,   348,     0,   429,   423,   426,
     0,     0,   424,   186,   183,   185,   386,     0,   396,   393,
     0,   398,   394,   351,     0,   483,     0,   247,     0,   311,
   309,   300,   298,   308,   306,   272,     0,   253,     0,     0,
     0,   318,   322,   319,   286,   304,   302,   334,     0,   197,
   229,     0,     0,     0,   291,     0,   279,     0,     0,   316,
     0,   142,     0,   146,     0,     0,   147,   389,     0,   377,
   376,   381,   380,   350,   358,   347,   428,   422,   430,   425,
   365,   364,   387,     0,   352,   353,   485,   482,   248,     0,
   273,   269,     0,   325,     0,   329,   328,   323,   320,   233,
     0,   230,   231,     0,     0,   296,   295,   281,     0,   293,
     0,   315,     0,     0,   148,     0,     0,   390,   349,   388,
   354,     0,   245,     0,   198,     0,   205,   206,     0,   207,
   208,     0,   254,     0,   251,   327,     0,   234,     0,     0,
   232,     0,     0,   280,     0,   313,   312,     0,   149,     0,
     0,     0,   224,   274,     0,     0,     0,   255,     0,   259,
     0,   262,   326,     0,   237,   235,     0,     0,   278,     0,
     0,     0,   150,     0,   249,     0,     0,   268,   265,   266,
   496,     0,   257,   260,     0,   256,     0,   263,   324,   236,
   276,   277,   152,     0,     0,     0,     0,   267,   264,   258,
   151,     0,     0,     0,     0,   283,     0,   250,   282,     0,
     0,     0
};

static const short yydefgoto[] = {   770,
   208,   347,   209,    85,    86,    68,    60,    87,   210,    22,
    23,    24,     8,     9,    10,    11,    12,    13,    14,    15,
   351,   352,   132,   105,    47,    70,   104,   130,   162,   163,
   164,    91,   114,   115,   116,   211,   166,   257,    92,   111,
   179,   180,   136,   183,   395,   168,   169,   170,   171,   399,
   549,   353,    18,    43,    72,    65,   107,    44,    63,    94,
    95,    96,    97,   212,   295,   354,   251,   747,   356,   357,
   358,   359,   684,   360,   361,   362,   363,   687,   364,   365,
   366,   367,   688,   368,   695,   719,   720,   721,   722,   369,
   370,   690,   371,   372,   373,   691,   374,   375,   539,   669,
   670,   376,   377,   378,   379,   380,   381,   382,   602,   603,
   604,   213,   214,   215,   216,   434,   217,   414,   415,   416,
   218,   219,   220,   221,   222,   223,   224,   225,   226,   227,
   228,   229,   230,   231,   232,   233,   234,   235,   236,   237,
   238,   239,   240,   241,   242,   330,   435,   742
};

static const short yypact[] = {   353,
-32768,-32768,   325,   -41,   376,   398,-32768,-32768,   164,   528,
   436,-32768,-32768,-32768,-32768,   494,-32768,-32768,-32768,-32768,
    10,-32768,-32768,-32768,    18,-32768,   297,-32768,    11,   576,
-32768,-32768,   445,   598,-32768,   -41,   428,-32768,-32768,   690,
-32768,   470,   -13,   -46,-32768,   495,    82,-32768,-32768,   -41,
   612,   328,-32768,   381,-32768,    28,-32768,-32768,-32768,-32768,
   -36,  1021,-32768,   531,   -13,-32768,-32768,   232,   577,-32768,
-32768,   -13,   -46,-32768,    82,-32768,-32768,-32768,   590,-32768,
-32768,-32768,   592,     2,-32768,-32768,   170,    -7,   916,-32768,
-32768,    92,-32768,  1055,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,   172,   202,-32768,   -13,-32768,-32768,   262,
    -1,-32768,   424,   -75,-32768,   504,    -1,     9,    86,   278,
-32768,   615,   617,-32768,-32768,-32768,-32768,   637,   936,-32768,
-32768,   202,   729,   653,   117,-32768,-32768,-32768,   660,  2333,
   132,   384,-32768,-32768,-32768,-32768,-32768,-32768,-32768,    -1,
-32768,   655,    -1,-32768,-32768,   337,   377,-32768,   417,   916,
-32768,  1001,-32768,-32768,-32768,-32768,    47,-32768,   406,-32768,
   472,-32768,-32768,-32768,-32768,-32768,   667,   903,   551,-32768,
-32768,-32768,   442,-32768,-32768,-32768,   460,-32768,-32768,  3080,
  3145,  3196,  3261,   466,    21,   497,-32768,  3312,  3377,  3428,
  5442,-32768,-32768,-32768,-32768,-32768,-32768,-32768,   543,   915,
    99,-32768,   548,   560,-32768,   712,-32768,   770,-32768,   836,
   888,-32768,-32768,-32768,-32768,-32768,-32768,-32768,   619,   945,
  1019,   937,   935,   669,   676,   694,   714,   258,-32768,-32768,
-32768,   872,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
  2125,   731,   472,-32768,-32768,-32768,   128,   634,   668,-32768,
   873,   719,-32768,   585,   721,-32768,   673,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,    25,-32768,   724,   992,
   643,   643,   290,-32768,-32768,-32768,-32768,-32768,   746,   962,
   208,-32768,   654,-32768,   358,   331,  5509,  3493,   622,-32768,
   427,  3544,-32768,   393,-32768,-32768,  3609,  3660,  3725,  3776,
  3841,  3892,  3957,  4008,  4073,  4124,  4189,  4240,   525,  4305,
  4356,  4421,  4472,  4537,  4588,  4653,  2384,-32768,-32768,  4704,
   510,   415,   416,  4769,-32768,   182,  2449,    13,   418,   426,
    26,   450,   204,   679,  5741,-32768,   -41,   618,   844,   448,
   827,-32768,   684,-32768,  1785,-32768,-32768,   685,-32768,-32768,
-32768,  2193,-32768,-32768,   689,-32768,-32768,-32768,  2193,-32768,
  2193,-32768,-32768,  5792,   697,-32768,-32768,-32768,-32768,-32768,
   469,-32768,   702,   711,   888,   947,   965,-32768,-32768,-32768,
-32768,   759,   668,-32768,-32768,   728,-32768,  1853,   732,-32768,
   873,-32768,-32768,-32768,-32768,-32768,-32768,   123,   740,-32768,
-32768,-32768,  2500,   643,-32768,   493,   643,   493,-32768,  2565,
  4820,   166,   -30,  2616,   308,-32768,  1180,-32768,-32768,  1645,
-32768,-32768,-32768,   781,-32768,-32768,   239,-32768,-32768,-32768,
-32768,-32768,   772,-32768,   244,-32768,  5560,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,   619,-32768,   619,-32768,   945,-32768,
   945,-32768,   945,-32768,  1019,-32768,  1019,-32768,  1019,-32768,
  1019,-32768,     2,-32768,-32768,   937,-32768,   937,-32768,   935,
-32768,   669,-32768,   676,-32768,   694,-32768,   714,-32768,   766,
   784,-32768,-32768,-32768,-32768,-32768,-32768,  4885,-32768,   143,
-32768,-32768,   153,-32768,-32768,   180,-32768,  4936,-32768,  5001,
-32768,   681,-32768,  5350,-32768,-32768,   235,   242,   783,  2681,
   620,-32768,-32768,   -41,  2732,-32768,-32768,-32768,-32768,  1070,
-32768,-32768,-32768,   821,   984,   903,-32768,-32768,-32768,   104,
  2797,-32768,  5052,-32768,   802,-32768,-32768,  1037,  1921,   812,
  1989,-32768,-32768,-32768,  5625,-32768,-32768,   259,-32768,   826,
   295,-32768,   826,-32768,-32768,   202,    61,-32768,-32768,-32768,
  5117,   817,-32768,-32768,-32768,-32768,-32768,  5168,-32768,-32768,
  5676,-32768,-32768,   202,   785,-32768,  5233,-32768,   252,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,   253,-32768,   845,   471,
    46,   681,-32768,-32768,-32768,-32768,-32768,-32768,   473,   783,
-32768,   941,   122,   851,-32768,  5484,-32768,  5375,   855,   865,
   867,-32768,   645,-32768,  2057,  2848,-32768,-32768,   792,-32768,
-32768,-32768,-32768,-32768,-32768,   202,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,   814,-32768,   202,-32768,-32768,-32768,  2259,
-32768,-32768,    87,-32768,   788,-32768,-32768,-32768,-32768,-32768,
  2913,-32768,-32768,   972,  5741,-32768,-32768,-32768,   885,   884,
  5417,-32768,   206,   478,-32768,   245,   134,-32768,-32768,-32768,
-32768,   481,-32768,   931,   934,  2259,-32768,-32768,  2259,-32768,
-32768,   897,-32768,   733,-32768,   905,   910,-32768,  1016,   138,
-32768,   929,  2193,-32768,   939,-32768,-32768,  2964,-32768,   257,
  4885,  2193,-32768,-32768,  3029,   167,  5284,-32768,   739,-32768,
  1484,-32768,-32768,   406,-32768,-32768,  1024,   944,-32768,  2193,
   273,   150,-32768,   269,-32768,  5375,   948,-32768,-32768,-32768,
-32768,   212,-32768,-32768,  1571,-32768,  1717,-32768,-32768,-32768,
-32768,-32768,-32768,   276,  2259,   946,  5417,-32768,-32768,-32768,
-32768,   974,  2259,   955,  2259,-32768,  2259,-32768,-32768,  1038,
  1052,-32768
};

static const short yypgoto[] = {-32768,
-32768,   -58,    14,   737,     4,   -99,   674,-32768,    -3,   677,
-32768,    79,-32768,  1047,   760,-32768,   266,-32768,-32768,   881,
     7,    23,-32768,-32768,  1007,   997,-32768,  -131,-32768,   912,
-32768,   281,  -121,   928,   431,  -195,-32768,-32768,   408,   509,
   832,  -259,   -73,-32768,-32768,-32768,-32768,-32768,   918,   686,
-32768,   700,   -34,-32768,-32768,-32768,-32768,  1040,   508,-32768,
  1006,-32768,-32768,   500,-32768,  -120,-32768,  -221,  -340,-32768,
   727,  -299,   101,  -526,-32768,  -325,-32768,-32768,-32768,  -336,
-32768,-32768,-32768,-32768,-32768,-32768,   389,   391,  -666,  -300,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,  -280,-32768,  -297,
   741,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,   511,
   517,-32768,-32768,   -31,-32768,  -369,-32768,   813,   219,  -269,
  1157,   133,  1187,   279,   423,   486,   -20,   569,   607,  -419,
-32768,   703,   819,   534,   699,   799,   801,   803,   800,   816,
-32768,   552,   815,   695,-32768,-32768,   -51,-32768
};


#define	YYLAST		5901


static const short yytable[] = {    21,
   174,   152,    29,    83,   403,   294,    16,   573,   173,   144,
    38,    48,   418,   278,   527,    16,    16,    16,    41,   423,
   425,   278,    17,   138,   139,   406,   511,    93,    76,   355,
   123,    17,    17,    17,   182,    83,    16,   538,    61,    16,
    16,   173,    61,   143,    20,    59,   656,   256,   258,    67,
   567,   134,    17,    64,   748,    17,    17,    16,    88,    93,
    61,   635,   531,   571,    50,    61,   561,    59,    89,   533,
    83,   534,    59,    17,   177,    84,   247,   585,   748,   249,
    42,    62,    25,    27,    90,    88,   146,   693,   243,   120,
    88,   407,   124,    50,   172,   135,   283,   259,   118,   300,
    89,   123,    84,    83,   615,  -154,   145,    84,    39,    49,
    40,    50,  -155,   279,    52,    54,    90,   184,    57,   262,
   157,   279,   663,   685,    61,    88,    77,   172,    57,    88,
    61,    59,   244,    69,   663,   160,   396,    67,   726,   178,
   157,  -103,    84,   590,   560,  -103,    84,   563,   291,   243,
   726,   161,   640,   592,   636,   613,    88,   110,    88,   685,
   578,   113,   685,   -30,     1,   405,   570,   738,   160,   270,
   272,   274,   276,    84,    88,    84,   551,   285,   287,   393,
   594,   694,   501,   147,   161,   629,   267,   267,   267,   267,
   125,    84,    61,   177,   267,   267,   290,   -93,   -93,   282,
   110,   113,  -289,   616,   515,   177,   706,     2,   426,   281,
   527,   644,   758,   289,   185,   664,   553,   187,     3,   383,
   512,   578,   157,   554,     4,   519,   394,   710,   685,   245,
     5,   727,   101,   578,   576,   606,   685,   578,   685,   579,
   685,   591,   426,   754,   582,   662,   437,   349,    88,   578,
   445,   593,   649,   651,   739,   187,   677,   701,   178,   630,
    88,    61,     7,   557,   348,    84,   119,    20,    67,   649,
   178,   128,   326,   725,    31,   491,   750,    84,   595,   667,
   502,   538,   500,   -66,   527,   506,   449,   451,   453,    20,
   419,   700,   524,   518,   304,   632,   129,    45,    31,   759,
   157,   427,   516,   267,   267,   267,   267,   267,   267,   267,
   267,   267,   267,   267,   267,    88,   267,   267,   267,   267,
   267,   267,   267,   383,   686,    19,   -66,   625,    71,   350,
   383,   431,   473,   607,   538,   608,   580,   383,   732,   383,
   187,   583,   383,   709,   327,   650,   652,    88,   -65,   689,
   683,   349,   -28,     1,   133,   733,   631,   409,   530,    46,
   686,   558,   755,   686,    84,   530,   383,   530,   348,   692,
   535,   753,   437,   705,   761,   148,    26,    57,   243,   443,
   536,    74,   420,   384,   246,   689,   531,   348,   689,   533,
    42,   -65,   633,   446,   548,   697,     2,   432,    28,   538,
   569,   572,   610,   729,   561,   692,   527,     3,   692,   165,
    20,   348,   735,     4,   503,  -317,   497,   267,   507,     5,
   538,   517,  -157,   267,   137,   187,   509,     6,    53,   686,
   752,  -138,   -65,   350,   634,   -29,     1,   686,   756,   686,
   350,   686,   165,    46,   -32,     1,   589,   350,   522,   350,
   513,     7,   645,   429,   689,   683,   597,   430,   599,   764,
   137,    20,   689,   729,   689,   735,   689,   752,   437,   542,
    58,   654,   250,   660,   692,   -65,   350,   524,   660,     2,
   657,   497,   692,    20,   692,   447,   692,   384,     2,   619,
     3,   621,   -25,   -25,   384,    66,     4,   280,   442,     3,
   157,   384,     5,   384,   679,     4,   384,  -317,   498,   252,
   508,     5,    20,    20,   681,   -96,   133,   383,   510,   383,
   -96,   -96,   -96,   -96,   134,   472,   642,   -31,     1,   385,
   384,    98,    88,   -25,     7,   523,   167,    35,   -25,   -25,
   -25,   265,   514,     7,   -25,   349,    78,   349,   -25,    84,
   638,   -96,   707,   -96,    36,    20,   -96,   -96,   -96,   -96,
    37,   543,   348,   655,   348,   661,   277,   267,   267,   167,
   708,     2,   100,   711,    78,   -34,     1,   102,    80,   106,
    20,    81,    20,   267,   383,   402,   383,   201,     4,   561,
   109,   117,   112,   383,     5,   140,   177,   -33,     1,    57,
   141,   142,   187,   749,   494,   495,    80,   261,   496,    81,
    20,   -35,     1,   702,   131,   149,    20,   151,   383,     2,
   438,   349,   438,   307,   308,   309,     7,   350,     2,   350,
   150,   153,   559,   385,    78,   559,     4,   154,   348,   383,
   385,     2,     5,   296,   263,   438,   530,   385,   301,   385,
   264,    88,   385,   181,   383,     2,   302,   383,     4,   734,
   186,   178,    20,   737,     5,   741,    80,   260,    84,    81,
    20,   383,     4,   386,     7,    20,   385,    20,     5,   322,
   383,   384,   530,   384,   609,   530,   439,   323,   439,   383,
    55,   440,   401,   440,    56,   441,     7,   441,   383,   530,
    20,    57,    20,   350,   383,    20,   324,    20,   530,   674,
     7,   439,   303,   383,   118,   383,   440,   349,   296,   400,
   441,   404,    20,   383,   408,   383,   530,   325,   350,   175,
    20,   383,   397,   383,   348,   383,   387,    99,    20,   413,
   600,   349,   103,   349,   601,    20,  -335,  -335,   384,   428,
   384,   530,    20,   248,   139,  -337,  -337,   384,   348,   530,
   348,   530,   398,   530,   350,   297,   586,   350,    30,   298,
    34,  -153,     2,   299,     2,    20,   525,   386,    78,   716,
    78,   350,   384,   528,   386,   716,   713,   532,   696,   714,
   350,   386,    51,   386,   717,   541,   386,    20,  -335,   350,
   717,   155,  -335,   384,    20,   159,    20,  -337,   350,    20,
    80,  -337,    80,    81,    20,    81,    20,   639,   384,   388,
   386,   384,   176,   350,   391,   350,   546,   385,   718,   385,
   552,     2,   555,   350,   743,   384,   159,    78,   159,   421,
   387,   350,   422,   350,   384,   350,   296,   387,   465,   467,
   469,   471,   544,   384,   387,   762,   387,   389,   264,   387,
  -491,  -491,   384,   766,   581,   768,    78,   769,   384,    80,
    35,   587,    81,    20,   577,   194,    78,   384,   646,   384,
   578,   195,   139,   387,   578,   678,   614,   384,   196,   384,
    32,   578,   197,    37,   385,   384,   385,   384,    80,   384,
   622,    81,    20,   385,   626,   198,   199,   680,    80,   200,
    32,    81,    20,   578,    32,   562,   121,   564,   202,   203,
   204,   205,   561,   388,   206,   207,  -492,  -492,   385,   -15,
   388,    32,   305,   306,  -490,  -490,   297,   388,   653,   388,
   520,   662,   388,   665,   521,   390,    35,   310,   311,   385,
   320,   321,    78,   671,   315,   316,   317,   318,   672,    35,
   673,   389,   328,   329,   385,    78,   388,   385,   389,   141,
   142,   386,   701,   386,   122,   389,    36,   389,   703,   156,
   389,   385,    37,   616,    80,    78,   712,    81,    20,  -204,
   385,  -401,  -401,   319,    79,   715,     4,    80,   723,   385,
    81,    20,     5,   724,   389,  -490,  -490,   297,   385,  -402,
  -402,   298,   455,   457,   385,   299,   725,    80,   476,   478,
    81,    20,   728,   385,   750,   385,   312,   313,   314,   765,
   157,   158,   730,   385,   387,   385,   387,   771,   386,   763,
   386,   385,   751,   385,   156,   385,   757,   386,   767,   390,
    78,   772,  -490,  -490,   297,   474,   390,    33,   424,    79,
    75,     4,   299,   390,     2,   390,   188,     5,   390,   -15,
    78,   108,   386,   255,  -490,  -490,   297,   253,   545,    79,
   520,     4,    80,   392,   299,    81,    20,     5,   410,   411,
   412,    73,   390,   386,   417,   157,   254,   550,     2,   127,
   537,   387,    80,   387,    78,    81,    20,   744,   386,   745,
   387,   386,   658,    79,   540,     4,    82,   388,   659,   388,
   480,     5,   -15,   482,   486,   386,   484,  -490,  -490,   297,
   459,   461,   463,   520,   386,   387,    80,   623,   648,    81,
    20,   488,     0,   386,   493,     0,     0,     0,     0,     0,
   126,     0,   386,     0,     0,   389,   387,   389,   386,     0,
  -490,  -490,   297,     0,     0,     0,   298,   386,     0,   386,
   521,   387,     0,     0,   387,     0,     0,   386,     0,   386,
     0,     0,     0,     0,   388,   386,   388,   386,   387,   386,
     0,     0,     0,   388,     0,     0,     0,   387,     0,     0,
     0,     0,     0,     0,     0,     0,   387,     0,     0,     0,
     0,     0,     0,     0,     0,   387,     0,     0,   388,     0,
     0,   387,   389,     0,   389,     0,     0,     0,     0,    78,
   387,   389,   387,     0,     0,     0,     0,     0,   194,   388,
   387,     0,   387,   390,   195,   390,     0,     0,   387,     0,
   387,   196,   387,     0,   388,   197,   389,   388,     0,     0,
     0,    80,     0,     0,    81,    20,     0,     0,   198,   199,
     0,   388,   200,     0,     0,     0,     0,   389,     0,     0,
   388,   202,   203,   204,   205,     0,     0,   206,   207,   388,
     0,     0,   389,     0,     0,   389,     0,     0,   388,     0,
     0,     0,     0,     0,   388,     0,     0,     0,     0,   389,
   390,     0,   390,   388,     0,   388,     0,     0,   389,   390,
     0,     0,     0,   388,     0,   388,     0,   389,     0,     0,
     0,   388,     0,   388,     0,   388,   389,     0,     0,     0,
     0,     0,   389,     0,   390,     0,   268,   268,   268,   268,
     0,   389,     0,   389,   268,   268,     0,     0,     0,     0,
     0,   389,     0,   389,     0,   390,     0,     0,     0,   389,
     0,   389,     0,   389,     0,     0,   269,   269,   269,   269,
   390,     0,     0,   390,   269,   269,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,   390,     0,     0,
     0,     0,     0,     0,     0,     0,   390,     0,     0,     0,
     0,     0,     0,     0,     0,   390,     0,     0,     0,     0,
     0,     0,     0,     0,   390,     0,     0,     0,     0,     0,
   390,     0,     0,     0,     0,     0,     0,     0,     0,   390,
     0,   390,     0,     0,     0,     0,     0,     0,     0,   390,
     0,   390,     0,     0,     0,     0,     0,   390,     0,   390,
     0,   390,     0,   268,   268,   268,   268,   268,   268,   268,
   268,   268,   268,   268,   268,     0,   268,   268,   268,   268,
   268,   268,   268,     0,   331,     0,     0,     0,     0,     0,
     0,     0,     0,   269,   269,   269,   269,   269,   269,   269,
   269,   269,   269,   269,   269,     0,   269,   269,   269,   269,
   269,   269,   269,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,   332,   192,   193,
   716,   333,   334,    78,   335,     0,     0,   336,     0,     0,
     0,   337,   194,     0,     0,   717,     0,     0,   338,   339,
     5,   340,     0,   341,   342,   196,   343,     0,     0,   344,
     0,     0,     0,     0,     0,    80,     0,     0,    81,    20,
     0,   331,     0,     0,     0,     0,   345,   268,   157,   746,
     0,     0,   346,   268,     0,   202,   203,   204,   205,     0,
     0,   206,   207,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,   269,     0,     0,
     0,     0,     0,   269,   332,   192,   193,   716,   333,   334,
    78,   335,     0,     0,   336,     0,     0,     0,   337,   194,
     0,     0,   717,     0,     0,   338,   339,     5,   340,     0,
   341,   342,   196,   343,     0,   574,   344,   190,   191,     0,
     0,     0,    80,     0,     0,    81,    20,     0,     0,     0,
     0,     0,     0,   345,     0,   157,   760,     0,     0,   346,
     0,     0,   202,   203,   204,   205,     0,     0,   206,   207,
     0,     0,     0,     0,     0,     0,     0,     0,     0,   192,
   193,     0,     0,     0,    78,     0,     0,     0,     0,     0,
     0,     0,     0,   194,     0,     0,     0,     0,     0,   195,
     0,     0,     0,     0,     0,     0,   196,   331,     0,     0,
   197,     0,     0,     0,     0,     0,    80,   268,   268,    81,
    20,     0,     0,   198,   199,     0,     0,   200,     0,   201,
   575,     0,     0,   268,     0,     0,   202,   203,   204,   205,
     0,     0,   206,   207,     0,     0,     0,   269,   269,     0,
   332,   192,   193,  -261,   333,   334,    78,   335,     0,     0,
   336,     0,     0,   269,   337,   194,     0,     0,  -261,     0,
     0,   338,   339,     5,   340,   331,   341,   342,   196,   343,
     0,     0,   344,     0,     0,     0,     0,     0,    80,     0,
     0,    81,    20,     0,     0,     0,     0,     0,     0,   345,
     0,   157,  -261,     0,     0,   346,     0,     0,   202,   203,
   204,   205,     0,     0,   206,   207,     0,     0,   332,   192,
   193,     0,   333,   334,    78,   335,     0,     0,   336,     0,
     0,     0,   337,   194,     0,     0,     0,     0,     0,   338,
   339,     5,   340,   331,   341,   342,   196,   343,     0,     0,
   344,     0,     0,     0,     0,     0,    80,     0,     0,    81,
    20,     0,     0,     0,     0,     0,     0,   345,     0,   157,
   526,     0,     0,   346,     0,     0,   202,   203,   204,   205,
     0,     0,   206,   207,     0,     0,   332,   192,   193,     0,
   333,   334,    78,   335,     0,     0,   336,     0,     0,     0,
   337,   194,     0,     0,     0,     0,     0,   338,   339,     5,
   340,   331,   341,   342,   196,   343,     0,     0,   344,     0,
     0,     0,     0,     0,    80,     0,     0,    81,    20,     0,
     0,     0,     0,     0,     0,   345,     0,   157,   547,     0,
     0,   346,     0,     0,   202,   203,   204,   205,     0,     0,
   206,   207,     0,     0,   332,   192,   193,     0,   333,   334,
    78,   335,     0,     0,   336,     0,     0,     0,   337,   194,
     0,     0,     0,     0,     0,   338,   339,     5,   340,   331,
   341,   342,   196,   343,     0,     0,   344,     0,     0,     0,
     0,     0,    80,     0,     0,    81,    20,     0,     0,     0,
     0,     0,     0,   345,     0,   157,   624,     0,     0,   346,
     0,     0,   202,   203,   204,   205,     0,     0,   206,   207,
     0,     0,   332,   192,   193,     0,   333,   334,    78,   335,
     0,     0,   336,     0,     0,     0,   337,   194,     0,     0,
     0,     0,     0,   338,   339,     5,   340,   331,   341,   342,
   196,   343,     0,     0,   344,     0,     0,     0,     0,     0,
    80,     0,     0,    81,    20,     0,     0,     0,     0,     0,
     0,   345,     0,   157,   627,     0,     0,   346,     0,     0,
   202,   203,   204,   205,     0,     0,   206,   207,     0,     0,
   332,   192,   193,     0,   333,   334,    78,   335,     0,     0,
   336,     0,     0,     0,   337,   194,     0,     0,     0,     0,
     0,   338,   339,     5,   340,   331,   341,   342,   196,   343,
     0,     0,   344,     0,     0,     0,     0,     0,    80,     0,
     0,    81,    20,     0,     0,     0,     0,     0,     0,   345,
     0,   157,   675,     0,     0,   346,     0,     0,   202,   203,
   204,   205,     0,     0,   206,   207,     0,     0,   332,   192,
   193,     0,   333,   334,    78,   335,     0,     0,   336,     0,
     0,     0,   337,   194,     0,     0,     0,     0,     0,   338,
   339,     5,   340,   331,   341,   342,   196,   343,     0,     0,
   344,     0,     0,     0,     0,     0,    80,     0,     0,    81,
    20,     0,     0,     0,     0,     0,     0,   345,     0,   157,
     0,     0,     0,   346,     0,     0,   202,   203,   204,   205,
     0,     0,   206,   207,     0,     0,   529,   192,   193,     0,
   333,   334,    78,   335,     0,     0,   336,     0,     0,     0,
   337,   194,     0,     0,     0,     0,     0,   338,   339,   331,
   340,     0,   341,   342,   196,   343,     0,     0,   344,     0,
     0,     0,     0,     0,    80,     0,     0,    81,    20,     0,
     0,     0,     0,     0,     0,   345,     0,   157,     0,     0,
     0,   346,     0,     0,   202,   203,   204,   205,     0,     0,
   206,   207,   529,   192,   193,     0,   682,   334,    78,   335,
     0,     0,   336,     0,     0,     0,   337,   194,     0,     0,
     0,     0,     0,   338,   339,     0,   340,     0,   341,   342,
   196,   343,     0,   189,   344,   190,   191,     0,     0,     0,
    80,     0,     0,    81,    20,     0,     0,     0,     0,     0,
     0,   345,     0,   157,     0,     0,     0,   346,     0,     0,
   202,   203,   204,   205,     0,     0,   206,   207,     0,     0,
     0,     0,     0,     0,     0,     0,     0,   192,   193,     0,
     0,     0,    78,     0,   489,     0,   190,   191,     0,     0,
     0,   194,     0,     0,     0,     0,     0,   195,     0,     0,
     0,     0,     0,     0,   196,     0,     0,     0,   197,     0,
     0,     0,     0,     0,    80,     0,     0,    81,    20,     0,
     0,   198,   199,     0,     0,   200,     0,   201,   192,   193,
     0,     0,     0,    78,   202,   203,   204,   205,     0,     0,
   206,   207,   194,     0,     0,     0,     0,     0,   195,   504,
     0,   190,   191,     0,     0,   196,     0,     0,     0,   197,
     0,     0,     0,     0,     0,    80,     0,     0,    81,    20,
     0,   490,   198,   199,     0,     0,   200,     0,     0,     0,
     0,     0,     0,     0,     0,   202,   203,   204,   205,     0,
     0,   206,   207,   192,   193,     0,     0,     0,    78,     0,
   556,     0,   190,   191,     0,     0,     0,   194,     0,     0,
     0,     0,     0,   195,     0,     0,     0,     0,     0,     0,
   196,     0,     0,     0,   197,     0,     0,     0,     0,     0,
    80,     0,     0,    81,    20,     0,     0,   198,   199,     0,
     0,   200,     0,     0,   192,   193,     0,   505,     0,    78,
   202,   203,   204,   205,     0,     0,   206,   207,   194,     0,
     0,     0,     0,     0,   195,   565,     0,   190,   191,     0,
     0,   196,     0,     0,     0,   197,     0,     0,     0,     0,
     0,    80,     0,     0,    81,    20,     0,     0,   198,   199,
     0,     0,   200,     0,     0,     0,     0,   557,     0,     0,
     0,   202,   203,   204,   205,     0,     0,   206,   207,   192,
   193,     0,     0,     0,    78,     0,   436,     0,   190,   191,
     0,     0,     0,   194,     0,     0,     0,     0,     0,   195,
     0,     0,     0,     0,     0,     0,   196,     0,     0,     0,
   197,     0,     0,     0,     0,     0,    80,     0,     0,    81,
    20,     0,     0,   198,   199,     0,     0,   200,   566,     0,
   192,   193,     0,     0,     0,    78,   202,   203,   204,   205,
     0,     0,   206,   207,   194,     0,     0,     0,     0,     0,
   195,   436,     0,   190,   191,     0,     0,   196,     0,     0,
     0,   197,     0,     0,     0,     0,     0,    80,     0,     0,
    81,    20,     0,     0,   198,   199,     0,     0,   200,     0,
     0,     0,     0,   557,     0,     0,     0,   202,   203,   204,
   205,     0,     0,   206,   207,   192,   193,     0,     0,     0,
    78,     0,   611,     0,   190,   191,     0,     0,     0,   194,
     0,     0,     0,     0,     0,   195,     0,     0,     0,     0,
     0,     0,   196,     0,     0,     0,   197,     0,     0,     0,
     0,     0,    80,     0,     0,    81,    20,     0,     0,   198,
   199,     0,     0,   200,     0,     0,   192,   193,   148,     0,
     0,    78,   202,   203,   204,   205,     0,     0,   206,   207,
   194,     0,     0,     0,     0,     0,   195,   617,     0,   190,
   191,     0,     0,   196,     0,     0,     0,   197,     0,     0,
     0,     0,     0,    80,     0,     0,    81,    20,     0,     0,
   198,   199,     0,     0,   200,   612,     0,     0,     0,     0,
     0,     0,     0,   202,   203,   204,   205,     0,     0,   206,
   207,   192,   193,     0,     0,     0,    78,     0,   611,     0,
   190,   191,     0,     0,     0,   194,     0,     0,     0,     0,
     0,   195,     0,     0,     0,     0,     0,     0,   196,     0,
     0,     0,   197,     0,     0,     0,     0,     0,    80,     0,
     0,    81,    20,     0,     0,   198,   199,     0,     0,   200,
     0,     0,   192,   193,     0,   618,     0,    78,   202,   203,
   204,   205,     0,     0,   206,   207,   194,     0,     0,     0,
     0,     0,   195,   698,     0,   190,   191,     0,     0,   196,
     0,     0,     0,   197,     0,     0,     0,     0,     0,    80,
     0,     0,    81,    20,     0,     0,   198,   199,     0,     0,
   200,   676,     0,     0,     0,     0,     0,     0,     0,   202,
   203,   204,   205,     0,     0,   206,   207,   192,   193,     0,
     0,     0,    78,     0,   698,     0,   190,   191,     0,     0,
     0,   194,     0,     0,     0,     0,     0,   195,     0,     0,
     0,     0,     0,     0,   196,     0,     0,     0,   197,     0,
     0,     0,     0,     0,    80,     0,     0,    81,    20,     0,
     0,   198,   199,     0,     0,   200,   699,     0,   192,   193,
     0,     0,     0,    78,   202,   203,   204,   205,     0,     0,
   206,   207,   194,     0,     0,     0,     0,     0,   195,   617,
     0,   190,   191,     0,     0,   196,     0,     0,     0,   197,
     0,     0,     0,     0,     0,    80,     0,     0,    81,    20,
     0,     0,   198,   199,     0,     0,   200,   731,     0,     0,
     0,     0,     0,     0,     0,   202,   203,   204,   205,     0,
     0,   206,   207,   192,   193,     0,     0,     0,    78,     0,
   266,     0,   190,   191,     0,     0,     0,   194,     0,     0,
     0,     0,     0,   195,     0,     0,     0,     0,     0,     0,
   196,     0,     0,     0,   197,     0,     0,     0,     0,     0,
    80,     0,     0,    81,    20,     0,     0,   198,   199,     0,
     0,   200,     0,     0,   192,   193,     0,   736,     0,    78,
   202,   203,   204,   205,     0,     0,   206,   207,   194,     0,
     0,     0,     0,     0,   195,   271,     0,   190,   191,     0,
     0,   196,     0,     0,     0,   197,     0,     0,     0,     0,
     0,    80,     0,     0,    81,    20,     0,     0,   198,   199,
     0,     0,   200,     0,     0,     0,     0,     0,     0,     0,
     0,   202,   203,   204,   205,     0,     0,   206,   207,   192,
   193,     0,     0,     0,    78,     0,   273,     0,   190,   191,
     0,     0,     0,   194,     0,     0,     0,     0,     0,   195,
     0,     0,     0,     0,     0,     0,   196,     0,     0,     0,
   197,     0,     0,     0,     0,     0,    80,     0,     0,    81,
    20,     0,     0,   198,   199,     0,     0,   200,     0,     0,
   192,   193,     0,     0,     0,    78,   202,   203,   204,   205,
     0,     0,   206,   207,   194,     0,     0,     0,     0,     0,
   195,   275,     0,   190,   191,     0,     0,   196,     0,     0,
     0,   197,     0,     0,     0,     0,     0,    80,     0,     0,
    81,    20,     0,     0,   198,   199,     0,     0,   200,     0,
     0,     0,     0,     0,     0,     0,     0,   202,   203,   204,
   205,     0,     0,   206,   207,   192,   193,     0,     0,     0,
    78,     0,   284,     0,   190,   191,     0,     0,     0,   194,
     0,     0,     0,     0,     0,   195,     0,     0,     0,     0,
     0,     0,   196,     0,     0,     0,   197,     0,     0,     0,
     0,     0,    80,     0,     0,    81,    20,     0,     0,   198,
   199,     0,     0,   200,     0,     0,   192,   193,     0,     0,
     0,    78,   202,   203,   204,   205,     0,     0,   206,   207,
   194,     0,     0,     0,     0,     0,   195,   286,     0,   190,
   191,     0,     0,   196,     0,     0,     0,   197,     0,     0,
     0,     0,     0,    80,     0,     0,    81,    20,     0,     0,
   198,   199,     0,     0,   200,     0,     0,     0,     0,     0,
     0,     0,     0,   202,   203,   204,   205,     0,     0,   206,
   207,   192,   193,     0,     0,     0,    78,     0,   288,     0,
   190,   191,     0,     0,     0,   194,     0,     0,     0,     0,
     0,   195,     0,     0,     0,     0,     0,     0,   196,     0,
     0,     0,   197,     0,     0,     0,     0,     0,    80,     0,
     0,    81,    20,     0,     0,   198,   199,     0,     0,   200,
     0,     0,   192,   193,     0,     0,     0,    78,   202,   203,
   204,   205,     0,     0,   206,   207,   194,     0,     0,     0,
     0,     0,   195,   436,     0,   190,   191,     0,     0,   196,
     0,     0,     0,   197,     0,     0,     0,     0,     0,    80,
     0,     0,    81,    20,     0,     0,   198,   199,     0,     0,
   200,     0,     0,     0,     0,     0,     0,     0,     0,   202,
   203,   204,   205,     0,     0,   206,   207,   192,   193,     0,
     0,     0,    78,     0,   444,     0,   190,   191,     0,     0,
     0,   194,     0,     0,     0,     0,     0,   195,     0,     0,
     0,     0,     0,     0,   196,     0,     0,     0,   197,     0,
     0,     0,     0,     0,    80,     0,     0,    81,    20,     0,
     0,   198,   199,     0,     0,   200,     0,     0,   192,   193,
     0,     0,     0,    78,   202,   203,   204,   205,     0,     0,
   206,   207,   194,     0,     0,     0,     0,     0,   195,   448,
     0,   190,   191,     0,     0,   196,     0,     0,     0,   197,
     0,     0,     0,     0,     0,    80,     0,     0,    81,    20,
     0,     0,   198,   199,     0,     0,   200,     0,     0,     0,
     0,     0,     0,     0,     0,   202,   203,   204,   205,     0,
     0,   206,   207,   192,   193,     0,     0,     0,    78,     0,
   450,     0,   190,   191,     0,     0,     0,   194,     0,     0,
     0,     0,     0,   195,     0,     0,     0,     0,     0,     0,
   196,     0,     0,     0,   197,     0,     0,     0,     0,     0,
    80,     0,     0,    81,    20,     0,     0,   198,   199,     0,
     0,   200,     0,     0,   192,   193,     0,     0,     0,    78,
   202,   203,   204,   205,     0,     0,   206,   207,   194,     0,
     0,     0,     0,     0,   195,   452,     0,   190,   191,     0,
     0,   196,     0,     0,     0,   197,     0,     0,     0,     0,
     0,    80,     0,     0,    81,    20,     0,     0,   198,   199,
     0,     0,   200,     0,     0,     0,     0,     0,     0,     0,
     0,   202,   203,   204,   205,     0,     0,   206,   207,   192,
   193,     0,     0,     0,    78,     0,   454,     0,   190,   191,
     0,     0,     0,   194,     0,     0,     0,     0,     0,   195,
     0,     0,     0,     0,     0,     0,   196,     0,     0,     0,
   197,     0,     0,     0,     0,     0,    80,     0,     0,    81,
    20,     0,     0,   198,   199,     0,     0,   200,     0,     0,
   192,   193,     0,     0,     0,    78,   202,   203,   204,   205,
     0,     0,   206,   207,   194,     0,     0,     0,     0,     0,
   195,   456,     0,   190,   191,     0,     0,   196,     0,     0,
     0,   197,     0,     0,     0,     0,     0,    80,     0,     0,
    81,    20,     0,     0,   198,   199,     0,     0,   200,     0,
     0,     0,     0,     0,     0,     0,     0,   202,   203,   204,
   205,     0,     0,   206,   207,   192,   193,     0,     0,     0,
    78,     0,   458,     0,   190,   191,     0,     0,     0,   194,
     0,     0,     0,     0,     0,   195,     0,     0,     0,     0,
     0,     0,   196,     0,     0,     0,   197,     0,     0,     0,
     0,     0,    80,     0,     0,    81,    20,     0,     0,   198,
   199,     0,     0,   200,     0,     0,   192,   193,     0,     0,
     0,    78,   202,   203,   204,   205,     0,     0,   206,   207,
   194,     0,     0,     0,     0,     0,   195,   460,     0,   190,
   191,     0,     0,   196,     0,     0,     0,   197,     0,     0,
     0,     0,     0,    80,     0,     0,    81,    20,     0,     0,
   198,   199,     0,     0,   200,     0,     0,     0,     0,     0,
     0,     0,     0,   202,   203,   204,   205,     0,     0,   206,
   207,   192,   193,     0,     0,     0,    78,     0,   462,     0,
   190,   191,     0,     0,     0,   194,     0,     0,     0,     0,
     0,   195,     0,     0,     0,     0,     0,     0,   196,     0,
     0,     0,   197,     0,     0,     0,     0,     0,    80,     0,
     0,    81,    20,     0,     0,   198,   199,     0,     0,   200,
     0,     0,   192,   193,     0,     0,     0,    78,   202,   203,
   204,   205,     0,     0,   206,   207,   194,     0,     0,     0,
     0,     0,   195,   464,     0,   190,   191,     0,     0,   196,
     0,     0,     0,   197,     0,     0,     0,     0,     0,    80,
     0,     0,    81,    20,     0,     0,   198,   199,     0,     0,
   200,     0,     0,     0,     0,     0,     0,     0,     0,   202,
   203,   204,   205,     0,     0,   206,   207,   192,   193,     0,
     0,     0,    78,     0,   466,     0,   190,   191,     0,     0,
     0,   194,     0,     0,     0,     0,     0,   195,     0,     0,
     0,     0,     0,     0,   196,     0,     0,     0,   197,     0,
     0,     0,     0,     0,    80,     0,     0,    81,    20,     0,
     0,   198,   199,     0,     0,   200,     0,     0,   192,   193,
     0,     0,     0,    78,   202,   203,   204,   205,     0,     0,
   206,   207,   194,     0,     0,     0,     0,     0,   195,   468,
     0,   190,   191,     0,     0,   196,     0,     0,     0,   197,
     0,     0,     0,     0,     0,    80,     0,     0,    81,    20,
     0,     0,   198,   199,     0,     0,   200,     0,     0,     0,
     0,     0,     0,     0,     0,   202,   203,   204,   205,     0,
     0,   206,   207,   192,   193,     0,     0,     0,    78,     0,
   470,     0,   190,   191,     0,     0,     0,   194,     0,     0,
     0,     0,     0,   195,     0,     0,     0,     0,     0,     0,
   196,     0,     0,     0,   197,     0,     0,     0,     0,     0,
    80,     0,     0,    81,    20,     0,     0,   198,   199,     0,
     0,   200,     0,     0,   192,   193,     0,     0,     0,    78,
   202,   203,   204,   205,     0,     0,   206,   207,   194,     0,
     0,     0,     0,     0,   195,   475,     0,   190,   191,     0,
     0,   196,     0,     0,     0,   197,     0,     0,     0,     0,
     0,    80,     0,     0,    81,    20,     0,     0,   198,   199,
     0,     0,   200,     0,     0,     0,     0,     0,     0,     0,
     0,   202,   203,   204,   205,     0,     0,   206,   207,   192,
   193,     0,     0,     0,    78,     0,   477,     0,   190,   191,
     0,     0,     0,   194,     0,     0,     0,     0,     0,   195,
     0,     0,     0,     0,     0,     0,   196,     0,     0,     0,
   197,     0,     0,     0,     0,     0,    80,     0,     0,    81,
    20,     0,     0,   198,   199,     0,     0,   200,     0,     0,
   192,   193,     0,     0,     0,    78,   202,   203,   204,   205,
     0,     0,   206,   207,   194,     0,     0,     0,     0,     0,
   195,   479,     0,   190,   191,     0,     0,   196,     0,     0,
     0,   197,     0,     0,     0,     0,     0,    80,     0,     0,
    81,    20,     0,     0,   198,   199,     0,     0,   200,     0,
     0,     0,     0,     0,     0,     0,     0,   202,   203,   204,
   205,     0,     0,   206,   207,   192,   193,     0,     0,     0,
    78,     0,   481,     0,   190,   191,     0,     0,     0,   194,
     0,     0,     0,     0,     0,   195,     0,     0,     0,     0,
     0,     0,   196,     0,     0,     0,   197,     0,     0,     0,
     0,     0,    80,     0,     0,    81,    20,     0,     0,   198,
   199,     0,     0,   200,     0,     0,   192,   193,     0,     0,
     0,    78,   202,   203,   204,   205,     0,     0,   206,   207,
   194,     0,     0,     0,     0,     0,   195,   483,     0,   190,
   191,     0,     0,   196,     0,     0,     0,   197,     0,     0,
     0,     0,     0,    80,     0,     0,    81,    20,     0,     0,
   198,   199,     0,     0,   200,     0,     0,     0,     0,     0,
     0,     0,     0,   202,   203,   204,   205,     0,     0,   206,
   207,   192,   193,     0,     0,     0,    78,     0,   485,     0,
   190,   191,     0,     0,     0,   194,     0,     0,     0,     0,
     0,   195,     0,     0,     0,     0,     0,     0,   196,     0,
     0,     0,   197,     0,     0,     0,     0,     0,    80,     0,
     0,    81,    20,     0,     0,   198,   199,     0,     0,   200,
     0,     0,   192,   193,     0,     0,     0,    78,   202,   203,
   204,   205,     0,     0,   206,   207,   194,     0,     0,     0,
     0,     0,   195,   487,     0,   190,   191,     0,     0,   196,
     0,     0,     0,   197,     0,     0,     0,     0,     0,    80,
     0,     0,    81,    20,     0,     0,   198,   199,     0,     0,
   200,     0,     0,     0,     0,     0,     0,     0,     0,   202,
   203,   204,   205,     0,     0,   206,   207,   192,   193,     0,
     0,     0,    78,     0,   492,     0,   190,   191,     0,     0,
     0,   194,     0,     0,     0,     0,     0,   195,     0,     0,
     0,     0,     0,     0,   196,     0,     0,     0,   197,     0,
     0,     0,     0,     0,    80,     0,     0,    81,    20,     0,
     0,   198,   199,     0,     0,   200,     0,     0,   192,   193,
     0,     0,     0,    78,   202,   203,   204,   205,     0,     0,
   206,   207,   194,     0,     0,     0,     0,     0,   195,   499,
     0,   190,   191,     0,     0,   196,     0,     0,     0,   197,
     0,     0,     0,     0,     0,    80,     0,     0,    81,    20,
     0,     0,   198,   199,     0,     0,   200,     0,     0,     0,
     0,     0,     0,     0,     0,   202,   203,   204,   205,     0,
     0,   206,   207,   192,   193,     0,     0,     0,    78,     0,
   568,     0,   190,   191,     0,     0,     0,   194,     0,     0,
     0,     0,     0,   195,     0,     0,     0,     0,     0,     0,
   196,     0,     0,     0,   197,     0,     0,     0,     0,     0,
    80,     0,     0,    81,    20,     0,     0,   198,   199,     0,
     0,   200,     0,     0,   192,   193,     0,     0,     0,    78,
   202,   203,   204,   205,     0,     0,   206,   207,   194,     0,
     0,     0,     0,     0,   195,   588,     0,   190,   191,     0,
     0,   196,     0,     0,     0,   197,     0,     0,     0,     0,
     0,    80,     0,     0,    81,    20,     0,     0,   198,   199,
     0,     0,   200,     0,     0,     0,     0,     0,     0,     0,
     0,   202,   203,   204,   205,     0,     0,   206,   207,   192,
   193,     0,     0,     0,    78,     0,   596,     0,   190,   191,
     0,     0,     0,   194,     0,     0,     0,     0,     0,   195,
     0,     0,     0,     0,     0,     0,   196,     0,     0,     0,
   197,     0,     0,     0,     0,     0,    80,     0,     0,    81,
    20,     0,     0,   198,   199,     0,     0,   200,     0,     0,
   192,   193,     0,     0,     0,    78,   202,   203,   204,   205,
     0,     0,   206,   207,   194,     0,     0,     0,     0,     0,
   195,   598,     0,   190,   191,     0,     0,   196,     0,     0,
     0,   197,     0,     0,     0,     0,     0,    80,     0,     0,
    81,    20,     0,     0,   198,   199,     0,     0,   200,     0,
     0,     0,     0,     0,     0,     0,     0,   202,   203,   204,
   205,     0,     0,   206,   207,   192,   193,     0,     0,     0,
    78,     0,   620,     0,   190,   191,     0,     0,     0,   194,
     0,     0,     0,     0,     0,   195,     0,     0,     0,     0,
     0,     0,   196,     0,     0,     0,   197,     0,     0,     0,
     0,     0,    80,     0,     0,    81,    20,     0,     0,   198,
   199,     0,     0,   200,     0,     0,   192,   193,     0,     0,
     0,    78,   202,   203,   204,   205,     0,     0,   206,   207,
   194,     0,     0,     0,     0,     0,   195,   637,     0,   190,
   191,     0,     0,   196,     0,     0,     0,   197,     0,     0,
     0,     0,     0,    80,     0,     0,    81,    20,     0,     0,
   198,   199,     0,     0,   200,     0,     0,     0,     0,     0,
     0,     0,     0,   202,   203,   204,   205,     0,     0,   206,
   207,   192,   193,     0,     0,     0,    78,     0,   641,     0,
   190,   191,     0,     0,     0,   194,     0,     0,     0,     0,
     0,   195,     0,     0,     0,     0,     0,     0,   196,     0,
     0,     0,   197,     0,     0,     0,     0,     0,    80,     0,
     0,    81,    20,     0,     0,   198,   199,     0,     0,   200,
     0,     0,   192,   193,     0,     0,     0,    78,   202,   203,
   204,   205,     0,     0,   206,   207,   194,     0,     0,     0,
     0,     0,   195,   647,     0,   190,   191,     0,     0,   196,
     0,     0,     0,   197,     0,     0,     0,     0,     0,    80,
     0,     0,    81,    20,     0,     0,   198,   199,     0,     0,
   200,     0,     0,     0,     0,     0,     0,     0,     0,   202,
   203,   204,   205,     0,     0,   206,   207,   192,   193,     0,
     0,     0,    78,     0,   740,     0,   190,   191,     0,     0,
     0,   194,     0,     0,     0,     0,     0,   195,     0,     0,
     0,     0,     0,     0,   196,     0,     0,     0,   197,     0,
     0,     0,     0,     0,    80,     0,     0,    81,    20,     0,
     0,   198,   199,     0,     0,   200,     0,     0,   192,   193,
     0,     0,     0,    78,   202,   203,   204,   205,     0,     0,
   206,   207,   194,     0,     0,     0,     0,     0,   195,     0,
   605,     0,     0,     0,     0,   196,     0,     0,     0,   197,
     0,     0,     0,     0,     0,    80,     0,     0,    81,    20,
     0,     0,   198,   199,     0,   668,   200,     0,     0,     0,
     0,     0,     0,     0,     0,   202,   203,   204,   205,     0,
     0,   206,   207,  -284,  -284,  -284,     0,     0,     0,  -284,
     0,     0,     0,     0,     0,     0,     0,     0,  -284,     0,
     0,     0,     0,     0,  -284,     0,     0,   704,     0,   192,
   193,  -284,     0,     0,    78,  -284,     0,     0,     0,     0,
     0,  -284,     0,   194,  -284,  -284,     0,     0,     0,   195,
     0,     0,  -284,     0,   190,   191,   196,     0,  -284,     0,
   197,  -284,  -284,  -284,  -284,     0,    80,  -284,  -284,    81,
    20,   192,   193,     0,     0,     0,    78,   345,  -292,     0,
     0,     0,     0,     0,     0,   194,   202,   203,   204,   205,
     0,   195,   206,   207,   666,     0,   192,   193,   196,     0,
     0,    78,   197,     0,     0,     0,     0,     0,    80,     0,
   194,    81,    20,     0,     0,     0,   195,     0,     0,   345,
  -292,   190,   191,   196,     0,     0,     0,   197,   202,   203,
   204,   205,     0,    80,   206,   207,    81,    20,   192,   193,
   198,   199,     0,    78,   200,     0,   201,   292,     0,     0,
     0,   293,   194,   202,   203,   204,   205,     0,   195,   206,
   207,     0,     0,   192,   193,   196,     0,     0,    78,   197,
     0,     0,   190,   191,     0,    80,     0,   194,    81,    20,
     0,     0,     0,   195,     0,     0,   345,     0,     0,     0,
   196,     0,     0,     0,   197,   202,   203,   204,   205,     0,
    80,   206,   207,    81,    20,     0,     0,   198,   199,     0,
     0,   200,   433,     0,   192,   193,     0,     0,     0,    78,
   202,   203,   204,   205,     0,     0,   206,   207,   194,     0,
     0,     0,     0,     0,   195,     0,     0,   190,   191,     0,
     0,   196,     0,     0,     0,   197,     0,     0,     0,     0,
     0,    80,     0,     0,    81,    20,     0,     0,   198,   199,
     0,     0,   200,   584,     0,     0,     0,     0,     0,     0,
     0,   202,   203,   204,   205,     0,     0,   206,   207,   192,
   193,     0,     0,     0,    78,     0,     0,     0,   190,   191,
     0,     0,     0,   194,     0,     0,     0,     0,     0,   195,
     0,     0,     0,     0,     0,     0,   196,     0,     0,     0,
   197,     0,     0,     0,     0,     0,    80,     0,     0,    81,
    20,     0,     0,   198,   199,     0,     0,   200,   628,     0,
   192,   193,     0,     0,     0,    78,   202,   203,   204,   205,
     0,     0,   206,   207,   194,     0,     0,     0,     0,     0,
   195,     0,     0,   190,   191,     0,     0,   196,     0,     0,
     0,   197,     0,     0,     0,     0,     0,    80,     0,     0,
    81,    20,     0,     0,   198,   199,     0,     0,   200,   643,
     0,     0,     0,     0,     0,     0,     0,   202,   203,   204,
   205,     0,     0,   206,   207,   192,   193,     0,     0,     0,
    78,     0,     0,     0,     0,     0,     0,     0,     0,   194,
     0,     0,     0,     0,     0,   195,     0,     0,     0,     0,
     0,     0,   196,     0,     0,     0,   197,     0,     0,     0,
     0,     0,    80,     0,     0,    81,    20,     0,     0,   198,
   199,     0,     0,   200,     0,     2,   192,   193,     0,     0,
     0,    78,   202,   203,   204,   205,     0,     0,   206,   207,
   194,     0,     0,     0,     0,     0,   195,     0,     0,     0,
     0,     0,     0,   196,     0,     0,     0,   197,     0,     0,
     0,     0,     0,    80,     0,     0,    81,    20,     0,     0,
     0,     0,     0,     0,   345,     0,     0,     0,     0,     0,
     0,     0,     0,   202,   203,   204,   205,     0,     0,   206,
   207
};

static const short yycheck[] = {     3,
   132,   123,     6,    62,   264,   201,     0,   427,   129,     1,
     1,     1,   282,     1,   355,     9,    10,    11,     1,   289,
   290,     1,     0,    99,   100,     1,     1,    62,     1,   251,
    89,     9,    10,    11,   134,    94,    30,   374,    42,    33,
    34,   162,    46,   117,    86,    42,     1,     1,   169,    46,
   420,    53,    30,   100,   721,    33,    34,    51,    62,    94,
    64,     1,   362,    94,   101,    69,    97,    64,    62,   369,
   129,   371,    69,    51,   133,    62,   150,   447,   745,   153,
    63,    95,     4,     5,    62,    89,     1,     1,   140,    97,
    94,    67,     1,   101,   129,    97,   196,   171,    97,     1,
    94,   160,    89,   162,     1,    93,    98,    94,    99,    99,
   101,   101,    95,   101,    36,    37,    94,     1,    40,   178,
    95,   101,     1,   650,   128,   129,    99,   162,    50,   133,
   134,   128,     1,    52,     1,   129,   257,   134,     1,   133,
    95,    95,   129,     1,   414,    99,   133,   417,   200,   201,
     1,   129,   572,     1,    94,   525,   160,    79,   162,   686,
   100,    83,   689,     0,     1,   265,     1,     1,   162,   190,
   191,   192,   193,   160,   178,   162,   398,   198,   199,   253,
     1,    95,     1,    98,   162,   555,   190,   191,   192,   193,
    99,   178,   196,   252,   198,   199,   200,    99,   100,   196,
   122,   123,    99,   100,     1,   264,     1,    44,     1,   196,
   551,   581,     1,   200,    98,    94,    94,   139,    55,   251,
   341,   100,    95,   101,    61,   347,    99,    94,   755,    98,
    67,    94,     1,   100,   430,     1,   763,   100,   765,     1,
   767,    99,     1,    94,     1,     1,   298,   251,   252,   100,
   302,    99,     1,     1,    88,   177,   626,     1,   252,     1,
   264,   265,    99,    98,   251,   252,    97,    86,   265,     1,
   264,   100,    15,     1,     9,   327,     1,   264,    99,   616,
    99,   618,   334,    52,   625,   337,   307,   308,   309,    86,
     1,   661,   351,   345,   216,     1,    95,     1,    33,    88,
    95,    94,    99,   307,   308,   309,   310,   311,   312,   313,
   314,   315,   316,   317,   318,   319,   320,   321,   322,   323,
   324,   325,   326,   355,   650,     1,    95,   549,     1,   251,
   362,     1,   319,    99,   671,    94,    98,   369,   708,   371,
   262,    98,   374,    99,    87,    94,    94,   351,    52,   650,
   650,   355,     0,     1,    93,    99,    98,   279,   362,    63,
   686,   413,    94,   689,   351,   369,   398,   371,   355,   650,
   374,    99,   424,   671,    99,    98,     1,   299,   430,   301,
   374,     1,    93,   251,     1,   686,   686,   374,   689,   689,
    63,    95,    98,     1,   398,   655,    44,    67,     1,   736,
   421,    94,   524,   703,    97,   686,   747,    55,   689,   129,
    86,   398,   712,    61,   336,     1,     1,   421,     1,    67,
   757,   343,    95,   427,     1,   347,     1,    75,     1,   755,
   730,    95,    52,   355,   566,     0,     1,   763,   736,   765,
   362,   767,   162,    63,     0,     1,   498,   369,     1,   371,
     1,    99,   584,    96,   755,   755,   508,   100,   510,   757,
     1,    86,   763,   763,   765,   765,   767,   767,   520,     1,
     1,     1,    96,     1,   755,    95,   398,   536,     1,    44,
   601,     1,   763,    86,   765,    93,   767,   355,    44,   541,
    55,   543,    45,    46,   362,     1,    61,     1,    72,    55,
    95,   369,    67,   371,   636,    61,   374,    93,    93,    93,
    93,    67,    86,    86,   646,    92,    93,   549,    93,   551,
    97,    98,    99,   100,    53,     1,   578,     0,     1,   251,
   398,     1,   536,    86,    99,    88,   129,    44,    91,    92,
    93,   100,    93,    99,    97,   549,    50,   551,   101,   536,
   571,    92,   673,    94,    61,    86,    97,    98,    99,   100,
    67,    93,   549,    93,   551,    93,   101,   571,   572,   162,
    93,    44,    65,    93,    50,     0,     1,     1,    82,    72,
    86,    85,    86,   587,   616,     1,   618,    95,    61,    97,
     1,    83,     1,   625,    67,    92,   655,     0,     1,   521,
    97,    98,   524,   724,    95,    96,    82,   177,    99,    85,
    86,     0,     1,   665,   107,     1,    86,     1,   650,    44,
     1,   625,     1,     5,     6,     7,    99,   549,    44,   551,
   122,   123,   414,   355,    50,   417,    61,     1,   625,   671,
   362,    44,    67,   101,    94,     1,   650,   369,   101,   371,
   100,   655,   374,     1,   686,    44,    97,   689,    61,   711,
     1,   655,    86,   715,    67,   717,    82,     1,   655,    85,
    86,   703,    61,   251,    99,    86,   398,    86,    67,    11,
   712,   549,   686,   551,    65,   689,    67,    12,    67,   721,
     1,    72,   262,    72,     5,    76,    99,    76,   730,   703,
    86,   623,    86,   625,   736,    86,    13,    86,   712,    65,
    99,    67,     1,   745,    97,   747,    72,   721,   101,     1,
    76,     1,    86,   755,     1,   757,   730,    14,   650,     1,
    86,   763,    99,   765,   721,   767,   251,    64,    86,    97,
    60,   745,    69,   747,    64,    86,    45,    46,   616,    96,
   618,   755,    86,    99,   100,    45,    46,   625,   745,   763,
   747,   765,    95,   767,   686,    93,     1,   689,     9,    97,
    11,    93,    44,   101,    44,    86,    93,   355,    50,    47,
    50,   703,   650,    99,   362,    47,   686,    99,     1,   689,
   712,   369,    33,   371,    62,    99,   374,    86,    97,   721,
    62,   128,   101,   671,    86,   129,    86,    97,   730,    86,
    82,   101,    82,    85,    86,    85,    86,     1,   686,   251,
   398,   689,    94,   745,    94,   747,    99,   549,    96,   551,
    99,    44,    93,   755,    96,   703,   160,    50,   162,    94,
   355,   763,    97,   765,   712,   767,   101,   362,   315,   316,
   317,   318,    94,   721,   369,   755,   371,   251,   100,   374,
    91,    92,   730,   763,    93,   765,    50,   767,   736,    82,
    44,    88,    85,    86,    94,    59,    50,   745,    94,   747,
   100,    65,   100,   398,   100,    94,    66,   755,    72,   757,
    10,   100,    76,    67,   616,   763,   618,   765,    82,   767,
    99,    85,    86,   625,    93,    89,    90,    94,    82,    93,
    30,    85,    86,   100,    34,   416,     1,   418,   102,   103,
   104,   105,    97,   355,   108,   109,    91,    92,   650,    86,
   362,    51,    45,    46,    91,    92,    93,   369,    94,   371,
    97,     1,   374,    93,   101,   251,    44,     3,     4,   671,
    16,    17,    50,    99,    18,    19,    20,    21,    94,    44,
    94,   355,    91,    92,   686,    50,   398,   689,   362,    97,
    98,   549,     1,   551,    59,   369,    61,   371,    94,    44,
   374,   703,    67,   100,    82,    50,    56,    85,    86,    56,
   712,    45,    46,    57,    59,    99,    61,    82,    94,   721,
    85,    86,    67,    94,   398,    91,    92,    93,   730,    45,
    46,    97,   310,   311,   736,   101,     1,    82,   320,   321,
    85,    86,    94,   745,     1,   747,     8,     9,    10,    56,
    95,    96,    94,   755,   549,   757,   551,     0,   616,    94,
   618,   763,    99,   765,    44,   767,    99,   625,    94,   355,
    50,     0,    91,    92,    93,   319,   362,    11,    97,    59,
    54,    61,   101,   369,    44,   371,   139,    67,   374,    86,
    50,    75,   650,   162,    91,    92,    93,   160,   393,    59,
    97,    61,    82,   252,   101,    85,    86,    67,    97,    98,
    99,    52,   398,   671,   282,    95,    96,   398,    44,    94,
   374,   616,    82,   618,    50,    85,    86,   719,   686,   719,
   625,   689,   602,    59,   374,    61,    96,   549,   602,   551,
   322,    67,    86,   323,   325,   703,   324,    91,    92,    93,
   312,   313,   314,    97,   712,   650,    82,   101,   587,    85,
    86,   326,    -1,   721,   330,    -1,    -1,    -1,    -1,    -1,
    96,    -1,   730,    -1,    -1,   549,   671,   551,   736,    -1,
    91,    92,    93,    -1,    -1,    -1,    97,   745,    -1,   747,
   101,   686,    -1,    -1,   689,    -1,    -1,   755,    -1,   757,
    -1,    -1,    -1,    -1,   616,   763,   618,   765,   703,   767,
    -1,    -1,    -1,   625,    -1,    -1,    -1,   712,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,   721,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,   730,    -1,    -1,   650,    -1,
    -1,   736,   616,    -1,   618,    -1,    -1,    -1,    -1,    50,
   745,   625,   747,    -1,    -1,    -1,    -1,    -1,    59,   671,
   755,    -1,   757,   549,    65,   551,    -1,    -1,   763,    -1,
   765,    72,   767,    -1,   686,    76,   650,   689,    -1,    -1,
    -1,    82,    -1,    -1,    85,    86,    -1,    -1,    89,    90,
    -1,   703,    93,    -1,    -1,    -1,    -1,   671,    -1,    -1,
   712,   102,   103,   104,   105,    -1,    -1,   108,   109,   721,
    -1,    -1,   686,    -1,    -1,   689,    -1,    -1,   730,    -1,
    -1,    -1,    -1,    -1,   736,    -1,    -1,    -1,    -1,   703,
   616,    -1,   618,   745,    -1,   747,    -1,    -1,   712,   625,
    -1,    -1,    -1,   755,    -1,   757,    -1,   721,    -1,    -1,
    -1,   763,    -1,   765,    -1,   767,   730,    -1,    -1,    -1,
    -1,    -1,   736,    -1,   650,    -1,   190,   191,   192,   193,
    -1,   745,    -1,   747,   198,   199,    -1,    -1,    -1,    -1,
    -1,   755,    -1,   757,    -1,   671,    -1,    -1,    -1,   763,
    -1,   765,    -1,   767,    -1,    -1,   190,   191,   192,   193,
   686,    -1,    -1,   689,   198,   199,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,   703,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,   712,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,   721,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,   730,    -1,    -1,    -1,    -1,    -1,
   736,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   745,
    -1,   747,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   755,
    -1,   757,    -1,    -1,    -1,    -1,    -1,   763,    -1,   765,
    -1,   767,    -1,   307,   308,   309,   310,   311,   312,   313,
   314,   315,   316,   317,   318,    -1,   320,   321,   322,   323,
   324,   325,   326,    -1,     1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,   307,   308,   309,   310,   311,   312,   313,
   314,   315,   316,   317,   318,    -1,   320,   321,   322,   323,
   324,   325,   326,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    44,    45,    46,
    47,    48,    49,    50,    51,    -1,    -1,    54,    -1,    -1,
    -1,    58,    59,    -1,    -1,    62,    -1,    -1,    65,    66,
    67,    68,    -1,    70,    71,    72,    73,    -1,    -1,    76,
    -1,    -1,    -1,    -1,    -1,    82,    -1,    -1,    85,    86,
    -1,     1,    -1,    -1,    -1,    -1,    93,   421,    95,    96,
    -1,    -1,    99,   427,    -1,   102,   103,   104,   105,    -1,
    -1,   108,   109,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,   421,    -1,    -1,
    -1,    -1,    -1,   427,    44,    45,    46,    47,    48,    49,
    50,    51,    -1,    -1,    54,    -1,    -1,    -1,    58,    59,
    -1,    -1,    62,    -1,    -1,    65,    66,    67,    68,    -1,
    70,    71,    72,    73,    -1,     1,    76,     3,     4,    -1,
    -1,    -1,    82,    -1,    -1,    85,    86,    -1,    -1,    -1,
    -1,    -1,    -1,    93,    -1,    95,    96,    -1,    -1,    99,
    -1,    -1,   102,   103,   104,   105,    -1,    -1,   108,   109,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    45,
    46,    -1,    -1,    -1,    50,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    59,    -1,    -1,    -1,    -1,    -1,    65,
    -1,    -1,    -1,    -1,    -1,    -1,    72,     1,    -1,    -1,
    76,    -1,    -1,    -1,    -1,    -1,    82,   571,   572,    85,
    86,    -1,    -1,    89,    90,    -1,    -1,    93,    -1,    95,
    96,    -1,    -1,   587,    -1,    -1,   102,   103,   104,   105,
    -1,    -1,   108,   109,    -1,    -1,    -1,   571,   572,    -1,
    44,    45,    46,    47,    48,    49,    50,    51,    -1,    -1,
    54,    -1,    -1,   587,    58,    59,    -1,    -1,    62,    -1,
    -1,    65,    66,    67,    68,     1,    70,    71,    72,    73,
    -1,    -1,    76,    -1,    -1,    -1,    -1,    -1,    82,    -1,
    -1,    85,    86,    -1,    -1,    -1,    -1,    -1,    -1,    93,
    -1,    95,    96,    -1,    -1,    99,    -1,    -1,   102,   103,
   104,   105,    -1,    -1,   108,   109,    -1,    -1,    44,    45,
    46,    -1,    48,    49,    50,    51,    -1,    -1,    54,    -1,
    -1,    -1,    58,    59,    -1,    -1,    -1,    -1,    -1,    65,
    66,    67,    68,     1,    70,    71,    72,    73,    -1,    -1,
    76,    -1,    -1,    -1,    -1,    -1,    82,    -1,    -1,    85,
    86,    -1,    -1,    -1,    -1,    -1,    -1,    93,    -1,    95,
    96,    -1,    -1,    99,    -1,    -1,   102,   103,   104,   105,
    -1,    -1,   108,   109,    -1,    -1,    44,    45,    46,    -1,
    48,    49,    50,    51,    -1,    -1,    54,    -1,    -1,    -1,
    58,    59,    -1,    -1,    -1,    -1,    -1,    65,    66,    67,
    68,     1,    70,    71,    72,    73,    -1,    -1,    76,    -1,
    -1,    -1,    -1,    -1,    82,    -1,    -1,    85,    86,    -1,
    -1,    -1,    -1,    -1,    -1,    93,    -1,    95,    96,    -1,
    -1,    99,    -1,    -1,   102,   103,   104,   105,    -1,    -1,
   108,   109,    -1,    -1,    44,    45,    46,    -1,    48,    49,
    50,    51,    -1,    -1,    54,    -1,    -1,    -1,    58,    59,
    -1,    -1,    -1,    -1,    -1,    65,    66,    67,    68,     1,
    70,    71,    72,    73,    -1,    -1,    76,    -1,    -1,    -1,
    -1,    -1,    82,    -1,    -1,    85,    86,    -1,    -1,    -1,
    -1,    -1,    -1,    93,    -1,    95,    96,    -1,    -1,    99,
    -1,    -1,   102,   103,   104,   105,    -1,    -1,   108,   109,
    -1,    -1,    44,    45,    46,    -1,    48,    49,    50,    51,
    -1,    -1,    54,    -1,    -1,    -1,    58,    59,    -1,    -1,
    -1,    -1,    -1,    65,    66,    67,    68,     1,    70,    71,
    72,    73,    -1,    -1,    76,    -1,    -1,    -1,    -1,    -1,
    82,    -1,    -1,    85,    86,    -1,    -1,    -1,    -1,    -1,
    -1,    93,    -1,    95,    96,    -1,    -1,    99,    -1,    -1,
   102,   103,   104,   105,    -1,    -1,   108,   109,    -1,    -1,
    44,    45,    46,    -1,    48,    49,    50,    51,    -1,    -1,
    54,    -1,    -1,    -1,    58,    59,    -1,    -1,    -1,    -1,
    -1,    65,    66,    67,    68,     1,    70,    71,    72,    73,
    -1,    -1,    76,    -1,    -1,    -1,    -1,    -1,    82,    -1,
    -1,    85,    86,    -1,    -1,    -1,    -1,    -1,    -1,    93,
    -1,    95,    96,    -1,    -1,    99,    -1,    -1,   102,   103,
   104,   105,    -1,    -1,   108,   109,    -1,    -1,    44,    45,
    46,    -1,    48,    49,    50,    51,    -1,    -1,    54,    -1,
    -1,    -1,    58,    59,    -1,    -1,    -1,    -1,    -1,    65,
    66,    67,    68,     1,    70,    71,    72,    73,    -1,    -1,
    76,    -1,    -1,    -1,    -1,    -1,    82,    -1,    -1,    85,
    86,    -1,    -1,    -1,    -1,    -1,    -1,    93,    -1,    95,
    -1,    -1,    -1,    99,    -1,    -1,   102,   103,   104,   105,
    -1,    -1,   108,   109,    -1,    -1,    44,    45,    46,    -1,
    48,    49,    50,    51,    -1,    -1,    54,    -1,    -1,    -1,
    58,    59,    -1,    -1,    -1,    -1,    -1,    65,    66,     1,
    68,    -1,    70,    71,    72,    73,    -1,    -1,    76,    -1,
    -1,    -1,    -1,    -1,    82,    -1,    -1,    85,    86,    -1,
    -1,    -1,    -1,    -1,    -1,    93,    -1,    95,    -1,    -1,
    -1,    99,    -1,    -1,   102,   103,   104,   105,    -1,    -1,
   108,   109,    44,    45,    46,    -1,    48,    49,    50,    51,
    -1,    -1,    54,    -1,    -1,    -1,    58,    59,    -1,    -1,
    -1,    -1,    -1,    65,    66,    -1,    68,    -1,    70,    71,
    72,    73,    -1,     1,    76,     3,     4,    -1,    -1,    -1,
    82,    -1,    -1,    85,    86,    -1,    -1,    -1,    -1,    -1,
    -1,    93,    -1,    95,    -1,    -1,    -1,    99,    -1,    -1,
   102,   103,   104,   105,    -1,    -1,   108,   109,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    45,    46,    -1,
    -1,    -1,    50,    -1,     1,    -1,     3,     4,    -1,    -1,
    -1,    59,    -1,    -1,    -1,    -1,    -1,    65,    -1,    -1,
    -1,    -1,    -1,    -1,    72,    -1,    -1,    -1,    76,    -1,
    -1,    -1,    -1,    -1,    82,    -1,    -1,    85,    86,    -1,
    -1,    89,    90,    -1,    -1,    93,    -1,    95,    45,    46,
    -1,    -1,    -1,    50,   102,   103,   104,   105,    -1,    -1,
   108,   109,    59,    -1,    -1,    -1,    -1,    -1,    65,     1,
    -1,     3,     4,    -1,    -1,    72,    -1,    -1,    -1,    76,
    -1,    -1,    -1,    -1,    -1,    82,    -1,    -1,    85,    86,
    -1,    88,    89,    90,    -1,    -1,    93,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,   102,   103,   104,   105,    -1,
    -1,   108,   109,    45,    46,    -1,    -1,    -1,    50,    -1,
     1,    -1,     3,     4,    -1,    -1,    -1,    59,    -1,    -1,
    -1,    -1,    -1,    65,    -1,    -1,    -1,    -1,    -1,    -1,
    72,    -1,    -1,    -1,    76,    -1,    -1,    -1,    -1,    -1,
    82,    -1,    -1,    85,    86,    -1,    -1,    89,    90,    -1,
    -1,    93,    -1,    -1,    45,    46,    -1,    99,    -1,    50,
   102,   103,   104,   105,    -1,    -1,   108,   109,    59,    -1,
    -1,    -1,    -1,    -1,    65,     1,    -1,     3,     4,    -1,
    -1,    72,    -1,    -1,    -1,    76,    -1,    -1,    -1,    -1,
    -1,    82,    -1,    -1,    85,    86,    -1,    -1,    89,    90,
    -1,    -1,    93,    -1,    -1,    -1,    -1,    98,    -1,    -1,
    -1,   102,   103,   104,   105,    -1,    -1,   108,   109,    45,
    46,    -1,    -1,    -1,    50,    -1,     1,    -1,     3,     4,
    -1,    -1,    -1,    59,    -1,    -1,    -1,    -1,    -1,    65,
    -1,    -1,    -1,    -1,    -1,    -1,    72,    -1,    -1,    -1,
    76,    -1,    -1,    -1,    -1,    -1,    82,    -1,    -1,    85,
    86,    -1,    -1,    89,    90,    -1,    -1,    93,    94,    -1,
    45,    46,    -1,    -1,    -1,    50,   102,   103,   104,   105,
    -1,    -1,   108,   109,    59,    -1,    -1,    -1,    -1,    -1,
    65,     1,    -1,     3,     4,    -1,    -1,    72,    -1,    -1,
    -1,    76,    -1,    -1,    -1,    -1,    -1,    82,    -1,    -1,
    85,    86,    -1,    -1,    89,    90,    -1,    -1,    93,    -1,
    -1,    -1,    -1,    98,    -1,    -1,    -1,   102,   103,   104,
   105,    -1,    -1,   108,   109,    45,    46,    -1,    -1,    -1,
    50,    -1,     1,    -1,     3,     4,    -1,    -1,    -1,    59,
    -1,    -1,    -1,    -1,    -1,    65,    -1,    -1,    -1,    -1,
    -1,    -1,    72,    -1,    -1,    -1,    76,    -1,    -1,    -1,
    -1,    -1,    82,    -1,    -1,    85,    86,    -1,    -1,    89,
    90,    -1,    -1,    93,    -1,    -1,    45,    46,    98,    -1,
    -1,    50,   102,   103,   104,   105,    -1,    -1,   108,   109,
    59,    -1,    -1,    -1,    -1,    -1,    65,     1,    -1,     3,
     4,    -1,    -1,    72,    -1,    -1,    -1,    76,    -1,    -1,
    -1,    -1,    -1,    82,    -1,    -1,    85,    86,    -1,    -1,
    89,    90,    -1,    -1,    93,    94,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,   102,   103,   104,   105,    -1,    -1,   108,
   109,    45,    46,    -1,    -1,    -1,    50,    -1,     1,    -1,
     3,     4,    -1,    -1,    -1,    59,    -1,    -1,    -1,    -1,
    -1,    65,    -1,    -1,    -1,    -1,    -1,    -1,    72,    -1,
    -1,    -1,    76,    -1,    -1,    -1,    -1,    -1,    82,    -1,
    -1,    85,    86,    -1,    -1,    89,    90,    -1,    -1,    93,
    -1,    -1,    45,    46,    -1,    99,    -1,    50,   102,   103,
   104,   105,    -1,    -1,   108,   109,    59,    -1,    -1,    -1,
    -1,    -1,    65,     1,    -1,     3,     4,    -1,    -1,    72,
    -1,    -1,    -1,    76,    -1,    -1,    -1,    -1,    -1,    82,
    -1,    -1,    85,    86,    -1,    -1,    89,    90,    -1,    -1,
    93,    94,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   102,
   103,   104,   105,    -1,    -1,   108,   109,    45,    46,    -1,
    -1,    -1,    50,    -1,     1,    -1,     3,     4,    -1,    -1,
    -1,    59,    -1,    -1,    -1,    -1,    -1,    65,    -1,    -1,
    -1,    -1,    -1,    -1,    72,    -1,    -1,    -1,    76,    -1,
    -1,    -1,    -1,    -1,    82,    -1,    -1,    85,    86,    -1,
    -1,    89,    90,    -1,    -1,    93,    94,    -1,    45,    46,
    -1,    -1,    -1,    50,   102,   103,   104,   105,    -1,    -1,
   108,   109,    59,    -1,    -1,    -1,    -1,    -1,    65,     1,
    -1,     3,     4,    -1,    -1,    72,    -1,    -1,    -1,    76,
    -1,    -1,    -1,    -1,    -1,    82,    -1,    -1,    85,    86,
    -1,    -1,    89,    90,    -1,    -1,    93,    94,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,   102,   103,   104,   105,    -1,
    -1,   108,   109,    45,    46,    -1,    -1,    -1,    50,    -1,
     1,    -1,     3,     4,    -1,    -1,    -1,    59,    -1,    -1,
    -1,    -1,    -1,    65,    -1,    -1,    -1,    -1,    -1,    -1,
    72,    -1,    -1,    -1,    76,    -1,    -1,    -1,    -1,    -1,
    82,    -1,    -1,    85,    86,    -1,    -1,    89,    90,    -1,
    -1,    93,    -1,    -1,    45,    46,    -1,    99,    -1,    50,
   102,   103,   104,   105,    -1,    -1,   108,   109,    59,    -1,
    -1,    -1,    -1,    -1,    65,     1,    -1,     3,     4,    -1,
    -1,    72,    -1,    -1,    -1,    76,    -1,    -1,    -1,    -1,
    -1,    82,    -1,    -1,    85,    86,    -1,    -1,    89,    90,
    -1,    -1,    93,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,   102,   103,   104,   105,    -1,    -1,   108,   109,    45,
    46,    -1,    -1,    -1,    50,    -1,     1,    -1,     3,     4,
    -1,    -1,    -1,    59,    -1,    -1,    -1,    -1,    -1,    65,
    -1,    -1,    -1,    -1,    -1,    -1,    72,    -1,    -1,    -1,
    76,    -1,    -1,    -1,    -1,    -1,    82,    -1,    -1,    85,
    86,    -1,    -1,    89,    90,    -1,    -1,    93,    -1,    -1,
    45,    46,    -1,    -1,    -1,    50,   102,   103,   104,   105,
    -1,    -1,   108,   109,    59,    -1,    -1,    -1,    -1,    -1,
    65,     1,    -1,     3,     4,    -1,    -1,    72,    -1,    -1,
    -1,    76,    -1,    -1,    -1,    -1,    -1,    82,    -1,    -1,
    85,    86,    -1,    -1,    89,    90,    -1,    -1,    93,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,   102,   103,   104,
   105,    -1,    -1,   108,   109,    45,    46,    -1,    -1,    -1,
    50,    -1,     1,    -1,     3,     4,    -1,    -1,    -1,    59,
    -1,    -1,    -1,    -1,    -1,    65,    -1,    -1,    -1,    -1,
    -1,    -1,    72,    -1,    -1,    -1,    76,    -1,    -1,    -1,
    -1,    -1,    82,    -1,    -1,    85,    86,    -1,    -1,    89,
    90,    -1,    -1,    93,    -1,    -1,    45,    46,    -1,    -1,
    -1,    50,   102,   103,   104,   105,    -1,    -1,   108,   109,
    59,    -1,    -1,    -1,    -1,    -1,    65,     1,    -1,     3,
     4,    -1,    -1,    72,    -1,    -1,    -1,    76,    -1,    -1,
    -1,    -1,    -1,    82,    -1,    -1,    85,    86,    -1,    -1,
    89,    90,    -1,    -1,    93,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,   102,   103,   104,   105,    -1,    -1,   108,
   109,    45,    46,    -1,    -1,    -1,    50,    -1,     1,    -1,
     3,     4,    -1,    -1,    -1,    59,    -1,    -1,    -1,    -1,
    -1,    65,    -1,    -1,    -1,    -1,    -1,    -1,    72,    -1,
    -1,    -1,    76,    -1,    -1,    -1,    -1,    -1,    82,    -1,
    -1,    85,    86,    -1,    -1,    89,    90,    -1,    -1,    93,
    -1,    -1,    45,    46,    -1,    -1,    -1,    50,   102,   103,
   104,   105,    -1,    -1,   108,   109,    59,    -1,    -1,    -1,
    -1,    -1,    65,     1,    -1,     3,     4,    -1,    -1,    72,
    -1,    -1,    -1,    76,    -1,    -1,    -1,    -1,    -1,    82,
    -1,    -1,    85,    86,    -1,    -1,    89,    90,    -1,    -1,
    93,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   102,
   103,   104,   105,    -1,    -1,   108,   109,    45,    46,    -1,
    -1,    -1,    50,    -1,     1,    -1,     3,     4,    -1,    -1,
    -1,    59,    -1,    -1,    -1,    -1,    -1,    65,    -1,    -1,
    -1,    -1,    -1,    -1,    72,    -1,    -1,    -1,    76,    -1,
    -1,    -1,    -1,    -1,    82,    -1,    -1,    85,    86,    -1,
    -1,    89,    90,    -1,    -1,    93,    -1,    -1,    45,    46,
    -1,    -1,    -1,    50,   102,   103,   104,   105,    -1,    -1,
   108,   109,    59,    -1,    -1,    -1,    -1,    -1,    65,     1,
    -1,     3,     4,    -1,    -1,    72,    -1,    -1,    -1,    76,
    -1,    -1,    -1,    -1,    -1,    82,    -1,    -1,    85,    86,
    -1,    -1,    89,    90,    -1,    -1,    93,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,   102,   103,   104,   105,    -1,
    -1,   108,   109,    45,    46,    -1,    -1,    -1,    50,    -1,
     1,    -1,     3,     4,    -1,    -1,    -1,    59,    -1,    -1,
    -1,    -1,    -1,    65,    -1,    -1,    -1,    -1,    -1,    -1,
    72,    -1,    -1,    -1,    76,    -1,    -1,    -1,    -1,    -1,
    82,    -1,    -1,    85,    86,    -1,    -1,    89,    90,    -1,
    -1,    93,    -1,    -1,    45,    46,    -1,    -1,    -1,    50,
   102,   103,   104,   105,    -1,    -1,   108,   109,    59,    -1,
    -1,    -1,    -1,    -1,    65,     1,    -1,     3,     4,    -1,
    -1,    72,    -1,    -1,    -1,    76,    -1,    -1,    -1,    -1,
    -1,    82,    -1,    -1,    85,    86,    -1,    -1,    89,    90,
    -1,    -1,    93,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,   102,   103,   104,   105,    -1,    -1,   108,   109,    45,
    46,    -1,    -1,    -1,    50,    -1,     1,    -1,     3,     4,
    -1,    -1,    -1,    59,    -1,    -1,    -1,    -1,    -1,    65,
    -1,    -1,    -1,    -1,    -1,    -1,    72,    -1,    -1,    -1,
    76,    -1,    -1,    -1,    -1,    -1,    82,    -1,    -1,    85,
    86,    -1,    -1,    89,    90,    -1,    -1,    93,    -1,    -1,
    45,    46,    -1,    -1,    -1,    50,   102,   103,   104,   105,
    -1,    -1,   108,   109,    59,    -1,    -1,    -1,    -1,    -1,
    65,     1,    -1,     3,     4,    -1,    -1,    72,    -1,    -1,
    -1,    76,    -1,    -1,    -1,    -1,    -1,    82,    -1,    -1,
    85,    86,    -1,    -1,    89,    90,    -1,    -1,    93,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,   102,   103,   104,
   105,    -1,    -1,   108,   109,    45,    46,    -1,    -1,    -1,
    50,    -1,     1,    -1,     3,     4,    -1,    -1,    -1,    59,
    -1,    -1,    -1,    -1,    -1,    65,    -1,    -1,    -1,    -1,
    -1,    -1,    72,    -1,    -1,    -1,    76,    -1,    -1,    -1,
    -1,    -1,    82,    -1,    -1,    85,    86,    -1,    -1,    89,
    90,    -1,    -1,    93,    -1,    -1,    45,    46,    -1,    -1,
    -1,    50,   102,   103,   104,   105,    -1,    -1,   108,   109,
    59,    -1,    -1,    -1,    -1,    -1,    65,     1,    -1,     3,
     4,    -1,    -1,    72,    -1,    -1,    -1,    76,    -1,    -1,
    -1,    -1,    -1,    82,    -1,    -1,    85,    86,    -1,    -1,
    89,    90,    -1,    -1,    93,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,   102,   103,   104,   105,    -1,    -1,   108,
   109,    45,    46,    -1,    -1,    -1,    50,    -1,     1,    -1,
     3,     4,    -1,    -1,    -1,    59,    -1,    -1,    -1,    -1,
    -1,    65,    -1,    -1,    -1,    -1,    -1,    -1,    72,    -1,
    -1,    -1,    76,    -1,    -1,    -1,    -1,    -1,    82,    -1,
    -1,    85,    86,    -1,    -1,    89,    90,    -1,    -1,    93,
    -1,    -1,    45,    46,    -1,    -1,    -1,    50,   102,   103,
   104,   105,    -1,    -1,   108,   109,    59,    -1,    -1,    -1,
    -1,    -1,    65,     1,    -1,     3,     4,    -1,    -1,    72,
    -1,    -1,    -1,    76,    -1,    -1,    -1,    -1,    -1,    82,
    -1,    -1,    85,    86,    -1,    -1,    89,    90,    -1,    -1,
    93,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   102,
   103,   104,   105,    -1,    -1,   108,   109,    45,    46,    -1,
    -1,    -1,    50,    -1,     1,    -1,     3,     4,    -1,    -1,
    -1,    59,    -1,    -1,    -1,    -1,    -1,    65,    -1,    -1,
    -1,    -1,    -1,    -1,    72,    -1,    -1,    -1,    76,    -1,
    -1,    -1,    -1,    -1,    82,    -1,    -1,    85,    86,    -1,
    -1,    89,    90,    -1,    -1,    93,    -1,    -1,    45,    46,
    -1,    -1,    -1,    50,   102,   103,   104,   105,    -1,    -1,
   108,   109,    59,    -1,    -1,    -1,    -1,    -1,    65,     1,
    -1,     3,     4,    -1,    -1,    72,    -1,    -1,    -1,    76,
    -1,    -1,    -1,    -1,    -1,    82,    -1,    -1,    85,    86,
    -1,    -1,    89,    90,    -1,    -1,    93,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,   102,   103,   104,   105,    -1,
    -1,   108,   109,    45,    46,    -1,    -1,    -1,    50,    -1,
     1,    -1,     3,     4,    -1,    -1,    -1,    59,    -1,    -1,
    -1,    -1,    -1,    65,    -1,    -1,    -1,    -1,    -1,    -1,
    72,    -1,    -1,    -1,    76,    -1,    -1,    -1,    -1,    -1,
    82,    -1,    -1,    85,    86,    -1,    -1,    89,    90,    -1,
    -1,    93,    -1,    -1,    45,    46,    -1,    -1,    -1,    50,
   102,   103,   104,   105,    -1,    -1,   108,   109,    59,    -1,
    -1,    -1,    -1,    -1,    65,     1,    -1,     3,     4,    -1,
    -1,    72,    -1,    -1,    -1,    76,    -1,    -1,    -1,    -1,
    -1,    82,    -1,    -1,    85,    86,    -1,    -1,    89,    90,
    -1,    -1,    93,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,   102,   103,   104,   105,    -1,    -1,   108,   109,    45,
    46,    -1,    -1,    -1,    50,    -1,     1,    -1,     3,     4,
    -1,    -1,    -1,    59,    -1,    -1,    -1,    -1,    -1,    65,
    -1,    -1,    -1,    -1,    -1,    -1,    72,    -1,    -1,    -1,
    76,    -1,    -1,    -1,    -1,    -1,    82,    -1,    -1,    85,
    86,    -1,    -1,    89,    90,    -1,    -1,    93,    -1,    -1,
    45,    46,    -1,    -1,    -1,    50,   102,   103,   104,   105,
    -1,    -1,   108,   109,    59,    -1,    -1,    -1,    -1,    -1,
    65,     1,    -1,     3,     4,    -1,    -1,    72,    -1,    -1,
    -1,    76,    -1,    -1,    -1,    -1,    -1,    82,    -1,    -1,
    85,    86,    -1,    -1,    89,    90,    -1,    -1,    93,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,   102,   103,   104,
   105,    -1,    -1,   108,   109,    45,    46,    -1,    -1,    -1,
    50,    -1,     1,    -1,     3,     4,    -1,    -1,    -1,    59,
    -1,    -1,    -1,    -1,    -1,    65,    -1,    -1,    -1,    -1,
    -1,    -1,    72,    -1,    -1,    -1,    76,    -1,    -1,    -1,
    -1,    -1,    82,    -1,    -1,    85,    86,    -1,    -1,    89,
    90,    -1,    -1,    93,    -1,    -1,    45,    46,    -1,    -1,
    -1,    50,   102,   103,   104,   105,    -1,    -1,   108,   109,
    59,    -1,    -1,    -1,    -1,    -1,    65,     1,    -1,     3,
     4,    -1,    -1,    72,    -1,    -1,    -1,    76,    -1,    -1,
    -1,    -1,    -1,    82,    -1,    -1,    85,    86,    -1,    -1,
    89,    90,    -1,    -1,    93,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,   102,   103,   104,   105,    -1,    -1,   108,
   109,    45,    46,    -1,    -1,    -1,    50,    -1,     1,    -1,
     3,     4,    -1,    -1,    -1,    59,    -1,    -1,    -1,    -1,
    -1,    65,    -1,    -1,    -1,    -1,    -1,    -1,    72,    -1,
    -1,    -1,    76,    -1,    -1,    -1,    -1,    -1,    82,    -1,
    -1,    85,    86,    -1,    -1,    89,    90,    -1,    -1,    93,
    -1,    -1,    45,    46,    -1,    -1,    -1,    50,   102,   103,
   104,   105,    -1,    -1,   108,   109,    59,    -1,    -1,    -1,
    -1,    -1,    65,     1,    -1,     3,     4,    -1,    -1,    72,
    -1,    -1,    -1,    76,    -1,    -1,    -1,    -1,    -1,    82,
    -1,    -1,    85,    86,    -1,    -1,    89,    90,    -1,    -1,
    93,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   102,
   103,   104,   105,    -1,    -1,   108,   109,    45,    46,    -1,
    -1,    -1,    50,    -1,     1,    -1,     3,     4,    -1,    -1,
    -1,    59,    -1,    -1,    -1,    -1,    -1,    65,    -1,    -1,
    -1,    -1,    -1,    -1,    72,    -1,    -1,    -1,    76,    -1,
    -1,    -1,    -1,    -1,    82,    -1,    -1,    85,    86,    -1,
    -1,    89,    90,    -1,    -1,    93,    -1,    -1,    45,    46,
    -1,    -1,    -1,    50,   102,   103,   104,   105,    -1,    -1,
   108,   109,    59,    -1,    -1,    -1,    -1,    -1,    65,     1,
    -1,     3,     4,    -1,    -1,    72,    -1,    -1,    -1,    76,
    -1,    -1,    -1,    -1,    -1,    82,    -1,    -1,    85,    86,
    -1,    -1,    89,    90,    -1,    -1,    93,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,   102,   103,   104,   105,    -1,
    -1,   108,   109,    45,    46,    -1,    -1,    -1,    50,    -1,
     1,    -1,     3,     4,    -1,    -1,    -1,    59,    -1,    -1,
    -1,    -1,    -1,    65,    -1,    -1,    -1,    -1,    -1,    -1,
    72,    -1,    -1,    -1,    76,    -1,    -1,    -1,    -1,    -1,
    82,    -1,    -1,    85,    86,    -1,    -1,    89,    90,    -1,
    -1,    93,    -1,    -1,    45,    46,    -1,    -1,    -1,    50,
   102,   103,   104,   105,    -1,    -1,   108,   109,    59,    -1,
    -1,    -1,    -1,    -1,    65,     1,    -1,     3,     4,    -1,
    -1,    72,    -1,    -1,    -1,    76,    -1,    -1,    -1,    -1,
    -1,    82,    -1,    -1,    85,    86,    -1,    -1,    89,    90,
    -1,    -1,    93,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,   102,   103,   104,   105,    -1,    -1,   108,   109,    45,
    46,    -1,    -1,    -1,    50,    -1,     1,    -1,     3,     4,
    -1,    -1,    -1,    59,    -1,    -1,    -1,    -1,    -1,    65,
    -1,    -1,    -1,    -1,    -1,    -1,    72,    -1,    -1,    -1,
    76,    -1,    -1,    -1,    -1,    -1,    82,    -1,    -1,    85,
    86,    -1,    -1,    89,    90,    -1,    -1,    93,    -1,    -1,
    45,    46,    -1,    -1,    -1,    50,   102,   103,   104,   105,
    -1,    -1,   108,   109,    59,    -1,    -1,    -1,    -1,    -1,
    65,     1,    -1,     3,     4,    -1,    -1,    72,    -1,    -1,
    -1,    76,    -1,    -1,    -1,    -1,    -1,    82,    -1,    -1,
    85,    86,    -1,    -1,    89,    90,    -1,    -1,    93,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,   102,   103,   104,
   105,    -1,    -1,   108,   109,    45,    46,    -1,    -1,    -1,
    50,    -1,     1,    -1,     3,     4,    -1,    -1,    -1,    59,
    -1,    -1,    -1,    -1,    -1,    65,    -1,    -1,    -1,    -1,
    -1,    -1,    72,    -1,    -1,    -1,    76,    -1,    -1,    -1,
    -1,    -1,    82,    -1,    -1,    85,    86,    -1,    -1,    89,
    90,    -1,    -1,    93,    -1,    -1,    45,    46,    -1,    -1,
    -1,    50,   102,   103,   104,   105,    -1,    -1,   108,   109,
    59,    -1,    -1,    -1,    -1,    -1,    65,     1,    -1,     3,
     4,    -1,    -1,    72,    -1,    -1,    -1,    76,    -1,    -1,
    -1,    -1,    -1,    82,    -1,    -1,    85,    86,    -1,    -1,
    89,    90,    -1,    -1,    93,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,   102,   103,   104,   105,    -1,    -1,   108,
   109,    45,    46,    -1,    -1,    -1,    50,    -1,     1,    -1,
     3,     4,    -1,    -1,    -1,    59,    -1,    -1,    -1,    -1,
    -1,    65,    -1,    -1,    -1,    -1,    -1,    -1,    72,    -1,
    -1,    -1,    76,    -1,    -1,    -1,    -1,    -1,    82,    -1,
    -1,    85,    86,    -1,    -1,    89,    90,    -1,    -1,    93,
    -1,    -1,    45,    46,    -1,    -1,    -1,    50,   102,   103,
   104,   105,    -1,    -1,   108,   109,    59,    -1,    -1,    -1,
    -1,    -1,    65,     1,    -1,     3,     4,    -1,    -1,    72,
    -1,    -1,    -1,    76,    -1,    -1,    -1,    -1,    -1,    82,
    -1,    -1,    85,    86,    -1,    -1,    89,    90,    -1,    -1,
    93,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   102,
   103,   104,   105,    -1,    -1,   108,   109,    45,    46,    -1,
    -1,    -1,    50,    -1,     1,    -1,     3,     4,    -1,    -1,
    -1,    59,    -1,    -1,    -1,    -1,    -1,    65,    -1,    -1,
    -1,    -1,    -1,    -1,    72,    -1,    -1,    -1,    76,    -1,
    -1,    -1,    -1,    -1,    82,    -1,    -1,    85,    86,    -1,
    -1,    89,    90,    -1,    -1,    93,    -1,    -1,    45,    46,
    -1,    -1,    -1,    50,   102,   103,   104,   105,    -1,    -1,
   108,   109,    59,    -1,    -1,    -1,    -1,    -1,    65,    -1,
     1,    -1,    -1,    -1,    -1,    72,    -1,    -1,    -1,    76,
    -1,    -1,    -1,    -1,    -1,    82,    -1,    -1,    85,    86,
    -1,    -1,    89,    90,    -1,     1,    93,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,   102,   103,   104,   105,    -1,
    -1,   108,   109,    44,    45,    46,    -1,    -1,    -1,    50,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    59,    -1,
    -1,    -1,    -1,    -1,    65,    -1,    -1,     1,    -1,    45,
    46,    72,    -1,    -1,    50,    76,    -1,    -1,    -1,    -1,
    -1,    82,    -1,    59,    85,    86,    -1,    -1,    -1,    65,
    -1,    -1,    93,    -1,     3,     4,    72,    -1,    99,    -1,
    76,   102,   103,   104,   105,    -1,    82,   108,   109,    85,
    86,    45,    46,    -1,    -1,    -1,    50,    93,    94,    -1,
    -1,    -1,    -1,    -1,    -1,    59,   102,   103,   104,   105,
    -1,    65,   108,   109,     1,    -1,    45,    46,    72,    -1,
    -1,    50,    76,    -1,    -1,    -1,    -1,    -1,    82,    -1,
    59,    85,    86,    -1,    -1,    -1,    65,    -1,    -1,    93,
    94,     3,     4,    72,    -1,    -1,    -1,    76,   102,   103,
   104,   105,    -1,    82,   108,   109,    85,    86,    45,    46,
    89,    90,    -1,    50,    93,    -1,    95,    96,    -1,    -1,
    -1,   100,    59,   102,   103,   104,   105,    -1,    65,   108,
   109,    -1,    -1,    45,    46,    72,    -1,    -1,    50,    76,
    -1,    -1,     3,     4,    -1,    82,    -1,    59,    85,    86,
    -1,    -1,    -1,    65,    -1,    -1,    93,    -1,    -1,    -1,
    72,    -1,    -1,    -1,    76,   102,   103,   104,   105,    -1,
    82,   108,   109,    85,    86,    -1,    -1,    89,    90,    -1,
    -1,    93,    94,    -1,    45,    46,    -1,    -1,    -1,    50,
   102,   103,   104,   105,    -1,    -1,   108,   109,    59,    -1,
    -1,    -1,    -1,    -1,    65,    -1,    -1,     3,     4,    -1,
    -1,    72,    -1,    -1,    -1,    76,    -1,    -1,    -1,    -1,
    -1,    82,    -1,    -1,    85,    86,    -1,    -1,    89,    90,
    -1,    -1,    93,    94,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,   102,   103,   104,   105,    -1,    -1,   108,   109,    45,
    46,    -1,    -1,    -1,    50,    -1,    -1,    -1,     3,     4,
    -1,    -1,    -1,    59,    -1,    -1,    -1,    -1,    -1,    65,
    -1,    -1,    -1,    -1,    -1,    -1,    72,    -1,    -1,    -1,
    76,    -1,    -1,    -1,    -1,    -1,    82,    -1,    -1,    85,
    86,    -1,    -1,    89,    90,    -1,    -1,    93,    94,    -1,
    45,    46,    -1,    -1,    -1,    50,   102,   103,   104,   105,
    -1,    -1,   108,   109,    59,    -1,    -1,    -1,    -1,    -1,
    65,    -1,    -1,     3,     4,    -1,    -1,    72,    -1,    -1,
    -1,    76,    -1,    -1,    -1,    -1,    -1,    82,    -1,    -1,
    85,    86,    -1,    -1,    89,    90,    -1,    -1,    93,    94,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,   102,   103,   104,
   105,    -1,    -1,   108,   109,    45,    46,    -1,    -1,    -1,
    50,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    59,
    -1,    -1,    -1,    -1,    -1,    65,    -1,    -1,    -1,    -1,
    -1,    -1,    72,    -1,    -1,    -1,    76,    -1,    -1,    -1,
    -1,    -1,    82,    -1,    -1,    85,    86,    -1,    -1,    89,
    90,    -1,    -1,    93,    -1,    44,    45,    46,    -1,    -1,
    -1,    50,   102,   103,   104,   105,    -1,    -1,   108,   109,
    59,    -1,    -1,    -1,    -1,    -1,    65,    -1,    -1,    -1,
    -1,    -1,    -1,    72,    -1,    -1,    -1,    76,    -1,    -1,
    -1,    -1,    -1,    82,    -1,    -1,    85,    86,    -1,    -1,
    -1,    -1,    -1,    -1,    93,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,   102,   103,   104,   105,    -1,    -1,   108,
   109
};
#define YYPURE 1

/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
#line 3 "/usr/cygnus/gnupro-98r1/share/bison.simple"

/* Skeleton output parser for bison,
   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* As a special exception, when this file is copied by Bison into a
   Bison output file, you may use that output file without restriction.
   This special exception was added by the Free Software Foundation
   in version 1.24 of Bison.  */

#ifndef alloca
#ifdef __GNUC__
#define alloca __builtin_alloca
#else /* not GNU C.  */
#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi)
#include <alloca.h>
#else /* not sparc */
#if defined (MSDOS) && !defined (__TURBOC__)
#include <malloc.h>
#else /* not MSDOS, or __TURBOC__ */
#if defined(_AIX)
#include <malloc.h>
 #pragma alloca
#else /* not MSDOS, __TURBOC__, or _AIX */
#ifdef __hpux
#ifdef __cplusplus
extern "C" {
void *alloca (unsigned int);
};
#else /* not __cplusplus */
void *alloca ();
#endif /* not __cplusplus */
#endif /* __hpux */
#endif /* not _AIX */
#endif /* not MSDOS, or __TURBOC__ */
#endif /* not sparc.  */
#endif /* not GNU C.  */
#endif /* alloca not defined.  */

/* This is the parser code that is written into each bison parser
  when the %semantic_parser declaration is not specified in the grammar.
  It was written by Richard Stallman by simplifying the hairy parser
  used when %semantic_parser is specified.  */

/* Note: there must be only one dollar sign in this file.
   It is replaced by the list of actions, each action
   as one case of the switch.  */

#define yyerrok		(yyerrstatus = 0)
#define yyclearin	(yychar = YYEMPTY)
#define YYEMPTY		-2
#define YYEOF		0
#define YYACCEPT	return(0)
#define YYABORT 	return(1)
#define YYERROR		goto yyerrlab1
/* Like YYERROR except do call yyerror.
   This remains here temporarily to ease the
   transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */
#define YYFAIL		goto yyerrlab
#define YYRECOVERING()  (!!yyerrstatus)
#define YYBACKUP(token, value) \
do								\
  if (yychar == YYEMPTY && yylen == 1)				\
    { yychar = (token), yylval = (value);			\
      yychar1 = YYTRANSLATE (yychar);				\
      YYPOPSTACK;						\
      goto yybackup;						\
    }								\
  else								\
    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
while (0)

#define YYTERROR	1
#define YYERRCODE	256

#ifndef YYPURE
#define YYLEX		yylex()
#endif

#ifdef YYPURE
#ifdef YYLSP_NEEDED
#ifdef YYLEX_PARAM
#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
#else
#define YYLEX		yylex(&yylval, &yylloc)
#endif
#else /* not YYLSP_NEEDED */
#ifdef YYLEX_PARAM
#define YYLEX		yylex(&yylval, YYLEX_PARAM)
#else
#define YYLEX		yylex(&yylval)
#endif
#endif /* not YYLSP_NEEDED */
#endif

/* If nonreentrant, generate the variables here */

#ifndef YYPURE

int	yychar;			/*  the lookahead symbol		*/
YYSTYPE	yylval;			/*  the semantic value of the		*/
				/*  lookahead symbol			*/

#ifdef YYLSP_NEEDED
YYLTYPE yylloc;			/*  location data for the lookahead	*/
				/*  symbol				*/
#endif

int yynerrs;			/*  number of parse errors so far       */
#endif  /* not YYPURE */

#if YYDEBUG != 0
int yydebug;			/*  nonzero means print parse trace	*/
/* Since this is uninitialized, it does not stop multiple parsers
   from coexisting.  */
#endif

/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/

#ifndef	YYINITDEPTH
#define YYINITDEPTH 200
#endif

/*  YYMAXDEPTH is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#if YYMAXDEPTH == 0
#undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif

/* Prevent warning if -Wstrict-prototypes.  */
#ifdef __GNUC__
int yyparse (void);
#endif

#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
#else				/* not GNU C or C++ */
#ifndef __cplusplus

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__yy_memcpy (to, from, count)
     char *to;
     char *from;
     int count;
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#else /* __cplusplus */

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__yy_memcpy (char *to, char *from, int count)
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#endif
#endif

#line 196 "/usr/cygnus/gnupro-98r1/share/bison.simple"

/* The user can define YYPARSE_PARAM as the name of an argument to be passed
   into yyparse.  The argument should have type void *.
   It should actually point to an object.
   Grammar actions can access the variable by casting it
   to the proper pointer type.  */

#ifdef YYPARSE_PARAM
#ifdef __cplusplus
#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
#define YYPARSE_PARAM_DECL
#else /* not __cplusplus */
#define YYPARSE_PARAM_ARG YYPARSE_PARAM
#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
#endif /* not __cplusplus */
#else /* not YYPARSE_PARAM */
#define YYPARSE_PARAM_ARG
#define YYPARSE_PARAM_DECL
#endif /* not YYPARSE_PARAM */

int
yyparse(YYPARSE_PARAM_ARG)
     YYPARSE_PARAM_DECL
{
  register int yystate;
  register int yyn;
  register short *yyssp;
  register YYSTYPE *yyvsp;
  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */

  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/

  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */

#ifdef YYLSP_NEEDED
  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
  YYLTYPE *yyls = yylsa;
  YYLTYPE *yylsp;

#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
#else
#define YYPOPSTACK   (yyvsp--, yyssp--)
#endif

  int yystacksize = YYINITDEPTH;

#ifdef YYPURE
  int yychar;
  YYSTYPE yylval;
  int yynerrs;
#ifdef YYLSP_NEEDED
  YYLTYPE yylloc;
#endif
#endif

  YYSTYPE yyval;		/*  the variable used to return		*/
				/*  semantic values from the action	*/
				/*  routines				*/

  int yylen;

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Starting parse\n");
#endif

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY;		/* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

  yyssp = yyss - 1;
  yyvsp = yyvs;
#ifdef YYLSP_NEEDED
  yylsp = yyls;
#endif

/* Push a new state, which is found in  yystate  .  */
/* In all cases, when you get here, the value and location stacks
   have just been pushed. so pushing a state here evens the stacks.  */
yynewstate:

  *++yyssp = yystate;

  if (yyssp >= yyss + yystacksize - 1)
    {
      /* Give user a chance to reallocate the stack */
      /* Use copies of these so that the &'s don't force the real ones into memory. */
      YYSTYPE *yyvs1 = yyvs;
      short *yyss1 = yyss;
#ifdef YYLSP_NEEDED
      YYLTYPE *yyls1 = yyls;
#endif

      /* Get the current used size of the three stacks, in elements.  */
      int size = yyssp - yyss + 1;

#ifdef yyoverflow
      /* Each stack pointer address is followed by the size of
	 the data in use in that stack, in bytes.  */
#ifdef YYLSP_NEEDED
      /* This used to be a conditional around just the two extra args,
	 but that might be undefined if yyoverflow is a macro.  */
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yyls1, size * sizeof (*yylsp),
		 &yystacksize);
#else
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yystacksize);
#endif

      yyss = yyss1; yyvs = yyvs1;
#ifdef YYLSP_NEEDED
      yyls = yyls1;
#endif
#else /* no yyoverflow */
      /* Extend the stack our own way.  */
      if (yystacksize >= YYMAXDEPTH)
	{
	  yyerror("parser stack overflow");
	  return 2;
	}
      yystacksize *= 2;
      if (yystacksize > YYMAXDEPTH)
	yystacksize = YYMAXDEPTH;
      yyss = (short *) alloca (yystacksize * sizeof (*yyssp));
      __yy_memcpy ((char *)yyss, (char *)yyss1, size * sizeof (*yyssp));
      yyvs = (YYSTYPE *) alloca (yystacksize * sizeof (*yyvsp));
      __yy_memcpy ((char *)yyvs, (char *)yyvs1, size * sizeof (*yyvsp));
#ifdef YYLSP_NEEDED
      yyls = (YYLTYPE *) alloca (yystacksize * sizeof (*yylsp));
      __yy_memcpy ((char *)yyls, (char *)yyls1, size * sizeof (*yylsp));
#endif
#endif /* no yyoverflow */

      yyssp = yyss + size - 1;
      yyvsp = yyvs + size - 1;
#ifdef YYLSP_NEEDED
      yylsp = yyls + size - 1;
#endif

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
#endif

      if (yyssp >= yyss + yystacksize - 1)
	YYABORT;
    }

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Entering state %d\n", yystate);
#endif

  goto yybackup;
 yybackup:

/* Do appropriate processing given the current state.  */
/* Read a lookahead token if we need one and don't already have one.  */
/* yyresume: */

  /* First try to decide what to do without reference to lookahead token.  */

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* yychar is either YYEMPTY or YYEOF
     or a valid token in external form.  */

  if (yychar == YYEMPTY)
    {
#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Reading a token: ");
#endif
      yychar = YYLEX;
    }

  /* Convert token to internal form (in yychar1) for indexing tables with */

  if (yychar <= 0)		/* This means end of input. */
    {
      yychar1 = 0;
      yychar = YYEOF;		/* Don't call YYLEX any more */

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Now at end of input.\n");
#endif
    }
  else
    {
      yychar1 = YYTRANSLATE(yychar);

#if YYDEBUG != 0
      if (yydebug)
	{
	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
	  /* Give the individual parser a way to print the precise meaning
	     of a token, for further debugging info.  */
#ifdef YYPRINT
	  YYPRINT (stderr, yychar, yylval);
#endif
	  fprintf (stderr, ")\n");
	}
#endif
    }

  yyn += yychar1;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
    goto yydefault;

  yyn = yytable[yyn];

  /* yyn is what to do for this token type in this state.
     Negative => reduce, -yyn is rule number.
     Positive => shift, yyn is new state.
       New state is final state => don't bother to shift,
       just return success.
     0, or most negative number => error.  */

  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrlab;

  if (yyn == YYFINAL)
    YYACCEPT;

  /* Shift the lookahead token.  */

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
#endif

  /* Discard the token being shifted unless it is eof.  */
  if (yychar != YYEOF)
    yychar = YYEMPTY;

  *++yyvsp = yylval;
#ifdef YYLSP_NEEDED
  *++yylsp = yylloc;
#endif

  /* count tokens shifted since error; after three, turn off error status.  */
  if (yyerrstatus) yyerrstatus--;

  yystate = yyn;
  goto yynewstate;

/* Do the default action for the current state.  */
yydefault:

  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;

/* Do a reduction.  yyn is the number of a rule to reduce with.  */
yyreduce:
  yylen = yyr2[yyn];
  if (yylen > 0)
    yyval = yyvsp[1-yylen]; /* implement default value of the action */

#if YYDEBUG != 0
  if (yydebug)
    {
      int i;

      fprintf (stderr, "Reducing via rule %d (line %d), ",
	       yyn, yyrline[yyn]);

      /* Print the symbols being reduced, and their result.  */
      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
    }
#endif


  switch (yyn) {

case 1:
#line 253 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{;
    break;}
case 18:
#line 297 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 
		  yyval.node = build_java_array_type (yyvsp[-2].node, -1);
		  CLASS_LOADED_P (yyval.node) = 1;
		;
    break;}
case 19:
#line 302 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = build_unresolved_array_type (yyvsp[-2].node); ;
    break;}
case 20:
#line 304 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = build_unresolved_array_type (yyvsp[-2].node); ;
    break;}
case 21:
#line 306 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{RULE ("']' expected"); RECOVER;;
    break;}
case 22:
#line 308 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{RULE ("']' expected"); RECOVER;;
    break;}
case 26:
#line 323 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = make_qualified_name (yyvsp[-2].node, yyvsp[0].node, yyvsp[-1].operator.location); ;
    break;}
case 28:
#line 332 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyval.node = NULL;;
    break;}
case 36:
#line 344 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = NULL;
		;
    break;}
case 37:
#line 348 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = NULL;
		;
    break;}
case 40:
#line 360 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ ctxp->package = EXPR_WFL_NODE (yyvsp[-1].node); ;
    break;}
case 41:
#line 362 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing name"); RECOVER;;
    break;}
case 42:
#line 364 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("';' expected"); RECOVER;;
    break;}
case 45:
#line 374 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  tree name = EXPR_WFL_NODE (yyvsp[-1].node), node, last_name;
		  int   i = IDENTIFIER_LENGTH (name)-1;
		  char *last = &IDENTIFIER_POINTER (name)[i];
		  while (last != IDENTIFIER_POINTER (name))
		    {
		      if (last [0] == '.')
			break;
		      last--;
		    }
		  last_name = get_identifier (++last);
		  if (IS_A_SINGLE_IMPORT_CLASSFILE_NAME_P (last_name))
		    {
		      tree err = find_name_in_single_imports (last_name);
		      if (err && err != name)
			parse_error_context
			  (yyvsp[-1].node, "Ambiguous class: `%s' and `%s'",
			   IDENTIFIER_POINTER (name), 
			   IDENTIFIER_POINTER (err));
		    }
		  else
		    {
		      IS_A_SINGLE_IMPORT_CLASSFILE_NAME_P (last_name) = 1;
		      node = build_tree_list (yyvsp[-1].node, last_name);
		      TREE_CHAIN (node) = ctxp->import_list;
		      ctxp->import_list = node;
		    }
		;
    break;}
case 46:
#line 403 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing name"); RECOVER;;
    break;}
case 47:
#line 405 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("';' expected"); RECOVER;;
    break;}
case 48:
#line 410 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  tree name = EXPR_WFL_NODE (yyvsp[-3].node);
		  tree node = build_tree_list (yyvsp[-3].node, NULL_TREE);
		  if (!IS_AN_IMPORT_ON_DEMAND_P (name))
		    {
		      read_import_dir (yyvsp[-3].node);
		      IS_AN_IMPORT_ON_DEMAND_P (name) = 1;
		    }
		  TREE_CHAIN (node) = ctxp->import_demand_list;
		  ctxp->import_demand_list = node;
		;
    break;}
case 49:
#line 422 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("'*' expected"); RECOVER;;
    break;}
case 50:
#line 424 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("';' expected"); RECOVER;;
    break;}
case 51:
#line 429 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  maybe_generate_clinit ();
		  yyval.node = yyvsp[0].node;
		;
    break;}
case 53:
#line 435 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = NULL; ;
    break;}
case 54:
#line 437 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  YYERROR_NOW;
		  yyerror ("Class or interface declaration expected");
		;
    break;}
case 55:
#line 448 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.value = (1 << yyvsp[0].value);
		;
    break;}
case 56:
#line 452 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  int acc = (1 << yyvsp[0].value);
		  if (yyval.value & acc)
		    parse_error_context 
		      (ctxp->modifier_ctx [yyvsp[0].value], "Modifier `%s' declared twice",
		       java_accstring_lookup (acc));
		  else
		    {
		      yyval.value |= acc;
		    }
		;
    break;}
case 57:
#line 468 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ create_class (yyvsp[-4].value, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;
    break;}
case 58:
#line 470 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 
		  yyval.node = yyvsp[0].node;
		;
    break;}
case 59:
#line 474 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ create_class (0, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;
    break;}
case 60:
#line 476 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 	
		  yyval.node = yyvsp[0].node;
		;
    break;}
case 61:
#line 480 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing class name"); RECOVER;;
    break;}
case 62:
#line 482 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing class name"); RECOVER;;
    break;}
case 63:
#line 484 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{if (!ctxp->class_err) yyerror ("'{' expected"); DRECOVER(class1);;
    break;}
case 64:
#line 486 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{if (!ctxp->class_err) yyerror ("'{' expected"); RECOVER;;
    break;}
case 65:
#line 490 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = NULL; ;
    break;}
case 66:
#line 492 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = yyvsp[0].node; ;
    break;}
case 67:
#line 494 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("'{' expected"); ctxp->class_err=1;;
    break;}
case 68:
#line 496 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing super class name"); ctxp->class_err=1;;
    break;}
case 69:
#line 500 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = NULL_TREE; ;
    break;}
case 70:
#line 502 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = yyvsp[0].node; ;
    break;}
case 71:
#line 504 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  ctxp->class_err=1;
		  yyerror ("Missing interface name"); 
		;
    break;}
case 72:
#line 512 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 
		  ctxp->interface_number = 1;
		  yyval.node = build_tree_list (yyvsp[0].node, NULL_TREE);
		;
    break;}
case 73:
#line 517 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 
		  ctxp->interface_number++;
		  yyval.node = chainon (yyvsp[-2].node, build_tree_list (yyvsp[0].node, NULL_TREE));
		;
    break;}
case 74:
#line 522 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing interface name"); RECOVER;;
    break;}
case 75:
#line 527 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = ctxp->current_parsed_class; ;
    break;}
case 76:
#line 529 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = ctxp->current_parsed_class; ;
    break;}
case 87:
#line 554 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ register_fields (0, yyvsp[-2].node, yyvsp[-1].node); ;
    break;}
case 88:
#line 556 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  int acc_count = 0;

		  check_modifiers 
		    ("Illegal modifier `%s' for field declaration",
		     yyvsp[-3].value, FIELD_MODIFIERS);
		  check_modifiers_consistency (yyvsp[-3].value);
		  register_fields (yyvsp[-3].value, yyvsp[-2].node, yyvsp[-1].node);
		;
    break;}
case 90:
#line 571 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = chainon (yyvsp[-2].node, yyvsp[0].node); ;
    break;}
case 91:
#line 573 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 92:
#line 578 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = build_tree_list (yyvsp[0].node, NULL_TREE); ;
    break;}
case 93:
#line 580 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 
		  if (java_error_count)
		    yyvsp[0].node = NULL_TREE;
		  yyval.node = build_tree_list 
		    (yyvsp[-2].node, build_assignment (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node));
		;
    break;}
case 94:
#line 587 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyerror ("Missing variable initializer");
		  yyval.node = build_tree_list (yyvsp[-2].node, NULL_TREE);
		  RECOVER;
		;
    break;}
case 95:
#line 593 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyerror ("';' expected");
		  yyval.node = build_tree_list (yyvsp[-3].node, NULL_TREE);
		  RECOVER;
		;
    break;}
case 97:
#line 603 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = NULL;	/* FIXME */
		;
    break;}
case 98:
#line 607 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Invalid declaration"); DRECOVER(vdi);;
    break;}
case 99:
#line 609 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("']' expected"); DRECOVER(vdi);;
    break;}
case 100:
#line 611 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Unbalanced ']'"); DRECOVER(vdi);;
    break;}
case 102:
#line 617 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = NULL; ;
    break;}
case 103:
#line 623 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  current_function_decl = yyvsp[0].node;
		  source_start_java_method (current_function_decl);
		;
    break;}
case 104:
#line 628 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 
		  BLOCK_EXPR_BODY 
		    (DECL_FUNCTION_BODY (current_function_decl)) = yyvsp[0].node;
		  maybe_absorb_scoping_blocks ();
		  exit_block (); /* Exit function's body. */

		  /* Merge last line of the function with first line,
		     directly in the function decl. It will be used to
		     emit correct debug info. */
		  DECL_SOURCE_LINE_MERGE (current_function_decl,
					  ctxp->last_ccb_indent1);
		;
    break;}
case 105:
#line 641 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{YYNOT_TWICE yyerror ("'{' expected"); RECOVER;;
    break;}
case 106:
#line 646 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = method_header (0, yyvsp[-2].node, yyvsp[-1].node, NULL); ;
    break;}
case 107:
#line 648 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = method_header (0, void_type_node, yyvsp[-1].node, NULL); ;
    break;}
case 108:
#line 650 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = method_header (yyvsp[-3].value, yyvsp[-2].node, yyvsp[-1].node, NULL); ;
    break;}
case 109:
#line 652 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = method_header (yyvsp[-3].value, void_type_node, yyvsp[-1].node, NULL); ;
    break;}
case 110:
#line 654 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{RECOVER;;
    break;}
case 111:
#line 656 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{RECOVER;;
    break;}
case 112:
#line 658 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Identifier expected"); RECOVER;;
    break;}
case 113:
#line 660 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Identifier expected"); RECOVER;;
    break;}
case 114:
#line 662 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyerror ("Invalid method declaration, return type required");
		  RECOVER;
		;
    break;}
case 115:
#line 670 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = method_declarator (yyvsp[-2].node, NULL_TREE); ;
    break;}
case 116:
#line 672 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = method_declarator (yyvsp[-3].node, yyvsp[-1].node); ;
    break;}
case 117:
#line 674 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  /* Issue a warning here: obsolete declaration. FIXME */
		  yyval.node = NULL;	/* FIXME */
		;
    break;}
case 118:
#line 679 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("')' expected"); DRECOVER(method_declarator);;
    break;}
case 119:
#line 681 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("']' expected"); RECOVER;;
    break;}
case 120:
#line 686 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  ctxp->formal_parameter_number = 1;
		;
    break;}
case 121:
#line 690 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  ctxp->formal_parameter_number += 1;
		  yyval.node = chainon (yyvsp[-2].node, yyvsp[0].node);
		;
    break;}
case 122:
#line 695 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing formal parameter term"); RECOVER;;
    break;}
case 123:
#line 700 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = build_tree_list (yyvsp[0].node, yyvsp[-1].node);
		;
    break;}
case 124:
#line 704 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  SOURCE_FRONTEND_DEBUG (("Modifiers: %d", yyvsp[-2].value));
		  yyval.node = NULL;	/* FIXME */
		;
    break;}
case 125:
#line 709 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing identifier"); RECOVER;;
    break;}
case 126:
#line 711 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  SOURCE_FRONTEND_DEBUG (("Modifiers: %d", yyvsp[-2].value));
		  yyerror ("Missing identifier"); RECOVER;
		;
    break;}
case 129:
#line 720 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing class type term"); RECOVER;;
    break;}
case 132:
#line 727 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing class type term"); RECOVER;;
    break;}
case 135:
#line 734 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = NULL_TREE; ;
    break;}
case 136:
#line 740 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  RULE ("STATIC_INITIALIZER");
		;
    break;}
case 137:
#line 744 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  RULE ("STATIC_INITIALIZER");
		;
    break;}
case 138:
#line 751 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  SOURCE_FRONTEND_DEBUG (("Modifiers: %d", yyvsp[0].value));
		;
    break;}
case 139:
#line 763 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  RULE ("CONSTRUCTOR_DECLARATION");
		;
    break;}
case 140:
#line 767 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  SOURCE_FRONTEND_DEBUG (("Modifiers: %d", yyvsp[-3].value));
		  RULE ("CONSTRUCTOR_DECLARATION (modifier)");
		;
    break;}
case 141:
#line 773 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  RULE ("CONSTRUCTOR_DECLARATION");
		;
    break;}
case 142:
#line 778 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  SOURCE_FRONTEND_DEBUG (("Modifiers: %d", yyvsp[-4].value));
		  RULE ("CONSTRUCTOR_DECLARATION (modifier)");
		;
    break;}
case 152:
#line 806 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{RULE ("explicit_constructor_invocation (X.super)");;
    break;}
case 153:
#line 811 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  tree wfl = build_wfl_node (this_identifier_node, input_filename, 0, 0);
		  EXPR_WFL_LINECOL (wfl) = yyvsp[0].operator.location;
		  yyval.node = wfl;
		;
    break;}
case 154:
#line 817 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  tree wfl = build_wfl_node (super_identifier_node, input_filename, 0, 0);
		  EXPR_WFL_LINECOL (wfl) = yyvsp[0].operator.location;
		  yyval.node = wfl;
		;
    break;}
case 155:
#line 828 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ create_interface (0, yyvsp[0].node, NULL_TREE); ;
    break;}
case 156:
#line 830 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = yyvsp[0].node;
		;
    break;}
case 157:
#line 834 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ create_interface (yyvsp[-2].value, yyvsp[0].node, NULL_TREE); ;
    break;}
case 158:
#line 836 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = yyvsp[0].node;
		;
    break;}
case 159:
#line 840 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ create_interface (0, yyvsp[-1].node, yyvsp[0].node);	;
    break;}
case 160:
#line 842 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = yyvsp[0].node;
		;
    break;}
case 161:
#line 846 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ create_interface (yyvsp[-3].value, yyvsp[-1].node, yyvsp[0].node); ;
    break;}
case 162:
#line 848 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = yyvsp[0].node;
		;
    break;}
case 163:
#line 852 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("(here)'{' expected"); RECOVER;;
    break;}
case 164:
#line 854 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("(there)'{' expected"); RECOVER;;
    break;}
case 165:
#line 859 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 
		  ctxp->interface_number = 1;
		  yyval.node = build_tree_list (yyvsp[0].node, NULL_TREE);
		;
    break;}
case 166:
#line 864 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 
		  ctxp->interface_number++;
		  yyval.node = chainon (yyvsp[-2].node, build_tree_list (yyvsp[0].node, NULL_TREE));
		;
    break;}
case 167:
#line 869 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Invalid interface type"); RECOVER;;
    break;}
case 168:
#line 871 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 169:
#line 876 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = NULL_TREE; ;
    break;}
case 170:
#line 878 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = NULL_TREE; ;
    break;}
case 178:
#line 899 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 
		  check_abstract_method_header (yyvsp[-1].node);
		  current_function_decl = NULL_TREE; /* FIXME ? */
		;
    break;}
case 179:
#line 904 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("';' expected"); RECOVER;;
    break;}
case 180:
#line 910 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  RULE ("ARRAY_INITIALIZER (empty)");
		;
    break;}
case 181:
#line 914 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  RULE ("ARRAY_INITIALIZER (variable)");
		;
    break;}
case 182:
#line 918 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  RULE ("ARRAY_INITIALIZER (,)");
		;
    break;}
case 183:
#line 922 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  RULE ("ARRAY_INITIALIZER (variable, ,)");
		;
    break;}
case 186:
#line 931 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 187:
#line 937 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = size_zero_node; ;
    break;}
case 188:
#line 939 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ enter_block (); ;
    break;}
case 189:
#line 942 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 
		  maybe_absorb_scoping_blocks ();
		  yyval.node = exit_block ();
		;
    break;}
case 193:
#line 956 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = java_method_add_stmt (current_function_decl, yyvsp[0].node); ;
    break;}
case 196:
#line 966 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ declare_local_variables (0, yyvsp[-1].node, yyvsp[0].node); ;
    break;}
case 197:
#line 968 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ declare_local_variables (yyvsp[-2].value, yyvsp[-1].node, yyvsp[0].node); ;
    break;}
case 199:
#line 974 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ RULE ("STATEMENT (labeled)"); ;
    break;}
case 200:
#line 976 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ RULE ("STATEMENT (if-then)"); ;
    break;}
case 201:
#line 978 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ RULE ("STATEMENT (if-then-else)"); ;
    break;}
case 202:
#line 980 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ RULE ("STATEMENT (while)"); ;
    break;}
case 203:
#line 982 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 
		  /* If the for loop is unlabeled, we must return the
		     block it was defined it. It our last chance to
		     get a hold on it. */
		  if (!LOOP_HAS_LABEL_P (yyval.node))
		    yyval.node = exit_block ();
		;
    break;}
case 205:
#line 994 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ RULE ("NSI STATEMENT (labeled)"); ;
    break;}
case 206:
#line 996 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ RULE ("NSI STATEMENT (if-then-else)"); ;
    break;}
case 207:
#line 998 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ RULE ("NSI STATEMENT (while)"); ;
    break;}
case 208:
#line 1000 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ RULE ("NSI STATEMENT (for)"); ;
    break;}
case 209:
#line 1005 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ RULE ("STATEMENT (block)"); ;
    break;}
case 210:
#line 1007 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ RULE ("STATEMENT (empty)"); ;
    break;}
case 211:
#line 1009 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ RULE ("STATEMENT (expression)"); ;
    break;}
case 212:
#line 1011 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ RULE ("STATEMENT (switch)"); ;
    break;}
case 213:
#line 1013 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ RULE ("STATEMENT (do)"); ;
    break;}
case 214:
#line 1015 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ RULE ("STATEMENT (break)"); ;
    break;}
case 215:
#line 1017 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ RULE ("STATEMENT (continue)"); ;
    break;}
case 217:
#line 1020 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ RULE ("STATEMENT (synchronized)"); ;
    break;}
case 218:
#line 1022 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ RULE ("STATEMENT (throw)"); ;
    break;}
case 219:
#line 1024 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ RULE ("STATEMENT (try)"); ;
    break;}
case 220:
#line 1029 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = size_zero_node; ;
    break;}
case 221:
#line 1034 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = build_labeled_block (EXPR_WFL_LINECOL (yyvsp[-1].node), 
					    EXPR_WFL_NODE (yyvsp[-1].node), yyvsp[-1].node);
		  pushlevel (2);
		  push_labeled_block (yyval.node);
		  PUSH_LABELED_BLOCK (yyval.node);
		;
    break;}
case 222:
#line 1045 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 
		  yyval.node = complete_labeled_statement (yyvsp[-1].node, yyvsp[0].node);
		  pop_labeled_block ();
		  POP_LABELED_BLOCK ();
		;
    break;}
case 223:
#line 1051 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("':' expected"); RECOVER;;
    break;}
case 224:
#line 1056 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 
		  yyval.node = complete_labeled_statement (yyvsp[-1].node, yyvsp[0].node);
		  pop_labeled_block ();
		  POP_LABELED_BLOCK ();
		;
    break;}
case 225:
#line 1067 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  /* We have a statement. Generate a WFL around it so
		     we can debug it */
		  yyval.node = build_expr_wfl (yyvsp[-1].node, input_filename, lineno, 0);
		  /* We know we have a statement, so set the debug
                     info to be eventually generate here. */
		  yyval.node = JAVA_MAYBE_GENERATE_DEBUG_INFO (yyval.node);
		;
    break;}
case 226:
#line 1076 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  if (ctxp->prevent_ese != lineno)
		    yyerror ("Invalid expression statement");
		  DRECOVER (expr_stmt);
		;
    break;}
case 227:
#line 1082 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  if (ctxp->prevent_ese != lineno)
		    yyerror ("Invalid expression statement");
		  DRECOVER (expr_stmt);
		;
    break;}
case 228:
#line 1088 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  if (ctxp->prevent_ese != lineno)
		    yyerror ("Invalid expression statement");
		  DRECOVER (expr_stmt);
		;
    break;}
case 229:
#line 1094 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("')' expected"); RECOVER;;
    break;}
case 230:
#line 1096 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("';' expected"); RECOVER;;
    break;}
case 231:
#line 1098 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("')' expected"); RECOVER;;
    break;}
case 232:
#line 1100 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("';' expected"); RECOVER;;
    break;}
case 233:
#line 1102 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("'(' expected"); RECOVER;;
    break;}
case 234:
#line 1104 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("')' expected"); RECOVER;;
    break;}
case 235:
#line 1106 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("')' expected"); RECOVER;;
    break;}
case 236:
#line 1108 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("';' expected"); RECOVER;;
    break;}
case 237:
#line 1110 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("';' expected"); RECOVER;;
    break;}
case 239:
#line 1116 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  RULE ("++INCREMENT");
		;
    break;}
case 240:
#line 1120 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  RULE ("--DECREMENT");
		;
    break;}
case 241:
#line 1124 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  RULE ("INCREMENT++");
		;
    break;}
case 242:
#line 1128 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  RULE ("DECREMENT--");
		;
    break;}
case 244:
#line 1133 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  RULE ("INSTANCE CREATION");
		;
    break;}
case 245:
#line 1140 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = build_if_else_statement (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[0].node, NULL_TREE); ;
    break;}
case 246:
#line 1142 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("'(' expected"); RECOVER;;
    break;}
case 247:
#line 1144 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 248:
#line 1146 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("')' expected"); RECOVER;;
    break;}
case 249:
#line 1151 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = build_if_else_statement (yyvsp[-5].operator.location, yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node); ;
    break;}
case 250:
#line 1156 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = build_if_else_statement (yyvsp[-5].operator.location, yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node); ;
    break;}
case 252:
#line 1162 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("'(' expected"); RECOVER;;
    break;}
case 253:
#line 1164 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term or ')'"); DRECOVER(switch_statement);;
    break;}
case 254:
#line 1166 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("'{' expected"); RECOVER;;
    break;}
case 266:
#line 1195 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing or invalid constant expression"); RECOVER;;
    break;}
case 267:
#line 1197 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("':' expected"); RECOVER;;
    break;}
case 268:
#line 1199 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("':' expected"); RECOVER;;
    break;}
case 269:
#line 1204 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 
		  tree body = build_loop_body (yyvsp[-2].operator.location, yyvsp[-1].node, 0);
		  yyval.node = build_new_loop (body);
		;
    break;}
case 270:
#line 1212 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = complete_loop_body (0, NULL_TREE, yyvsp[0].node, 0); ;
    break;}
case 271:
#line 1214 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{YYERROR_NOW; yyerror ("'(' expected"); RECOVER;;
    break;}
case 272:
#line 1216 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term and ')' expected"); RECOVER;;
    break;}
case 273:
#line 1218 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("')' expected"); RECOVER;;
    break;}
case 274:
#line 1223 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = complete_loop_body (0, NULL_TREE, yyvsp[0].node, 0); ;
    break;}
case 275:
#line 1228 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 
		  tree body = build_loop_body (0, NULL_TREE, 1);
		  yyval.node = build_new_loop (body);
		;
    break;}
case 276:
#line 1237 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = complete_loop_body (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[-5].node, 1); ;
    break;}
case 277:
#line 1242 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = complete_for_loop (EXPR_WFL_LINECOL (yyvsp[-4].node), yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node);;
    break;}
case 278:
#line 1244 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 
		  yyval.node = complete_for_loop (0, NULL_TREE, yyvsp[-2].node, yyvsp[0].node);
		  /* We have not condition, so we get rid of the EXIT_EXPR */
		  LOOP_EXPR_BODY_CONDITION_EXPR (LOOP_EXPR_BODY (yyval.node), 0) = 
		    size_zero_node;
		;
    break;}
case 279:
#line 1251 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Invalid control expression"); RECOVER;;
    break;}
case 280:
#line 1253 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Invalid update expression"); RECOVER;;
    break;}
case 281:
#line 1255 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Invalid update expression"); RECOVER;;
    break;}
case 282:
#line 1260 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = complete_for_loop (EXPR_WFL_LINECOL (yyvsp[-4].node), yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node);;
    break;}
case 283:
#line 1262 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 
		  yyval.node = complete_for_loop (0, NULL_TREE, yyvsp[-2].node, yyvsp[0].node);
		  /* We have not condition, so we get rid of the EXIT_EXPR */
		  LOOP_EXPR_BODY_CONDITION_EXPR (LOOP_EXPR_BODY (yyval.node), 0) = 
		    size_zero_node;
		;
    break;}
case 284:
#line 1272 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 
		  /* This scope defined for local variable that may be
                     defined within the scope of the for loop */
		  enter_block (); 
		;
    break;}
case 285:
#line 1278 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("'(' expected"); DRECOVER(for_1);;
    break;}
case 286:
#line 1280 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Invalid init statement"); RECOVER;;
    break;}
case 287:
#line 1285 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 
		  /* We now declare the loop body. The loop is
                     declared as a for loop. */
		  tree body = build_loop_body (0, NULL_TREE, 0);
		  yyval.node =  build_new_loop (body);
		  IS_FOR_LOOP_P (yyval.node) = 1;
		  /* The loop is added to the current block the for
                     statement is defined within */
		  java_method_add_stmt (current_function_decl, yyval.node);
		;
    break;}
case 288:
#line 1297 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = size_zero_node; ;
    break;}
case 289:
#line 1299 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 
		  /* Init statement recorded within the previously
                     defined block scope */
		  yyval.node = java_method_add_stmt (current_function_decl, yyvsp[0].node);
		;
    break;}
case 290:
#line 1305 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 
		  /* Local variable are recorded within the previously
		     defined block scope */
		  yyval.node = NULL_TREE;
		;
    break;}
case 291:
#line 1311 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("';' expected"); DRECOVER(for_init_1);;
    break;}
case 292:
#line 1315 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyval.node = size_zero_node;;
    break;}
case 293:
#line 1317 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = build_debugable_stmt (BUILD_LOCATION (), yyvsp[0].node); ;
    break;}
case 294:
#line 1322 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = add_stmt_to_compound (NULL_TREE, NULL_TREE, yyvsp[0].node); ;
    break;}
case 295:
#line 1324 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = add_stmt_to_compound (yyvsp[-2].node, NULL_TREE, yyvsp[0].node); ;
    break;}
case 296:
#line 1326 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 297:
#line 1331 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = build_bc_statement (yyvsp[-1].operator.location, 1, NULL_TREE); ;
    break;}
case 298:
#line 1333 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = build_bc_statement (yyvsp[-2].operator.location, 1, yyvsp[-1].node); ;
    break;}
case 299:
#line 1335 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 300:
#line 1337 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("';' expected"); RECOVER;;
    break;}
case 301:
#line 1342 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = build_bc_statement (yyvsp[-1].operator.location, 0, NULL_TREE); ;
    break;}
case 302:
#line 1344 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = build_bc_statement (yyvsp[-2].operator.location, 0, yyvsp[-1].node); ;
    break;}
case 303:
#line 1346 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 304:
#line 1348 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("';' expected"); RECOVER;;
    break;}
case 305:
#line 1353 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = build_return (yyvsp[-1].operator.location, NULL_TREE); ;
    break;}
case 306:
#line 1355 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = build_return (yyvsp[-2].operator.location, yyvsp[-1].node); ;
    break;}
case 307:
#line 1357 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 308:
#line 1359 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("';' expected"); RECOVER;;
    break;}
case 310:
#line 1365 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 311:
#line 1367 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("';' expected"); RECOVER;;
    break;}
case 313:
#line 1373 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("'{' expected"); RECOVER;;
    break;}
case 314:
#line 1375 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("'(' expected"); RECOVER;;
    break;}
case 315:
#line 1377 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 316:
#line 1379 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 317:
#line 1384 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  SOURCE_FRONTEND_DEBUG (("Modifiers: %d", yyvsp[0].value));
		;
    break;}
case 321:
#line 1394 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("'{' expected"); DRECOVER (try_statement);;
    break;}
case 325:
#line 1405 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("'(' expected"); RECOVER;;
    break;}
case 326:
#line 1407 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); DRECOVER (1);;
    break;}
case 327:
#line 1409 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); DRECOVER (2);;
    break;}
case 329:
#line 1415 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("'{' expected"); RECOVER; ;
    break;}
case 333:
#line 1427 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = build_this (yyvsp[0].operator.location); ;
    break;}
case 334:
#line 1429 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyval.node = yyvsp[-1].node;;
    break;}
case 343:
#line 1445 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("')' expected"); RECOVER;;
    break;}
case 344:
#line 1447 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("'class' or 'this' expected" ); RECOVER;;
    break;}
case 345:
#line 1449 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("'class' expected" ); RECOVER;;
    break;}
case 346:
#line 1451 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("'class' expected" ); RECOVER;;
    break;}
case 347:
#line 1456 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = build_method_invocation (yyvsp[-3].node, yyvsp[-1].node);
		  TREE_SET_CODE (yyval.node, JAVA_NEW_CLASS_EXPR);
		;
    break;}
case 348:
#line 1461 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = build_method_invocation (yyvsp[-2].node, NULL_TREE);
		  TREE_SET_CODE (yyval.node, JAVA_NEW_CLASS_EXPR);
		;
    break;}
case 349:
#line 1469 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyval.node = yyvsp[-4].node;;
    break;}
case 350:
#line 1471 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyval.node = yyvsp[-3].node;;
    break;}
case 355:
#line 1480 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("'(' expected"); DRECOVER(new_1);;
    break;}
case 356:
#line 1482 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("'(' expected"); RECOVER;;
    break;}
case 357:
#line 1484 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("')' or term expected"); RECOVER;;
    break;}
case 358:
#line 1486 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("')' expected"); RECOVER;;
    break;}
case 359:
#line 1488 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{YYERROR_NOW; yyerror ("Identifier expected"); RECOVER;;
    break;}
case 360:
#line 1490 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("'(' expected"); RECOVER;;
    break;}
case 363:
#line 1500 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 
		  yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, NULL_TREE);
		  ctxp->formal_parameter_number = 1; 
		;
    break;}
case 364:
#line 1505 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  ctxp->formal_parameter_number += 1;
		  yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, yyvsp[-2].node);
		;
    break;}
case 365:
#line 1510 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 366:
#line 1515 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = build_newarray_node (yyvsp[-1].node, yyvsp[0].node, 0); ;
    break;}
case 367:
#line 1517 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = build_newarray_node (yyvsp[-1].node, yyvsp[0].node, 0); ;
    break;}
case 368:
#line 1519 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = build_newarray_node (yyvsp[-2].node, yyvsp[-1].node, ctxp->osb_number); ;
    break;}
case 369:
#line 1521 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = build_newarray_node (yyvsp[-2].node, yyvsp[-1].node, ctxp->osb_number); ;
    break;}
case 370:
#line 1525 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyval.node = yyvsp[-2].node;;
    break;}
case 371:
#line 1527 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyval.node = yyvsp[-2].node;;
    break;}
case 372:
#line 1529 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("'[' expected"); DRECOVER ("]");;
    break;}
case 373:
#line 1531 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("']' expected"); RECOVER;;
    break;}
case 374:
#line 1536 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = build_tree_list (NULL_TREE, yyvsp[0].node); ;
    break;}
case 375:
#line 1538 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, yyval.node); ;
    break;}
case 376:
#line 1543 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 
		  EXPR_WFL_LINECOL (yyvsp[-1].node) = yyvsp[-2].operator.location;
		  yyval.node = yyvsp[-1].node;
		;
    break;}
case 377:
#line 1548 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("']' expected"); RECOVER;;
    break;}
case 378:
#line 1550 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyerror ("Missing term");
		  yyerror ("']' expected");
		  RECOVER;
		;
    break;}
case 379:
#line 1559 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ ctxp->osb_number = 1; ;
    break;}
case 380:
#line 1561 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ ctxp->osb_number++; ;
    break;}
case 381:
#line 1563 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyerror ("']' expected"); RECOVER;;
    break;}
case 382:
#line 1568 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = make_qualified_primary (yyvsp[-2].node, yyvsp[0].node, yyvsp[-1].operator.location); ;
    break;}
case 383:
#line 1570 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  tree super_wfl = 
		    build_wfl_node (super_identifier_node, input_filename, 0, 0);
		  EXPR_WFL_LINECOL (super_wfl) = yyvsp[-2].operator.location;
		  yyval.node = make_qualified_name (super_wfl, yyvsp[0].node, yyvsp[-1].operator.location);
		;
    break;}
case 384:
#line 1577 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Field expected"); DRECOVER (super_field_acces);;
    break;}
case 385:
#line 1582 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = build_method_invocation (yyvsp[-2].node, NULL_TREE); ;
    break;}
case 386:
#line 1584 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = build_method_invocation (yyvsp[-3].node, yyvsp[-1].node); ;
    break;}
case 387:
#line 1586 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 
		  tree invok = build_method_invocation (yyvsp[-2].node, NULL_TREE);
		  yyval.node = make_qualified_primary (yyvsp[-4].node, invok, yyvsp[-3].operator.location);
		;
    break;}
case 388:
#line 1591 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 
		  tree invok = build_method_invocation (yyvsp[-3].node, yyvsp[-1].node);
		  yyval.node = make_qualified_primary (yyvsp[-5].node, invok, yyvsp[-4].operator.location);
		;
    break;}
case 389:
#line 1596 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  tree invok;
		  tree wfl = build_wfl_node (super_identifier_node, input_filename, 0, 0);
		  EXPR_WFL_LINECOL (wfl) = yyvsp[-4].operator.location;
		  invok = build_method_invocation (yyvsp[-2].node, NULL_TREE);
		  yyval.node = make_qualified_primary (wfl, invok, yyvsp[-3].operator.location);
		;
    break;}
case 390:
#line 1604 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  tree invok;
		  tree wfl = build_wfl_node (super_identifier_node, input_filename, 0, 0);
		  EXPR_WFL_LINECOL (wfl) = yyvsp[-5].operator.location;
		  invok = build_method_invocation (yyvsp[-3].node, yyvsp[-1].node);
		  yyval.node = make_qualified_primary (wfl, invok, yyvsp[-4].operator.location);
		;
    break;}
case 391:
#line 1616 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyerror ("'(' expected"); DRECOVER (method_invocation); ;
    break;}
case 392:
#line 1618 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyerror ("'(' expected"); DRECOVER (method_invocation); ;
    break;}
case 393:
#line 1623 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = build_array_ref (yyvsp[-2].operator.location, yyvsp[-3].node, yyvsp[-1].node); ;
    break;}
case 394:
#line 1625 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = build_array_ref (yyvsp[-2].operator.location, yyvsp[-3].node, yyvsp[-1].node); ;
    break;}
case 395:
#line 1627 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyerror ("Missing term and ']' expected");
		  DRECOVER(array_access);
		;
    break;}
case 396:
#line 1632 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyerror ("']' expected");
		  DRECOVER(array_access);
		;
    break;}
case 397:
#line 1637 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyerror ("Missing term and ']' expected");
		  DRECOVER(array_access);
		;
    break;}
case 398:
#line 1642 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyerror ("']' expected");
		  DRECOVER(array_access);
		;
    break;}
case 403:
#line 1657 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = build_incdec (yyvsp[0].operator.token, yyvsp[0].operator.location, yyvsp[-1].node, 1); ;
    break;}
case 404:
#line 1662 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = build_incdec (yyvsp[0].operator.token, yyvsp[0].operator.location, yyvsp[-1].node, 1); ;
    break;}
case 407:
#line 1669 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;
    break;}
case 408:
#line 1671 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;
    break;}
case 410:
#line 1674 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;
    break;}
case 411:
#line 1676 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;
    break;}
case 412:
#line 1681 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyval.node = build_incdec (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node, 0); ;
    break;}
case 413:
#line 1683 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;
    break;}
case 414:
#line 1688 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyval.node = build_incdec (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node, 0); ;
    break;}
case 415:
#line 1690 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;
    break;}
case 417:
#line 1696 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;
    break;}
case 418:
#line 1698 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;
    break;}
case 420:
#line 1701 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;
    break;}
case 421:
#line 1703 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;
    break;}
case 422:
#line 1708 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 
		  tree type = yyvsp[-3].node;
		  while (ctxp->osb_number--)
		    type = build_java_array_type (type, -1);
		  yyval.node = build_cast (yyvsp[-4].operator.location, type, yyvsp[0].node); 
		;
    break;}
case 423:
#line 1715 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = build_cast (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[0].node); ;
    break;}
case 424:
#line 1717 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = build_cast (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[0].node); ;
    break;}
case 425:
#line 1719 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 
		  char *ptr;
		  while (ctxp->osb_number--)
		    obstack_1grow (&temporary_obstack, '[');
		  obstack_grow0 (&temporary_obstack, 
				 IDENTIFIER_POINTER (EXPR_WFL_NODE (yyvsp[-3].node)),
				 IDENTIFIER_LENGTH (EXPR_WFL_NODE (yyvsp[-3].node)));
		  ptr = obstack_finish (&temporary_obstack);
		  EXPR_WFL_NODE (yyvsp[-3].node) = get_identifier (ptr);
		  yyval.node = build_cast (yyvsp[-4].operator.location, yyvsp[-3].node, yyvsp[0].node);
		;
    break;}
case 426:
#line 1731 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("']' expected, invalid type expression");;
    break;}
case 427:
#line 1733 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
	          if (ctxp->prevent_ese != lineno)
		    yyerror ("Invalid type expression"); RECOVER;
		  RECOVER;
		;
    break;}
case 428:
#line 1739 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 429:
#line 1741 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 430:
#line 1743 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 432:
#line 1749 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ 
		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), 
				    yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node);
		;
    break;}
case 433:
#line 1754 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
				    yyvsp[-2].node, yyvsp[0].node); 
		;
    break;}
case 434:
#line 1759 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
				    yyvsp[-2].node, yyvsp[0].node); 
		;
    break;}
case 435:
#line 1764 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 436:
#line 1766 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 437:
#line 1768 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 439:
#line 1774 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
				    yyvsp[-2].node, yyvsp[0].node); 
		;
    break;}
case 440:
#line 1779 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
				    yyvsp[-2].node, yyvsp[0].node); 
		;
    break;}
case 441:
#line 1784 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 442:
#line 1786 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 444:
#line 1792 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
				    yyvsp[-2].node, yyvsp[0].node); 
		;
    break;}
case 445:
#line 1797 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
				    yyvsp[-2].node, yyvsp[0].node); 
		;
    break;}
case 446:
#line 1802 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
				    yyvsp[-2].node, yyvsp[0].node); 
		;
    break;}
case 447:
#line 1807 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 448:
#line 1809 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 449:
#line 1811 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 451:
#line 1817 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
				    yyvsp[-2].node, yyvsp[0].node); 
		;
    break;}
case 452:
#line 1822 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
				    yyvsp[-2].node, yyvsp[0].node); 
		;
    break;}
case 453:
#line 1827 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
				    yyvsp[-2].node, yyvsp[0].node); 
		;
    break;}
case 454:
#line 1832 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
				    yyvsp[-2].node, yyvsp[0].node); 
		;
    break;}
case 456:
#line 1838 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 457:
#line 1840 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 458:
#line 1842 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 459:
#line 1844 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 460:
#line 1846 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Invalid reference type"); RECOVER;;
    break;}
case 462:
#line 1852 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
				    yyvsp[-2].node, yyvsp[0].node); 
		;
    break;}
case 463:
#line 1857 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
				    yyvsp[-2].node, yyvsp[0].node); 
		;
    break;}
case 464:
#line 1862 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 465:
#line 1864 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 467:
#line 1870 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
				    yyvsp[-2].node, yyvsp[0].node); 
		;
    break;}
case 468:
#line 1875 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 470:
#line 1881 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
				    yyvsp[-2].node, yyvsp[0].node); 
		;
    break;}
case 471:
#line 1886 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 473:
#line 1892 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
				    yyvsp[-2].node, yyvsp[0].node); 
		;
    break;}
case 474:
#line 1897 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 476:
#line 1903 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
				    yyvsp[-2].node, yyvsp[0].node); 
		;
    break;}
case 477:
#line 1908 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 479:
#line 1914 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
				    yyvsp[-2].node, yyvsp[0].node); 
		;
    break;}
case 480:
#line 1919 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); RECOVER;;
    break;}
case 483:
#line 1926 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  YYERROR_NOW;
		  yyerror ("Missing term");
		  DRECOVER (1);
		;
    break;}
case 484:
#line 1932 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); DRECOVER (2);;
    break;}
case 485:
#line 1934 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{yyerror ("Missing term"); DRECOVER (3);;
    break;}
case 488:
#line 1944 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{ yyval.node = build_assignment (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node); ;
    break;}
case 489:
#line 1946 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"
{
		  if (ctxp->prevent_ese != lineno)
		    yyerror ("Missing term");
		  DRECOVER (assign);
		;
    break;}
}
   /* the action file gets copied in in place of this dollarsign */
#line 498 "/usr/cygnus/gnupro-98r1/share/bison.simple"

  yyvsp -= yylen;
  yyssp -= yylen;
#ifdef YYLSP_NEEDED
  yylsp -= yylen;
#endif

#if YYDEBUG != 0
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

  *++yyvsp = yyval;

#ifdef YYLSP_NEEDED
  yylsp++;
  if (yylen == 0)
    {
      yylsp->first_line = yylloc.first_line;
      yylsp->first_column = yylloc.first_column;
      yylsp->last_line = (yylsp-1)->last_line;
      yylsp->last_column = (yylsp-1)->last_column;
      yylsp->text = 0;
    }
  else
    {
      yylsp->last_line = (yylsp+yylen-1)->last_line;
      yylsp->last_column = (yylsp+yylen-1)->last_column;
    }
#endif

  /* Now "shift" the result of the reduction.
     Determine what state that goes to,
     based on the state we popped back to
     and the rule number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTBASE];

  goto yynewstate;

yyerrlab:   /* here on detecting error */

  if (! yyerrstatus)
    /* If not already recovering from an error, report this error.  */
    {
      ++yynerrs;

#ifdef YYERROR_VERBOSE
      yyn = yypact[yystate];

      if (yyn > YYFLAG && yyn < YYLAST)
	{
	  int size = 0;
	  char *msg;
	  int x, count;

	  count = 0;
	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
	  for (x = (yyn < 0 ? -yyn : 0);
	       x < (sizeof(yytname) / sizeof(char *)); x++)
	    if (yycheck[x + yyn] == x)
	      size += strlen(yytname[x]) + 15, count++;
	  msg = (char *) malloc(size + 15);
	  if (msg != 0)
	    {
	      strcpy(msg, "parse error");

	      if (count < 5)
		{
		  count = 0;
		  for (x = (yyn < 0 ? -yyn : 0);
		       x < (sizeof(yytname) / sizeof(char *)); x++)
		    if (yycheck[x + yyn] == x)
		      {
			strcat(msg, count == 0 ? ", expecting `" : " or `");
			strcat(msg, yytname[x]);
			strcat(msg, "'");
			count++;
		      }
		}
	      yyerror(msg);
	      free(msg);
	    }
	  else
	    yyerror ("parse error; also virtual memory exceeded");
	}
      else
#endif /* YYERROR_VERBOSE */
	yyerror("parse error");
    }

  goto yyerrlab1;
yyerrlab1:   /* here on error raised explicitly by an action */

  if (yyerrstatus == 3)
    {
      /* if just tried and failed to reuse lookahead token after an error, discard it.  */

      /* return failure if at end of input */
      if (yychar == YYEOF)
	YYABORT;

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
#endif

      yychar = YYEMPTY;
    }

  /* Else will try to reuse lookahead token
     after shifting the error token.  */

  yyerrstatus = 3;		/* Each real token shifted decrements this */

  goto yyerrhandle;

yyerrdefault:  /* current state does not do anything special for the error token. */

#if 0
  /* This is wrong; only states that explicitly want error tokens
     should shift them.  */
  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
  if (yyn) goto yydefault;
#endif

yyerrpop:   /* pop the current state because it cannot handle the error token */

  if (yyssp == yyss) YYABORT;
  yyvsp--;
  yystate = *--yyssp;
#ifdef YYLSP_NEEDED
  yylsp--;
#endif

#if YYDEBUG != 0
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "Error: state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

yyerrhandle:

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yyerrdefault;

  yyn += YYTERROR;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
    goto yyerrdefault;

  yyn = yytable[yyn];
  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	goto yyerrpop;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrpop;

  if (yyn == YYFINAL)
    YYACCEPT;

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Shifting error token, ");
#endif

  *++yyvsp = yylval;
#ifdef YYLSP_NEEDED
  *++yylsp = yylloc;
#endif

  yystate = yyn;
  goto yynewstate;
}
#line 1972 "/nfs/hoser/beer/java/egcs/gcc/java/parse.y"



#include "lex.c"

/* Flag for the error report routine to issue the error the first time
   it's called (overriding the default behavior which is to drop the
   first invocation and honor the second one, taking advantage of a
   richer context.  */
static int force_error = 0;

/* Create a new parser context and make it the current one. */

void
java_push_parser_context ()
{
  struct parser_ctxt *new = 
    (struct parser_ctxt *)malloc(sizeof (struct parser_ctxt));

  bzero (new, sizeof (struct parser_ctxt));
  new->next = ctxp;
  ctxp = new;
  if (ctxp->next)
    ctxp->incomplete_class = ctxp->next->incomplete_class;
}  

void
java_parser_context_save_global ()
{
  ctxp->finput = finput;
  ctxp->lineno = lineno;
  ctxp->current_class = current_class;
  ctxp->filename = input_filename;
  ctxp->current_function_decl = current_function_decl;
}

void
java_parser_context_restore_global ()
{
  finput = ctxp->finput;
  lineno = ctxp->lineno;
  current_class = ctxp->current_class;
  input_filename = ctxp->filename;
  current_function_decl = ctxp->current_function_decl;
}

void 
java_pop_parser_context ()
{
  tree current;
  struct parser_ctxt *toFree = ctxp;
  struct parser_ctxt *next = ctxp->next;

  if (next)
    {
      next->incomplete_class = ctxp->incomplete_class;
      lineno = ctxp->lineno;
      finput = ctxp->finput;
      current_class = ctxp->current_class;
    }

  /* Set the single import class file flag to 0 for the current list
     of imported things */
  for (current = ctxp->import_list; current; current = TREE_CHAIN (current))
    IS_A_SINGLE_IMPORT_CLASSFILE_NAME_P (TREE_PURPOSE (current)) = 0;

  /* And restore those of the previous context */
  if (ctxp = next)
    for (current = ctxp->import_list; current; current = TREE_CHAIN (current))
      IS_A_SINGLE_IMPORT_CLASSFILE_NAME_P (TREE_PURPOSE (current)) = 1;

  free (toFree);
}

static int do_warning = 0;

void
yyerror (msg)
     char *msg;
{
  static java_lc elc;
  static int  prev_lineno;
  static char *prev_msg;

  int i, save_lineno;
  char *remainder, *code_from_source;
  extern struct obstack temporary_obstack;
  
  if (!force_error && prev_lineno == lineno)
    return;

  /* Save current error location but report latter, when the context is
     richer.  */
  if (ctxp->java_error_flag == 0)
    {
      ctxp->java_error_flag = 1;
      elc = ctxp->elc;
      /* Do something to use the previous line if we're reaching the
	 end of the file... */
#ifdef VERBOSE_SKELETON
      printf ("* Error detected (%s)\n", (msg ? msg : "(null)"));
#endif
      return;
    }

  /* Ignore duplicate message on the same line. BTW, this is dubious. FIXME */
  if (!force_error && msg == prev_msg && prev_lineno == elc.line)
    return;

  ctxp->java_error_flag = 0;
  if (do_warning)
    java_warning_count++;
  else
    java_error_count++;
  
  if (elc.col == 0 && msg[1] == ';')
    {
      elc.col  = ctxp->p_line->char_col-1;
      elc.line = ctxp->p_line->lineno;
    }

  save_lineno = lineno;
  prev_lineno = lineno = elc.line;
  prev_msg = msg;

  code_from_source = java_get_line_col (ctxp->filename, elc.line, elc.col);
  obstack_grow0 (&temporary_obstack, 
		 code_from_source, strlen (code_from_source));
  remainder = obstack_finish (&temporary_obstack);
  if (do_warning)
    warning ("%s.\n%s", msg, remainder);
  else
    error ("%s.\n%s", msg, remainder);

  /* This allow us to cheaply avoid an extra 'Invalid expression
     statement' error report when errors have been already reported on
     the same line. This occurs when we report an error but don't have
     a synchronization point other than ';', which
     expression_statement is the only one to take care of.  */
  ctxp->prevent_ese = lineno = save_lineno;
}

static void
parse_error (msg)
     char *msg;
{
  java_error (NULL);
  java_error (msg);
}

/* Issue an error message at a current source line CL */

static void
parse_error_context VPROTO ((tree cl, char *msg, ...))
{
#ifndef __STDC__
  tree cl;
  char *msg;
#endif
  char buffer [4096];
  va_list ap;

  VA_START (ap, msg);
#ifndef __STDC__
  cl = va_arg (ap, tree);
  msg = va_arg (ap, char *);
#endif
  vsprintf (buffer, msg, ap);

  force_error = 1;
  ctxp->elc.line = EXPR_WFL_LINENO (cl);
  ctxp->elc.col  = (EXPR_WFL_COLNO (cl) == 0xfff ? -1 : EXPR_WFL_COLNO (cl));

  parse_error (buffer);
  force_error = 0;
}

/* Issue a warning at a current source line CL */

static void
parse_warning_context VPROTO ((tree cl, char *msg, ...))
{
#ifndef __STDC__
  tree cl;
  char *msg;
#endif
  char buffer [4096];
  va_list ap;

  VA_START (ap, msg);
#ifndef __STDC__
  cl = va_arg (ap, tree);
  msg = va_arg (ap, char *);
#endif
  vsprintf (buffer, msg, ap);

  force_error = do_warning = 1;
  ctxp->elc.line = EXPR_WFL_LINENO (cl);
  ctxp->elc.col  = (EXPR_WFL_COLNO (cl) == 0xfff ? -1 : EXPR_WFL_COLNO (cl));

  parse_error (buffer);
  do_warning = force_error = 0;
}

void
java_report_errors ()
{
  if (java_error_count)
    fprintf (stderr, "%d error%s", 
	     java_error_count, (java_error_count == 1 ? "" : "s"));
  if (java_warning_count)
    fprintf (stderr, "%s%d warning%s", (java_error_count ? ", " : ""),
	     java_warning_count, (java_warning_count == 1 ? "" : "s"));
  if (java_error_count || java_warning_count)
    putc ('\n', stderr);
}

static char *
java_accstring_lookup (flags)
     int flags;
{
  static char buffer [80];
#define COPY_RETURN(S) {strcpy (buffer, S); return buffer;}

  /* Access modifier looked-up first for easier report on forbidden
     access. */
  if (flags & ACC_PUBLIC) COPY_RETURN ("public");
  if (flags & ACC_PRIVATE) COPY_RETURN ("private");
  if (flags & ACC_PROTECTED) COPY_RETURN ("protected");
  if (flags & ACC_STATIC) COPY_RETURN ("static");
  if (flags & ACC_FINAL) COPY_RETURN ("final");
  if (flags & ACC_SYNCHRONIZED) COPY_RETURN ("synchronized");
  if (flags & ACC_VOLATILE) COPY_RETURN ("volatile");
  if (flags & ACC_TRANSIENT) COPY_RETURN ("transient");
  if (flags & ACC_NATIVE) COPY_RETURN ("native");
  if (flags & ACC_INTERFACE) COPY_RETURN ("interface");
  if (flags & ACC_ABSTRACT) COPY_RETURN ("abstract");

  buffer [0] = '\0';
  return buffer;
#undef COPY_RETURN
}

static void
redefinition_error (context, id, decl, cl)
     char *context;
     tree id, decl, cl;
{
  parse_error_context (cl, "%s `%s' already defined in %s:%d", 
		       context, IDENTIFIER_POINTER (id), 
		       DECL_SOURCE_FILE (decl), DECL_SOURCE_LINE (decl));
  /* Here we should point out where its redefined. It's a unicode. FIXME */
}

/* Build something that the type identifier resolver will identify as
   being an array to an unresolved type. TYPE_WFL is a WFL on a
   identifier. */

static tree
build_unresolved_array_type (type_or_wfl)
     tree type_or_wfl;
{
  char *ptr;

  /* TYPE_OR_WFL might be an array on a primitive type. In this case,
     just create a array type */
  if (TREE_CODE (type_or_wfl) == RECORD_TYPE)
    {
      tree type = build_java_array_type (type_or_wfl, -1);
      CLASS_LOADED_P (type) = CLASS_LOADED_P (type_or_wfl);
      return type;
    }

  obstack_1grow (&temporary_obstack, '[');
  obstack_grow0 (&temporary_obstack,
		 IDENTIFIER_POINTER (EXPR_WFL_NODE (type_or_wfl)),
		 IDENTIFIER_LENGTH (EXPR_WFL_NODE (type_or_wfl)));
  ptr = obstack_finish (&temporary_obstack);
  return build_expr_wfl (get_identifier (ptr),
			 EXPR_WFL_FILENAME (type_or_wfl),
			 EXPR_WFL_LINENO (type_or_wfl),
			 EXPR_WFL_COLNO (type_or_wfl));
}

/* Check modifiers. If one doesn't fit, retrieve it in its declaration line
  and point it out.  */

static void
check_modifiers (message, value, mask)
     char *message;
     int value;
     int mask;
{
  /* Should point out the one that don't fit. ASCII/unicode,
     going backward. FIXME */
  if (value & ~mask)
    {
      int i, remainder = value & ~mask;
      for (i = 0; i <= 10; i++)
        if ((1 << i) & remainder)
	  parse_error_context (ctxp->modifier_ctx [i], message, 
			       java_accstring_lookup (1 << i));
    }
}

static void
parser_add_interface (class_decl, interface_decl, wfl)
     tree class_decl, interface_decl, wfl;
{
  if (maybe_add_interface (TREE_TYPE (class_decl), TREE_TYPE (interface_decl)))
    parse_error_context (wfl, "Interface `%s' repeated",
			 IDENTIFIER_POINTER (DECL_NAME (interface_decl)));
}

/* Bulk of common class/interface checks. Return 1 if an error was
   encountered. TAG is 0 for a class, 1 for an interface.  */

static int
check_class_interface_creation (is_interface, flags, raw_name, qualified_name, decl, cl)
     int is_interface, flags;
     tree raw_name, qualified_name, decl, cl;
{
  tree node;

  if (!quiet_flag)
    fprintf (stderr, " %s %s", (is_interface ? "interface" : "class"), 
	     IDENTIFIER_POINTER (qualified_name));

  /* Scope of an interface/class type name:
       - Can't be imported by a single type import
       - Can't already exists in the package */
  if (IS_A_SINGLE_IMPORT_CLASSFILE_NAME_P (raw_name)
      && (node = find_name_in_single_imports (raw_name)))
    {
      parse_error_context 
	(cl, "%s name `%s' clashes with imported type `%s'",
	 (is_interface ? "Interface" : "Class"),
	 IDENTIFIER_POINTER (raw_name), IDENTIFIER_POINTER (node));
      return 1;
    }
  if (decl && CLASS_COMPLETE_P (decl))
    {
      redefinition_error ((is_interface ? "Interface" : "Class"), 
			  qualified_name, decl, cl);
      return 1;
    }

  /* If public, file name should match class/interface name */
  if (flags & ACC_PUBLIC)
    {
      char *f;

      /* Contains OS dependent assumption on path separator. FIXME */
      for (f = &input_filename [strlen (input_filename)]; 
	   f != input_filename && f[0] != '/'; f--);
      if (f[0] == '/')
	f++;
      if (strncmp (IDENTIFIER_POINTER (raw_name), 
		   f , IDENTIFIER_LENGTH (raw_name)) ||
	  f [IDENTIFIER_LENGTH (raw_name)] != '.')
	parse_error_context (cl, "Public %s `%s' must be defined in a file "
			     "called `%s.java'", 
			     (is_interface ? "interface" : "class"),
			     IDENTIFIER_POINTER (qualified_name),
			     IDENTIFIER_POINTER (raw_name));
    }

  check_modifiers ((is_interface ? 
		    "Illegal modifier `%s' for interface declaration" :
		    "Illegal modifier `%s' for class declaration"), flags,
		   (is_interface ? INTERFACE_MODIFIERS : CLASS_MODIFIERS));
  return 0;
}

/* If DECL is NULL, create and push a new DECL, record the current
   line CL and do other maintenance things.  */

static tree
maybe_create_class_interface_decl (decl, qualified_name, cl)
     tree decl, qualified_name, cl;
{
  if (decl)
    DECL_ARTIFICIAL (decl) = 1; /* FIXME */
  else
    decl = push_class (make_class (), qualified_name);
  
  /* Take care of the file and line business */
  DECL_SOURCE_FILE (decl) = EXPR_WFL_FILENAME (cl);
  DECL_SOURCE_LINE (decl) = EXPR_WFL_LINENO (cl);
  CLASS_FROM_SOURCE_P (TREE_TYPE (decl)) = 1;

  ctxp->current_parsed_class = decl;
  
  /* Link the declaration to the already seen ones */
  TREE_CHAIN (decl) = ctxp->class_list;
  ctxp->class_list = decl;
  /* Install a new dependency list element */
  create_jdep_list (ctxp);

  SOURCE_FRONTEND_DEBUG (("Defining class/interface %s", 
			  IDENTIFIER_POINTER (qualified_name)));
  return decl;
}

static void
add_superinterfaces (decl, interface_list)
     tree decl, interface_list;
{
  tree node;
  /* Superinterface(s): if present and defined, parser_check_super_interface ()
     takes care of ensuring that:
       - This is an accessible interface type,
       - Circularity detection.
   parser_add_interface is then called. If present but not defined,
   the check operation is delayed until the super interface gets
   defined.  */
  for (node = interface_list; node; node = TREE_CHAIN (node))
    {
      tree current = TREE_PURPOSE (node), interface_decl;
      if ((interface_decl = IDENTIFIER_CLASS_VALUE (EXPR_WFL_NODE (current))))
	{
	  if (!parser_check_super_interface (interface_decl, decl, current))
	    parser_add_interface (decl, interface_decl, current);
	}
      else
	register_incomplete_type (JDEP_INTERFACE,
				  current, decl, NULL_TREE);
    }
}

/* Create an interface in pass1 and return its decl. Return the
   interface's decl in pass 2.  */

static tree
create_interface (flags, id, super)
     int flags;
     tree id, super;
{
  int chk;
  tree raw_name = EXPR_WFL_NODE (id);
  tree q_name = parser_qualified_classname (id);
  tree decl = IDENTIFIER_CLASS_VALUE (q_name);

  EXPR_WFL_NODE (id) = q_name;	/* Keep source location, even if refined. */

  /* Basic checks: scope, redefinition, modifiers */ 
  if (check_class_interface_creation (1, flags, raw_name, q_name, decl, id))
    return NULL_TREE;

  /* Interface modifiers check
       - public/abstract allowed (already done at that point)
       - abstract is obsolete (comes first, it's a warning, or should be)
       - Can't use twice the same (checked in the modifier rule) */
  if (flags & ACC_ABSTRACT)
    parse_warning_context 
      (MODIFIER_WFL (ABSTRACT_TK),
       "Obsolete use of `abstract' modifier. Interface `%s' is implicitely "
       "abstract", IDENTIFIER_POINTER (raw_name));
  if (flags & ACC_PUBLIC && flags & ACC_ABSTRACT)
    parse_error_context 
      (MODIFIER_WFL (ABSTRACT_TK),
       "Can't specify both `public' and `abstract' modifiers in the "
       "definition of interface `%s'", IDENTIFIER_POINTER (raw_name));

  /* Create a new decl if DECL is NULL, otherwise fix it */
  decl = maybe_create_class_interface_decl (decl, q_name, id);

  /* Set super info and mark the class a complete */
  set_super_info (ACC_ABSTRACT | ACC_INTERFACE | flags, TREE_TYPE (decl), 
		  object_type_node, ctxp->interface_number);
  ctxp->interface_number = 0;
  CLASS_COMPLETE_P (decl) = 1;
  add_superinterfaces (decl, super);

  return decl;
}

/* Create an class in pass1 and return its decl. Return class
   interface's decl in pass 2.  */

static tree
create_class (flags, id, super, interfaces)
     int flags;
     tree id, super, interfaces;
{
  int chk;
  tree raw_name = EXPR_WFL_NODE (id);
  tree class_id, decl;
  tree super_decl = NULL, super_decl_type;

  class_id = parser_qualified_classname (id);
  decl = IDENTIFIER_CLASS_VALUE (class_id);
  EXPR_WFL_NODE (id) = class_id;

  /* Basic check: scope, redefinition, modifiers */
  if (check_class_interface_creation (0, flags, raw_name, class_id, decl, id))
    return NULL_TREE;

  /* Class modifier check: 
       - Allowed modifier (already done at that point)
       - abstract AND final forbidden 
       - Public classes defined in the correct file */
  if ((flags & ACC_ABSTRACT) && (flags & ACC_FINAL))
    parse_error_context (id, "Class `%s' can't be declared both abstract "
			 "and final", IDENTIFIER_POINTER (raw_name));

  /* Create a new decl if DECL is NULL, otherwise fix it */
  decl = maybe_create_class_interface_decl (decl, class_id, id);

  /* If SUPER exists, use it, otherwise use Object */
  if (super)
    {
      /* Can't extend java.lang.Object */
      if (TREE_TYPE (IDENTIFIER_CLASS_VALUE (class_id)) == object_type_node)
	{
	  parse_error_context (id, "Can't extend `java.lang.Object'");
	  return NULL_TREE;
	}

      /* The class is known and exists if there is a decl. Otherwise,
         postpone the operation and do it later. */
      super_decl = IDENTIFIER_CLASS_VALUE (EXPR_WFL_NODE (super));
      if (super_decl)
	{
	  parser_check_super (super_decl, decl, id);
	  super_decl_type = TREE_TYPE (super_decl);
	}
      else
	super_decl_type = 
	  register_incomplete_type (JDEP_SUPER, super, decl, NULL_TREE);
    }
  else if (TREE_TYPE (decl) != object_type_node)
    super_decl_type = object_type_node;
  /* We're defining java.lang.Object */
  else
    super_decl_type = NULL_TREE;

  /* Set super info and mark the class a complete */
  set_super_info (flags, TREE_TYPE (decl), super_decl_type, 
		  ctxp->interface_number);
  ctxp->interface_number = 0;
  CLASS_COMPLETE_P (decl) = 1;
  add_superinterfaces (decl, interfaces);

  return decl;
}

/* Can't use lookup_field () since we don't want to load the class and
   can't set the CLASS_LOADED_P flag */

static tree
find_field (class, name)
     tree class;
     tree name;
{
  tree decl;
  for (decl = TYPE_FIELDS (class); decl; decl = TREE_CHAIN (decl))
    {
      if (DECL_NAME (decl) == name)
	return decl;
    }
  return NULL_TREE;
}

/* Wrap around lookup_field that doesn't potentially upset the value
   of CLASS */

static tree
lookup_field_wrapper (class, name)
     tree class, name;
{
  tree type = class;
  return lookup_field (&type, name);
}

/* Find duplicate field within the same class declarations and report
   the error */

static int
duplicate_declaration_error (class, new_field_name, new_type, cl)
     tree class, new_field_name, new_type, cl;
{
  /* This might be modified to work with method decl as well */
  tree decl = find_field (TREE_TYPE (ctxp->current_parsed_class), 
			  new_field_name);
  if (decl)
    {
      char *t1 = strdup ((char *)lang_printable_name (new_type, 1));
      char *t2 = 
	strdup ((TREE_CODE (TREE_TYPE (decl)) == TREE_LIST ?
		 IDENTIFIER_POINTER (TYPE_NAME 
				     (TREE_PURPOSE (TREE_TYPE (decl)))) :
		 (char *)lang_printable_name (TREE_TYPE (decl), 1)));
      parse_error_context 
	(cl , "Duplicate variable declaration: `%s %s' was `%s %s' (%s:%d)", 
	 t1, IDENTIFIER_POINTER (new_field_name),
	 t2, IDENTIFIER_POINTER (DECL_NAME (decl)),
	 DECL_SOURCE_FILE (decl), DECL_SOURCE_LINE (decl));
      free (t1);
      free (t2);
      return 0;
    }
  return 1;
}

/* Field registration routine. If TYPE doesn't exist, field
   declarations are linked to the undefined TYPE dependency list, to
   be later resolved in java_complete_class () */

static void
register_fields (flags, type, variable_list)
     int flags;
     tree type, variable_list;
{
  tree current, type_decl, returned_type;
  tree class_type = TREE_TYPE (ctxp->current_parsed_class);
  int saved_lineno = lineno;
  int must_chain = 0;
  tree wfl = NULL_TREE;

  /* If we're adding fields to interfaces, those fields are public,
     static, final */
  if (CLASS_INTERFACE (TYPE_NAME (class_type)))
    {
      OBSOLETE_MODIFIER_WARNING (MODIFIER_WFL (PUBLIC_TK),
				 flags, ACC_PUBLIC, 
				 "%s", "interface field(s)");
      OBSOLETE_MODIFIER_WARNING (MODIFIER_WFL (STATIC_TK),
				 flags, ACC_STATIC, 
				 "%s", "interface field(s)");
      OBSOLETE_MODIFIER_WARNING (MODIFIER_WFL (FINAL_TK),
				 flags, ACC_FINAL, "%s", "interface field(s)");
      check_modifiers ("Illegal interface member modifier `%s'", flags,
		       INTERFACE_FIELD_MODIFIERS);
      flags |= (ACC_PUBLIC | ACC_STATIC | ACC_FINAL);
    }

  if (unresolved_type_p (type, &returned_type))
    {
      if (returned_type)
	type = returned_type;
      else
	{
	  wfl = type;
	  type = obtain_incomplete_type (type);
	  must_chain = 1;
	}
    }

  for (current = variable_list; current; current = TREE_CHAIN (current))
    {
      tree cl = TREE_PURPOSE (current);
      tree init = TREE_VALUE (current);
      tree current_name = EXPR_WFL_NODE (cl);

      if (duplicate_declaration_error (class_type, current_name, type, cl))
        {
	  tree field_decl;
	  lineno = EXPR_WFL_LINENO (cl);
	  field_decl = add_field (class_type, current_name, type, flags);

	  /* Check if we must chain. */
	  if (must_chain)
	    register_incomplete_type (JDEP_FIELD, wfl, field_decl, type);
	  
	  /* Default value of a static field is 0 and it is considered
             initialized. */
	  if (flags & ACC_STATIC)
	    INITIALIZED_P (field_decl) = 1;

	  /* If we have an initialization value tied to the field */
	  if (init)
	    {
	      /* The field is declared static */
	      if (flags & ACC_STATIC)
		{
		  /* FIXME */
		  if (flags & ACC_FINAL)
		    ;		
		  /* Otherwise, the field should be initialized in
		     <clinit>. This field is remembered so we can
		     generate <clinit> later. */
		  else
		    {
		      INITIALIZED_P (field_decl) = 1;
		      TREE_CHAIN (init) = ctxp->static_initialized;
		      ctxp->static_initialized = init;
		    }
		}
	      /* A non-static field declared with an immediate
		 initialization is to be initialized in <init>, if
		 any.  This field is remembered to be processed at the
		 time of the generation of <init>. */
	      else
		{
		  TREE_CHAIN (init) = ctxp->non_static_initialized;
		  ctxp->non_static_initialized = init;
		}
	    }
	}
    }
  lineno = saved_lineno;
}

/* Check whether it is necessary to generate a <clinit> for the class
   we just parsed. */

static void
maybe_generate_clinit ()
{
  int saved_lineno;
  tree meth, mdecl, c;
  tree cclass, class_wfl;

  if (!ctxp->static_initialized || java_error_count)
    return;

  cclass = TREE_TYPE (ctxp->current_parsed_class);
  class_wfl = build_expr_wfl (DECL_NAME (TYPE_NAME (cclass)),
			      input_filename, 0, 0);
  
  saved_lineno = lineno;
  lineno = 0;
  meth = make_node (FUNCTION_TYPE);
  TREE_TYPE (meth) = void_type_node;
  TYPE_ARG_TYPES (meth) = NULL_TREE;
  mdecl = add_method (cclass, ACC_STATIC, clinit_identifier_node,
		     build_java_signature (meth));
  lineno = saved_lineno;

  DECL_SOURCE_LINE (mdecl) = 1;
  DECL_SOURCE_LINE_MERGE (mdecl, 1);
  source_start_java_method (mdecl);
  enter_block ();

  /* Keep initialization in order to enforce 8.5 */
  ctxp->static_initialized = nreverse (ctxp->static_initialized);

  /* We process the list of assignment we produced as the result of
     the declaration of initialized static field and add them as
     statement to the <clinit> method. */
  for (c = ctxp->static_initialized; c; c = TREE_CHAIN (c))
    {
      /* We build the assignment expression that will initialize the
	 field to its value. There are strict rules on static
	 initializers (8.5). FIXME */
      java_method_add_stmt (mdecl, c);
    }

  BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (mdecl)) = exit_block ();
  exit_block ();
  ctxp->static_initialized = NULL_TREE;
}

/* Shared accros method_declarator and method_header to remember the
   patch stage that was reached during the declaration of the method.
   A method DECL is built differently is there is no patch
   (JDEP_NO_PATCH) or a patch (JDEP_METHOD or JDEP_METHOD_RETURN)
   pending on the currently defined method.  */

static int patch_stage;

/* Check the method declaration and add the method to its current
   class.  If the argument list is known to contain incomplete types,
   the method is partially added and the registration will be resume
   once the method arguments resolved  */

static tree
method_header (flags, type, mdecl, throws)
     int flags;
     tree type, mdecl, throws;
{
  tree meth = TREE_VALUE (mdecl);
  tree id = TREE_PURPOSE (mdecl);
  tree this_class = TREE_TYPE (ctxp->current_parsed_class);
  tree handle_class = CLASS_TO_HANDLE_TYPE (this_class);
  tree meth_name, returned_type;
  int saved_lineno;
  
  check_modifiers_consistency (flags);
  
  /* There are some forbidden modifiers for an abstract method and its
     class must be abstract as well.  */
  if (flags & ACC_ABSTRACT)
    {
      ABSTRACT_CHECK (flags, ACC_PRIVATE, id, "Private");
      ABSTRACT_CHECK (flags, ACC_STATIC, id, "Static");
      ABSTRACT_CHECK (flags, ACC_FINAL, id, "Final");
      ABSTRACT_CHECK (flags, ACC_NATIVE, id, "Native");
      ABSTRACT_CHECK (flags, ACC_SYNCHRONIZED,id, "Synchronized");
      if (!CLASS_ABSTRACT (TYPE_NAME (this_class)))
	parse_error_context 
	  (id, "Class `%s' must be declared abstract to define abstract "
	   "method `%s'", 
	   IDENTIFIER_POINTER (DECL_NAME (ctxp->current_parsed_class)),
	   IDENTIFIER_POINTER (EXPR_WFL_NODE (id)));
    }


  /* Method declared within the scope of an interface are implicitly
     abstract and public. Conflicts with other erroneously provided
     modifiers are check right after. */

  if (CLASS_INTERFACE (TYPE_NAME (this_class)))
    {
      /* If FLAGS isn't set because of a modifier, turn the
	 corresponding modifier WFL to NULL so we issue a warning on
	 the obsolete use of the modifier */
      if (!(flags & ACC_PUBLIC))
        MODIFIER_WFL (PUBLIC_TK) = NULL;
      if (!(flags & ACC_ABSTRACT))
        MODIFIER_WFL (ABSTRACT_TK) = NULL;
      flags |= ACC_PUBLIC;
      flags |= ACC_ABSTRACT;
    }

  /* Modifiers context reset moved up, so abstract method declaration
     modifiers can be later checked.  */

  meth_name = EXPR_WFL_NODE (id);

  if (unresolved_type_p (type, &returned_type))
    {
      if (returned_type)
	TREE_TYPE (meth) = returned_type;
      else 
	{
	  patch_stage = JDEP_METHOD_RETURN;
	  TREE_TYPE (meth) = 
	    register_incomplete_type (patch_stage, type, id, NULL_TREE);
	}
    }
  else
    TREE_TYPE (meth) = type;

  saved_lineno = lineno;
  /* When defining an abstract or interface method, the curly
     bracket at level 1 doesn't exist because there is no function
     body */
  lineno = (ctxp->first_ccb_indent1 ? ctxp->first_ccb_indent1 : 
	    EXPR_WFL_LINENO (id));

  if (patch_stage)		/* includes ret type and/or all args */
    {
      jdep *jdep;
      meth = add_method_1 (this_class, flags, meth_name, meth);
      /* Patch for the return type */
      if (patch_stage == JDEP_METHOD_RETURN)
	{
	  jdep = CLASSD_LAST (ctxp->classd_list);
	  JDEP_GET_PATCH (jdep) = &TREE_TYPE (TREE_TYPE (meth));
	}
      /* This is the stop JDEP. METH allows the function's signature
	 to be computed. */
      register_incomplete_type (JDEP_METHOD_END, NULL_TREE, meth, NULL_TREE);
    }
  else
    {
      tree signature = build_java_signature (meth);
      tree arg, orig_arg;
      /* Save original argument list, including argument's names */
      orig_arg = TYPE_ARG_TYPES (meth);
      /* Add the method to its class */
      meth = add_method (this_class, flags, meth_name, signature);
      /* Fix the method argument list so we have the argument name
         information */
      arg = TYPE_ARG_TYPES (TREE_TYPE (meth));
      if (TREE_CODE (TREE_TYPE (meth)) == METHOD_TYPE)
	{
	  TREE_PURPOSE (arg) = this_identifier_node;
	  arg = TREE_CHAIN (arg);
	}
      while (orig_arg)
        {
	  TREE_PURPOSE (arg) = TREE_PURPOSE (orig_arg);
	  orig_arg = TREE_CHAIN (orig_arg);
	  arg = TREE_CHAIN (arg);
	}
    }
  DECL_MAX_LOCALS (meth) = ctxp->formal_parameter_number+1;
  lineno = saved_lineno;
  /* We set the DECL_NAME to ID so we can track the location where
     the function was declared. This allow us to report
     redefinition error accurately. When method are verified,
     DECL_NAME is reinstalled properly (using the content of the
     WFL node ID) (see check_method_redefinition). We don't do that
     when Object is being defined. */
  if (TREE_TYPE (ctxp->current_parsed_class) != object_type_node)
    DECL_NAME (meth) = id;
  return meth;
}

/* Check modifiers that can be declared but exclusively */

static void
check_modifiers_consistency (flags)
     int flags;
{
  int acc_count = 0;
  tree cl = NULL_TREE;

  THIS_MODIFIER_ONLY (flags, ACC_PUBLIC, 0, acc_count, cl);
  THIS_MODIFIER_ONLY (flags, ACC_PRIVATE, 1, acc_count, cl);
  THIS_MODIFIER_ONLY (flags, ACC_PROTECTED, 2, acc_count, cl);
  if (acc_count > 1)
    parse_error_context
      (cl, "Inconsistent member declaration. At most one of `public', "
       "`private', or `protected' may be specified");
}

/* Check the methode header METH for abstract specifics features */

static void
check_abstract_method_header (meth)
     tree meth;
{
  int flags = get_access_flags_from_decl (meth);
  /* DECL_NAME might still be a WFL node */
  tree name = (TREE_CODE (DECL_NAME (meth)) == EXPR_WITH_FILE_LOCATION ?
	       EXPR_WFL_NODE (DECL_NAME (meth)) : DECL_NAME (meth));

  OBSOLETE_MODIFIER_WARNING (MODIFIER_WFL (ABSTRACT_TK), flags,
			     ACC_ABSTRACT, "abstract method `%s'",
			     IDENTIFIER_POINTER (name));
  OBSOLETE_MODIFIER_WARNING (MODIFIER_WFL (PUBLIC_TK), flags, 
			     ACC_PUBLIC, "abstract method `%s'",
			     IDENTIFIER_POINTER (name));

  check_modifiers ("Illegal modifier `%s' for interface method",
		  flags, INTERFACE_METHOD_MODIFIERS);
}

/* Create a FUNCTION_TYPE node and start augmenting it with the
   declared function arguments. Arguments type that can't be resolved
   are left as they are, but the returned node is marked as containing
   incomplete types.  */

static tree
method_declarator (id, list)
     tree id, list;
{
  tree arg_types = NULL_TREE, current, node;
  tree meth = make_node (FUNCTION_TYPE);
  jdep *jdep;
  int incomplete = 0;

  patch_stage = JDEP_NO_PATCH;
  
  for (current = list; current; current = TREE_CHAIN (current))
    {
      tree wfl_name = TREE_PURPOSE (current);
      tree type = TREE_VALUE (current);
      tree name = EXPR_WFL_NODE (wfl_name);
      tree patchable_type = NULL_TREE, already;
      tree arg_node, returned_type;

      /* Check redefinition */
      for (already = arg_types; already; already = TREE_CHAIN (already))
	if (TREE_PURPOSE (already) == name)
	  {
	    parse_error_context 
	      (wfl_name, "Variable `%s' is used more than once in the "
	       "argument list of method `%s'", IDENTIFIER_POINTER (name),
	       IDENTIFIER_POINTER (EXPR_WFL_NODE (id)));
	    break;
	  }

      /* If we've an incomplete argument type, we know there is a location
	 to patch when the type get resolved, later.  */
      jdep = NULL;
      if (unresolved_type_p (type, &returned_type))
	{
	  if (returned_type)
	    type = returned_type;
	  else
	    {
	      patch_stage = JDEP_METHOD;
	      type = register_incomplete_type (patch_stage, type, 
					       wfl_name, NULL_TREE);
	      jdep = CLASSD_LAST (ctxp->classd_list);
	      JDEP_MISC (jdep) = id;
	    }
	}
      /* The argument node: a name and a (possibly) incomplete type */
      arg_node = build_tree_list (name, type);
      if (jdep)
	JDEP_GET_PATCH (jdep) = &TREE_VALUE (arg_node);
      TREE_CHAIN (arg_node) = arg_types;
      arg_types = arg_node;
    }
  TYPE_ARG_TYPES (meth) = nreverse (arg_types);
  node = build_tree_list (id, meth);
  return node;
}

static int
unresolved_type_p (wfl, returned)
     tree wfl;
     tree *returned;
     
{
  if (TREE_CODE (wfl) == EXPR_WITH_FILE_LOCATION)
    {
      tree decl = IDENTIFIER_CLASS_VALUE (EXPR_WFL_NODE (wfl));
      if (returned)
	*returned = (decl ? TREE_TYPE (decl) : NULL_TREE);
      return 1;
    }
  if (returned)
    *returned = wfl;
  return 0;
}

/* From NAME, build a qualified identifier node using the
   qualification from the current package definition. */

static tree
parser_qualified_classname (name)
     tree name;
{
  if (ctxp->package)
    return merge_qualified_name (ctxp->package, EXPR_WFL_NODE (name));
  else 
    return EXPR_WFL_NODE (name);
}

/* Called once the type a interface extends is resolved. Returns 0 if
   everything is OK.  */

static int
parser_check_super_interface (super_decl, this_decl, this_wfl)
     tree super_decl, this_decl, this_wfl;
{
  tree super_type = TREE_TYPE (super_decl);

  /* Has to be an interface */
  if (!CLASS_INTERFACE (TYPE_NAME (TREE_TYPE (super_decl))))
    {
      parse_error_context 
	(this_wfl, "Can't use %s `%s' to implement/extend %s `%s'",
	 (TYPE_ARRAY_P (super_type) ? "array" : "class"),
	 IDENTIFIER_POINTER (DECL_NAME (super_decl)),
	 (CLASS_INTERFACE (TYPE_NAME (TREE_TYPE (this_decl))) ? 
	  "interface" : "class"),
	 IDENTIFIER_POINTER (DECL_NAME (this_decl)));
      return 1;
    }

  /* Check scope: same package OK, other package: OK if public */
  if (check_pkg_class_access (DECL_NAME (super_decl), lookup_cl (this_decl)))
    return 1;

  SOURCE_FRONTEND_DEBUG (("Completing interface %s with %s",
			  IDENTIFIER_POINTER (DECL_NAME (this_decl)),
			  IDENTIFIER_POINTER (DECL_NAME (super_decl))));
  return 0;
}

/* Makes sure that SUPER_DECL is suitable to extend THIS_DECL. Returns
   0 if everthing is OK.  */

static int
parser_check_super (super_decl, this_decl, wfl)
     tree super_decl, this_decl, wfl;
{
  tree this_type  = TREE_TYPE (this_decl);
  tree super_type = TREE_TYPE (super_decl);

  /* SUPER should be a CLASS (neither an array nor an interface) */
  if (TYPE_ARRAY_P (super_type) || CLASS_INTERFACE (TYPE_NAME (super_type)))
    {
      parse_error_context 
	(wfl, "Class `%s' can't subclass %s `%s'",
	 IDENTIFIER_POINTER (DECL_NAME (this_decl)),
	 (CLASS_INTERFACE (TYPE_NAME (super_type)) ? "interface" : "array"),
	 IDENTIFIER_POINTER (DECL_NAME (super_decl)));
      return 1;
    }

  if (CLASS_FINAL (TYPE_NAME (super_type)))
    {
      parse_error_context (wfl, "Can't subclass final classes: %s",
			   IDENTIFIER_POINTER (DECL_NAME (super_decl)));
      return 1;
    }

  /* Check scope: same package OK, other package: OK if public */
  if (check_pkg_class_access (DECL_NAME (super_decl), wfl))
    return 1;
  
  SOURCE_FRONTEND_DEBUG (("Completing class %s with %s",
			  IDENTIFIER_POINTER (DECL_NAME (this_decl)),
			  IDENTIFIER_POINTER (DECL_NAME (super_decl))));
  return 0;
}

/* Create a new dependency list and link it (in a LIFO manner) to the
   CTXP list of type dependency list.  */

static void
create_jdep_list (ctxp)
     struct parser_ctxt *ctxp;
{
  jdeplist *new = malloc (sizeof (jdeplist));	
  
  if (!new)
    fatal ("Can't alloc jdeplist - create_jdep_list");
    
  new->first = new->last = NULL;
  new->next = ctxp->classd_list;
  ctxp->classd_list = new;
}

static jdeplist *
reverse_jdep_list (ctxp)
     struct parser_ctxt *ctxp;
{
  register jdeplist *prev = NULL, *current, *next;
  for (current = ctxp->classd_list; current; current = next)
    {
      next = current->next;
      current->next = prev;
      prev = current;
    }
  return prev;
}

/* Create a fake pointer based on the ID stored in the WFL */

static tree
obtain_incomplete_type (wfl)
     tree wfl;
{
  tree ptr;
  tree name = EXPR_WFL_NODE (wfl);

  for (ptr = ctxp->incomplete_class; ptr; ptr = TREE_CHAIN (ptr))
    if (TYPE_NAME (TREE_PURPOSE (ptr)) == name)
      break;

  if (!ptr)
    {
      tree core;
      push_obstacks (&permanent_obstack, &permanent_obstack);
      BUILD_PTR_FROM_NAME (core, name);
      ptr = build_tree_list (core, NULL_TREE);
      pop_obstacks ();
      TREE_CHAIN (ptr) = ctxp->incomplete_class;
      ctxp->incomplete_class = ptr;
    }

  return ptr;
}

/* Register a incomplete type whose name is WFL. Reuse PTR if PTR is
   non NULL instead of computing a new fake type based on WFL. The new
   dependency is inserted in the current type dependency list, in FIFO
   manner.  */

static tree
register_incomplete_type (kind, wfl, decl, ptr)
     int kind;
     tree wfl, decl, ptr;
{
  jdep *new = malloc (sizeof (jdep));

  if (!new)
    fatal ("Can't allocate new jdep - register_incomplete_type");
  if (!ptr && kind != JDEP_METHOD_END) /* JDEP_METHOD_END is a mere marker */
    ptr = obtain_incomplete_type (wfl);

  JDEP_KIND (new) = kind;
  JDEP_DECL (new) = decl;
  JDEP_SOLV (new) = ptr;
  JDEP_WFL (new) = wfl;
  JDEP_CHAIN (new) = NULL;
  JDEP_MISC (new) = NULL_TREE;
  JDEP_GET_PATCH (new) = (tree *)NULL;

  JDEP_INSERT (ctxp->classd_list, new);

  return ptr;
}

void
java_check_circular_reference ()
{
  tree current;
  for (current = ctxp->class_list; current; current = TREE_CHAIN (current))
    {
      tree type = TREE_TYPE (current);
      if (CLASS_INTERFACE (TYPE_NAME (type)))
	{
	  /* Check all interfaces this class extends */
	  tree basetype_vec = TYPE_BINFO_BASETYPES (type);
	  int n, i;

	  if (!basetype_vec)
	    return;
	  n = TREE_VEC_LENGTH (basetype_vec);
	  for (i = 0; i < n; i++)
	    {
	      tree vec_elt = TREE_VEC_ELT (basetype_vec, i);
	      if (vec_elt && BINFO_TYPE (vec_elt) != object_type_node 
		  && interface_of_p (type, BINFO_TYPE (vec_elt)))
		parse_error_context (lookup_cl (current),
				     "Cyclic interface inheritance");
	    }
	}
      else
	if (inherits_from_p (CLASSTYPE_SUPER (type), type))
	  parse_error_context (lookup_cl (current), 
			       "Cyclic class inheritance");
    }
}

void
safe_layout_class (class)
     tree class;
{
  tree save_current_class = current_class;
  char *save_input_filename = input_filename;
  int save_lineno = lineno;
  
  push_obstacks (&permanent_obstack, &permanent_obstack);
  layout_class (class);
  pop_obstacks ();
  
  current_class = save_current_class;
  input_filename = save_input_filename;
  lineno = save_lineno;
  CLASS_LOADED_P (class) = 1;
}

static tree
jdep_resolve_class (dep)
     jdep *dep;
{
  tree decl;

  if (!JDEP_RESOLVED_P (dep))
    {
      decl = 
	resolve_class (JDEP_TO_RESOLVE (dep), JDEP_DECL (dep), JDEP_WFL (dep));
      JDEP_RESOLVED (dep, decl);
    }
  else
    decl = JDEP_RESOLVED_DECL (dep);

  if (!decl)
    {
      complete_class_report_errors (dep);
      return NULL_TREE;
    }
  return decl;
}

/* Complete unsatisfied class declaration and their dependencies */

void
java_complete_class ()
{
  tree current;
  tree cclass;
  jdeplist *cclassd;
  int error_found;

  push_obstacks (&permanent_obstack, &permanent_obstack);

  /* Process imports and reverse the import on demand list */
  process_imports ();
  if (ctxp->import_demand_list)
    ctxp->import_demand_list = nreverse (ctxp->import_demand_list);

  /* Rever things so we have the right order */
  ctxp->class_list = nreverse (ctxp->class_list);
  ctxp->classd_list = reverse_jdep_list (ctxp);
    
  for (cclassd = ctxp->classd_list, cclass = ctxp->class_list; 
       cclass && cclassd; 
       cclass = TREE_CHAIN (cclass), cclassd = CLASSD_CHAIN (cclassd))
    {
      jdep *dep;
      for (dep = CLASSD_FIRST (cclassd); dep; dep = JDEP_CHAIN (dep))
	{
	  tree decl;

	  if (!(decl = jdep_resolve_class (dep)))
	    continue;

	  /* Now it's time to patch */
	  switch (JDEP_KIND (dep))
	    {
	    case JDEP_SUPER:
	      /* Simply patch super */
	      if (parser_check_super (decl, JDEP_DECL (dep), JDEP_WFL (dep)))
		continue;
	      BINFO_TYPE (TREE_VEC_ELT (BINFO_BASETYPES (TYPE_BINFO 
	        (TREE_TYPE (JDEP_DECL (dep)))), 0)) = TREE_TYPE (decl);
	      break;

	    case JDEP_FIELD:
	      {
		/* We do part of the job done in add_field */
		tree field_decl = JDEP_DECL (dep);
		tree field_type = TREE_TYPE (decl);
		push_obstacks (&permanent_obstack, &permanent_obstack);
#if ! JAVA_PROMOTE_TO_INT
		if (TREE_CODE (field_type) == RECORD_TYPE)
#endif
		  field_type = promote_type (field_type);
		pop_obstacks ();
		TREE_TYPE (field_decl) = field_type;
		SOURCE_FRONTEND_DEBUG 
		  (("Completed field/var decl `%s' with `%s'",
		    IDENTIFIER_POINTER (DECL_NAME (field_decl)),
		    IDENTIFIER_POINTER (DECL_NAME (decl))));
		break;
	      }
	    case JDEP_METHOD:	/* We start patching a method */
	    case JDEP_METHOD_RETURN:
	      error_found = 0;
	      while (1)
		{
		  if (decl)
		    {
		      tree type = promote_type (TREE_TYPE(decl));
		      JDEP_APPLY_PATCH (dep, type);
		      SOURCE_FRONTEND_DEBUG 
			(((JDEP_KIND (dep) == JDEP_METHOD_RETURN ?
			   "Completing fct `%s' with ret type `%s'":
			   "Completing arg `%s' with type `%s'"),
			  IDENTIFIER_POINTER (EXPR_WFL_NODE 
					      (JDEP_DECL_WFL (dep))),
			  IDENTIFIER_POINTER (DECL_NAME (decl))));
		    }
		  else
		    error_found = 1;
		  dep = JDEP_CHAIN (dep);
		  if (JDEP_KIND (dep) == JDEP_METHOD_END)
		    break;
		  else
		    decl = jdep_resolve_class (dep);
		}
	      if (!error_found)
		{
		  tree mdecl = JDEP_DECL (dep), signature;
		  push_obstacks (&permanent_obstack, &permanent_obstack);
		  /* Recompute and reset the signature */
		  signature = build_java_signature (TREE_TYPE (mdecl));
		  set_java_signature (TREE_TYPE (mdecl), signature);
		  pop_obstacks ();
		}
	      else
		continue;
	      break;

	    case JDEP_INTERFACE:
	      if (parser_check_super_interface (decl, JDEP_DECL (dep),
						JDEP_WFL (dep)))
		continue;
	      parser_add_interface (JDEP_DECL (dep), decl, JDEP_WFL (dep));
	      break;

	    case JDEP_VARIABLE:
	      JDEP_APPLY_PATCH (dep, promote_type (TREE_TYPE (decl)));
	      SOURCE_FRONTEND_DEBUG 
		(("Completing variable `%s' with type `%s'",
		  (TREE_CODE (JDEP_DECL_WFL (dep)) == EXPR_WITH_FILE_LOCATION ?
		   IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_DECL_WFL (dep))) :
		   IDENTIFIER_POINTER (DECL_NAME (JDEP_DECL_WFL (dep)))),
		  IDENTIFIER_POINTER (DECL_NAME (decl))));
	      break;

	    case JDEP_TYPE:
	      JDEP_APPLY_PATCH (dep, TREE_TYPE (decl));
	      SOURCE_FRONTEND_DEBUG 
		(("Completing a random type dependency on a '%s' node",
		  tree_code_name [TREE_CODE (JDEP_DECL (dep))]));
	      break;

	    case JDEP_PARM:
	      JDEP_APPLY_PATCH (dep, promote_type (TREE_TYPE (decl)));
	      SOURCE_FRONTEND_DEBUG 
		(("Completing parameter `%s' with type `%s'",
		  IDENTIFIER_POINTER (JDEP_MISC (dep)),
		  IDENTIFIER_POINTER (DECL_NAME (decl))));
	      break;

	    default:
	      fatal ("incomplete switch - java_complete_class");
	    }
	}
    }
  pop_obstacks ();
  return;
}

/* Resolve class CLASS_TYPE. Handle the case of trying to resolve an
   array.  */

static tree
resolve_class (class_type, decl, cl)
     tree class_type, decl, cl;
{
  char *name = IDENTIFIER_POINTER (TYPE_NAME (class_type));
  char *base = name;
  tree resolved_type, resolved_type_decl;
  
  /* 1- Check to see if we have an array. If true, find what we really
     want to resolve  */
  while (name[0] == '[')
    name++;
  if (base != name)
    TYPE_NAME (class_type) = get_identifier (name);

  /* 2- Resolve the bare type */
  if (!(resolved_type_decl = do_resolve_class (class_type, decl, cl)))
    return NULL_TREE;
  resolved_type = TREE_TYPE (resolved_type_decl);

  /* 3- If we have and array, reconstruct the array down to its nesting */
  if (base != name)
    {
      while (base != name)
	{
	  if (TREE_CODE (resolved_type) == RECORD_TYPE)
	    resolved_type  = promote_type (resolved_type);
	  resolved_type = build_java_array_type (resolved_type, -1);
	  name--;
	}
      /* Build a fake decl for this, since this is what is expected to
         be returned.  */
      resolved_type_decl =
	build_decl (TYPE_DECL, TYPE_NAME (resolved_type), resolved_type);
      /* Figure how those two things are important for error report. FIXME */
      DECL_SOURCE_LINE (resolved_type_decl) = 0;
      DECL_SOURCE_FILE (resolved_type_decl) = input_filename;
    }
  return resolved_type_decl;
}

/* Effectively perform the resolution of class CLASS_TYPE. DECL or CL
   are used to report error messages.  */

static tree
do_resolve_class (class_type, decl, cl)
     tree class_type;
     tree decl;
     tree cl;
{
  tree new_class_decl;
  tree original_name = NULL_TREE;

  /* Do not try to replace TYPE_NAME (class_type) by a variable, since
     its is changed by find_in_imports{_on_demand} */

  /* 1- Check for the type in single imports */
  if (find_in_imports (class_type))
    return NULL_TREE;

  /* 2- And check for the type in the current compilation unit. If it fails,
     try with a name qualified with the package name if appropriate. */

  if ((new_class_decl = IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type))))
    {
      if (!CLASS_LOADED_P (TREE_TYPE (new_class_decl)) &&
	  !CLASS_FROM_SOURCE_P (TREE_TYPE (new_class_decl)))
	load_class (TYPE_NAME (class_type), 0);
      return IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type));
    }

  original_name = TYPE_NAME (class_type);
  if (!QUALIFIED_P (TYPE_NAME (class_type)) && ctxp->package)
    TYPE_NAME (class_type) = merge_qualified_name (ctxp->package, 
						   TYPE_NAME (class_type));
  if ((new_class_decl = IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type))))
    {
      if (!CLASS_LOADED_P (TREE_TYPE (new_class_decl)) &&
	  !CLASS_FROM_SOURCE_P (TREE_TYPE (new_class_decl)))
	load_class (TYPE_NAME (class_type), 0);
      return IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type));
    }
  TYPE_NAME (class_type) = original_name;

  /* 3- Check an other compilation unit that bears the name of type */
  load_class (TYPE_NAME (class_type), 0);
  if (check_pkg_class_access (TYPE_NAME (class_type), 
			      (cl ? cl : lookup_cl (decl))))
    return NULL_TREE;

  if ((new_class_decl = IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type))))
    return new_class_decl;

  /* 4- Check the import on demands. Don't allow bar.baz to be
     imported from foo.* */
  if (!QUALIFIED_P (TYPE_NAME (class_type)))
    if (find_in_imports_on_demand (class_type))
      return NULL_TREE;

  /* 5- Last call for a resolution */
  return IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type));
}

/* Resolve NAME and lay it out (if not done and if not the current
   parsed class). Return a decl node.  */

static tree
resolve_and_layout (name, cl)
     tree name;
     tree cl;
{
  tree decl = resolve_no_layout (name, cl);
  if (decl && TREE_TYPE (decl) != current_class 
      && !CLASS_LOADED_P (TREE_TYPE (decl)))
    safe_layout_class (TREE_TYPE (decl));
  return decl;
}

/* Resolve a class, returns its decl but doesn't perform any
   layout. The current parsing context is saved and restored */

static tree
resolve_no_layout (name, cl)
     tree name, cl;
{
  tree ptr, decl;
  BUILD_PTR_FROM_NAME (ptr, name);
  java_parser_context_save_global ();
  decl = resolve_class (ptr, NULL_TREE, cl);
  java_parser_context_restore_global ();
  
  return decl;
}

/* Called to report errors. Skip leader '[' in a complex array type
   description that failed to be resolved. */

static char *
purify_type_name (name)
     char *name;
{
  while (*name && *name == '[')
    name++;
  return name;
}

/* The type CURRENT refers to can't be found. We print error messages.  */

static void
complete_class_report_errors (dep)
     jdep *dep;
{
  switch (JDEP_KIND (dep))
    {
    case JDEP_SUPER:
      parse_error_context  
	(JDEP_WFL (dep), "Superclass `%s' of class `%s' not found",
	 IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep))),
	 IDENTIFIER_POINTER (DECL_NAME (JDEP_DECL (dep))));
      break;
    case JDEP_FIELD:
      parse_error_context
	(JDEP_WFL (dep), "Type `%s' not found in declaration of field `%s'",
	 IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep))),
	 IDENTIFIER_POINTER (DECL_NAME (JDEP_DECL (dep))));
      break;
    case JDEP_METHOD:		/* Covers arguments */
      parse_error_context
	(JDEP_WFL (dep), "Type `%s' not found in the declaration of the "
	 "argument `%s' of method `%s'",
	 IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep))),
	 IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_DECL_WFL (dep))),
	 IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_MISC (dep))));
      break;
    case JDEP_METHOD_RETURN:	/* Covers return type */
      parse_error_context
	(JDEP_WFL (dep), "Type `%s' not found in the declaration of the "
	 "return type of method `%s'", 
	 IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep))),
	 IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_DECL_WFL (dep))));
      break;
    case JDEP_INTERFACE:
      parse_error_context
	(JDEP_WFL (dep), "Superinterface `%s' of %s `%s' not found",
	 IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep))),
	 (CLASS_OR_INTERFACE (JDEP_DECL (dep), "class", "interface")),
	 IDENTIFIER_POINTER (DECL_NAME (JDEP_DECL (dep))));
      break;
    case JDEP_VARIABLE:
      parse_error_context
	(JDEP_WFL (dep), "Type `%s' not found in the declaration of the "
	 "local variable `%s'", 
	 purify_type_name (IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep)))),
	 IDENTIFIER_POINTER (DECL_NAME (JDEP_DECL (dep))));
      break;
    }
}

/* Check uninitialized final.  */

void
java_check_final ()
{
}

static int
check_method_redefinition (class, method)
     tree class, method;
{
  tree redef, name;
  tree cl = DECL_NAME (method);
  tree sig = TYPE_LANG_SPECIFIC (TREE_TYPE (method))->signature;
  /* decl name of generated <clinit> doesn't need to be fixed and
     checked */
  if (DECL_NAME (method) != clinit_identifier_node)
    {
      /* NAME is just the plain name when Object is being defined */
      if (class != object_type_node)
	name = DECL_NAME (method) = EXPR_WFL_NODE (DECL_NAME (method));
      else
	name = DECL_NAME (method);
    }
  else 
    return 0;
  
  for (redef = TYPE_METHODS (class); redef; redef = TREE_CHAIN (redef))
    {
      struct lang_type *t = TYPE_LANG_SPECIFIC (TREE_TYPE (redef));
      
      if (! t || (redef == method))
	break;
      if (DECL_NAME (redef) == name && sig == t->signature)
	{
	  parse_error_context (cl, "Duplicate method declaration");
	  return 1;
	}
    }
  return 0;
}

/* Check all the methods of CLASS. Methods are first completed then
   checked according to regular method existance rules.
   If no constructor were encountered, then build its declaration. */

static void
java_check_regular_methods (class_decl)
     tree class_decl;
{
  tree method;
  tree class = CLASS_TO_HANDLE_TYPE (TREE_TYPE (class_decl));
  tree super_class = CLASSTYPE_SUPER (class);
  int seen_constructor = 0;

  TYPE_METHODS (class) = nreverse (TYPE_METHODS (class));

  /* Should take interfaces into account. FIXME */
  for (method = TYPE_METHODS (class); method; method = TREE_CHAIN (method))
    {
      tree found, sig;
      tree method_wfl = DECL_NAME (method);
      int aflags;

      if (DECL_CONSTRUCTOR_P (method))
	seen_constructor = 1;

      /* Check for redefinitions */
      if (check_method_redefinition (class, method))
	continue;

      sig = build_java_argument_signature (TREE_TYPE (method));

      found = lookup_argument_method (super_class, DECL_NAME (method), sig);
      if (! found)
        continue;
      /* Can't override a method with the same name and different return
	 types. */
      if (TREE_TYPE (TREE_TYPE (found)) != TREE_TYPE (TREE_TYPE (method)))
	parse_warning_context 
	  (method_wfl,
	   "Method `%s' redefined with different return type in class `%s'",
	   lang_printable_name (found),
	   IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));

      /* Can't override final. Can't override static. */
      if (METHOD_FINAL (found) || METHOD_STATIC (found))
	{
	  /* Static *can* override static */
	  if (METHOD_STATIC (found) && METHOD_STATIC (method))
	    continue;
	  parse_error_context 
	    (method_wfl,
	     "%s methods can't be overriden. Method `%s' is %s in class `%s'",
	     (METHOD_FINAL (found) ? "Final" : "Static"),
	     lang_printable_name (found),
	     (METHOD_FINAL (found) ? "final" : "static"),
	     IDENTIFIER_POINTER
	       (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));
	  continue;
	}
      /* Static method can't override instance method. */
      if (METHOD_STATIC (method))
	{
	  parse_error_context 
	    (method_wfl,
	     "Instance methods can't be overriden by a static method. Method "
	     "`%s' is an instance method in class `%s'",
	     lang_printable_name (found),
	     IDENTIFIER_POINTER
	       (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));
	  continue;
	}
      /* Overriding/hiding public must be public or
	 overriding/hiding protected must be protected or public */
      if ((METHOD_PUBLIC (found) && !METHOD_PUBLIC (method)) ||
	  (METHOD_PROTECTED (found) 
	   && !(METHOD_PUBLIC (method) || METHOD_PROTECTED (method))))
	{
	  parse_error_context 
	    (method_wfl,
	     "Methods can't be overridden to be more private. Method `%s' is "
	     "%s in class `%s'", lang_printable_name (found),
	     (METHOD_PUBLIC (found) ? "public" : "protected"),
	     IDENTIFIER_POINTER 
	       (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));
	  continue;
	}

      /* If the method has default access in an other package, then
      issue a warning that the current method doesn't override the one
      that was found elsewhere */
      aflags = get_access_flags_from_decl (found);
      if ((!aflags || (aflags > ACC_PROTECTED))
	  && !class_in_current_package (DECL_CONTEXT (found)))
	parse_warning_context 
	  (method_wfl, "Method `%s' in class `%s' does not "
	   "override the corresponding method in class `%s', which is "
	   "private to a different package",
	   lang_printable_name (found),
	   IDENTIFIER_POINTER (DECL_NAME (class_decl)),
	   IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));

      /* Check on (default) package access. FIXME.  */
      /* Inheriting multiple methods with the same signature. FIXME */
    }
  
  TYPE_METHODS (class) = nreverse (TYPE_METHODS (class));

  if (!seen_constructor)
    {
      /* No constructor seen, we craft one, at line 0 */
      int saved_lineno = lineno;
      tree meth, decl;
      lineno = 0;
      meth = make_node (FUNCTION_TYPE);
      TREE_TYPE (meth) = void_type_node;
      TYPE_ARG_TYPES (meth) = NULL_TREE; 
      decl = add_method (class, 0, init_identifier_node,
			 build_java_signature (meth));
      DECL_CONSTRUCTOR_P (decl) = 1;
      lineno = saved_lineno;
    }
}

/* Check abstract method of interface INTERFACE */

static void
java_check_abstract_methods (interface)
     tree interface;
{
  int i, n;
  tree method, basetype_vec, found;

  for (method = TYPE_METHODS (interface); method; method = TREE_CHAIN (method))
    {
      char *csig;
      tree name = DECL_NAME (method);

      /* 2- Check for double definition inside the defining interface */
      if (check_method_redefinition (interface, method))
	continue;

      /* 3- Overriding is OK as far as we preserve the return type and
	 the thrown exceptions */
      found = lookup_java_interface_method2 (interface, method);
      if (found)
	{
	  parse_error_context 
	    (lookup_cl (method),
	     "Method `%s' previously defined in interface `%s' is "
	     "redefined with different return type in interface `%s'",
	     lang_printable_name (found),
	     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))),
	     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (interface))));
	  continue;
	}
    }

  /* 4- Inherited methods can't differ by their returned types */
  if (!(basetype_vec = TYPE_BINFO_BASETYPES (interface)))
    return;
  n = TREE_VEC_LENGTH (basetype_vec);
  for (i = 0; i < n; i++)
    {
      tree sub_interface_method, sub_interface;
      tree vec_elt = TREE_VEC_ELT (basetype_vec, i);
      if (!vec_elt)
	continue;
      sub_interface = BINFO_TYPE (vec_elt);
      for (sub_interface_method = TYPE_METHODS (sub_interface); 
	   sub_interface_method;
	   sub_interface_method = TREE_CHAIN (sub_interface_method))
	{
	  found = lookup_java_interface_method2 (interface, 
						 sub_interface_method);
	  if (found && (found != sub_interface_method))
	    parse_error_context 
	      (lookup_cl (sub_interface_method),
	       "Interface `%s' inherits method `%s' from interface `%s'. This "
	       "method is redefined with a different return "
	       "type in interface `%s'",
	       IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (interface))),
	       lang_printable_name (found),
	       IDENTIFIER_POINTER 
	         (DECL_NAME (TYPE_NAME (DECL_CONTEXT (sub_interface_method)))),
	       IDENTIFIER_POINTER 
	         (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));
	}
    }
}

/* Check the method on all the defined classes. Should be done to the
   classes declared in the compilation unit only. FIXME  */

void
java_check_methods ()
{

  tree current;
  for (current = ctxp->class_list; current; current = TREE_CHAIN (current))
    if (CLASS_FROM_SOURCE_P (TREE_TYPE (current)))
      {
	tree class = CLASS_TO_HANDLE_TYPE (TREE_TYPE (current));

	if (CLASS_INTERFACE (TYPE_NAME (class)))
	  java_check_abstract_methods (class);
	else
	  java_check_regular_methods (current);
      }
}

/* Lookup methods in interfaces using their name and partial
   signature. Return a matching method only if their types differ.  */

static tree
lookup_java_interface_method2 (class, method_decl)
     tree class, method_decl;
{
  int i, n;
  tree basetype_vec = TYPE_BINFO_BASETYPES (class), to_return;

  if (!basetype_vec)
    return NULL_TREE;

  n = TREE_VEC_LENGTH (basetype_vec);
  for (i = 0; i < n; i++)
    {
      tree vec_elt = TREE_VEC_ELT (basetype_vec, i), to_return;
      if ((BINFO_TYPE (vec_elt) != object_type_node)
	  && (to_return = 
	      lookup_java_method2 (BINFO_TYPE (vec_elt), method_decl, 1)))
	return to_return;
    }
  for (i = 0; i < n; i++)
    {
      to_return = lookup_java_interface_method2 
	(BINFO_TYPE (TREE_VEC_ELT (basetype_vec, i)), method_decl);
      if (to_return)
	return to_return;
    }

  return NULL_TREE;
}

/* Lookup method using their name and partial signature. Return a
   matching method only if their types differ.  */

static tree
lookup_java_method2 (clas, method_decl, do_interface)
     tree clas, method_decl;
     int do_interface;
{
  tree method, method_signature, method_name, method_type;
  method_signature = build_java_argument_signature (TREE_TYPE (method_decl));
  method_name = DECL_NAME (method_decl);
  method_type = TREE_TYPE (TREE_TYPE (method_decl));

  while (clas != NULL_TREE)
    {
      for (method = TYPE_METHODS (clas);
	   method != NULL_TREE;  method = TREE_CHAIN (method))
	{
	  tree method_sig = build_java_argument_signature (TREE_TYPE (method));
	  if (DECL_NAME (method) == method_name 
	      && method_sig == method_signature 
	      && TREE_TYPE (TREE_TYPE (method)) != method_type)
	    {
	      return method;
	    }
	}
      clas = (do_interface ? NULL_TREE : CLASSTYPE_SUPER (clas));
    }
  return NULL_TREE;
}

/* Return the line that matches DECL line number. Used during error
   report */

static tree
lookup_cl (decl)
     tree decl;
{
  static tree cl = NULL_TREE;
  
  if (!decl)
    return NULL_TREE;

  if (cl == NULL_TREE)
    cl = build_expr_wfl (NULL_TREE, NULL, 0, 0);

  EXPR_WFL_FILENAME_NODE (cl) = get_identifier (DECL_SOURCE_FILE (decl));
  EXPR_WFL_SET_LINECOL (cl, DECL_SOURCE_LINE_FIRST (decl), -1);

  return cl;
}

/* Look for a simple name in the single-type import list */

static tree
find_name_in_single_imports (name)
     tree name;
{
  tree node;

  for (node = ctxp->import_list; node; node = TREE_CHAIN (node))
    if (TREE_VALUE (node) == name)
      return (EXPR_WFL_NODE (TREE_PURPOSE (node)));

  return NULL_TREE;
}

/* Process all single-type import. */

static int
process_imports ()
{
  tree import;
  int error_found;

  for (import = ctxp->import_list; import; import = TREE_CHAIN (import))
    {
      tree to_be_found = EXPR_WFL_NODE (TREE_PURPOSE (import));

      /* Don't load twice something already defined. */
      if (IDENTIFIER_CLASS_VALUE (to_be_found))
	continue;
      QUALIFIED_P (to_be_found) = 1;
      load_class (to_be_found, 0);
      error_found =
	check_pkg_class_access (to_be_found, TREE_PURPOSE (import));
      if (!IDENTIFIER_CLASS_VALUE (to_be_found))
	{
	  parse_error_context (TREE_PURPOSE (import),
			       "Class or interface `%s' not found in import",
			       IDENTIFIER_POINTER (to_be_found));
	  return 1;
	}
      if (error_found)
	return 1;
    }
  return 0;
}

/* Possibly find a class imported by a single-type import statement. Return
   1 if an error occured, 0 otherwise. */

static int
find_in_imports (class_type)
     tree class_type;
{
  tree import;

  for (import = ctxp->import_list; import; import = TREE_CHAIN (import))
    if (TREE_VALUE (import) == TYPE_NAME (class_type))
      {
	TYPE_NAME (class_type) = EXPR_WFL_NODE (TREE_PURPOSE (import));
	QUALIFIED_P (TYPE_NAME (class_type)) = 1;
	return check_pkg_class_access (TYPE_NAME (class_type), 
				       TREE_PURPOSE (import));
      }
  return 0;
}

/* Process a import on demand statement (lazy) */

static int
read_import_entry (jcf, dirp, returned_name)
     JCF *jcf;
     DIR *dirp;
     char **returned_name;
{
  if (dirp)
    {
      struct dirent *direntp = readdir (dirp);
      if (!direntp)
	{
	  *returned_name = NULL;
	  return 0;
	}
      else
	{
	  *returned_name = direntp->d_name;
	  return (strlen (direntp->d_name));
	}
    }
  else
    {
      int current_dir_len = strlen (jcf->classname);
      char *current_entry;
      int current_entry_len;

      /* Here we read a zip directory as a file directory. The files
	 we're selecting must have the same root than the directory
	 we're examining. */

      ZipDirectory *zipd = (ZipDirectory *)jcf->zipd; 

      while (zipd)
	{
	  current_entry = ZIPDIR_FILENAME (zipd);
	  current_entry_len = zipd->filename_length;
	  while (current_entry_len && current_entry [current_entry_len] != '/')
	    current_entry_len--;
	  /* If the path of the current file doesn't match the directory we're
	     scanning, that the end of the search */
	  current_entry_len++;
	  if (strncmp (jcf->classname, current_entry, current_dir_len))
	    {
	      *returned_name = NULL;
	      return 0;
	    }
	  /* Ok, we have at least the same path. The position of the last '/'
	     of the current file we're examining should match the size of
	     name of the directory we're browsing, otherwise that an entry
	     belonging to a sub directory, we want to skip it. */
	  if (current_entry_len != current_dir_len)
	    zipd = ZIPDIR_NEXT (zipd);
	  else
	    {
	      jcf->zipd = ZIPDIR_NEXT (zipd); /* Prepare next read */
	      *returned_name = &current_entry [current_entry_len];
	      return (zipd->filename_length - current_entry_len);
	    }
	}
    }
}

/* Read a import directory, gathering potential match for further type
   references. Indifferently reads a filesystem or a ZIP archive
   directory.  */

static void
read_import_dir (wfl)
     tree wfl;
{
  char *name = IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl));
  int name_len = IDENTIFIER_LENGTH (EXPR_WFL_NODE (wfl)), reclen;
  DIR *dirp = NULL;
  tree dirname = ident_subst (name, name_len, "", '.', '/', "");
  JCF jcfr, *jcf, *saved_jcf = current_jcf;
  char *founddirname, *d_name;
  struct ZipFileCache zip_cache;

  jcf = &jcfr;
  if (!classpath)
    fix_classpath ();
  if (!(founddirname = find_class (name, name_len, jcf, 0)))
    fatal ("Can't import `%s'", name);
  if (jcf->outofsynch)
    jcf_out_of_synch (jcf);
  if (jcf->seen_in_zip)
    jcf->zipd = ZIPDIR_NEXT ((ZipDirectory *)jcf->zipd);

  else if (founddirname && (dirp = opendir (founddirname)))
    {
      readdir (dirp); readdir (dirp);
    }

  if (!founddirname && !dirp)
    {
      static int first = 1;
      if (first)
	{
	  char buffer [256];
	  sprintf (buffer, "Can't find default package `%s'. Check "
		   "the CLASSPATH environment variable and the access to the "
		   "archives.", name);
	  error (buffer);
	  java_error_count++;
	  first = 0;
	}
      else
	parse_error_context (wfl, "Package `%s' not found in import", name);
      current_jcf = saved_jcf;
      return;
    }

  /* Here we should have a unified way of retrieving an entry, to be
     indexed. */
  while ((reclen = read_import_entry (jcf, dirp, &d_name)))
    {
      int java_or_class = 0;
      int len; 
      if ((reclen > 5) 
	  && !strcmp (&d_name [reclen-5], ".java"))
	{
	  java_or_class = 1;
	  len = reclen - 5;
	}
	  
      if (!java_or_class && (reclen > 6) &&
	  !strcmp (&d_name [reclen-6], ".class"))
	{
	  java_or_class = 2;
	  len = reclen - 6;
	}

      if (java_or_class)
	{
	  char *id_name;
	  tree node, old;

	  obstack_grow (&temporary_obstack, name, name_len);
	  obstack_1grow (&temporary_obstack, '/');
	  obstack_grow0 (&temporary_obstack, d_name, len);
	  id_name = obstack_finish (&temporary_obstack);

	  node = get_identifier (id_name);
	  IS_A_CLASSFILE_NAME (node) = 1; /* Or soon to be */
	  QUALIFIED_P (node) = 1; /* As soon as we turn / into . */
	}
    }
  if (dirp)
    closedir (dirp);
  
  current_jcf = saved_jcf;
}

/* Possibly find a type in the import on demands specified
   types. Returns 1 if an error occured, 0 otherwise. Run throught the
   entire list, to detected potential double definitions.  */
		 
static int
find_in_imports_on_demand (class_type)
     tree class_type;
{
  tree node, import, node_to_use;
  int seen_once = -1;
  tree cl;

  for (import = ctxp->import_demand_list; import; import = TREE_CHAIN (import))
    {
      char *id_name;
      tree found;
      obstack_grow (&temporary_obstack, 
		    IDENTIFIER_POINTER (EXPR_WFL_NODE (TREE_PURPOSE (import))),
		    IDENTIFIER_LENGTH (EXPR_WFL_NODE (TREE_PURPOSE (import))));
      obstack_1grow (&temporary_obstack, '/');
      obstack_grow0 (&temporary_obstack, 
		     IDENTIFIER_POINTER (TYPE_NAME (class_type)),
		     IDENTIFIER_LENGTH (TYPE_NAME (class_type)));
      id_name = obstack_finish (&temporary_obstack);
	      
      node = maybe_get_identifier (id_name);
      if (node && IS_A_CLASSFILE_NAME (node))
	{
	  if (seen_once < 0)
	    {
	      cl = TREE_PURPOSE (import);
	      seen_once = 1;
	      node_to_use = node;
	    }
	  else
	    {
	      seen_once++;
	      parse_error_context 
		(import, "Type `%s' also potentially defined in package `%s'",
		 IDENTIFIER_POINTER (TYPE_NAME (class_type)),
		 IDENTIFIER_POINTER (EXPR_WFL_NODE (TREE_PURPOSE (import))));
	    }
	}
    }

  if (seen_once == 1)
    {
      /* Setup lineno so that it refers to the line of the import (in
	 case we parse a class file and encounter errors */
      tree decl;
      int saved_lineno = lineno;
      lineno = EXPR_WFL_LINENO (cl);
      TYPE_NAME (class_type) = ident_subst (IDENTIFIER_POINTER (node_to_use),
					    IDENTIFIER_LENGTH (node_to_use),
					    "", '/', '.', "");
      QUALIFIED_P (TYPE_NAME (class_type)) = 1;
      decl = IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type));
      /* If there is no DECL set for the class or if the class isn't
	 loaded and not seen in source yet, the load */
      if (!decl || (!CLASS_LOADED_P (TREE_TYPE (decl))
		    && !CLASS_FROM_SOURCE_P (TREE_TYPE (decl))))
	load_class (node_to_use, 0);
      lineno = saved_lineno;
      return check_pkg_class_access (TYPE_NAME (class_type), cl);
    }
  else
    return (seen_once < 0 ? 0 : seen_once); /* It's ok not to have found */
}

/* Check that CLASS_NAME refers to a PUBLIC class. Return 0 if no
   access violations were found, 1 otherwise.  */

static int
check_pkg_class_access (class_name, cl)
     tree class_name;
     tree cl;
{
  tree type;
  int access;

  if (!QUALIFIED_P (class_name) || !IDENTIFIER_CLASS_VALUE (class_name))
    return 0;

  if (!(type = TREE_TYPE (IDENTIFIER_CLASS_VALUE (class_name))))
    return 0;

  if (!CLASS_PUBLIC (TYPE_NAME (type)))
    {
      parse_error_context 
	(cl, "Can't access %s `%s'. Only public classes and interfaces in "
	 "other packages can be accessed",
	 (CLASS_INTERFACE (TYPE_NAME (type)) ? "interface" : "class"),
	 IDENTIFIER_POINTER (class_name));
      return 1;
    }
  return 0;
}

/* Local variable declaration. */

static void
declare_local_variables (modifier, type, vlist)
     int modifier;
     tree type;
     tree vlist;
{
  tree decl, current, returned_type, type_wfl, init_stmt = NULL_TREE;
  int must_chain = 0;

  /* Push a new block if statement were seen between the last time we
     pushed a block and now. Keep a cound of block to close */
  if (BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (current_function_decl)))
    {
      tree body = DECL_FUNCTION_BODY (current_function_decl);
      tree b = enter_block ();
      BLOCK_EXPR_ORIGIN(b) = body;
    }

  if (modifier)
    {
      int i;
      for (i = 0; i <= 10; i++) if (1 << i & modifier) break;
      parse_error_context 
	(ctxp->modifier_ctx [i],
	 (modifier == ACC_FINAL ?
	  "Unsupported JDK1.1 `final' locals" :
	  "Only `final' is allowed as a local variables modifier"));
      return;
    }

  if (unresolved_type_p (type, &returned_type))
    {
      if (returned_type)
        type = returned_type;
      else 
	{
	  type_wfl = type;
	  type = obtain_incomplete_type (type);
	  must_chain = 1;
	}
    }
  
  for (current = vlist; current; current = TREE_CHAIN (current))
    {
      tree wfl  = TREE_PURPOSE (current);
      tree name = EXPR_WFL_NODE (wfl);
      tree init = TREE_VALUE (current);
      tree other = lookup_name_in_blocks (name);

      /* Don't try to use an INIT statement when an error was found */
      if (init && java_error_count)
	init = NULL_TREE;

      if (other)
	parse_error_context 
	  (wfl, "Variable `%s' is already defined in this method and was "
	   "declared `%s %s' in line %d", 
	   IDENTIFIER_POINTER (name), lang_printable_name (TREE_TYPE (other)),
	   IDENTIFIER_POINTER (name), DECL_SOURCE_LINE (other));
      else
	{
	  if (!must_chain && TREE_CODE (type) == RECORD_TYPE)
	    type = promote_type (type);
	  /* Never layout this decl. This will be done when its scope
             will be entered */
	  decl = build_decl_no_layout (VAR_DECL, name, type);
	  BLOCK_CHAIN_DECL (decl);

	  /* Add the initialization function to the current function's code */
	  if (init)
	    {
	      tree wfl;
	      MODIFY_EXPR_FROM_INITIALIZATION_P (init) = 1;
	      java_method_add_stmt 
		(current_function_decl,
		 build_debugable_stmt (EXPR_WFL_LINECOL (init), init));
	    }

	  if (must_chain)
	    {
	      jdep *dep;
	      register_incomplete_type (JDEP_VARIABLE, type_wfl, decl, type);
	      dep = CLASSD_LAST (ctxp->classd_list);
	      JDEP_GET_PATCH (dep) = &TREE_TYPE (decl);
	    }
	}
    }
  SOURCE_FRONTEND_DEBUG (("Defined locals"));
}

/* Called during parsing. Build decls from argument list.  */

static void
source_start_java_method (fndecl)
     tree fndecl;
{
  tree tem;
  tree parm_decl;
  int i;

  extern tree current_binding_level;
  current_function_decl = fndecl;

  /* New scope for the function */
  enter_block ();
  for (tem = TYPE_ARG_TYPES (TREE_TYPE (fndecl)), i = 0;
       tem != NULL_TREE; tem = TREE_CHAIN (tem), i++)
    {
      tree type = TREE_VALUE (tem);
      tree name = TREE_PURPOSE (tem);
      
      /* If type is incomplete. Layout can't take place
	 now. Create an incomplete decl and ask for the decl to be
	 patched later */
      if (INCOMPLETE_TYPE_P (type))
	{
	  jdep *jdep;
	  parm_decl = build_decl_no_layout (PARM_DECL, name, type);
	  
	  register_incomplete_type (JDEP_PARM, NULL_TREE, NULL_TREE, type);
	  jdep = CLASSD_LAST (ctxp->classd_list);
	  JDEP_MISC (jdep) = name;
	  JDEP_GET_PATCH (jdep) = &TREE_TYPE (parm_decl);
	}
      else
	parm_decl = build_decl (PARM_DECL, name, type);

      BLOCK_CHAIN_DECL (parm_decl);
    }
  tem = BLOCK_EXPR_DECLS (DECL_FUNCTION_BODY (current_function_decl));
  BLOCK_EXPR_DECLS (DECL_FUNCTION_BODY (current_function_decl)) =
    nreverse (tem);
  DECL_ARG_SLOT_COUNT (current_function_decl) = i;
}

/* Called during expansion. Push decls formerly built from argument
   list so they're usable during expansion. */

static void
expand_start_java_method (fndecl)
     tree fndecl;
{
  tree tem, *ptr;
  tree parm_decl;

  extern tree current_binding_level;
  current_function_decl = fndecl;

  announce_function (fndecl);
  pushlevel (1);		/* Push parameters */
  ptr = &DECL_ARGUMENTS (fndecl);
  tem  = BLOCK_EXPR_DECLS (DECL_FUNCTION_BODY (current_function_decl));
  while (tem)
    {
      tree next = TREE_CHAIN (tem);
      DECL_ARG_TYPE (tem) = TREE_TYPE (tem);
      layout_decl (tem, 0);
      pushdecl (tem);
      INITIALIZED_P (tem) = 1;	/* Parms are initialized */
      *ptr = tem;
      ptr = &TREE_CHAIN (tem);
      tem = next;
    }
  *ptr = NULL_TREE;
  pushdecl_force_head (DECL_ARGUMENTS (fndecl));
  lineno = DECL_SOURCE_LINE_FIRST (fndecl);
  complete_start_java_method (fndecl); 
}

/* Terminate a function and expand its body.  */

static void
source_end_java_method ()
{
  tree fndecl = current_function_decl;

  java_parser_context_save_global ();
  lineno = ctxp->last_ccb_indent1;

  /* Generate function's code */
  if (BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (fndecl))
      && ! flag_emit_class_files)
    expand_expr_stmt (BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (fndecl)));

  /* pop out of its parameters */
  pushdecl_force_head (DECL_ARGUMENTS (fndecl));
  poplevel (1, 0, 1);
  BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;

  /* Generate rtl for function exit.  */
  if (! flag_emit_class_files)
    {
      lineno = DECL_SOURCE_LINE_LAST (fndecl);
      expand_function_end (input_filename, lineno, 0);

      /* Run the optimizers and output assembler code for this function. */
      rest_of_compilation (fndecl);
    }

  current_function_decl = NULL_TREE;
  /*  permanent_allocation (1); */
  java_parser_context_restore_global ();
}

/* Record EXPR in the current function block. Complements compound
   expression second operand if necessary.  */

tree
java_method_add_stmt (fndecl, expr)
     tree fndecl, expr;
{
  tree body = BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (fndecl));
  tree node;

  if (java_error_count)
    return body;
  if ((node = add_stmt_to_compound (body, NULL_TREE, expr)) == body)
    return body;

  BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (fndecl)) = node;
  TREE_SIDE_EFFECTS (node) = 1;
  return node;
}

/* Add STMT to EXISTING if possible, otherwise create a new
   COMPOUND_EXPR and add STMT to it. */

static tree
add_stmt_to_compound (existing, type, stmt)
     tree existing, type, stmt;
{
  tree node;

  if (existing && (TREE_CODE (existing) == COMPOUND_EXPR)
      && TREE_OPERAND (existing, 1) == size_zero_node)
    {
      TREE_OPERAND (existing, 1) = stmt;
      TREE_TYPE (existing) = type;
      return existing;
    }
  else if (existing)
    node = build (COMPOUND_EXPR, type, existing, stmt);
  else
    node = build (COMPOUND_EXPR, type, stmt, size_zero_node);
  
  return node;
}

/* Hold THIS for the scope of the current public method decl.  */
static tree current_this;

/* Layout all class found during parsing */

void
java_layout_classes ()
{
  tree current;
  for (current = ctxp->class_list; current; current = TREE_CHAIN (current))
    {
      current_class = TREE_TYPE (current);
      TYPE_FIELDS (current_class) = nreverse (TYPE_FIELDS (current_class));
      if (!TYPE_SIZE (current_class))
	safe_layout_class (current_class);
    }
}

/* Expand all methods in all registered classes.  */

void
java_complete_expand_methods ()
{
  tree current;
  
  for (current = ctxp->class_list; current; current = TREE_CHAIN (current))
    {
      extern tree current_constant_pool_data_ref;
      tree class_type = CLASS_TO_HANDLE_TYPE (TREE_TYPE (current));
      tree decl;
      int saved_lineno;

      current_class = TREE_TYPE (current);

      /* Initialize a new constant pool */
      init_outgoing_cpool ();

      /* Don't process function bodies in interfaces */
      if (!CLASS_INTERFACE (TYPE_NAME (current_class)))
	for (decl = TYPE_METHODS (class_type); decl; decl = TREE_CHAIN (decl))
	  {
	    current_function_decl = decl;
	    /* Don't generate debug info on line zero when expanding a
	       generated constructor. */
	    if (DECL_CONSTRUCTOR_P (decl) && !DECL_FUNCTION_BODY (decl))
	      {
		/* If we found errors, it's too dangerous to try to generate
		   and expand a constructor */
		if (!java_error_count)
		  {
		    restore_line_number_status (1);
		    java_complete_expand_method (decl);
		    restore_line_number_status (0);
		  }
	      }
	    else
	      java_complete_expand_method (decl);
	  }

      /* Make the class data, register it and run the rest of decl
         compilation on it */
      if (!java_error_count && ! flag_emit_class_files)
	{
	  make_class_data (current_class);
	  register_class ();
	  rest_of_decl_compilation (TYPE_NAME (current_class), (char*) 0, 1, 0);
	}
    }
}

/* Complete and expand a method.  */

static void
java_complete_expand_method (mdecl)
     tree mdecl;
{
  tree node;
  jdep *current;
  int no_ac_found = 1;

  /* We generate some code for an empty constructor */
  if (DECL_CONSTRUCTOR_P (mdecl) && !DECL_FUNCTION_BODY (mdecl))
    {
      tree arg_list, func, call;
      tree method_type = TREE_TYPE (mdecl);
      tree class_type = CLASS_TO_HANDLE_TYPE (current_class);
      tree self_type = (CLASSTYPE_SUPER (class_type) ? 
			CLASSTYPE_SUPER (class_type) : class_type);
      tree method_signature = 
	TYPE_LANG_SPECIFIC (method_type)->signature;
      tree method = 
	lookup_java_constructor (CLASS_TO_HANDLE_TYPE (self_type),
				 method_signature);
      tree block, compound;

      /* Fixe the begining/ending lines of the method so that with
         no_line_numbers set to 1 it doesn't generate debug info at
         line 1 for this artificial constructor. */
      DECL_SOURCE_LINE (mdecl) = 1;
      DECL_SOURCE_LINE_MERGE (mdecl, 1);
      source_start_java_method (mdecl);
      arg_list = BLOCK_EXPR_DECLS (DECL_FUNCTION_BODY (mdecl));
      enter_block ();
      func = build_known_method_ref (method, method_type, self_type,
				     method_signature, arg_list);
      
      if (! flag_emit_class_files)
	func = build1 (NOP_EXPR, build_pointer_type (method_type), func);
      call = build (CALL_EXPR, TREE_TYPE (method_type), func, 
		    build_tree_list (NULL_TREE, arg_list), NULL_TREE);
      TREE_SIDE_EFFECTS (call) = 1;
      call = build_class_init (self_type, call);
      compound = java_method_add_stmt (mdecl, call);
      block = exit_block ();
      BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (mdecl)) = block;
      /* The function decl, its block and the compound statement
         within this block are all of void type. */
      TREE_TYPE (block) = TREE_TYPE (compound) = 
	TREE_TYPE (DECL_FUNCTION_BODY (mdecl)) = void_type_node;
      exit_block ();
      no_ac_found = 0;
    }
  
  if (DECL_FUNCTION_BODY (mdecl))
    {
      expand_start_java_method (mdecl);

      current_this 
	= (!METHOD_STATIC (mdecl) ? 
	   BLOCK_EXPR_DECLS (DECL_FUNCTION_BODY (mdecl)) : NULL_TREE);

      if (BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (mdecl)) && no_ac_found)
	java_complete_tree (BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (mdecl)));
      /* Don't go any further if we've found error(s) during the
         expansion */
      if (!java_error_count)
	source_end_java_method ();
    }
}

/* Expand finals.  */

void
java_expand_finals ()
{
}

/* Wrap non WFL PRIMARY around a WFL and set EXPR_WFL_QUALIFICATION to
   a tree list node containing RIGHT. Fore coming RIGHTs will be
   chained to this hook. LOCATION contains the location of the
   separating `.' operator.  */

static tree
make_qualified_primary (primary, right, location)
     tree primary, right;
     int location;
{
  tree wfl;

  /* We want to process THIS . xxx symbolicaly, to keep it consistent
     with the way we're processing SUPER. A THIS from a primary as a
     different form than a SUPER. Turn THIS into something symbolic */
  if (TREE_CODE (primary) == JAVA_THIS_EXPR)
    {
      wfl = build_wfl_node (this_identifier_node, input_filename, 0, 0);
      EXPR_WFL_LINECOL (wfl) = EXPR_WFL_LINECOL (primary);
      wfl = make_qualified_name (wfl, right, location);
      PRIMARY_P (wfl) = 1;
      return wfl;
    }
  /* Other non WFL node are wrapped around a WFL */
  else if (TREE_CODE (primary) != EXPR_WITH_FILE_LOCATION)
    {
      wfl = build_expr_wfl (NULL_TREE, ctxp->filename, 0, 0);
      EXPR_WFL_LINECOL (wfl) = EXPR_WFL_LINECOL (primary);
      EXPR_WFL_QUALIFICATION (wfl) = build_tree_list (primary, NULL_TREE);
    }
  else
    {
      wfl = primary;
      if (!EXPR_WFL_QUALIFICATION (primary))
	EXPR_WFL_QUALIFICATION (primary) = 
	  build_tree_list (primary, NULL_TREE);
    }

  EXPR_WFL_LINECOL (right) = location;
  chainon (EXPR_WFL_QUALIFICATION (wfl), build_tree_list (right, NULL_TREE));
  PRIMARY_P (wfl) =  1;
  return wfl;
}

/* Simple merge of two name separated by a `.' */

static tree
merge_qualified_name (left, right)
     tree left, right;
{
  tree node;
  obstack_grow (&temporary_obstack, IDENTIFIER_POINTER (left),
		IDENTIFIER_LENGTH (left));
  obstack_1grow (&temporary_obstack, '.');
  obstack_grow0 (&temporary_obstack, IDENTIFIER_POINTER (right),
		 IDENTIFIER_LENGTH (right));
  node =  get_identifier (obstack_base (&temporary_obstack));
  obstack_free (&temporary_obstack, obstack_base (&temporary_obstack));
  QUALIFIED_P (node) = 1;
  return node;
}

/* Merge the two parts of a qualified name into LEFT.  Set the
   location information of the resulting node to LOCATION, usually
   inherited from the location information of the `.' operator. */

static tree
make_qualified_name (left, right, location)
     tree left, right;
     int location;
{
  int qualified;
  tree left_id = EXPR_WFL_NODE (left);
  tree right_id = EXPR_WFL_NODE (right);
  tree wfl, merge;

  merge = merge_qualified_name (left_id, right_id);

  /* Left wasn't qualified and is now qualified */
  if (!QUALIFIED_P (left_id))
    {
      tree wfl = build_expr_wfl (left_id, ctxp->filename, 0, 0);
      EXPR_WFL_LINECOL (wfl) = EXPR_WFL_LINECOL (left);
      EXPR_WFL_QUALIFICATION (left) = build_tree_list (wfl, NULL_TREE);
    }
  
  wfl = build_expr_wfl (right_id, ctxp->filename, 0, 0);
  EXPR_WFL_LINECOL (wfl) = location;
  chainon (EXPR_WFL_QUALIFICATION (left), build_tree_list (wfl, NULL_TREE));

  EXPR_WFL_NODE (left) = merge;
  return left;
}

/* Extract the last identifier component of the qualified in WFL. The
   last identifier is removed from the linked list */

static tree
cut_identifier_in_qualified (wfl)
     tree wfl;
{
  tree q;
  tree previous = NULL_TREE;
  for (q = EXPR_WFL_QUALIFICATION (wfl); ; previous = q, q = TREE_CHAIN (q))
    if (!TREE_CHAIN (q))
      {
	if (!previous)
	  fatal ("Operating on a non qualified qualified WFL - "
		 "cut_identifier_in_qualified");
	TREE_CHAIN (previous) = NULL_TREE;
	return TREE_PURPOSE (q);
      }
}

/* Resolve the expression name NAME. Return its decl.  */

static tree
resolve_expression_name (id)
     tree id;
{
  tree name = EXPR_WFL_NODE (id);
  tree decl;

  /* 6.5.5.1: Simple expression names */
  if (!PRIMARY_P (id) && !QUALIFIED_P (name))
    {
      /* 15.13.1: NAME can appear within the scope of a local variable
         declaration */
      if ((decl = IDENTIFIER_LOCAL_VALUE (name)))
        return decl;

      /* 15.13.1: NAME can appear within a class declaration */
      else 
        {
	  decl = lookup_field_wrapper (current_class, name);
	  if (decl)
	    {
	      int fs = FIELD_STATIC (decl);
	      /* Instance variable (8.3.1.1) can't appear within
		 static method, static initializer or initializer for
		 a static variable. */
	      if (!fs && METHOD_STATIC (current_function_decl))
	        {
		  parse_error_context 
		    (id, "Can't make a static reference to nonstatic variable "
		     "`%s' in class `%s'",
		     IDENTIFIER_POINTER (name),
		     IDENTIFIER_POINTER (DECL_NAME 
					 (TYPE_NAME (current_class))));
		  return error_mark_node;
		}
	      decl = build_field_ref ((fs ? NULL_TREE : current_this),
				      current_class, name);
	      return (fs ? build_class_init (current_class, decl) : decl);
	    }
	  /* Fall down to error report on undefined variable */
	}
    }
  /* 6.5.5.2 Qualified Expression Names */
  else
    {
      qualify_ambiguous_name (id);
      /* 15.10.1 Field Access Using a Primary and/or Expression Name */
      /* 15.10.2: Accessing Superclass Members using super */
      return resolve_field_access (id, NULL, NULL);
    }

  /* We've got an error here */
  parse_error_context (id, "Undefined variable `%s'", 
		       IDENTIFIER_POINTER (name));

  return error_mark_node;
}

/* 15.10.1 Field Acess Using a Primary and/or Expression Name.
   We return something suitable to generate the field access. We also
   return the field decl in FIELD_DECL and its type in FIELD_TYPE.  If
   recipient's address can be null. */

static tree
resolve_field_access (qual_wfl, field_decl, field_type)
     tree qual_wfl;
     tree *field_decl, *field_type;
{
  int is_static = 0;
  tree field_ref;
  tree decl, where_found, type_found;

  if (resolve_qualified_expression_name (qual_wfl, &decl,
					 &where_found, &type_found))
    return error_mark_node;

  /* Resolve the LENGTH field of an array here */
  if (DECL_NAME (decl) == length_identifier_node && TYPE_ARRAY_P (type_found)
      && ! flag_emit_class_files)
    {
      tree length = build_java_array_length_access (where_found);
      field_ref =
	build_java_arraynull_check (type_found, length, int_type_node);
    }
  /* We might have been trying to resolve field.method(). In which
     case, the resolution is over and decl is the answer */
  else if (DECL_P (decl) && IDENTIFIER_LOCAL_VALUE (DECL_NAME (decl)) == decl)
    field_ref = decl;
  else if (DECL_P (decl))
    {
      is_static = DECL_P (decl) && FIELD_STATIC (decl);
      field_ref = build_field_ref ((is_static ? NULL_TREE : where_found), 
				   type_found, DECL_NAME (decl));
      if (field_ref == error_mark_node)
	return error_mark_node;
      if (is_static)
	{
	  field_ref = build_class_init (type_found, field_ref);
	  /* If the static field was identified by an expression that
	     needs to be generated, make the field access a compound
	     expression whose first part of the evaluation of the
	     field selector part. */
	  if (where_found && TREE_CODE (where_found) != TYPE_DECL)
	    {
	      tree type = QUAL_DECL_TYPE (field_ref);
	      field_ref = build (COMPOUND_EXPR, type, where_found, field_ref);
	    }
	}
    }
  else
    field_ref = decl;

  if (field_decl)
    *field_decl = decl;
  if (field_type)
    *field_type = QUAL_DECL_TYPE (decl);
  return field_ref;
}

/* 6.5.5.2: Qualified Expression Names */

static int
resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)
     tree wfl;
     tree *found_decl, *type_found, *where_found;
{
  int from_type = 0;		/* Field search initiated from a type */
  int from_super = 0, from_cast = 0;
  int previous_call_static = 0;
  int is_static;
  tree decl = NULL_TREE, type = NULL_TREE, q;
  *where_found = NULL_TREE;

  for (q = EXPR_WFL_QUALIFICATION (wfl); q; q = TREE_CHAIN (q))
    {
      tree qual_wfl = QUAL_WFL (q);

      /* 15.10.1 Field Access Using a Primary */
      
      switch (TREE_CODE (qual_wfl))
	{
	case CALL_EXPR:
	case JAVA_NEW_CLASS_EXPR:
	  /* If the access to the function call is a non static field,
	     build the code to access it. */
	  if (DECL_P (decl) && !FIELD_STATIC (decl))
	    {
	      decl = maybe_access_field (decl, *where_found, type);
	      if (decl == error_mark_node)
		return 1;
	    }
	  /* And code for the function call */
	  if (complete_function_arguments (qual_wfl))
	    return 1;
	  *where_found = 
	    patch_method_invocation_stmt (qual_wfl, decl, type, &is_static);
	  if (*where_found == error_mark_node)
	    return 1;
	  *type_found = type = QUAL_DECL_TYPE (*where_found);

	  /* If the previous call was static and this one is too,
	     build a compound expression to hold the two (because in
	     that case, previous function calls aren't transported as
	     forcoming function's argument. */
	  if (previous_call_static && is_static)
	    {
	      decl = build (COMPOUND_EXPR, type, decl, *where_found);
	      TREE_SIDE_EFFECTS (decl) = 1;
	    }
	  else
	    {
	      previous_call_static = is_static;
	      decl = *where_found;
	    }
	  continue;

	case CONVERT_EXPR:
	  *where_found = decl = java_complete_tree (qual_wfl);
	  if (decl == error_mark_node)
	    return 1;
	  *type_found = type = QUAL_DECL_TYPE (decl);
	  from_cast = 1;
	  continue;

	case ARRAY_REF:
	  /* If the access to the function call is a non static field,
	     build the code to access it. */
	  if (DECL_P (decl) && !FIELD_STATIC (decl))
	    {
	      decl = maybe_access_field (decl, *where_found, type);
	      if (decl == error_mark_node)
		return 1;
	    }
	  /* And code for the array reference expression */
	  decl = java_complete_tree (qual_wfl);
	  if (decl == error_mark_node)
	    return 1;
	  type = QUAL_DECL_TYPE (decl);
	  continue;
	}

      /* If we fall here, we weren't processing a (static) function call. */
      previous_call_static = 0;

      /* It can be the keyword THIS */
      if (EXPR_WFL_NODE (qual_wfl) == this_identifier_node)
	{
	  if (!current_this)
	    {
	      parse_error_context 
		(wfl, "Keyword `this' used outside allowed context");
	      return 1;
	    }
	  /* We have to generate code for intermediate acess */
	  *where_found = decl = current_this;
	  type = QUAL_DECL_TYPE (decl);
	  continue;
	}

      /* 15.10.2 Accessing Superclass Members using SUPER */
      if (EXPR_WFL_NODE (qual_wfl) == super_identifier_node)
	{
	  tree node;
	  /* Check on the restricted use of SUPER */
	  if (METHOD_STATIC (current_function_decl)
	      || current_class == object_type_node)
	    {
	      parse_error_context 
		(wfl, "Keyword `super' used outside allowed context");
	      return 1;
	    }
	  /* Otherwise, treat SUPER as (SUPER_CLASS)THIS */
	  node = build_cast (EXPR_WFL_LINECOL (qual_wfl), 
			     CLASSTYPE_SUPER (current_class),
			     build_this (EXPR_WFL_LINECOL (qual_wfl)));
	  *where_found = decl = java_complete_tree (node);
	  *type_found = type = QUAL_DECL_TYPE (decl);
	  from_super = from_type = 1;
	  continue;
	}

      /* 15.13.1: Can't search for field name in packages, so we
	 assume a variable/class name was meant. */
      if (RESOLVE_PACKAGE_NAME_P (qual_wfl))
	{
	  if (from_super || from_cast)
	    parse_error_context 
	      ((from_cast ? qual_wfl : wfl),
	       "No variable `%s' defined in class `%s'",
	       IDENTIFIER_POINTER (EXPR_WFL_NODE (qual_wfl)),
	       lang_printable_name (type));
	  else
	    parse_error_context
	      (qual_wfl, "Undefined variable or class name: `%s'",
	       IDENTIFIER_POINTER (EXPR_WFL_NODE (qual_wfl)));
	  return 1;
	}

      /* We have a type name. It's been already resolved when the
	 expression was qualified. */
      else if (RESOLVE_TYPE_NAME_P (qual_wfl))
	{
	  if (!(decl = QUAL_RESOLUTION (q)))
	    return 1;		/* Error reported already */

	  if (not_accessible_p (TREE_TYPE (decl), decl, 0))
	    {
	      parse_error_context 
		(qual_wfl, "Can't access %s field `%s.%s' from `%s'",
		 java_accstring_lookup (get_access_flags_from_decl (decl)),
		 IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))),
		 IDENTIFIER_POINTER (DECL_NAME (decl)),
		 IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class))));
	      return 1;
	    }
	  
	  type = TREE_TYPE (decl);
	  from_type = 1;
	}
      /* We resolve and expression name */
      else 
	{
	  tree field_decl;

	  /* If there exists an early resolution, use it. That occurs
	     only once and we know that there are more things to
	     come. Don't do that when processing something after SUPER
	     (we need more thing to be put in place below */
	  if (!from_super && QUAL_RESOLUTION (q))
	    decl = QUAL_RESOLUTION (q);

	  /* We have to search for a field, knowing the type of its
             container. The flag FROM_TYPE indicates that we resolved
             the last member of the expression as a type name, which
             means that for the resolution of this field, will check
             on other errors than if the it was resolved as a member
             of an other field. */
	  else
	    {
	      int is_static;
	      if (!from_type && !JREFERENCE_TYPE_P (type))
		{
		  parse_error_context 
		    (qual_wfl, "Attempt to reference field `%s' in `%s %s'",
		     IDENTIFIER_POINTER (EXPR_WFL_NODE (qual_wfl)),
		     lang_printable_name (type),
		     IDENTIFIER_POINTER (DECL_NAME (field_decl)));
		  return 1;
		}
	      
	      if (!(field_decl = 
		    lookup_field_wrapper (type, EXPR_WFL_NODE (qual_wfl))))
		{
		  parse_error_context 
		    (qual_wfl, "No variable `%s' defined in class `%s'",
		     IDENTIFIER_POINTER (EXPR_WFL_NODE (qual_wfl)), 
		     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));
		  return 1;
		}
	      
	      /* Check on accessibility here */
	      if (not_accessible_p (type, field_decl, from_super))
		{
		  parse_error_context 
		    (qual_wfl,
		     "Can't access %s field `%s.%s' from `%s'",
		     java_accstring_lookup 
		       (get_access_flags_from_decl (field_decl)),
		     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))),
		     IDENTIFIER_POINTER (DECL_NAME (field_decl)),
		     IDENTIFIER_POINTER 
		       (DECL_NAME (TYPE_NAME (current_class))));
		  return 1;
		}
	      
	      /* There are things to check when fields are accessed
	         from type. There are no restrictions on a static
	         declaration of the field when it is accessed from an
	         interface */
	      is_static = FIELD_STATIC (field_decl);
	      if (!from_super && from_type 
		  && !TYPE_INTERFACE_P (type) && !is_static)
		{
		  parse_error_context 
		    (qual_wfl, "Can't make a static reference to nonstatic "
		     "variable `%s' in class `%s'",
		     IDENTIFIER_POINTER (EXPR_WFL_NODE (qual_wfl)),
		     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));
		  return 1;
		}
	      from_cast = from_super = 0;

	      /* If we need to generate something to get a proper handle
		 on what this field is accessed from, do it now. */
	      if (!is_static)
		{
		  decl = maybe_access_field (decl, *where_found, type);
		  if (decl == error_mark_node)
		    return 1;
		}

	      /* We want to keep the location were found it, and the type
		 we found. */
	      *where_found = decl;
	      *type_found = type;

	      /* This is the decl found and eventually the next one to
		 search from */
	      decl = field_decl;
	    }

	  from_type = 0;
	  type = QUAL_DECL_TYPE (decl);
	}
    }
  *found_decl = decl;
  return 0;
}

/* 6.6 Qualified name and access control. Returns 1 if MEMBER (a decl)
   can't be accessed from REFERENCE (a record type). */

int not_accessible_p (reference, member, from_super)
     tree reference, member;
     int from_super;
{
  int access_flag = get_access_flags_from_decl (member);

  /* Access always granted for members declared public */
  if (access_flag & ACC_PUBLIC)
    return 0;
  
  /* Check access on protected members */
  if (access_flag & ACC_PROTECTED)
    {
      /* Access granted if it occurs from within the package
         containing the class in which the protected member is
         declared */
      if (class_in_current_package (DECL_CONTEXT (member)))
	return 0;

      if (TREE_CODE (member) == FUNCTION_DECL && DECL_CONSTRUCTOR_P (member))
	{
	  /* Access from SUPER is granted */
	  if (from_super)
	    return 0;
	  /* Otherwise, access isn't granted */
	  return 1;
	}
      else
	{
	  /* If accessed with the form `super.member', then access is
             granted */
	  if (from_super)
	    return 0;

	  /* Otherwise, access is granted if occuring from the class where
	     member is declared or a subclass of it */
	  if (inherits_from_p (reference, current_class))
	    return 0;
	}
      return 1;
    }

  /* Check access on private members. Access is granted only if it
     occurs from within the class in witch it is declared*/

  if (access_flag & ACC_PRIVATE)
    return (current_class == DECL_CONTEXT (member) ? 0 : 1);

  /* Default access are permitted only when occuring within the
     package in which the type (REFERENCE) is declared. In other words,
     REFERENCE is defined in the current package */
  if (ctxp->package)
    return !class_in_current_package (reference);
  
  /* Otherwise, access is granted */
  return 0;
}

/* Returns 1 if class was declared in the current package, 0 otherwise */

static int
class_in_current_package (class)
     tree class;
{
  static tree cache = NULL_TREE;
  int qualified_flag;
  tree left;

  if (cache == class)
    return 1;

  qualified_flag = QUALIFIED_P (DECL_NAME (TYPE_NAME (class)));

  /* If the current package is empty and the name of CLASS is
     qualified, class isn't in the current package.  If there is a
     current package and the name of the CLASS is not qualified, class
     isn't in the current package */
  if (!ctxp->package && qualified_flag || ctxp->package && !qualified_flag)
    return 0;

  /* If there is not package and the name of CLASS isn't qualified,
     they belong to the same unnamed package */
  if (!ctxp->package && !qualified_flag)
    return 1;

  /* Compare the left part of the name of CLASS with the package name */
  breakdown_qualified (&left, NULL, DECL_NAME (TYPE_NAME (class)));
  if (ctxp->package == left)
    {
      cache = class;
      return 1;
    }
  return 0;
}

/* This function may generate code to access DECL from WHERE. This is
   done only if certain conditions meet.  */

static tree
maybe_access_field (decl, where, type)
  tree decl, where, type;
{
  if (DECL_P (decl) && decl != current_this
      && (!(TREE_CODE (decl) != PARM_DECL
	    && FIELD_STATIC (decl)))
      && !IDENTIFIER_LOCAL_VALUE (DECL_NAME (decl)))
    decl = build_field_ref (where ? where : current_this, 
			    type, DECL_NAME (decl));
  return decl;
}

/* Build a method invocation statement, by patching PATCH. If non NULL
   and according to the situation, PRIMARY and WHERE may be
   used. IS_STATIC is set to 1 if the invoked function is static. */

static tree
patch_method_invocation_stmt (patch, primary, where, is_static)
     tree patch, primary, where;
     int *is_static;
{
  tree wfl = TREE_OPERAND (patch, 0);
  tree args = TREE_OPERAND (patch, 1);
  tree name = EXPR_WFL_NODE (wfl);
  tree list, class_type;
  
  /* Should be overriden if everything goes well. Otherwise, if
     something fails, it should keep this value. It stop the
     evaluation of a bogus assignment. See java_complete_tree,
     MODIFY_EXPR: for the reasons why we sometimes want to keep on
     evaluating an assignment */
  TREE_TYPE (patch) = error_mark_node;

  /* Since lookup functions are messing with line numbers, save the
     context now.  */
  java_parser_context_save_global ();

  /* 15.11.1: Compile-Time Step 1: Determine Class or Interface to Search */

  /* Resolution of qualified name, excluding constructors */
  if (QUALIFIED_P (name) && !CALL_CONSTRUCTOR_P (patch))
    {
      tree class_decl, identifier, identifier_wfl;
      /* Extract the last IDENTIFIER of the qualified
	 expression. This is a wfl and we will use it's location
	 data during error report. */
      identifier_wfl = cut_identifier_in_qualified (wfl);
      identifier = EXPR_WFL_NODE (identifier_wfl);
      
      /* Given the context, IDENTIFIER is syntactically qualified
	 as a MethodName. We need to qualify what's before */
      qualify_ambiguous_name (wfl);

      /* Package resolution are erroneous */
      if (RESOLVE_PACKAGE_NAME_P (wfl))
	{
	  tree remainder;
	  breakdown_qualified (&remainder, NULL, EXPR_WFL_NODE (wfl));
	  parse_error_context (wfl, "Can't search method `%s' in package "
			       "`%s'",IDENTIFIER_POINTER (identifier),
			       IDENTIFIER_POINTER (remainder));
	  return error_mark_node;
	}
      /* We're resolving a call from a type */
      else if (RESOLVE_TYPE_NAME_P (wfl))
	{
	  tree decl = QUAL_RESOLUTION (EXPR_WFL_QUALIFICATION (wfl));
	  tree name = DECL_NAME (decl);
	  tree type;

	  class_decl = resolve_and_layout (name, wfl);
	  if (CLASS_INTERFACE (decl))
	    {
	      parse_error_context
		(identifier_wfl, "Can't make static reference to method "
		 "`%s' in interface `%s'", IDENTIFIER_POINTER (identifier), 
		 IDENTIFIER_POINTER (name));
	      return error_mark_node;
	    }
	  /* Look the method up in the type selector. The method ought
             to be static. */
	  type = TREE_TYPE (class_decl);
	  list = lookup_method_invoke (0, wfl, type, identifier, args);
	  if (list && !METHOD_STATIC (list))
	    {
	      char *fct_name = strdup ((char *)lang_printable_name (list));
	      parse_error_context 
		(identifier_wfl,
		 "Can't make static reference to method `%s %s' in class `%s'",
		 lang_printable_name (TREE_TYPE (TREE_TYPE (list))), fct_name, 
		 IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));
	      free (fct_name);
	      return error_mark_node;
	    }
	}
      /* We're resolving an expression name */
      else
	{
	  tree field, type;
	  
	  /* 1- Find the field to which the call applies */
	  field = resolve_field_access (wfl, NULL, &type);
	  if (field == error_mark_node)
	    return error_mark_node;
	  
	  /* 2- Do the layout of the class where the last field
	     was found, so we can search it. */
	  class_decl = 
	    resolve_and_layout (DECL_NAME (TYPE_NAME (type)), NULL_TREE);
	  
	  /* 3- Retrieve a filtered list of method matches, Refine
	     if necessary. In any cases, point out errors.  */
	  list = lookup_method_invoke (0, identifier_wfl, type, 
				       identifier, args);

	  /* 4- Add the field as an argument */
	  args = tree_cons (NULL_TREE, field, args);
	}

      /* CLASS_TYPE is used during the call to not_accessible_p and
	 IDENTIFIER_WFL will be used to report any problem further */
      class_type = TREE_TYPE (class_decl);
      wfl = identifier_wfl;
    }
  /* Resolution of simple names, names generated after a primary: or
     constructors */
  else
    {
      tree class_to_search;
      int lc;		/* Looking for Constructor */
      
      /* We search constructor in their target class */
      if (CALL_CONSTRUCTOR_P (patch))
	{
	  class_to_search = resolve_no_layout (EXPR_WFL_NODE (wfl), NULL_TREE);
	  if (!class_to_search)
	    {
	      parse_error_context 
		(wfl, "Class `%s' not found in type declaration",
		 IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl)));
	      return error_mark_node;
	    }
	  
	  /* Can't instantiate an abstract class */
	  if (CLASS_ABSTRACT (class_to_search))
	    {
	      parse_error_context 
		(wfl, "Class `%s' is an abstract class. It can't be "
		 "instantiated", IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl)));
	      return error_mark_node;
	    }
	  class_to_search = TREE_TYPE (class_to_search);
	  lc = 1;
	}
      /* This is a regular search in the local class, unless an
         alternate class is specified. */
      else
	{
	  class_to_search = (where ? where : current_class);
	  lc = 0;
	}
      
      /* NAME is a simple identifier or comes from a primary. Search
	 in the class whose declaration contain the method being
	 invoked. */
      list = lookup_method_invoke (lc, wfl, class_to_search, name, args);

      /* Don't continue if no method were found, as the next statement
         can't be executed then. */
      if (!list) return error_mark_node;

      /* Check for static reference if non static methods */
      if (check_for_static_method_reference (wfl, patch, list, 
					     class_to_search, primary))
	return error_mark_node;

      /* Non static/constructor methods are called with the current
	 object extra argument. If method is resolved as a primary,
	 use the primary otherwise use the current THIS. */
      if (!CALL_CONSTRUCTOR_P (patch) && !METHOD_STATIC (list))
	args = tree_cons (NULL_TREE, primary ? primary : current_this, args);

      class_type = class_to_search;
    }
  
  /* Merge point of all resolution schemes. If we have nothing, this
     is an error, already signaled */
  if (!list) return error_mark_node;
  
  /* Check accessibility, position the is_static flag, build and
     return the call */
  if (not_accessible_p (class_type, list, 0))
    {
      char *fct_name = strdup ((char *)lang_printable_name (list));
      parse_error_context 
	(wfl, "Can't access %s method `%s %s.%s' from `%s'",
	 java_accstring_lookup (get_access_flags_from_decl (list)),
	 lang_printable_name (TREE_TYPE (TREE_TYPE (list))), 
	 IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (class_type))), fct_name,
	 IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class))));
      free (fct_name);
      return error_mark_node;
    }
  
  if (is_static) 
    *is_static = METHOD_STATIC (list);
  java_parser_context_restore_global ();
  return patch_invoke (patch, list, args, wfl);
}

/* Check that we're not trying to do a static reference to a method in
   non static method. Return 1 if it's the case, 0 otherwise. */

static int
check_for_static_method_reference (wfl, node, method, where, primary)
     tree wfl, node, method, where, primary;
{
  if (METHOD_STATIC (current_function_decl) 
      && !METHOD_STATIC (method) && !primary && !CALL_CONSTRUCTOR_P (node))
    {
      char *fct_name = strdup ((char *)lang_printable_name (method));
      parse_error_context 
	(wfl, "Can't make static reference to method `%s %s' in class `%s'", 
	 lang_printable_name (TREE_TYPE (TREE_TYPE (method))), fct_name,
	 IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (where))));
      free (fct_name);
      return 1;
    }
  return 0;
}

/* Patch an invoke expression METHOD and ARGS, based on its invocation
   mode.  */

static tree
patch_invoke (patch, method, args, cl)
     tree patch, method, args;
     tree cl;
{
  tree dtable, func;
  tree signature = build_java_signature (TREE_TYPE (method));
  tree original_call;

  switch (invocation_mode (method, 0))
    {
    case INVOKE_VIRTUAL:
      dtable = invoke_build_dtable (0, args);
      func = build_invokevirtual (dtable, method);
      break;
    case INVOKE_STATIC:
      func = build_known_method_ref (method, TREE_TYPE (method),
				     DECL_CONTEXT (method),
				     signature, args);
      args = nreverse (args);
      break;

    default:
      fatal ("Unknown invocation mode - build_invoke");
      return NULL_TREE;
    }


  /* Ensure self_type is initialized, (invokestatic). FIXME */
  func = build1 (NOP_EXPR, build_pointer_type (TREE_TYPE (method)), func);
  TREE_TYPE (patch) = TREE_TYPE (TREE_TYPE (method));
  TREE_OPERAND (patch, 0) = func;
  TREE_OPERAND (patch, 1) = args;
  original_call = patch;

  /* We're calling a constructor. New is called an its returned value
     is an argument to the constructor. We build a COMPOUND_EXPR and
     use saved expression so that the overall NEW expression value is
     a pointer to a newly created and initialized class. */
  if (CALL_CONSTRUCTOR_P (original_call))
    {
      tree class = DECL_CONTEXT (method);
      tree c1, saved_new, size, new;
      if (!TYPE_SIZE (class))
	safe_layout_class (class);
      size = size_in_bytes (class);
      new = build (CALL_EXPR, promote_type (class),
		   build_address_of (alloc_object_node),
		   tree_cons (NULL_TREE, build_class_ref (class),
			      build_tree_list (NULL_TREE, 
					       size_in_bytes (class))),
		   NULL_TREE);
      saved_new = save_expr (new);
      c1 = build_tree_list (NULL_TREE, saved_new);
      TREE_CHAIN (c1) = TREE_OPERAND (original_call, 1);
      TREE_OPERAND (original_call, 1) = c1;
      TREE_SET_CODE (original_call, CALL_EXPR);
      patch = build (COMPOUND_EXPR, TREE_TYPE (new), patch, saved_new);
    }
  return patch;
}

static int
invocation_mode (method, super)
     tree method;
     int super;
{
  int access = get_access_flags_from_decl (method);

  if (access & ACC_STATIC)
    return INVOKE_STATIC;

  if (CLASS_FINAL (TYPE_NAME (DECL_CONTEXT (method))))
    return INVOKE_STATIC;
  
  if (super)
    return INVOKE_SUPER;
  
  if (CLASS_INTERFACE (TYPE_NAME (DECL_CONTEXT (method))))
    return INVOKE_INTERFACE;
  
  if (DECL_CONSTRUCTOR_P (method))
    return INVOKE_STATIC;
  
  return INVOKE_VIRTUAL;
}

/* Retrieve a refined list of matching methods. */

static tree
lookup_method_invoke (lc, cl, class, name, arg_list)
     int lc;
     tree cl;
     tree class, name, arg_list;
{
  tree method = make_node (FUNCTION_TYPE);
  tree arg_type_list = NULL_TREE;
  tree signature, list, node, scratch;

  for (node = arg_list; node; node = TREE_CHAIN (node))
    {
      tree current_arg;
      current_arg = 
	build_tree_list (NULL_TREE,
			 promote_type (TREE_TYPE (TREE_VALUE (node))));
      arg_type_list = chainon (current_arg, arg_type_list);
    }
  TYPE_ARG_TYPES (method) = arg_type_list;

  if (!lc)
    {
      signature = build_java_argument_signature (method);
      list = match_java_method (class, name, signature);
      list = refine_accessible_methods_list (lc, list);
    }
  else
    {
      TREE_TYPE (method) = void_type_node;
      signature = build_java_signature (method);
      list = lookup_java_constructor (class, signature);
    }

  if (!list)
    {
      parse_error_context (cl, "Can't find method `%s(%s)' in class `%s'",
			   IDENTIFIER_POINTER (name),
			   IDENTIFIER_POINTER (signature),
			   IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (class))));
      return NULL_TREE;
    }

  if (lc)
    return list;

  if (TREE_CHAIN (list))
    {
      tree most_specific_list = NULL_TREE;
      tree current;
      /* 15.11.2.2 Choose the Most Specific Method */
      for (current = list; current; current = TREE_CHAIN (current))
	{
	  tree rest;
	  tree method = TREE_VALUE (list);
	  tree class_from = DECL_CONTEXT (method);
	  for (rest = TREE_CHAIN (current); rest; rest = TREE_CHAIN (rest))
	    {
	      tree other = TREE_VALUE (rest);

	      /* METHOD can be declared more specific with regard to OTHER iif:
		
		 - The class METHOD belongs can be converted to the
		   class OTHER belongs by method invocation conversion
		   (5.3).  Since we're dealing with classes here, it is
		   covered by the identity conversion or the windening
		   primitive conversion.
		
		 - The types of the arguments of METHOD can be
		   converted to the types of the arguments of OTHER by
		   method invocation conversion (5.3). */

	      if (valid_ref_assignconv_cast_p (class_from, 
					       DECL_CONTEXT (other), 0)
		  && 1)		/* Test on args non implemented */
		most_specific_list = tree_cons (NULL_TREE, method, 
						most_specific_list);
	    }
	}
      list = most_specific_list;
    }

  if (!list || TREE_CHAIN (list))
    {
      parse_error_context (cl, "Can't find method `%s(%s)' in class `%s'",
			   IDENTIFIER_POINTER (name),
			   IDENTIFIER_POINTER (signature),
			   IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (class))));
      return NULL_TREE;
    }

  /* 15.11.3 Is the Chosen Method Appropriate ? */
  else
    return TREE_VALUE (list);
}

/* Refine accessible methods from the raw matching method list, as
   specified in 15.11.4.3. Return a (possibly empty) new method
   list.  */

static tree
refine_accessible_methods_list (lc, list)
     int lc;			/* Looking for Constructor */
     tree list;
{
#define ADD_TO_LIST_AND_CONTINUE				\
  {								\
    refined_list = tree_cons (NULL_TREE, method, refined_list);	\
    continue;							\
  }
  tree node, refined_list = NULL_TREE;
  tree current_class_name = DECL_NAME (TYPE_NAME (current_class));

  for (node = list; node; node = TREE_CHAIN (node))
    {
      int access, identical;
      tree class_from, method, class_from_name;
      
      method = TREE_VALUE (node);

      /* Constructor not retained here, unless were specifically
       looking for them. */
      if (lc && DECL_CONSTRUCTOR_P (method))
	ADD_TO_LIST_AND_CONTINUE;

      access = get_access_flags_from_decl (method);
      class_from = DECL_CONTEXT (method);
      class_from_name = DECL_NAME (TYPE_NAME (class_from));
      
      identical = identical_subpath_p (current_class_name, class_from_name);

      /* Check accessibility of class_from from the current one: This
	 test has been already carried out when qualify_ambiguous_name
	 tried to resolve a type found in an other package. It is not
	 necessary to retest things here, the error has been already
	 reported. */
		  
      /* Public method are always OK */
      if (access & ACC_PUBLIC)
	ADD_TO_LIST_AND_CONTINUE;
      
      /* Protected method access is OK if classes are from the
	 same package or part of the same inheritance lineage */
      if ((access & ACC_PROTECTED)
	  && (inherits_from_p (current_class, class_from) || identical))
	ADD_TO_LIST_AND_CONTINUE;

      /* Methods with default (package) access are OK if classes are
	 from the same default package. */
      if (identical || 
	  (!QUALIFIED_P (class_from_name) && !QUALIFIED_P (current_class_name)))
	ADD_TO_LIST_AND_CONTINUE;

      /* Private method accessible iff current class is the node where
	 the method is defined */
      if ((access & ACC_PRIVATE) && (class_from == current_class))
	ADD_TO_LIST_AND_CONTINUE;
    }
#undef ADD_TO_LIST_AND_CONTINUE
  return refined_list;
}

/* Qualification routines */

static void
qualify_ambiguous_name (id)
     tree id;
{
  tree qual, qual_wfl, name, decl, ptr_type, saved_current_class;
  int again, super_found = 0, this_found = 0;

  /* We first qualify the first element, then derive qualification of
     others based on the first one. If the first element is qualified
     by a resolution (field or type), this resolution is stored in the
     QUAL_RESOLUTION of the qual element being examined. We need to
     save the current_class since the use of SUPER might change the
     its value. */
  saved_current_class = current_class;
  qual = EXPR_WFL_QUALIFICATION (id);
  do {

    /* Simple qualified expression feature a qual_wfl that is a
       WFL. Expression derived from a primary feature more complicated
       things like a CALL_EXPR. Expression from primary need to be
       worked out to extract the part on which the qualification will
       take place. */
    qual_wfl = QUAL_WFL (qual);
    switch (TREE_CODE (qual_wfl))
      {
      case CALL_EXPR:
	qual_wfl = TREE_OPERAND (qual_wfl, 0);
	if (TREE_CODE (qual_wfl) != EXPR_WITH_FILE_LOCATION)
	  {
	    qual = EXPR_WFL_QUALIFICATION (qual_wfl);
	    qual_wfl = QUAL_WFL (qual);
	  }
	break;
      case JAVA_NEW_CLASS_EXPR:
      case CONVERT_EXPR:
      case ARRAY_REF:
	qual_wfl = TREE_OPERAND (qual_wfl, 0);
	break;
      }
    name = EXPR_WFL_NODE (qual_wfl);
    ptr_type = current_class;
    again = 0;
    /* If we have a THIS (from a primary), we set the context accordingly */
    if (name == this_identifier_node)
      {
	qual = TREE_CHAIN (qual);
	qual_wfl = QUAL_WFL (qual);
	name = EXPR_WFL_NODE (qual_wfl);
	this_found = 1;
      }
    /* If we have a SUPER, we set the context accordingly */
    if (name == super_identifier_node)
      {
	current_class = CLASSTYPE_SUPER (ptr_type);
	/* Check that there is such a thing as a super class. If not,
	   return.  The error will be caught later on, during the
	   resolution */
	if (!current_class)
	  {
	    current_class = saved_current_class;
	    return;
	  }
	qual = TREE_CHAIN (qual);
	/* Do one more interation to set things up */
	super_found = again = 1;
      }
  } while (again);
  
  /* If name appears within the scope of a location variable
     declaration or parameter declaration, then it is an expression
     name. We don't carry this test out if we're in the context of the
     use of SUPER or THIS */

  if (!this_found && !super_found && (decl = IDENTIFIER_LOCAL_VALUE (name)))
    {
      RESOLVE_EXPRESSION_NAME_P (qual_wfl) = 1;
      QUAL_RESOLUTION (qual) = decl;
    }

  /* If within the class/interface NAME was found to be used there
     exists a (possibly inherited) field named NAME, then this is an
     expression name. */
  else if ((decl = lookup_field_wrapper (ptr_type, name)))
    {
      RESOLVE_EXPRESSION_NAME_P (qual_wfl) = 1;
      QUAL_RESOLUTION (qual) = decl;
    }

  /* We reclassify NAME as a type name if:
     - NAME is a class/interface declared within the compilation
       unit containing NAME,
     - NAME is imported via a single-type-import declaration,
     - NAME is declared in an another compilation unit of the package
       of the compilation unit containing NAME,
     - NAME is declared by exactly on type-import-on-demand declaration
     of the compilation unit containing NAME. */
  else if ((decl = resolve_and_layout (name, NULL_TREE)))
    {
      RESOLVE_TYPE_NAME_P (qual_wfl) = 1;
      QUAL_RESOLUTION (qual) = decl;
    }

  /* Method call are expression name */
  else if (TREE_CODE (QUAL_WFL (qual)) == CALL_EXPR)
    RESOLVE_EXPRESSION_NAME_P (qual_wfl) = 1;

  /* Check here that NAME isn't declared by more than one
     type-import-on-demand declaration of the compilation unit
     containing NAME. FIXME */

  /* Otherwise, NAME is reclassified as a package name */
  else 
    RESOLVE_PACKAGE_NAME_P (qual_wfl) = 1;

  /* Propagate the qualification accross other components of the
     qualified name */
  for (qual = TREE_CHAIN (qual); qual;
       qual_wfl = QUAL_WFL (qual), qual = TREE_CHAIN (qual))
    {
      if (RESOLVE_PACKAGE_NAME_P (qual_wfl))
	RESOLVE_PACKAGE_NAME_P (QUAL_WFL (qual)) = 1;
      else 
	RESOLVE_EXPRESSION_NAME_P (QUAL_WFL (qual)) = 1;
    }

  /* Store the global qualification for the ambiguous part of ID back
     into ID fields */
  if (RESOLVE_EXPRESSION_NAME_P (qual_wfl))
    RESOLVE_EXPRESSION_NAME_P (id) = 1;
  else if (RESOLVE_TYPE_NAME_P (qual_wfl))
    RESOLVE_TYPE_NAME_P (id) = 1;
  else if (RESOLVE_PACKAGE_NAME_P (qual_wfl))
    RESOLVE_PACKAGE_NAME_P (id) = 1;

  /* Restore the current class */
  current_class = saved_current_class;
}

static int
breakdown_qualified (left, right, source)
    tree *left, *right, source;
{
  char *p = IDENTIFIER_POINTER (source), *base;
  int   l = IDENTIFIER_LENGTH (source);

  /* Breakdown NAME into REMAINDER . IDENTIFIER */
  base = p;
  p += (l-1);
  while (*p != '.' && p != base)
    p--;

  /* We didn't find a '.'. Return an error */
  if (p == base)
    return 1;

  *p = '\0';
  if (right)
    *right = get_identifier (p+1);
  *left = get_identifier (IDENTIFIER_POINTER (source));
  *p = '.';
  
  return 0;
}

/* Return 1 if N1 and N2 have identical sub-path. */

static int
identical_subpath_p (n1, n2)
     tree n1, n2;
{
  tree left1, left2;

  if (!QUALIFIED_P (n1) || !QUALIFIED_P (n2))
    return n1 == n2;
  
  breakdown_qualified (&left1, NULL, n1);
  breakdown_qualified (&left2, NULL, n2);

  return left1 == left2;
}

static int
not_initialized_as_it_should_p (decl)
     tree decl;
{
  if (DECL_P (decl))
    {
      if (TREE_CODE (decl) == FIELD_DECL
	  && METHOD_STATIC (current_function_decl))
	return 0;
      return DECL_P (decl) && !INITIALIZED_P (decl);
    }
  return 0;
}

/* Patch tree nodes in a function body. When a BLOCK is found, push
   local variable decls if present.  */

static tree
java_complete_tree (node)
     tree node;
{
  tree nn, cn, wfl_op1, wfl_op2;
  int flag, location;

  /* CONVERT_EXPR always has its type set, even though it needs to be
     worked out */
  if (TREE_TYPE (node) && TREE_CODE (node) != CONVERT_EXPR)
    return node;

  /* The switch block implements cases processing container nodes
     first.  Contained nodes are always written back. Leaves come
     next and return a value. */
  switch (TREE_CODE (node))
    {
    case BLOCK:

      /* 1- Block section.
	 Set the local values on decl names so we can identify them
	 faster when they're referenced. At that stage, identifiers
	 are legal so we don't check for declaration errors. */
      for (cn = BLOCK_EXPR_DECLS (node); cn; cn = TREE_CHAIN (cn))
	{
	  DECL_CONTEXT (cn) = current_function_decl;
	  IDENTIFIER_LOCAL_VALUE (DECL_NAME (cn)) = cn;
	  INITIALIZED_P (cn) = 0;
	}
      if (BLOCK_EXPR_BODY (node))
	{
	  BLOCK_EXPR_BODY (node) = java_complete_tree (BLOCK_EXPR_BODY (node));
	  if (BLOCK_EXPR_BODY (node) == error_mark_node)
	    return error_mark_node;
	}
      /* Turn local bindings to null */
      for (cn = BLOCK_EXPR_DECLS (node); cn; cn = TREE_CHAIN (cn))
	IDENTIFIER_LOCAL_VALUE (DECL_NAME (cn)) = NULL_TREE;

      TREE_TYPE (node) = void_type_node;
      break;

      /* 2- They are expressions but ultimately deal with statements */
    case LABELED_BLOCK_EXPR:
      PUSH_LABELED_BLOCK (node);
      if (LABELED_BLOCK_BODY (node))
	COMPLETE_CHECK_OP_1 (node);
      TREE_TYPE (node) = void_type_node;
      POP_LABELED_BLOCK ();
      return node;

    case EXIT_BLOCK_EXPR:
      /* We don't complete operand 1, because it's the return value of
         the EXIT_BLOCK_EXPR which doesn't exist it Java */
      return patch_bc_statement (node);

    case LOOP_EXPR:
      PUSH_LOOP (node);
      /* Check whether the loop was enclosed in a labeled
         statement. If not, create one, insert the loop in it and
         return the node */
      nn = patch_loop_statement (node);
      /* Anyways, walk the body of the loop */
      TREE_OPERAND (node, 0) = java_complete_tree (TREE_OPERAND (node, 0));
      if (TREE_OPERAND (node, 0) == error_mark_node)
	return error_mark_node;
      TREE_TYPE (nn) = TREE_TYPE (node) = void_type_node;
      /* If we returned something different, that's because we
         inserted a label. Pop the label too. */
      if (nn != node)
	POP_LABELED_BLOCK ();
      POP_LOOP ();
      return nn;

    case EXIT_EXPR:
      TREE_OPERAND (node, 0) = java_complete_tree (TREE_OPERAND (node, 0));
      return patch_exit_expr (node);

    case COND_EXPR:
      /* Condition */
      TREE_OPERAND (node, 0) = java_complete_tree (TREE_OPERAND (node, 0));
      if (TREE_OPERAND (node, 0) == error_mark_node)
	return error_mark_node;
      /* then-else branches */
      TREE_OPERAND (node, 1) = java_complete_tree (TREE_OPERAND (node, 1));
      if (TREE_OPERAND (node, 1) == error_mark_node)
	return error_mark_node;
      TREE_OPERAND (node, 2) = java_complete_tree (TREE_OPERAND (node, 2));
      if (TREE_OPERAND (node, 2) == error_mark_node)
	return error_mark_node;
      return patch_if_else_statement (node);
      break;

      /* 3- Expression section */
    case COMPOUND_EXPR:
      TREE_OPERAND (node, 0) = java_complete_tree (TREE_OPERAND (node, 0));
      TREE_OPERAND (node, 1) = java_complete_tree (TREE_OPERAND (node, 1));
      if (TREE_OPERAND (node, 1) == error_mark_node)
	return error_mark_node;
      TREE_TYPE (node) = TREE_TYPE (TREE_OPERAND (node, 1));
      break;

    case RETURN_EXPR:
      return patch_return (node);

    case EXPR_WITH_FILE_LOCATION:
      if (!EXPR_WFL_NODE (node) /* Or a PRIMARY flag ? */
	  || TREE_CODE (EXPR_WFL_NODE (node)) == IDENTIFIER_NODE)
        return resolve_expression_name (node);
      else
	{
	  EXPR_WFL_NODE (node) = java_complete_tree (EXPR_WFL_NODE (node));
	  TREE_SIDE_EFFECTS (node) = 1;
	  if (EXPR_WFL_NODE (node) == error_mark_node)
	    {
	      /* Its important for the evaluation of assignment that
		 this mark on the TREE_TYPE is propagated. */
	      TREE_TYPE (node) = error_mark_node;
	      return error_mark_node;
	    }
	  else
	    TREE_TYPE (node) = TREE_TYPE (EXPR_WFL_NODE (node));
	}
      break;

    case JAVA_NEW_ARRAY_EXPR:
      /* Patch all the dimensions */
      flag = 0;
      for (cn = TREE_OPERAND (node, 1); cn; cn = TREE_CHAIN (cn))
	{
	  int location = EXPR_WFL_LINECOL (TREE_VALUE (cn));
	  tree dim = java_complete_tree (TREE_VALUE (cn));
	  if (dim == error_mark_node)
	    {
	      flag = 1;
	      continue;
	    }
	  else
	    {
	      TREE_VALUE (cn) = save_expr (dim);
	      /* Setup the location of the current dimension, for
		 later error report. */
	      TREE_PURPOSE (cn) = 
		build_expr_wfl (NULL_TREE, input_filename, 0, 0);
	      EXPR_WFL_LINECOL (TREE_PURPOSE (cn)) = location;
	    }
	}
      /* They complete the array creation expression, if no errors
         were found. */
      return (flag ? error_mark_node : patch_newarray (node));

    case JAVA_NEW_CLASS_EXPR:
    case CALL_EXPR:
      /* Complete function's argument first */
      if (complete_function_arguments (node))
	return error_mark_node;
      else
	return patch_method_invocation_stmt (node, NULL_TREE, NULL_TREE, NULL);

    case MODIFY_EXPR:
      /* Save potential wfls */
      wfl_op1 = TREE_OPERAND (node, 0);
      wfl_op2 = TREE_OPERAND (node, 1);
      TREE_OPERAND (node, 0) = java_complete_tree (wfl_op1);
      if (TREE_OPERAND (node, 0) == error_mark_node)
	return error_mark_node;

      if (COMPOUND_ASSIGN_P (wfl_op2))
	{
	  tree lvalue;
	  tree other = 
	    java_complete_tree (TREE_OPERAND (wfl_op2, 0));

	  /* Hand stablize the lhs on both places */
	  lvalue = stabilize_reference (other); 
	  TREE_OPERAND (node, 0) = lvalue;
	  TREE_OPERAND (TREE_OPERAND (node, 1), 0) = lvalue;
	}

      /* There are cases where the type of RHS is fixed. In those
	 cases, if the evaluation of the RHS fails, we further the
	 evaluation of the assignment to detect more errors. */
      nn = java_complete_tree (TREE_OPERAND (node, 1));
      if (nn == error_mark_node)
	{
	  /* It's hopeless, but we can further things on to discover
	     an error during the assignment. In any cases, the
	     assignment operation fails. */
	  if (TREE_CODE (TREE_OPERAND (node, 1)) != EXPR_WITH_FILE_LOCATION
	      && TREE_TYPE (TREE_OPERAND (node, 1)) != error_mark_node)
	    patch_assignment (node, wfl_op1, wfl_op2);

	  /* Now, we still mark the lhs as initialized */
	  if (DECL_P (TREE_OPERAND (node, 0)))
	    INITIALIZED_P (TREE_OPERAND (node, 0)) = 1;

	  return error_mark_node;
	}
      TREE_OPERAND (node, 1) = nn;
      return patch_assignment (node, wfl_op1, wfl_op2);

    case MULT_EXPR:
    case PLUS_EXPR:
    case MINUS_EXPR:
    case LSHIFT_EXPR:
    case RSHIFT_EXPR:
    case URSHIFT_EXPR:
    case BIT_AND_EXPR:
    case BIT_XOR_EXPR:
    case BIT_IOR_EXPR:
    case TRUNC_MOD_EXPR:
    case RDIV_EXPR:
    case TRUTH_ANDIF_EXPR:
    case TRUTH_ORIF_EXPR:
    case EQ_EXPR: 
    case NE_EXPR:
    case GT_EXPR:
    case GE_EXPR:
    case LT_EXPR:
    case LE_EXPR:
      /* Operands 0 and 1 are WFL in certain cases only. patch_binop
	 knows how to handle those cases. */
      wfl_op1 = TREE_OPERAND (node, 0);
      wfl_op2 = TREE_OPERAND (node, 1);
      TREE_OPERAND (node, 0) = java_complete_tree (wfl_op1);
      if (TREE_OPERAND (node, 0) == error_mark_node)
        return error_mark_node;
      TREE_OPERAND (node, 1) = java_complete_tree (wfl_op2);
      if (TREE_OPERAND (node, 1) == error_mark_node)
	return error_mark_node;
      return patch_binop (node, wfl_op1, wfl_op2);

    case JAVA_UNARY_PLUS_EXPR:
    case NEGATE_EXPR:
    case TRUTH_NOT_EXPR:
    case BIT_NOT_EXPR:
    case PREDECREMENT_EXPR:
    case PREINCREMENT_EXPR:
    case POSTDECREMENT_EXPR:
    case POSTINCREMENT_EXPR:
    case CONVERT_EXPR:
      /* There are cases were wfl_op1 is a WFL. patch_unaryop knows
	 how to handle those cases. */
      wfl_op1 = TREE_OPERAND (node, 0);
      TREE_OPERAND (node, 0) = java_complete_tree (wfl_op1);
      if (TREE_OPERAND (node, 0) == error_mark_node)
	return error_mark_node;
      return patch_unaryop (node, wfl_op1);

    case ARRAY_REF:
      /* There are cases were wfl_op1 is a WFL. patch_array_ref knows
	 how to handle those cases. */
      wfl_op1 = TREE_OPERAND (node, 0);
      TREE_OPERAND (node, 0) = java_complete_tree (wfl_op1);
      if (TREE_OPERAND (node, 0) == error_mark_node)
	return error_mark_node;
      /* The same applies to wfl_op2 */
      wfl_op2 = TREE_OPERAND (node, 1);
      TREE_OPERAND (node, 1) = java_complete_tree (wfl_op2);
      if (TREE_OPERAND (node, 1) == error_mark_node)
	return error_mark_node;
      return patch_array_ref (node, wfl_op1, wfl_op2);

    case JAVA_THIS_EXPR:
      /* Can't use THIS in a static environment */
      if (!current_this)
	{
	  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);
	  parse_error_context (wfl_operator, "Keyword `this' used outside "
			       "allowed context");
	  TREE_TYPE (node) = error_mark_node;
	  return error_mark_node;
	}
      return current_this;

    case STRING_CST:
      /* Build the internal string representation */
      push_obstacks (&permanent_obstack, &permanent_obstack);
      node = get_identifier (TREE_STRING_POINTER (node));
      location = alloc_name_constant (CONSTANT_String, node);
      node = build_ref_from_constant_pool (location);
      TREE_TYPE (node) = promote_type (string_type_node);
      return node;

    default:
      fatal ("No case for tree code `%s' - java_complete_tree\n",
	     tree_code_name [TREE_CODE (node)]);
    }
  return node;
}

/* Complete function call's argument. Return a non zero value is an
   error was found.  */

static int
complete_function_arguments (node)
     tree node;
{
  int flag = 0;
  tree cn;

  for (cn = TREE_OPERAND (node, 1); cn; cn = TREE_CHAIN (cn))
    {
      tree wfl = TREE_VALUE (cn), parm;
      parm = java_complete_tree (wfl);
      if (parm == error_mark_node)
	{
	  flag = 1;
	  continue;
	}
      if (TREE_CODE (TREE_TYPE (parm)) == RECORD_TYPE)
	TREE_VALUE (cn) = convert (promote_type (TREE_TYPE (parm)), parm);
      else
	TREE_VALUE (cn) = save_expr (parm);
      if (not_initialized_as_it_should_p (parm))
	{
	  ERROR_VARIABLE_NOT_INITIALIZED (wfl, EXPR_WFL_NODE (wfl));
	  INITIALIZED_P (parm) = 1;
	}
    }
  return flag;
}

/* Sometimes (for loops and variable initialized during their
   declaration), we want to wrap a statement around a WFL and turn it
   debugable.  */

static tree
build_debugable_stmt (location, stmt)
    int location;
    tree stmt;
{
  if (TREE_CODE (stmt) != EXPR_WITH_FILE_LOCATION)
    {
      stmt = build_expr_wfl (stmt, input_filename, 0, 0);
      EXPR_WFL_LINECOL (stmt) = location;
    }
  JAVA_MAYBE_GENERATE_DEBUG_INFO (stmt);
  return stmt;
}

static tree
build_expr_block (body, decls)
     tree body, decls;
{
  tree node = make_node (BLOCK);
  BLOCK_EXPR_DECLS (node) = decls;
  BLOCK_EXPR_BODY (body);
  if (body)
    TREE_TYPE (node) = TREE_TYPE (body);
  TREE_SIDE_EFFECTS (node) = 1;
  return node;
}

/* Create a new function block and link its supercontext to the
   previous block. The current function DECL is used as supercontext
   when enter_block is called for the first time for a given
   function. The current function body (DECL_FUNCTION_BODY) is set to
   the newly created block.  */

static block_level = 0;

static tree
enter_block ()
{
  tree b = build_expr_block (NULL_TREE, NULL_TREE);
  tree fndecl = current_function_decl; 

  if (!DECL_FUNCTION_BODY (fndecl))
    {
      BLOCK_SUPERCONTEXT (b) = fndecl;
      DECL_FUNCTION_BODY (fndecl) = b;
    }
  else
    {
      BLOCK_SUPERCONTEXT (b) = DECL_FUNCTION_BODY (fndecl);
      DECL_FUNCTION_BODY (fndecl) = b;
    }
  return b;
}

/* Exit a block by changing the current function body
   (DECL_FUNCTION_BODY) to the current block super context, only if
   the block being exited isn't the method's top level one.  */

static tree
exit_block ()
{
  tree b = DECL_FUNCTION_BODY (current_function_decl);

  if (BLOCK_SUPERCONTEXT (b) != current_function_decl)
    DECL_FUNCTION_BODY (current_function_decl) = BLOCK_SUPERCONTEXT (b);

  return b;
}

/* Lookup for NAME in the nested function's blocks, all the way up to
   the current toplevel one. It complies with Java's local variable
   scoping rules.  */

static tree
lookup_name_in_blocks (name)
     tree name;
{
  tree b = DECL_FUNCTION_BODY (current_function_decl);

  while (b != current_function_decl)
    {
      tree current;

      /* Paranoid sanity check. To be removed */
      if (TREE_CODE (b) != BLOCK)
	fatal ("non block expr function body - lookup_name_in_blocks");

      for (current = BLOCK_EXPR_DECLS (b); current; 
	   current = TREE_CHAIN (current))
	if (DECL_NAME (current) == name)
	  return current;
      b = BLOCK_SUPERCONTEXT (b);
    }
  return NULL_TREE;
}

static void
maybe_absorb_scoping_blocks ()
{
  while (BLOCK_EXPR_ORIGIN (DECL_FUNCTION_BODY (current_function_decl)))
    {
      tree b = exit_block ();
      java_method_add_stmt (current_function_decl, b);
      SOURCE_FRONTEND_DEBUG (("Absorbing scoping block at line %d", lineno));
    }
}


/* This section of the source is reserved to build_* functions that
   are building incomplete tree nodes and the patch_* functions that
   are completing them.  */

/* Build an incomplete CALL_EXPR node. Encapsulate it within a WFL */

static tree
build_method_invocation (name, args)
    tree name;
    tree args;
{
  tree call = build (CALL_EXPR, NULL_TREE, name, args, NULL_TREE);
  TREE_SIDE_EFFECTS (call) = 1;
  /* Check on cases where NAME isn't a WFL. FIXME */
  EXPR_WFL_LINECOL (call) = EXPR_WFL_LINECOL (name);
  return call;
}

/* Build an incomplete assignment expression. */

static tree
build_assignment (op, op_location, lhs, rhs)
     int op, op_location;
     tree lhs, rhs;
{
  tree assignment;
  /* Build the corresponding binop if we deal with a Compound
     Assignment operator. Mark the binop sub-tree as part of a
     Compound Assignment expression */
  if (op != ASSIGN_TK)
    {
      rhs = build_binop (BINOP_LOOKUP (op), op_location, lhs, rhs);
      COMPOUND_ASSIGN_P (rhs) = 1;
    }
  assignment = build (MODIFY_EXPR, NULL_TREE, lhs, rhs);
  TREE_SIDE_EFFECTS (assignment) = 1;
  EXPR_WFL_LINECOL (assignment) = op_location;
  return assignment;
}

/* Print an INTEGER_CST node in a static buffer, and return the buffer. */

static char *
print_int_node (node)
    tree node;
{
  static char buffer [80];
  if (TREE_CONSTANT_OVERFLOW (node))
    sprintf (buffer, "<overflow>");
    
  if (TREE_INT_CST_HIGH (node) == 0)
    sprintf (buffer, HOST_WIDE_INT_PRINT_UNSIGNED,
	     TREE_INT_CST_LOW (node));
  else if (TREE_INT_CST_HIGH (node) == -1
	   && TREE_INT_CST_LOW (node) != 0)
    {
      buffer [0] = '-';
      sprintf (&buffer [1], HOST_WIDE_INT_PRINT_UNSIGNED,
	       -TREE_INT_CST_LOW (node));
    }
  else
    sprintf (buffer, HOST_WIDE_INT_PRINT_DOUBLE_HEX,
	     TREE_INT_CST_HIGH (node), TREE_INT_CST_LOW (node));

  return buffer;
}

/* 15.25 Assignment operators. */

static tree
patch_assignment (node, wfl_op1, wfl_op2)
     tree node;
     tree wfl_op1;
     tree wfl_op2;
{
  tree rhs = TREE_OPERAND (node, 1);
  tree lvalue = TREE_OPERAND (node, 0);
  tree lhs_type, rhs_type, new_rhs = NULL_TREE;
  int all_primitive;
  int error_found = 0;
  int lvalue_from_array = 0;

  /* Can't assign to a final. */
  if (DECL_P (lvalue) && FIELD_FINAL (lvalue))
    {
      parse_error_context 
        (wfl_op1, "Can't assign a value to the final variable `%s'",
	 IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl_op1)));
      error_found = 1;
    }

  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);

  /* Lhs can be a named variable */
  if (DECL_P (lvalue))
    {
      INITIALIZED_P (lvalue) = 1;
      lhs_type = TREE_TYPE (lvalue);
    }
  /* Or Lhs can be a array acccess. Should that be lvalue ? FIXME +
     comment on reason why */
  else if (TREE_CODE (wfl_op1) == ARRAY_REF)
    {
      lhs_type = TREE_TYPE (lvalue);
      lvalue_from_array = 1;
    }
  /* Or a field access */
  else if (TREE_CODE (lvalue) == COMPONENT_REF)
    lhs_type = TREE_TYPE (lvalue);
  /* Or a function return slot */
  else if (TREE_CODE (lvalue) == RESULT_DECL)
    lhs_type = TREE_TYPE (lvalue);
  /* Otherwise, this is an error */
  else
    {
      parse_error_context (wfl_op1, "Invalid left hand side of assignment");
      error_found = 1;
    }

  rhs_type = TREE_TYPE (rhs);

  /* 5.2 Begin Assignment conversion */

  /* 5.1.1 Try Identity Conversion */
  if (lhs_type == rhs_type) 
    new_rhs = rhs;
  
  /* 5.1.2 Try Widening Primitive Conversion */
  all_primitive = JPRIMITIVE_TYPE_P (lhs_type) && JPRIMITIVE_TYPE_P (rhs_type);
  if (all_primitive && JINTEGRAL_TYPE_P (rhs_type)
      && ((TYPE_PRECISION (rhs_type) < TYPE_PRECISION (lhs_type))
	  || (JFLOAT_TYPE_P (lhs_type) &&
	      TYPE_PRECISION (rhs_type) == TYPE_PRECISION (lhs_type))))
    new_rhs = convert (lhs_type, rhs);
  else if (all_primitive && JFLOAT_TYPE_P (rhs_type)
	   && (TYPE_PRECISION (rhs_type) < TYPE_PRECISION (lhs_type)))
    new_rhs = convert (lhs_type, rhs);

  /* Try a narrowing primitive conversion: 
       - expression is a constant expression of type int AND
       - variable is byte, short or char AND
       - The value of the expression is representable in the type of the 
         variable */
  else if (rhs_type == int_type_node && TREE_CONSTANT (rhs)
	   && (lhs_type == byte_type_node || lhs_type == char_type_node
	       || lhs_type == short_type_node))
    {
      if (int_fits_type_p (rhs, lhs_type))
        new_rhs = convert (lhs_type, rhs);
      else
	parse_warning_context 
	  (wfl_op1, "Constant expression `%s' to wide for narrowing "
	   "primitive conversion to `%s'", 
	   print_int_node (rhs), lang_printable_name (lhs_type));
      /* Reported a warning that will turn into an error further
	 down, so we don't return */
    }

  /* 5.2 Try a reference conversion */
  else if (!JPRIMITIVE_TYPE_P (rhs_type) && JREFERENCE_TYPE_P (lhs_type))
    {
      /* `null' may be assigned to any reference type */
      if (rhs == null_pointer_node)
        new_rhs = null_pointer_node;
      /* Try the reference assignment conversion */
      else if (valid_ref_assignconv_cast_p (rhs_type, lhs_type, 0))
	new_rhs = rhs;
      if (new_rhs)
	lhs_type = promote_type (rhs_type);
    }

  /* 15.25.2 If we have a compound assignment, convert RHS into the
     type of the LHS */
  else if (COMPOUND_ASSIGN_P (TREE_OPERAND (node, 1)))
    new_rhs = convert (lhs_type, rhs);

  /* Explicit cast required. This is an error */
  if (!new_rhs)
    {
      char *t1 = strdup ((char *)lang_printable_name (TREE_TYPE (rhs)));
      char *t2 = strdup ((char *)lang_printable_name (lhs_type));
      tree wfl;
      char operation [32];	/* Max size known */

      /* If the assignment is part of a declaration, we use the WFL of
	 the declared variable to point out the error and call it a
	 declaration problem. If the assignment is a genuine =
	 operator, we call is a operator `=' problem, otherwise we
	 call it an assignment problem. In both of these last cases,
	 we use the WFL of the operator to indicate the error. */

      if (MODIFY_EXPR_FROM_INITIALIZATION_P (node))
	{
	  wfl = wfl_op1;
	  strcpy (operation, "declaration");
	}
      else
	{
	  wfl = wfl_operator;
	  if (COMPOUND_ASSIGN_P (TREE_OPERAND (node, 1)))
	    strcpy (operation, "assignment");
	  else if (TREE_CODE (TREE_OPERAND (node, 0)) == RESULT_DECL)
	    strcpy (operation, "`return'");
	  else
	    strcpy (operation, "`='");
	}

      parse_error_context 
	(wfl, (!can_cast_to_p (rhs_type, lhs_type) ?
	       "Incompatible type for %s. Can't convert `%s' to `%s'" :
	       "Incompatible type for %s. Explicit cast "
	       "needed to convert `%s' to `%s'"), operation, t1, t2);
      free (t1); free (t2);
      error_found = 1;
    }

  /* Before reporting type incompatibility errors, check that the rhs
     is initialized, if a variable */
  if (not_initialized_as_it_should_p (rhs))
    {
      ERROR_VARIABLE_NOT_INITIALIZED (wfl_op2, DECL_NAME (rhs));
      INITIALIZED_P (rhs) = 1;
    }

  if (error_found)
    return error_mark_node;

  /* If we built a compound expression as the result of a reference
     assignment into an array element, return it here. */
  if (TREE_CODE (node) == COMPOUND_EXPR)
    return node;
      
  TREE_OPERAND (node, 0) = lvalue;
  TREE_OPERAND (node, 1) = new_rhs;
  TREE_TYPE (node) = lhs_type;
  return node;
}

/* Check that SOURCE can be converted into DEST, at least with a
   cast. If the convertion can't occur at all, return 0 otherwise
   1. This function is used to produce accurate error messages on the
   reasons why an assignment failed. */

static int
can_cast_to_p (source, dest)
     tree source;
     tree dest;
{
  if (TREE_CODE (source) == POINTER_TYPE)
    source = TREE_TYPE (source);
  if (TREE_CODE (dest) == POINTER_TYPE)
    dest = TREE_TYPE (dest);

  if (TREE_CODE (source) == RECORD_TYPE && TREE_CODE (dest) == RECORD_TYPE)
    return valid_ref_assignconv_cast_p (source, dest, 1);

  else if (JNUMERIC_TYPE_P (source) && JNUMERIC_TYPE_P (dest))
    return 1;

  return 0;
}

/* Check that something of SOURCE type can be assigned or cast to
   something of DEST type at runtime. Return 1 if the operation is
   valid, 0 otherwise. If CAST is set to 1, we're treating the case
   were SOURCE is cast into DEST, which borrows a lot of the
   assignment check. */

static int
valid_ref_assignconv_cast_p (source, dest, cast)
     tree source;
     tree dest;
     int cast;
{
  if (TREE_CODE (source) == POINTER_TYPE)
    source = TREE_TYPE (source);
  if (TREE_CODE (dest) == POINTER_TYPE)
    dest = TREE_TYPE (dest);
  /* Case where SOURCE is a class type */
  if (TYPE_CLASS_P (source))
    {
      if (TYPE_CLASS_P (dest))
	return  source == dest || inherits_from_p (source, dest)
	  || cast && inherits_from_p (dest, source);
      if (TYPE_INTERFACE_P (dest))
	{
	  /* If doing a cast and SOURCE is final, the operation is
             always correct a compile time (because even if SOURCE
             does not implement DEST, a subclass of SOURCE might). */
	  if (cast && !CLASS_FINAL (TYPE_NAME (source)))
	    return 1;
	  /* Otherwise, SOURCE must implement DEST */
	  return interface_of_p (dest, source);
	}
      /* DEST is an array, cast permited if SOURCE is of Object type */
      return (cast && source == object_type_node ? 1 : 0);
    }
  if (TYPE_INTERFACE_P (source))
    {
      if (TYPE_CLASS_P (dest))
	{
	  /* If not casting, DEST must be the Object type */
	  if (!cast)
	    return dest == object_type_node;
	  /* We're doing a cast. The cast is always valid is class
	     DEST is not final, otherwise, DEST must implement SOURCE */
	  else if (!CLASS_FINAL (TYPE_NAME (source)))
	    return 1;
	  else
	    return interface_of_p (source, dest);
	}
      if (TYPE_INTERFACE_P (dest))
	{
	  /* If doing a cast, then if SOURCE and DEST contain method
             with the same signature but different return type, then
             this is a (compile time) error */
	  if (cast)
	    {
	      tree method_source, method_dest;
	      tree source_type;
	      tree source_sig, dest_sig;
	      tree source_name;
	      for (method_source = TYPE_METHODS (source); method_source; 
		   method_source = TREE_CHAIN (method_source))
		{
		  source_sig = 
		    build_java_argument_signature (TREE_TYPE (method_source));
		  source_type = TREE_TYPE (TREE_TYPE (method_source));
		  source_name = DECL_NAME (method_source);
		  for (method_dest = TYPE_METHODS (dest);
		       method_dest; method_dest = TREE_CHAIN (method_dest))
		    if (source_sig == 
			build_java_argument_signature (TREE_TYPE (method_dest))
			&& source_name == DECL_NAME (method_dest)
			&& source_type != TREE_TYPE (TREE_TYPE (method_dest)))
		      return 0;
		}
	      return 1;
	    }
	  else
	    return source == dest || interface_of_p (dest, source);
	}
      else			/* Array */
	return 0;
    }
  if (TYPE_ARRAY_P (source))
    {
      if (TYPE_CLASS_P (dest))
	return dest == object_type_node;
      if (TYPE_INTERFACE_P (dest))
	return 0;		/* Install test on Clonable. FIXME */
      else			/* Arrays */
	{
	  tree source_element_type = TYPE_ARRAY_ELEMENT (source);
	  tree dest_element_type = TYPE_ARRAY_ELEMENT (dest);
	  
	  if (source_element_type == dest_element_type)
	    return 1;
	  return valid_ref_assignconv_cast_p (source_element_type,
					      dest_element_type, cast);
	}
      return 0;
    }
  return 0;
}

/* Build an incomplete binop expression. */

static tree
build_binop (op, op_location, op1, op2)
     enum tree_code op;
     int op_location;
     tree op1, op2;
{
  tree wfl;

  /* URSHIFT_EXPR is not part of what GCC understands, we can't directly build
     a node with it */
  tree binop = 
    build ((op == URSHIFT_EXPR ? RSHIFT_EXPR : op), NULL_TREE, op1, op2);
  if (op == URSHIFT_EXPR)
    TREE_SET_CODE (binop, op);

  TREE_SIDE_EFFECTS (binop) = 1;
  /* Store the location of the operator, for better error report. The
     string of the operator will be rebuild based on the OP value. */
  EXPR_WFL_LINECOL (binop) = op_location;
  return binop;
}

/* Build the string of the operator retained by NODE. If NODE is part
   of a compound expression, add an '=' at the end of the string. This
   function is called when an error needs to be reported on an
   operator. The string is returned as a pointer to a static character
   buffer. */

static char *
operator_string (node)
     tree node;
{
#define BUILD_OPERATOR_STRING(S)					\
  {									\
    sprintf (buffer, "%s%s", S, (COMPOUND_ASSIGN_P (node) ? "=" : ""));	\
    return buffer;							\
  }
  
  static char buffer [10];
  switch (TREE_CODE (node))
    {
    case MULT_EXPR: BUILD_OPERATOR_STRING ("*");
    case RDIV_EXPR: BUILD_OPERATOR_STRING ("/");
    case TRUNC_MOD_EXPR: BUILD_OPERATOR_STRING ("%");
    case PLUS_EXPR: BUILD_OPERATOR_STRING ("+");
    case MINUS_EXPR: BUILD_OPERATOR_STRING ("-");
    case LSHIFT_EXPR: BUILD_OPERATOR_STRING ("<<");
    case RSHIFT_EXPR: BUILD_OPERATOR_STRING (">>");
    case URSHIFT_EXPR: BUILD_OPERATOR_STRING (">>>");
    case BIT_AND_EXPR: BUILD_OPERATOR_STRING ("&");
    case BIT_XOR_EXPR: BUILD_OPERATOR_STRING ("^");
    case BIT_IOR_EXPR: BUILD_OPERATOR_STRING ("|");
    case TRUTH_ANDIF_EXPR: BUILD_OPERATOR_STRING ("&&");
    case TRUTH_ORIF_EXPR: BUILD_OPERATOR_STRING ("||");
    case EQ_EXPR: BUILD_OPERATOR_STRING ("==");
    case NE_EXPR: BUILD_OPERATOR_STRING ("!=");
    case GT_EXPR: BUILD_OPERATOR_STRING (">");
    case GE_EXPR: BUILD_OPERATOR_STRING (">=");
    case LT_EXPR: BUILD_OPERATOR_STRING ("<");
    case LE_EXPR: BUILD_OPERATOR_STRING ("<=");
    case JAVA_UNARY_PLUS_EXPR: BUILD_OPERATOR_STRING ("+");
    case NEGATE_EXPR: BUILD_OPERATOR_STRING ("-");
    case TRUTH_NOT_EXPR: BUILD_OPERATOR_STRING ("!");
    case BIT_NOT_EXPR: BUILD_OPERATOR_STRING ("~");
    case PREINCREMENT_EXPR:	/* Fall through */
    case POSTINCREMENT_EXPR: BUILD_OPERATOR_STRING ("++");
    case PREDECREMENT_EXPR:	/* Fall through */
    case POSTDECREMENT_EXPR: BUILD_OPERATOR_STRING ("--");
    default:
      fatal ("unregistered operator %s - operator_string",
	     tree_code_name [TREE_CODE (node)]);
    }
  return NULL;
#undef BUILD_OPERATOR_STRING
}

/* Binary operators (15.16 up to 15.18). We return error_mark_node on
   errors but we modify NODE so that it contains the type computed
   according to the expression, when it's fixed. Otherwise, we write
   error_mark_node as the type. It allows us to further the analysis
   of remaining nodes and detects more errors in certain cases.  */

static tree
patch_binop (node, wfl_op1, wfl_op2)
     tree node;
     tree wfl_op1;
     tree wfl_op2;
{
  tree op1 = TREE_OPERAND (node, 0);
  tree op2 = TREE_OPERAND (node, 1);
  tree op1_type = TREE_TYPE (op1);
  tree op2_type = TREE_TYPE (op2);
  tree prom_type;
  int code = TREE_CODE (node);
  /* If 1, tell the routine that we have to return error_mark_node
     after checking for the initialization of the RHS */
  int error_found = 0;

  /* Figure what is going to be checked first for initialization prior
     its use. If NODE is part of a compound assignment, we check the
     second operand first, otherwise the first one first. We also
     initialize the matching WFL for the error report. `cfi' stands
     for Check For Initialization */
  tree cfi = (COMPOUND_ASSIGN_P (node) ? op2 : op1);
  tree cfi_wfl = (COMPOUND_ASSIGN_P (node) ? wfl_op2 : wfl_op1);

  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);

  /* Check initialization of LHS first. We then silence further error
     message if the variable wasn't initialized */
  if (not_initialized_as_it_should_p (cfi))
    {
      ERROR_VARIABLE_NOT_INITIALIZED (cfi_wfl, DECL_NAME (cfi));
      INITIALIZED_P (op1) = 1;
    }

  switch (code)
    {
    /* 15.16 Multiplicative operators */
    case MULT_EXPR:		/* 15.16.1 Multiplication Operator * */
    case RDIV_EXPR:		/* 15.16.2 Division Operator / */
    case TRUNC_MOD_EXPR:	/* 15.16.3 Remainder operator % */
      if (!JPRIMITIVE_TYPE_P (op1_type) || !JPRIMITIVE_TYPE_P (op2_type))
	{
	  if (!JPRIMITIVE_TYPE_P (op1_type))
	    ERROR_CANT_CONVERT_TO_NUMERIC (wfl_operator, node, op1_type);
	  if (!JPRIMITIVE_TYPE_P (op2_type) && (op1_type != op2_type))
	    ERROR_CANT_CONVERT_TO_NUMERIC (wfl_operator, node, op2_type);
	  TREE_TYPE (node) = error_mark_node;
	  error_found = 1;
	  break;
	}
      prom_type = binary_numeric_promotion (op1_type, op2_type, &op1, &op2);
      /* Change the division operator if necessary */
      if (code == RDIV_EXPR && TREE_CODE (prom_type) == INTEGER_TYPE)
	TREE_SET_CODE (node, TRUNC_DIV_EXPR);
      /* This one is more complicated. FLOATs are processed by a function
	 call to soft_fmod. */
      if (code == TRUNC_MOD_EXPR)
	return build_java_binop (TRUNC_MOD_EXPR, prom_type, op1, op2);
      break;

    /* 15.17 Additive Operators */
    case PLUS_EXPR:		/* 15.17.1 String Concatenation Operator + */
      if (JSTRING_TYPE_P (op1_type) || JSTRING_TYPE_P (op2_type))
	fatal ("operator `+' non implemented on String - patch_binop");
    case MINUS_EXPR:		/* 15.17.2 Additive Operators (+ and -) for
				   Numeric Types */
      if (!JPRIMITIVE_TYPE_P (op1_type) || !JPRIMITIVE_TYPE_P (op2_type))
	{
	  if (!JPRIMITIVE_TYPE_P (op1_type))
	    ERROR_CANT_CONVERT_TO_NUMERIC (wfl_operator, node, op1_type);
	  if (!JPRIMITIVE_TYPE_P (op2_type) && (op1_type != op2_type))
	    ERROR_CANT_CONVERT_TO_NUMERIC (wfl_operator, node, op2_type);
	  TREE_TYPE (node) = error_mark_node;
	  error_found = 1;
	  break;
	}
      prom_type = binary_numeric_promotion (op1_type, op2_type, &op1, &op2);
      break;

    /* 15.18 Shift Operators */
    case LSHIFT_EXPR:
    case RSHIFT_EXPR:
    case URSHIFT_EXPR:
      if (!JINTEGRAL_TYPE_P (op1_type) || !JINTEGRAL_TYPE_P (op2_type))
	{
	  if (!JINTEGRAL_TYPE_P (op1_type))
	    ERROR_CAST_NEEDED_TO_INTEGRAL (wfl_operator, node, op1_type);
	  else
	    parse_error_context 
	      (wfl_operator, (JPRIMITIVE_TYPE_P (op2_type) ? 
	       "Incompatible type for `%s'. Explicit cast needed to convert "
	       "shift distance from `%s' to integral" : 
	       "Incompatible type for `%s'. Can't convert shift distance from "
	       "`%s' to integral"), 
	       operator_string (node), lang_printable_name (op2_type));
	  TREE_TYPE (node) = error_mark_node;
	  error_found = 1;
	  break;
	}

      /* Unary numeric promotion (5.6.1) is performed on each operand
         separatly */
      op1 = convert (promote_type (op1_type), op1);
      op2 = convert (promote_type (op2_type), op2);

      /* The type of the shift expression is the type of the promoted
         type of the left-hand operand */
      prom_type = TREE_TYPE (op1);

      /* Shift int only up to 0x1f and long up to 0x3f */
      if (prom_type == int_type_node)
	op2 = fold (build (BIT_AND_EXPR, int_type_node, op2, 
			   build_int_2 (0x1f, 0)));
      else
	op2 = fold (build (BIT_AND_EXPR, int_type_node, op2, 
			   build_int_2 (0x3f, 0)));

      /* The >>> operator is a >> operating on unsigned quantities */
      if (code == URSHIFT_EXPR)
	{
	  op1 = convert (unsigned_type (prom_type), op1);
	  TREE_SET_CODE (node, RSHIFT_EXPR);
	}
      break;
      

      /* 15.21 Bitwise and Logical Operators */
    case BIT_AND_EXPR:
    case BIT_XOR_EXPR:
    case BIT_IOR_EXPR:
      if (JINTEGRAL_TYPE_P (op1_type) && JINTEGRAL_TYPE_P (op2_type))
	/* Binary numeric promotion is performed on both operand and the
	   expression retain that type */
	prom_type = binary_numeric_promotion (op1_type, op2_type, &op1, &op2);

      else if (TREE_CODE (op1_type) == BOOLEAN_TYPE 
	       && TREE_CODE (op1_type) == BOOLEAN_TYPE)
	/* The type of the bitwise operator expression is BOOLEAN */
	prom_type = boolean_type_node;
      else
	{
	  if (!JINTEGRAL_TYPE_P (op1_type))
	    ERROR_CAST_NEEDED_TO_INTEGRAL (wfl_operator, node, op1_type);
	  if (!JINTEGRAL_TYPE_P (op2_type) && (op1_type != op2_type))
	    ERROR_CAST_NEEDED_TO_INTEGRAL (wfl_operator, node, op2_type);
	  TREE_TYPE (node) = error_mark_node;
	  error_found = 1;
	  /* Insert a break here if adding thing before the switch's
             break for this case */
	}
      break;

      /* 15.22 Conditional-And Operator */
    case TRUTH_ANDIF_EXPR:
      /* 15.23 Conditional-Or Operator */
    case TRUTH_ORIF_EXPR:
      /* Operands must be of BOOLEAN type */
      if (TREE_CODE (op1_type) != BOOLEAN_TYPE || 
	  TREE_CODE (op2_type) != BOOLEAN_TYPE)
	{
	  if (TREE_CODE (op1_type) != BOOLEAN_TYPE)
	    ERROR_CANT_CONVERT_TO_BOOLEAN (wfl_operator, node, op1_type);
	  if (TREE_CODE (op2_type) != BOOLEAN_TYPE && (op1_type != op2_type))
	    ERROR_CANT_CONVERT_TO_BOOLEAN (wfl_operator, node, op2_type);
	  TREE_TYPE (node) = boolean_type_node;
	  error_found = 1;
	  break;
	}
      /* The type of the conditional operators is BOOLEAN */
      prom_type = boolean_type_node;
      break;

      /* 15.19.1 Numerical Comparison Operators <, <=, >, >= */
    case LT_EXPR:
    case GT_EXPR:
    case LE_EXPR:
    case GE_EXPR:
      /* The type of each of the operands must be a primitive numeric
         type */
      if (!JNUMERIC_TYPE_P (op1_type) || ! JNUMERIC_TYPE_P (op2_type))
	{
	  if (!JNUMERIC_TYPE_P (op1_type))
	    ERROR_CANT_CONVERT_TO_NUMERIC (wfl_operator, node, op1_type);
	  if (!JNUMERIC_TYPE_P (op2_type) && (op1_type != op2_type))
	    ERROR_CANT_CONVERT_TO_NUMERIC (wfl_operator, node, op2_type);
	  TREE_TYPE (node) = boolean_type_node;
	  error_found = 1;
	  break;
	}
      /* Binary numeric promotion is performed on the operands */
      binary_numeric_promotion (op1_type, op2_type, &op1, &op2);
      /* The type of the relation expression is always BOOLEAN */
      prom_type = boolean_type_node;
      break;

      /* 15.20 Equality Operator */
    case EQ_EXPR:
    case NE_EXPR:
      /* 15.20.1 Numerical Equality Operators == and != */
      /* Binary numeric promotion is performed on the operands */
      if (JPRIMITIVE_TYPE_P (op1_type) && JPRIMITIVE_TYPE_P (op2_type))
	binary_numeric_promotion (op1_type, op2_type, &op1, &op2);
      
      /* 15.20.2 Boolean Equality Operators == and != */
      else if (TREE_CODE (op1_type) == BOOLEAN_TYPE &&
	  TREE_CODE (op2_type) == BOOLEAN_TYPE)
	;			/* Nothing to do here */
      
      /* 15.20.3 Reference Equality Operators == and != */
      /* Types have to be either references or the null type */
      else if ((op1 == null_pointer_node || op2 == null_pointer_node 
		|| JREFERENCE_TYPE_P (op1_type) 
		|| JREFERENCE_TYPE_P (op2_type))
	       && ((op1_type == op2_type)
		   /* The should use a can_cast_to_p() */
		   ))
	;			/* Nothing to do here */
	  
      /* Else we have an error figure what can't be converted into
	 what and report the error */
      else
	{
	  char *t1;
	  t1 = strdup ((char *)lang_printable_name (op1_type));
	  parse_error_context 
	    (wfl_operator, "Incompatible type for `%s'. Can't convert `%s' "
	     "to `%s'", operator_string (node), t1, 
	     lang_printable_name (op2_type));
	  free (t1);
	  TREE_TYPE (node) = boolean_type_node;
	  error_found = 1;
	  break;
	}
      prom_type = boolean_type_node;
      break;
    }

  /* Then check the initialization of the RHS. We don't do that if
     we're dealing with a node that is part of a compound
     assignment. We then silence further error message if the variable
     wasn't initialized */
  if (not_initialized_as_it_should_p (op2) && !COMPOUND_ASSIGN_P (node))
    {
      ERROR_VARIABLE_NOT_INITIALIZED (wfl_op2, DECL_NAME (op2));
      INITIALIZED_P (op2) = 1;
    }

  if (error_found)
    return error_mark_node;

  TREE_OPERAND (node, 0) = op1;
  TREE_OPERAND (node, 1) = op2;
  TREE_TYPE (node) = prom_type;
  return fold (node);
}

/* Build an incomplete unary operator expression. Unary `+' node is
   build as a CONV_EXPR, even though its tree code is overridden by a
   JAVA_UNARY_PLUS_EXPR that isn't a tree code, to differentiate it during
   the walk. */

static tree
build_unaryop (op_token, op_location, op1)
     int op_token, op_location;
     tree op1;
{
  enum tree_code op;
  tree unaryop;
  switch (op_token)
    {
    case PLUS_TK: op = CONVERT_EXPR; break;
    case MINUS_TK: op = NEGATE_EXPR; break;
    case NEG_TK: op = TRUTH_NOT_EXPR; break;
    case NOT_TK: op = BIT_NOT_EXPR; break;
    default: fatal ("Unknown token `%d' for unary operator - build_unaryop",
		    op_token);
    }

  unaryop = build1 (op, NULL_TREE, op1);
  if (op_token == PLUS_TK)
    TREE_SET_CODE (unaryop, JAVA_UNARY_PLUS_EXPR);

  TREE_SIDE_EFFECTS (unaryop) = 1;
  /* Store the location of the operator, for better error report. The
     string of the operator will be rebuild based on the OP value. */
  EXPR_WFL_LINECOL (unaryop) = op_location;
  return unaryop;
}

/* Special case for the ++/-- operators, since they require an extra
   argument to build, which is set to NULL and patched
   later. IS_POST_P is 1 if the operator, 0 otherwise.  */

static tree
build_incdec (op_token, op_location, op1, is_post_p)
     int op_token, op_location;
     tree op1;
     int is_post_p;
{
  static enum tree_code lookup [2][2] = 
    {
      { PREDECREMENT_EXPR, PREINCREMENT_EXPR, },
      { POSTDECREMENT_EXPR, POSTINCREMENT_EXPR, },
    };
  tree node = build (lookup [is_post_p][(op_token - DECR_TK)], 
		     NULL_TREE, op1, NULL_TREE);
  TREE_SIDE_EFFECTS (node) = 1;
  /* Store the location of the operator, for better error report. The
     string of the operator will be rebuild based on the OP value. */
  EXPR_WFL_LINECOL (node) = op_location;
  return node;
}     

/* Build an incomplete cast operator, based on the use of the
   CONVERT_EXPR. Note that TREE_TYPE of the constructed node is
   set. java_complete_tree is trained to walk a CONVERT_EXPR even
   though its type is already set.  */

static tree
build_cast (location, type, exp)
     int location;
     tree type, exp;
{
  tree node = build1 (CONVERT_EXPR, type, exp);
  EXPR_WFL_LINECOL (node) = location;
  return node;
}

/* 15.14 Unary operators. We return error_mark_node in case of error,
   but preserve the type of NODE if the type is fixed.  */

static tree
patch_unaryop (node, wfl_op)
     tree node;
     tree wfl_op;
{
  tree op = TREE_OPERAND (node, 0);
  tree op_type = TREE_TYPE (op);
  tree prom_type, value;
  int code = TREE_CODE (node);
  int error_found = 0;

  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);

  switch (code)
    {
      /* 15.13.2 Postfix Increment Operator ++ */
    case POSTINCREMENT_EXPR:
      /* 15.13.3 Postfix Increment Operator -- */
    case POSTDECREMENT_EXPR:
      /* 15.14.1 Prefix Increment Operator ++ */
    case PREINCREMENT_EXPR:
      /* 15.14.2 Prefix Decrement Operator -- */
    case PREDECREMENT_EXPR:
      if (!DECL_P (op))
	{
	  parse_error_context (wfl_operator, "Invalid argument to `%s'",
			       operator_string (node));
	  TREE_TYPE (node) = error_mark_node;
	  error_found = 1;
	}
      else if (FIELD_FINAL (op))
	{
	  parse_error_context 
	    (wfl_op, "Can't assign a value to the final variable `%s'",
	     IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl_op)));
	  TREE_TYPE (node) = error_mark_node;
	  error_found = 1;
	}
      /* From now on, we know that op if a variable and that it has a
         valid wfl. We use wfl_op to locate errors related to the
         ++/-- operand. */
      else if (!JNUMERIC_TYPE_P (op_type))
	{
	  parse_error_context
	    (wfl_op, "Invalid argument type `%s' to `%s'",
	     lang_printable_name (op_type), operator_string (node));
	  TREE_TYPE (node) = error_mark_node;
	  error_found = 1;
	}
      else
	{
	  /* Before the addition, binary numeric promotion if performed on
	     both operands */
	  value = integer_one_node;
	  prom_type = binary_numeric_promotion (op_type, TREE_TYPE (value), 
						&op, &value);
	  /* And write the promoted increment back */
	  TREE_OPERAND (node, 1) = value;
	}
      break;

      /* 15.14.3 Unary Plus Operator + */
    case JAVA_UNARY_PLUS_EXPR:
      /* 15.14.4 Unary Minus Operator - */
    case NEGATE_EXPR:
      if (!JNUMERIC_TYPE_P (op_type))
	{
	  ERROR_CANT_CONVERT_TO_NUMERIC (wfl_operator, node, op_type);
	  TREE_TYPE (node) = error_mark_node;
	  error_found = 1;
	}
      /* Unary numeric promotion is performed on operand */
      else
	{
	  prom_type = promote_type (op_type);
	  op = convert (prom_type, op);
	  if (code == JAVA_UNARY_PLUS_EXPR)
	    node = op;
	}
      break;

      /* 15.14.5 Bitwise Complement Operator ~ */
    case BIT_NOT_EXPR:
      if (!JINTEGRAL_TYPE_P (op_type))
	{
	  ERROR_CAST_NEEDED_TO_INTEGRAL (wfl_operator, node, op_type);
	  TREE_TYPE (node) = error_mark_node;
	  error_found = 1;
	}
      else
	{
	  prom_type = promote_type (op_type);
	  op = convert (prom_type, op);
	}
      break;

      /* 15.14.6 Logical Complement Operator ! */
    case TRUTH_NOT_EXPR:
      if (TREE_CODE (op_type) != BOOLEAN_TYPE)
	{
	  ERROR_CANT_CONVERT_TO_BOOLEAN (wfl_operator, node, op_type);
	  TREE_TYPE (node) = boolean_type_node;
	  error_found = 1;
	}
      else
	prom_type = boolean_type_node;
      break;

      /* 15.15 Cast Expression */
    case CONVERT_EXPR:
      value = patch_cast (node, wfl_op, wfl_operator);
      if (value == error_mark_node)
	{
	  TREE_TYPE (node) = error_mark_node;
	  error_found = 1;
	}
      else
	node = value;
      break;
    }
  
  /* Check variable initialization */
  if (not_initialized_as_it_should_p (op))
    {
      ERROR_VARIABLE_NOT_INITIALIZED (wfl_op, DECL_NAME (op));
      INITIALIZED_P (op) = 1;
    }
  
  if (error_found)
    return error_mark_node;
  /* In the case of JAVA_UNARY_PLUS_EXPR, we replaced NODE by a new one */
  else if (code != JAVA_UNARY_PLUS_EXPR && code != CONVERT_EXPR)
    {
      TREE_OPERAND (node, 0) = op;
      TREE_TYPE (node) = prom_type;
    }
  return fold (node);
}

/* Generic type resolution that sometimes takes place during node
   patching. Returned the resolved type or generate an error
   message. Return the resolved type or NULL_TREE.  */

static tree
resolve_type_during_patch (type)
     tree type;
{
  if (unresolved_type_p (type, NULL))
    {
      tree type_decl = resolve_no_layout (EXPR_WFL_NODE (type), NULL_TREE);
      if (!type_decl)
	{
	  parse_error_context (type, 
			       "Class `%s' not found in type declaration",
			       IDENTIFIER_POINTER (EXPR_WFL_NODE (type)));
	  return NULL_TREE;
	}
      else
	return TREE_TYPE (type_decl);
    }
  return type;
}
/* 5.5 Casting Conversion. error_mark_node is returned if an error is
   found. Otherwise NODE or something meant to replace it is returned.  */

static tree
patch_cast (node, wfl_op, wfl_operator)
     tree node;
     tree wfl_op;
     tree wfl_operator;
{
  tree op = TREE_OPERAND (node, 0);
  tree op_type = TREE_TYPE (op);
  tree cast_type = TREE_TYPE (node);
  char *t1;

  /* First resolve OP_TYPE if unresolved */
  if (!(cast_type = resolve_type_during_patch (cast_type)))
    return error_mark_node;

  /* Check on cast that are proven correct at compile time */
  if (JNUMERIC_TYPE_P (cast_type) && JNUMERIC_TYPE_P (op_type))
    {
      static tree convert_narrow ();
      /* Same type */
      if (cast_type == op_type)
	return node;

      /* Try widening/narowwing convertion. Potentially, things need
	 to be worked out in gcc so we implement the extreme cases
	 correctly. fold_convert() needs to be fixed. */
      return convert (cast_type, op);
    }

  /* The remaining legal casts involve conversion between reference
     types. Check for their compile time correctness. */
  if (JREFERENCE_TYPE_P (op_type) && JREFERENCE_TYPE_P (cast_type) 
      && valid_ref_assignconv_cast_p (op_type, cast_type, 1))
    {
      TREE_TYPE (node) = promote_type (cast_type);
      /* Now, the case can be determined correct at compile time if
         OP_TYPE can be converted into CAST_TYPE by assignment
         conversion (5.2) */

      if (valid_ref_assignconv_cast_p (op_type, cast_type, 0))
	return node;

      /* The cast requires a run-time check */
      return build (CALL_EXPR, promote_type (cast_type),
		    build_address_of (soft_checkcast_node),
		    tree_cons (NULL_TREE, build_class_ref (cast_type),
			       build_tree_list (NULL_TREE, op)),
		    NULL_TREE);
    }

  /* Any other casts are proven incorrect at compile time */
  t1 = strdup ((char *)lang_printable_name (op_type));
  parse_error_context (wfl_operator, "Invalid cast from `%s' to `%s'",
		       t1, lang_printable_name (cast_type));
  free (t1);
  return error_mark_node;
}

/* Build an ARRAY_REF incomplete tree node. Note that operand 1 isn't
   a list of indices. */
static tree
build_array_ref (location, array, index)
     int location;
     tree array, index;
{
  tree node = build (ARRAY_REF, NULL_TREE, array, index);
  EXPR_WFL_LINECOL (node) = location;
  return node;
}

/* 15.12 Array Access Expression */

static tree
patch_array_ref (node, wfl_array, wfl_index)
     tree node, wfl_array, wfl_index;
{
  tree array = TREE_OPERAND (node, 0);
  tree array_type  = TREE_TYPE (array);
  tree index = TREE_OPERAND (node, 1);
  tree index_type = TREE_TYPE (index);
  tree promoted_index_type;
  int error_found = 0;

  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);

  if (not_initialized_as_it_should_p (array))
    {
      ERROR_VARIABLE_NOT_INITIALIZED (wfl_array, DECL_NAME (array));
      INITIALIZED_P (array) = 1;
    }
  if (! flag_emit_class_files)
    array = save_expr (array);

  if (TREE_CODE (array_type) == POINTER_TYPE)
    array_type = TREE_TYPE (array_type);

  /* The array reference must be an array */
  if (!TYPE_ARRAY_P (array_type))
    {
      parse_error_context 
	(wfl_operator, "`[]' can only be applied to arrays. It can't be "
	 "applied to `%s'", lang_printable_name (array_type));
      TREE_TYPE (node) = error_mark_node;
      error_found = 1;
    }

  /* The array index underdoes unary numeric promotion. The promoted
     type must be int */
  promoted_index_type = promote_type (index_type);
  if (promoted_index_type != int_type_node)
    {
      int could_cast = can_cast_to_p (index_type, int_type_node);
      parse_error_context 
	(wfl_operator, 
	 (could_cast ? "Incompatible type for `[]'. Explicit cast needed to "
	  "convert `%s' to `int'" : "Incompatible type for `[]'. "
	  "Can't convert `%s' to `int'"),
	 lang_printable_name (index_type));
      TREE_TYPE (node) = error_mark_node;
      error_found = 1;
    }

  /* Now if the index is a var/parm decl, check on its initialization */
  if (not_initialized_as_it_should_p (index))
    {
      ERROR_VARIABLE_NOT_INITIALIZED (wfl_index, DECL_NAME (index));
      INITIALIZED_P (index) = 1;
    }

  if (error_found)
    return error_mark_node;
  index = convert (promoted_index_type, index);

  if (TREE_CODE (array_type) == RECORD_TYPE)
    array_type = promote_type (TYPE_ARRAY_ELEMENT (array_type));
  if (flag_emit_class_files)
    {
      TREE_OPERAND (node, 0)= array;
      TREE_OPERAND (node, 1)= index;
    }
  else
    node = build_java_arrayaccess (array, array_type, index);
  TREE_TYPE (node) = array_type;
  return node;
}

/* 15.9 Array Creation Expressions */

static tree
build_newarray_node (type, dims, extra_dims)
     tree type;
     tree dims;
     int extra_dims;
{
  tree node =
    build (CALL_EXPR, NULL_TREE, type, nreverse (dims), 
	   build_int_2 (extra_dims, 0));
  TREE_SET_CODE (node, JAVA_NEW_ARRAY_EXPR);
  return node;
}

static tree
patch_newarray (node)
     tree node;
{
  tree type = TREE_OPERAND (node, 0);
  tree dims = TREE_OPERAND (node, 1);
  tree cdim, array_type;
  int error_found = 0;
  int ndims = 0;
  int xdims = TREE_INT_CST_LOW (TREE_OPERAND (node, 2));
  int total_dims;

  /* Dimension types are verified. It's better for the types to be
     verified in order. */
  for (cdim = dims, ndims = 0; cdim; cdim = TREE_CHAIN (cdim), ndims++ )
    {
      int dim_error = 0;
      tree dim = TREE_VALUE (cdim);

      /* Dim might have been saved during its evaluation */
      dim = (TREE_CODE (dim) == SAVE_EXPR ? dim = TREE_OPERAND (dim, 0) : dim);

      /* The type of each specified dimension must be an integral type. */
      if (!JINTEGRAL_TYPE_P (TREE_TYPE (dim)))
	dim_error = 1;

      /* Each expression undergoes an unary numeric promotion (5.6.1) and the
	 promoted type must be int. */
      else
	{
	  dim = convert (promote_type (TREE_TYPE (dim)), dim);
	  if (TREE_TYPE (dim) != int_type_node)
	    dim_error = 1;
	}

      /* Report errors on types here */
      if (dim_error)
	{
	  parse_error_context 
	    (TREE_PURPOSE (cdim), 
	     "Incompatible type for dimension in array creation expression. "
	     "%s convert `%s' to `int'", 
	     (can_cast_to_p (TREE_TYPE (dim), int_type_node) ?
	      "Explicit cast needed to" : "Can't"),
	     lang_printable_name (TREE_TYPE (dim)));
	  error_found = 1;
	}

      /* Check for uninitialized variables */
      if (not_initialized_as_it_should_p (dim))
	{
	  ERROR_VARIABLE_NOT_INITIALIZED (TREE_PURPOSE (cdim), 
					  DECL_NAME (dim));
	  INITIALIZED_P (dim) = 1;
	  error_found = 1;
	}

      TREE_PURPOSE (cdim) = NULL_TREE;
    }

  /* Resolve array base type if unresolved */
  if (!(type = resolve_type_during_patch (type)))
    error_found = 1;

  if (error_found)
    {
      /* We don't want further evaluation of this bogus array creation
         operation */
      TREE_TYPE (node) = error_mark_node;
      return error_mark_node;
    }

  /* The node is transformed into a function call. Things are done
     differently according to the number of dimensions. If the number
     of dimension is equal to 1, then the nature of the base type
     (primitive or not) matters. */
  total_dims = xdims + ndims;
  if (total_dims == 1)
    {
      if (JPRIMITIVE_TYPE_P (type))
	{
	  int type_code;
	  if (type == boolean_type_node)
	    type_code = 4;
	  else if (type == char_type_node)
	    type_code = 5;
	  else if (type == float_type_node)
	    type_code = 6;
	  else if (type == double_type_node)
	    type_code = 7;
	  else if (type == byte_type_node)
	    type_code = 8;
	  else if (type == short_type_node)
	    type_code = 9;
	  else if (type == int_type_node)
	    type_code = 10;
	  else if (type == long_type_node)
	    type_code = 11;
	  else
	    fatal ("Can't compute type code - patch_newarray");
	  return build_newarray (type_code, TREE_VALUE (dims));
	}
      else
	return build_anewarray (type, TREE_VALUE (dims));
    }
  
  /* Add extra dimensions as unknown dimensions */
  while (xdims--)
    dims = 
      chainon (dims, build_tree_list (NULL_TREE, integer_negative_one_node));
  dims = chainon (dims, build_tree_list (NULL_TREE, integer_zero_node));

  /* Can't reuse what's already written in expr.c because it uses the
     JVM stack representation. Provide a build_multianewarray. FIXME */
  array_type = type;
  for (cdim = TREE_CHAIN (dims); cdim; cdim = TREE_CHAIN (cdim))
    array_type = build_java_array_type (promote_type (array_type), 
					TREE_CODE (cdim) == INTEGER_CST ?
					TREE_INT_CST_LOW (cdim) : -1);
  return build (CALL_EXPR,
		promote_type (array_type),
		build_address_of (soft_multianewarray_node),
		tree_cons (NULL_TREE, build_class_ref (array_type),
			   tree_cons (NULL_TREE, 
				      build_int_2 (total_dims, 0), dims )),
		NULL_TREE);
}

static tree
build_this (location)
     int location;
{
  tree node = build_wfl_node (this_identifier_node, input_filename, 0, 0);
  TREE_SET_CODE (node, JAVA_THIS_EXPR);
  EXPR_WFL_LINECOL (node) = location;
  return node;
}

/* 14.15 The return statement. It builds a modify expression that
   assigns the returned value to the RESULT_DECL that hold the value
   to be returned. */

static tree
build_return (location, op)
     int location;
     tree op;
{
  tree node = build1 (RETURN_EXPR, NULL_TREE, op);
  EXPR_WFL_LINECOL (node) = location;
  return node;
}

static tree
patch_return (node)
     tree node;
{
  tree return_exp = TREE_OPERAND (node, 0);
  tree meth = current_function_decl;
  tree mtype = TREE_TYPE (TREE_TYPE (current_function_decl));
  tree modify;
  int error_found = 0;

  TREE_TYPE (node) = error_mark_node;
  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);

  /* It's invalid to have a return value within a function that is
     declared with the keyword void or that is a constructor */
  if (return_exp && (mtype == void_type_node || DECL_CONSTRUCTOR_P (meth)))
    error_found = 1;

  /* It's invalid to have a no return value within a function that
     isn't declared with the keyword `void' */
  if (!return_exp && (mtype != void_type_node && !DECL_CONSTRUCTOR_P (meth)))
    error_found = 2;

  if (error_found)
    {
      char *t = strdup ((char *)lang_printable_name (mtype));
      parse_error_context (wfl_operator, "`return' with%s value from `%s %s'",
			   (error_found == 1 ? "" : "out"), t,
			   lang_printable_name (meth));
      free (t);
      return error_mark_node;
    }

  /* If we have a return_exp, build a modify expression and expand it */
  if (return_exp)
    {
      modify = build (MODIFY_EXPR, NULL_TREE, DECL_RESULT (meth), return_exp);
      EXPR_WFL_LINECOL (modify) = EXPR_WFL_LINECOL (node);
      modify = java_complete_tree (modify);
      if (modify != error_mark_node)
	{
	  TREE_SIDE_EFFECTS (modify) = 1;
	  TREE_OPERAND (node, 0) = modify;
	}
      else
	return error_mark_node;
    }
  TREE_TYPE (node) = void_type_node;
  TREE_SIDE_EFFECTS (node) = 1;
  return node;
}

/* 14.8 The if Statement */

static tree
build_if_else_statement (location, expression, if_body, else_body)
     int location;
     tree expression, if_body, else_body;
{
  tree node;
  /* FIXME: make else body be a void node, where this function is
     called */
  if (!else_body)
    else_body = build (COMPOUND_EXPR, void_type_node, NULL_TREE, NULL_TREE);
  node = build (COND_EXPR, NULL_TREE, expression, if_body, else_body);
  EXPR_WFL_LINECOL (node) = location;
  return node;
}

static tree
patch_if_else_statement (node)
     tree node;
{
  tree expression = TREE_OPERAND (node, 0);

  TREE_TYPE (node) = error_mark_node;
  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);

  /* The type of expression must be boolean */
  if (TREE_TYPE (expression) != boolean_type_node)
    {
      parse_error_context 
	(wfl_operator, 
	 "Incompatible type for `if'. Can't convert `%s' to `boolean'", 
	 lang_printable_name (TREE_TYPE (expression)));
      return error_mark_node;
    }
  
  TREE_TYPE (node) = void_type_node;
  TREE_SIDE_EFFECTS (node) = 1;
  return node;
}

/* 14.6 Labeled Statements */

/* Action taken when a lableled statement is parsed. a new
   LABELED_BLOCK_EXPR is created. No statement is attached to the
   label, yet.  */

static tree
build_labeled_block (location, label, wfl)
     int location;
     tree label, wfl;
{
  tree label_name = merge_qualified_name (label_id, label);
  tree label_decl, node;

  /* Issue a warning if we try to reuse a label that was previously
     declared */
  if (IDENTIFIER_LOCAL_VALUE (label_name))
    {
      EXPR_WFL_LINECOL (wfl_operator) = location;
      parse_warning_context (wfl_operator, "Declaration of `%s' shadows "
			     "a previous declaration",
			     IDENTIFIER_POINTER (label));
      EXPR_WFL_LINECOL (wfl_operator) = 
        EXPR_WFL_LINECOL (IDENTIFIER_LOCAL_VALUE (label_name));
      parse_warning_context (wfl_operator, "This is the location of the "
			     "previous declaration of label `%s'",
			     IDENTIFIER_POINTER (label));
      java_warning_count--;
    }

  label_decl = create_label_decl (label_name);
  node = build (LABELED_BLOCK_EXPR, NULL_TREE, label_decl, NULL_TREE);
  EXPR_WFL_LINECOL (node) = location;
  TREE_SIDE_EFFECTS (node) = 1;
  return node;
}

/* Generate a label crafting a unique name for it. This is used to
   implicitely label loops that aren't the body part of labeled
   statement.  */

static tree
generate_labeled_block ()
{
  static int l_number = 0;
  char buf [20];
  tree label_name;
  
  sprintf (buf, "$a%d", l_number++);
  return build_labeled_block (0, get_identifier (buf), NULL_TREE);
}

/* A labeled statement LBE is attached a statement. If the statement
   happens to be a loop, a link from the loop back to the label is
   installed.  */

static tree
complete_labeled_statement (lbe, statement)
     tree lbe;			/* Labeled block expr */
     tree statement;
{
  /* In anyways, tie the loop to its statement */
  LABELED_BLOCK_BODY (lbe) = statement;

  /* Ok, if statement is a for loop, we have to attach the labeled
     statement to the block the for loop belongs to and return the
     block instead */
  if (TREE_CODE (statement) == LOOP_EXPR && IS_FOR_LOOP_P (statement))
    {
      java_method_add_stmt (current_function_decl, lbe);
      return exit_block ();
    }

  return lbe;
}

/* 14.10, 14.11, 14.12 Loop Statements */

/* Create an empty LOOP_EXPR and make it the last in the nested loop
   list. */

static tree
build_new_loop (loop_body)
     tree loop_body;
{
  tree loop =  build (LOOP_EXPR, NULL_TREE, loop_body);
  TREE_SIDE_EFFECTS (loop) = 1;
  PUSH_LOOP (loop);
  return loop;
}

/* Create a loop body according to the following structure:
     COMPOUND_EXPR
       COMPOUND_EXPR		(loop main body)
         EXIT_EXPR		(this order is for while/for loops.
         LABELED_BLOCK_EXPR      the order is reversed for do loops)
           LABEL_DECL           (continue occurding here branche at the 
           BODY			 end of this labeled block)
       INCREMENT		(if any)

  REVERSED, if non zero, tells that the loop condition expr comes
  after the body, like in the do-while loop.  */

static tree
build_loop_body (location, condition, reversed)
     int location;
     tree condition;
     int reversed;
{
  tree first, second, label, body;

  condition = build (EXIT_EXPR, NULL_TREE, condition); /* Force walk */
  EXPR_WFL_LINECOL (condition) = location; /* For accurate error report */
  condition = build_debugable_stmt (location, condition);
  TREE_SIDE_EFFECTS (condition) = 1;

  body = generate_labeled_block ();
  first = (reversed ? body : condition);
  second = (reversed ? condition : body);
  return 
    build (COMPOUND_EXPR, NULL_TREE, 
	   build (COMPOUND_EXPR, NULL_TREE, first, second), size_zero_node);
}

/* Install CONDITION (if any) and loop BODY (using REVERSED to tell
   their order) on the current loop. Unlink the current loop from the
   loop list.  */

static tree
complete_loop_body (location, condition, body, reversed)
     int location;
     tree condition, body;
     int reversed;
{
  tree to_return = ctxp->current_loop;
  tree loop_body = LOOP_EXPR_BODY (to_return);
  if (condition)
    {
      tree cnode = LOOP_EXPR_BODY_CONDITION_EXPR (loop_body, reversed);
      /* We wrapped the EXIT_EXPR around a WFL so we can debug it.
         The real EXIT_EXPR is one operand further. */
      EXPR_WFL_LINECOL (cnode) = location;
      /* This one is for accurate error reports */
      EXPR_WFL_LINECOL (TREE_OPERAND (cnode, 0)) = location;
      TREE_OPERAND (TREE_OPERAND (cnode, 0), 0) = condition;
    }
  LOOP_EXPR_BODY_BODY_EXPR (loop_body, reversed) = body;
  POP_LOOP ();
  return to_return;
}

/* Tailored version of complete_loop_body for FOR loops, when FOR
   loops feature the condition part */

static tree
complete_for_loop (location, condition, update, body)
    int location;
    tree condition, update, body;
{
  /* Put the condition and the loop body in place */
  tree loop = complete_loop_body (location, condition, body, 0);
  /* LOOP is the current loop which has been now popped of the loop
     stack. Install the update block */
  LOOP_EXPR_BODY_UPDATE_BLOCK (LOOP_EXPR_BODY (loop)) = update;
  return loop;
}

/* If the loop isn't surrounded by a labeled statement, create one and
   insert LOOP as it's body.  */

static tree
patch_loop_statement (loop)
     tree loop;
{
  tree cbl, loop_label, to_return_as_loop;

  if (LOOP_HAS_LABEL_P (loop))
    {
      loop_label = ctxp->current_labeled_block;
      to_return_as_loop = loop;
    }
  else
    {
      loop_label = generate_labeled_block ();
      LABELED_BLOCK_BODY (loop_label) = loop;
      PUSH_LABELED_BLOCK (loop_label);
      to_return_as_loop = loop_label;
    }
  TREE_TYPE (to_return_as_loop) = void_type_node;
  return to_return_as_loop;
}

/* 14.13, 14.14: break and continue Statements */

/* Build a break or a continue statement. a null NAME indicates an
   unlabeled break/continue statement.  */

static tree
build_bc_statement (location, is_break, name)
     int location, is_break;
     tree name;
{
  tree break_continue, label_block_expr = NULL_TREE;

  if (name)
    {
      if (!(label_block_expr = IDENTIFIER_LOCAL_VALUE 
	    (merge_qualified_name (label_id, EXPR_WFL_NODE (name)))))
	/* Null means that we don't have a target for this named
	   break/continue. In this case, we make the target to be the
	   label name, so that the error can be reported accuratly in
	   patch_bc_statement. */
	label_block_expr = EXPR_WFL_NODE (name);
    }
  /* Unlabeled break/continue will be handled during the
     break/continue patch operation */
  break_continue 
    = build (EXIT_BLOCK_EXPR, NULL_TREE, label_block_expr, NULL_TREE);

  IS_BREAK_STMT_P (break_continue) = is_break;
  TREE_SIDE_EFFECTS (break_continue) = 1;
  EXPR_WFL_LINECOL (break_continue) = location;
  return break_continue;
}

/* Verification of a break/continue statement. */

static tree
patch_bc_statement (node)
     tree node;
{
  tree bc_label = EXIT_BLOCK_LABELED_BLOCK (node), target_stmt;
  int is_unlabeled = 0;
 EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);
 
  /* Not having a target means that the break/continue statement is
     unlabeled. We try to find a descent label for it */
  if (!bc_label)
    {
      is_unlabeled = 1;
      /* There should be a loop to branch to */
      if (ctxp->current_loop)
	{
	  /* At that stage, we're in the loop body, which is
	     encapsulated around a LABELED_BLOCK_EXPR. So searching
	     the current loop label requires us to consider the
	     labeled block before the current one. */
	  if (!LOOP_HAS_LABEL_SKIP_P (ctxp->current_loop))
	    fatal ("unlabeled loop has not installed label -- "
		   "patch_bc_statement");
	  bc_label = TREE_CHAIN (ctxp->current_labeled_block);
	}
      /* Not having a loop to break/continue to is an error */
      else
	{
	  parse_error_context (wfl_operator, "`%s' must be in loop%s",
			       (IS_BREAK_STMT_P (node) ? "break" : "continue"),
			       (IS_BREAK_STMT_P (node) ? " or switch" : ""));
	  return error_mark_node;
	}
    }
  /* Having an identifier here means that the target is unknown. */
  else if (TREE_CODE (bc_label) == IDENTIFIER_NODE)
    {
      parse_error_context (wfl_operator, "No label definition found for `%s'",
			   IDENTIFIER_POINTER (bc_label));
      return error_mark_node;
    }

  /* Find the statement we're targeting. */
  target_stmt = LABELED_BLOCK_BODY (bc_label);

  /* 14.13 The break Statement */
  if (IS_BREAK_STMT_P (node))
    {
      /* Named break are always fine, as far as they have a target
         (already verified). Anonymous break need to target
         while/do/for/switch */
      if (is_unlabeled &&
	  !(TREE_CODE (target_stmt) == LOOP_EXPR   /* do/while/for */
	    || 0))		                   /* switch FIXME */
	{
	  parse_error_context (wfl_operator, 
			       "`break' must be in loop or switch");
	  return error_mark_node;
	}
      /* If previously unlabeled, install the new found label */
      if (is_unlabeled)
	EXIT_BLOCK_LABELED_BLOCK (node) = bc_label;
    }
  /* 14.14 The continue Statement */
  /* The continue statement must always target a loop */
  else 
    {
      if (TREE_CODE (target_stmt) != LOOP_EXPR) /* do/while/for */
	{
	  parse_error_context (wfl_operator, "`continue' must be in loop");
	  return error_mark_node;
	}
      /* Everything looks good. We can fix the `continue' jump to go
         at the place in the loop were the continue is. The continue
	 is the current labeled block, by construction. */
      EXIT_BLOCK_LABELED_BLOCK (node) = ctxp->current_labeled_block;
    }

  /* Our break/continue don't return values. */
  TREE_TYPE (node) = void_type_node;
  /* Encapsulate the break within a compound statement so that it's
     expanded all the times by expand_expr (and not clobered
     sometimes, like after a if statement) */
  node = add_stmt_to_compound (NULL_TREE, void_type_node, node);
  TREE_SIDE_EFFECTS (node) = 1;
  return node;
}

/* Process the exit expression belonging to a loop. Its type must be
   boolean.  */

static tree
patch_exit_expr (node)
     tree node;
{
  tree expression = TREE_OPERAND (node, 0);
  TREE_TYPE (node) = error_mark_node;
  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);

  /* The type of expression must be boolean */
  if (TREE_TYPE (expression) != boolean_type_node)
    {
      parse_error_context 
	(wfl_operator, 
	 "Incompatible type for loop conditional. Can't convert `%s' to "
	 "`boolean'", 
	 lang_printable_name (TREE_TYPE (expression)));
      return error_mark_node;
    }
  /* Now we know things are allright, invert the condition, fold and
     return */
  TREE_OPERAND (node, 0) = 
    fold (build1 (TRUTH_NOT_EXPR, boolean_type_node, expression));
  TREE_TYPE (node) = void_type_node;
  return node;
}
