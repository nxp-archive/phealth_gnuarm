2008-07-27  Victor Kaplansky  <victork@il.ibm.com>

	PR tree-optimization/35252
	* tree-vect-analyze.c (vect_build_slp_tree): Make IMAGPART_EXPR and
	REALPART_EXPR to be considered as same load operation.

	* gcc.dg/vect/vect-complex-1.c, gcc.dg/vect/vect-complex-2.c,
	gcc.dg/vect/fast-math-vect-complex-3.c,
	gcc.dg/vect/vect-complex-4.c: New tests.


Index: gcc/testsuite/gcc.dg/vect/vect-complex-1.c
===================================================================
--- gcc/testsuite/gcc.dg/vect/vect-complex-1.c	(revision 0)
+++ gcc/testsuite/gcc.dg/vect/vect-complex-1.c	(revision 138198)
@@ -0,0 +1,56 @@
+/* { dg-require-effective-target vect_float } */
+
+#include <stdio.h>
+#include <stdarg.h>
+#include "tree-vect.h"
+
+#define N 16
+
+_Complex float a[N] =
+    { 10.0F + 20.0iF, 11.0F + 21.0iF, 12.0F + 22.0iF, 13.0F + 23.0iF,
+      14.0F + 24.0iF, 15.0F + 25.0iF, 16.0F + 26.0iF, 17.0F + 27.0iF,
+      18.0F + 28.0iF, 19.0F + 29.0iF, 20.0F + 30.0iF, 21.0F + 31.0iF,
+      22.0F + 32.0iF, 23.0F + 33.0iF, 24.0F + 34.0iF, 25.0F + 35.0iF };
+_Complex float b[N] =
+    { 30.0F + 40.0iF, 31.0F + 41.0iF, 32.0F + 42.0iF, 33.0F + 43.0iF,
+      34.0F + 44.0iF, 35.0F + 45.0iF, 36.0F + 46.0iF, 37.0F + 47.0iF,
+      38.0F + 48.0iF, 39.0F + 49.0iF, 40.0F + 50.0iF, 41.0F + 51.0iF,
+      42.0F + 52.0iF, 43.0F + 53.0iF, 44.0F + 54.0iF, 45.0F + 55.0iF };
+
+_Complex float c[N];
+_Complex float res[N] =
+    { 40.0F + 60.0iF, 42.0F + 62.0iF, 44.0F + 64.0iF, 46.0F + 66.0iF,
+      48.0F + 68.0iF, 50.0F + 70.0iF, 52.0F + 72.0iF, 54.0F + 74.0iF,
+      56.0F + 76.0iF, 58.0F + 78.0iF, 60.0F + 80.0iF, 62.0F + 82.0iF,
+      64.0F + 84.0iF, 66.0F + 86.0iF, 68.0F + 88.0iF, 70.0F + 90.0iF };
+
+
+__attribute__ ((noinline)) void
+foo (void)
+{
+  int i;
+
+  for (i = 0; i < N; i++)
+    c[i] = a[i] + b[i];
+
+}
+
+int
+main (void)
+{ 
+  int i;
+  check_vect ();
+  
+  foo ();
+
+  /* check results:  */
+  for (i = 0; i < N; i++)
+    if (c[i] != res[i])
+      abort ();
+
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
+/* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" } } */
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/vect-complex-2.c
===================================================================
--- gcc/testsuite/gcc.dg/vect/vect-complex-2.c	(revision 0)
+++ gcc/testsuite/gcc.dg/vect/vect-complex-2.c	(revision 138198)
@@ -0,0 +1,56 @@
+/* { dg-require-effective-target vect_double } */
+
+#include <stdio.h>
+#include <stdarg.h>
+#include "tree-vect.h"
+
+#define N 16
+
+_Complex double a[N] =
+    { 10.0F + 20.0iF, 11.0F + 21.0iF, 12.0F + 22.0iF, 13.0F + 23.0iF,
+      14.0F + 24.0iF, 15.0F + 25.0iF, 16.0F + 26.0iF, 17.0F + 27.0iF,
+      18.0F + 28.0iF, 19.0F + 29.0iF, 20.0F + 30.0iF, 21.0F + 31.0iF,
+      22.0F + 32.0iF, 23.0F + 33.0iF, 24.0F + 34.0iF, 25.0F + 35.0iF };
+_Complex double b[N] =
+    { 30.0F + 40.0iF, 31.0F + 41.0iF, 32.0F + 42.0iF, 33.0F + 43.0iF,
+      34.0F + 44.0iF, 35.0F + 45.0iF, 36.0F + 46.0iF, 37.0F + 47.0iF,
+      38.0F + 48.0iF, 39.0F + 49.0iF, 40.0F + 50.0iF, 41.0F + 51.0iF,
+      42.0F + 52.0iF, 43.0F + 53.0iF, 44.0F + 54.0iF, 45.0F + 55.0iF };
+
+_Complex double c[N];
+_Complex double res[N] =
+    { 40.0F + 60.0iF, 42.0F + 62.0iF, 44.0F + 64.0iF, 46.0F + 66.0iF,
+      48.0F + 68.0iF, 50.0F + 70.0iF, 52.0F + 72.0iF, 54.0F + 74.0iF,
+      56.0F + 76.0iF, 58.0F + 78.0iF, 60.0F + 80.0iF, 62.0F + 82.0iF,
+      64.0F + 84.0iF, 66.0F + 86.0iF, 68.0F + 88.0iF, 70.0F + 90.0iF };
+
+
+__attribute__ ((noinline)) void
+foo (void)
+{
+  int i;
+
+  for (i = 0; i < N; i++)
+    c[i] = a[i] + b[i];
+
+}
+
+int
+main (void)
+{ 
+  int i;
+  check_vect ();
+  
+  foo ();
+
+  /* check results:  */
+  for (i = 0; i < N; i++)
+    if (c[i] != res[i])
+      abort ();
+
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
+/* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" } } */
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/fast-math-vect-complex-3.c
===================================================================
--- gcc/testsuite/gcc.dg/vect/fast-math-vect-complex-3.c	(revision 0)
+++ gcc/testsuite/gcc.dg/vect/fast-math-vect-complex-3.c	(revision 138198)
@@ -0,0 +1,61 @@
+/* { dg-require-effective-target vect_float } */
+
+#include <stdio.h>
+#include <stdarg.h>
+#include "tree-vect.h"
+
+#define N 16
+
+_Complex float a[N] =
+    { 10.0F + 20.0iF, 11.0F + 21.0iF, 12.0F + 22.0iF, 13.0F + 23.0iF,
+      14.0F + 24.0iF, 15.0F + 25.0iF, 16.0F + 26.0iF, 17.0F + 27.0iF,
+      18.0F + 28.0iF, 19.0F + 29.0iF, 20.0F + 30.0iF, 21.0F + 31.0iF,
+      22.0F + 32.0iF, 23.0F + 33.0iF, 24.0F + 34.0iF, 25.0F + 35.0iF };
+_Complex float b[N] =
+    { 30.0F + 40.0iF, 31.0F + 41.0iF, 32.0F + 42.0iF, 33.0F + 43.0iF,
+      34.0F + 44.0iF, 35.0F + 45.0iF, 36.0F + 46.0iF, 37.0F + 47.0iF,
+      38.0F + 48.0iF, 39.0F + 49.0iF, 40.0F + 50.0iF, 41.0F + 51.0iF,
+      42.0F + 52.0iF, 43.0F + 53.0iF, 44.0F + 54.0iF, 45.0F + 55.0iF };
+
+_Complex float c[N];
+_Complex float res[N] =
+    { -500.0F + 1000.0iF, -520.0F + 1102.0iF,
+      -540.0F + 1208.0iF, -560.0F + 1318.0iF,
+      -580.0F + 1432.0iF, -600.0F + 1550.0iF,
+      -620.0F + 1672.0iF, -640.0F + 1798.0iF,
+      -660.0F + 1928.0iF, -680.0F + 2062.0iF,
+      -700.0F + 2200.0iF, -720.0F + 2342.0iF,
+      -740.0F + 2488.0iF, -760.0F + 2638.0iF,
+      -780.0F + 2792.0iF, -800.0F + 2950.0iF };
+
+
+__attribute__ ((noinline)) void
+foo (void)
+{
+  int i;
+
+  for (i = 0; i < N; i++)
+    c[i] = a[i] * b[i];
+
+}
+
+int
+main (void)
+{ 
+  int i;
+  check_vect ();
+  
+  foo ();
+
+  /* check results:  */
+  for (i = 0; i < N; i++)
+  {
+    if (c[i] != res[i])
+      abort ();
+  }
+
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_interleave  && vect_extract_even_odd } } } } */
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/vect-complex-4.c
===================================================================
--- gcc/testsuite/gcc.dg/vect/vect-complex-4.c	(revision 0)
+++ gcc/testsuite/gcc.dg/vect/vect-complex-4.c	(revision 138198)
@@ -0,0 +1,109 @@
+/* { dg-require-effective-target vect_int } */
+
+#include <stdio.h>
+#include <stdarg.h>
+#include "tree-vect.h"
+
+#define N 16
+
+struct foostr {
+  _Complex short f1;
+  _Complex short f2;
+};
+
+struct foostr a[16] __attribute__ ((__aligned__(16))) =
+  {
+    11 + 23i, 24 + 22i,
+    11 + 26i, 24 + 35i,
+    19 + 20i, 29 + 14i,
+    23 + 31i, 26 + 30i,
+    29 + 39i, 24 + 18i,
+    20 + 32i, 16 + 23i,
+    13 + 26i, 37 + 34i,
+    12 + 23i, 26 + 14i,
+    36 + 14i, 31 + 17i,
+    35 + 17i, 17 + 36i,
+    13 + 34i, 19 + 12i,
+    27 + 34i, 36 + 19i,
+    21 + 39i, 16 + 33i,
+    28 + 18i, 39 + 26i,
+    32 + 27i, 13 + 38i,
+    35 + 36i, 34 + 28i,
+  };
+
+struct foostr b[16] __attribute__ ((__aligned__(16))) =
+  {
+    37 + 12i, 23 + 15i,
+    14 + 11i, 13 + 25i,
+    35 + 29i, 22 + 34i,
+    24 + 34i, 16 + 39i,
+    34 + 32i, 26 + 21i,
+    34 + 36i, 11 + 37i,
+    25 + 21i, 10 + 39i,
+    10 + 36i, 35 + 22i,
+    39 + 29i, 23 + 21i,
+    34 + 33i, 39 + 14i,
+    16 + 31i, 32 + 33i,
+    20 + 14i, 35 + 30i,
+    26 + 24i, 36 + 37i,
+    31 + 20i, 32 + 28i,
+    25 + 27i, 15 + 30i,
+    10 + 31i, 37 + 37i,
+  };
+struct foostr c[16] __attribute__ ((__aligned__(16)));
+struct foostr res[N] =
+  {
+    48 + 35i, 47 + 37i,
+    25 + 37i, 37 + 60i,
+    54 + 49i, 51 + 48i,
+    47 + 65i, 42 + 69i,
+    63 + 71i, 50 + 39i,
+    54 + 68i, 27 + 60i,
+    38 + 47i, 47 + 73i,
+    22 + 59i, 61 + 36i,
+    75 + 43i, 54 + 38i,
+    69 + 50i, 56 + 50i,
+    29 + 65i, 51 + 45i,
+    47 + 48i, 71 + 49i,
+    47 + 63i, 52 + 70i,
+    59 + 38i, 71 + 54i,
+    57 + 54i, 28 + 68i,
+    45 + 67i, 71 + 65i,
+  };
+
+__attribute__ ((noinline)) void
+foo (void)
+{
+  int i;
+
+  for (i = 0; i < N; i++)
+    {
+      c[i].f1 = a[i].f1 + b[i].f1;
+      c[i].f2 = a[i].f2 + b[i].f2;
+    }
+
+}
+
+int
+main (void)
+{ 
+  int i;
+  check_vect ();
+  
+  foo ();
+
+  /* check results:  */
+  for (i = 0; i < N; i++)
+    {
+      if (c[i].f1 != res[i].f1)
+	abort ();
+      if (c[i].f2 != res[i].f2)
+	abort ();
+    }
+
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
+/* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" } } */
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/tree-vect-analyze.c
===================================================================
--- gcc/tree-vect-analyze.c	(revision 138197)
+++ gcc/tree-vect-analyze.c	(revision 138198)
@@ -2751,7 +2751,9 @@ vect_build_slp_tree (loop_vec_info loop_
 	}
       else
 	{
-	  if (first_stmt_code != TREE_CODE (rhs))
+	  if ((first_stmt_code != TREE_CODE (rhs))
+	      && ((first_stmt_code != IMAGPART_EXPR) || (TREE_CODE (rhs) != REALPART_EXPR))
+	      && ((first_stmt_code != REALPART_EXPR) || (TREE_CODE (rhs) != IMAGPART_EXPR)))
 	    {
 	      if (vect_print_dump_info (REPORT_SLP)) 
 		{
