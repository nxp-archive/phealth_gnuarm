@deftypemethod BeanDescriptor {public Class} getBeanClass () 
Get the Bean's class.
@end deftypemethod
@deftypemethod BeanDescriptor {public Class} getCustomizerClass () 
Get the Bean's customizer's class.
@end deftypemethod
@deftypemethod BeanInfo {public BeanDescriptor} getBeanDescriptor () 
Get the general description of this Bean type.
@end deftypemethod
@deftypemethod BeanInfo {public EventSetDescriptor} getEventSetDescriptors () 
Get the events this Bean type fires.
@end deftypemethod
@deftypemethod BeanInfo {public int} getDefaultEventIndex () 
Get the "default" event, basically the one a RAD tool
 user is most likely to select.
@end deftypemethod
@deftypemethod BeanInfo {public PropertyDescriptor} getPropertyDescriptors () 
Get the properties (get/set method pairs) this Bean
 type supports.
@end deftypemethod
@deftypemethod BeanInfo {public int} getDefaultPropertyIndex () 
Get the "default" property, basically the one a RAD
 tool user is most likely to select.
@end deftypemethod
@deftypemethod BeanInfo {public MethodDescriptor} getMethodDescriptors () 
Get the methods this Bean type supports.
@end deftypemethod
@deftypemethod BeanInfo {public BeanInfo} getAdditionalBeanInfo () 
Get additional BeanInfos representing this Bean.
 In this version of JavaBeans, this method is used so
 that space and time can be saved by reading a BeanInfo
 for each class in the hierarchy (super, super(super),
 and so on).



 The order of precedence when two pieces of BeanInfo
 conflict (such as two PropertyDescriptors that have
 the same name), in order from highest precedence to
 lowest, is:
 
@itemize @bullet

 
@item
This BeanInfo object.

 
@item
@code{getAdditionalBeanInfo()[getAdditionalBeanInfo().length]}

 
@item
 ... 

 
@item
@code{getAdditionalBeanInfo()[1]}

 
@item
@code{getAdditionalBeanInfo()[0]}

 
@end itemize




 <STRONG>Spec Note:</STRONG> It is possible that
 returning @code{null} from this method could
 stop Introspection in its tracks, but it is unclear
 from the spec whether this is the case.
@end deftypemethod
@deftypemethod BeanInfo {public Image} getIcon (int@w{ }@var{iconType}) 
Get a visual icon for this Bean.
 A Bean does not have to support icons, and if it does
 support icons, it does not have to support every single
 type.  Sun recommends that if you only support one
 type, you support 16x16 color.  Sun also notes that you
 should try to use a type (like GIF) that allows for
 transparent pixels, so that the background of the RAD
 tool can show through.



 <STRONG>Spec Note:</STRONG> If you do not support the
 type of icon that is being asked for, but you do
 support another type, it is unclear whether you should
 return the other type or not.  I would presume not.
@end deftypemethod
@deftypemethod Beans {public static Object} instantiate (java.lang.ClassLoader@w{ }@var{cl}, java.lang.String@w{ }@var{beanName}) @*throws IOException, ClassNotFoundException
Allows you to instantiate a Bean.  This method takes
 a ClassLoader from which to read the Bean and the
 name of the Bean.



 The Bean name should be a dotted name, like a class.
 It can represent several things.  Beans will search
 for the Bean using the name like this:


 
@itemize @bullet

 
@item
Searches for a serialized instance of the Bean
 using getResource(), mangling the Bean name by
 replacing the dots with slashes and appending .ser
 (for example, gnu.beans.BlahDeBlah would cause
 Beans to search for gnu/beans/BlahDeBlah.ser using
 getResource()).

 
@item
Searches for the Bean class using the beanName,
 and then instantiates it with the no-arg constructor.
 At that point, if it is an Applet, it provides it
 with AppletContext and AppletStub, and then calls
 init().

 
@end itemize

@end deftypemethod
@deftypemethod Beans {public static Object} getInstanceOf (java.lang.Object@w{ }@var{bean}, java.lang.Class@w{ }@var{newClass}) 
Get the Bean as a different class type.
 This should be used instead of casting to get a new
 type view of a Bean, because in the future there may
 be new types of Bean, even Beans spanning multiple
 Objects.
@end deftypemethod
@deftypemethod Beans {public static boolean} isInstanceOf (java.lang.Object@w{ }@var{bean}, java.lang.Class@w{ }@var{newBeanClass}) 
Determine whether the Bean can be cast to a different
 class type.
 This should be used instead of instanceof to determine
 a Bean's castability, because in the future there may
 be new types of Bean, even Beans spanning multiple
 Objects.
@end deftypemethod
@deftypemethod Beans {public static boolean} isGuiAvailable () 
Find out whether the GUI is available to use.
 Defaults to true.
@end deftypemethod
@deftypemethod Beans {public static boolean} isDesignTime () 
Find out whether it is design time.  Design time means
 we are in a RAD tool.
 Defaults to false.
@end deftypemethod
@deftypemethod Beans {public static void} setGuiAvailable (boolean@w{ }@var{guiAvailable}) @*throws SecurityException
Set whether the GUI is available to use.
@end deftypemethod
@deftypemethod Beans {public static void} setDesignTime (boolean@w{ }@var{designTime}) @*throws SecurityException
Set whether it is design time.  Design time means we
 are in a RAD tool.
@end deftypemethod
@deftypemethod Customizer {public void} setObject (java.lang.Object@w{ }@var{bean}) 
Set the object to Customize.  This will always be a
 Bean that had a BeanDescriptor indicating this
 Customizer.
@end deftypemethod
@deftypemethod Customizer {public void} addPropertyChangeListener (java.beans.PropertyChangeListener@w{ }@var{l}) 
Add a PropertyChangeListener.
@end deftypemethod
@deftypemethod Customizer {public void} removePropertyChangeListener (java.beans.PropertyChangeListener@w{ }@var{l}) 
Remove a PropertyChangeListener.
@end deftypemethod
@deftypemethod DesignMode {public void} setDesignTime (boolean@w{ }@var{designTime}) 
The environment will call this method on your
 @code{BeanContextChild} when it is registered in a parent
 @code{BeanContext} or when behavior needs to switch from
 design time to runtime behavior (or vice versa).
 



 @code{BeanContext}s are required to fire
 @code{PropertyChangeEvent}s when properties change.
 @code{designTime} is a property, and therefore when you
 implement @code{setDesignTime()}, you need to fire a
 @code{PropertyChangeEvent} with the old value, the new
 value and using @code{PROPERTYNAME} as the property name.
@end deftypemethod
@deftypemethod DesignMode {public boolean} isDesignTime () 
This method should tell whether it is design time or runtime.
@end deftypemethod
@deftypemethod EventSetDescriptor {public Class} getListenerType () 
Get the class that contains the event firing methods.
@end deftypemethod
@deftypemethod EventSetDescriptor {public Method} getListenerMethods () 
Get the event firing methods.
@end deftypemethod
@deftypemethod EventSetDescriptor {public MethodDescriptor} getListenerMethodDescriptors () 
Get the event firing methods as MethodDescriptors.
@end deftypemethod
@deftypemethod EventSetDescriptor {public Method} getAddListenerMethod () 
Get the add listener method.
@end deftypemethod
@deftypemethod EventSetDescriptor {public Method} getRemoveListenerMethod () 
Get the remove listener method.
@end deftypemethod
@deftypemethod EventSetDescriptor {public void} setUnicast (boolean@w{ }@var{unicast}) 
Set whether or not multiple listeners may be added.
@end deftypemethod
@deftypemethod EventSetDescriptor {public boolean} isUnicast () 
Get whether or not multiple listeners may be added.  (Defaults to false.)
@end deftypemethod
@deftypemethod EventSetDescriptor {public void} setInDefaultEventSet (boolean@w{ }@var{inDefaultEventSet}) 
Set whether or not this is in the default event set.
@end deftypemethod
@deftypemethod EventSetDescriptor {public boolean} isInDefaultEventSet () 
Get whether or not this is in the default event set.  (Defaults to true.)
@end deftypemethod
@deftypemethod FeatureDescriptor {public String} getName () 
Get the programmatic name of this feature.
@end deftypemethod
@deftypemethod FeatureDescriptor {public void} setName (java.lang.String@w{ }@var{name}) 
Set the programmatic name of this feature.
@end deftypemethod
@deftypemethod FeatureDescriptor {public String} getDisplayName () 
Get the localized (display) name of this feature.
@end deftypemethod
@deftypemethod FeatureDescriptor {public void} setDisplayName (java.lang.String@w{ }@var{displayName}) 
Set the localized (display) name of this feature.
@end deftypemethod
@deftypemethod FeatureDescriptor {public String} getShortDescription () 
Get the localized short description for this feature.
@end deftypemethod
@deftypemethod FeatureDescriptor {public void} setShortDescription (java.lang.String@w{ }@var{shortDescription}) 
Set the localized short description for this feature.
@end deftypemethod
@deftypemethod FeatureDescriptor {public boolean} isExpert () 
Indicates whether this feature is for expert use only.
@end deftypemethod
@deftypemethod FeatureDescriptor {public void} setExpert (boolean@w{ }@var{expert}) 
Set whether this feature is for expert use only.
@end deftypemethod
@deftypemethod FeatureDescriptor {public boolean} isHidden () 
Indicates whether this feature is for use by tools only.
 If it is for use by tools only, then it should not be displayed.
@end deftypemethod
@deftypemethod FeatureDescriptor {public void} setHidden (boolean@w{ }@var{hidden}) 
Set whether this feature is for use by tools only.
 If it is for use by tools only, then it should not be displayed.
@end deftypemethod
@deftypemethod FeatureDescriptor {public Object} getValue (java.lang.String@w{ }@var{name}) 
Get an arbitrary value set with setValue().
@end deftypemethod
@deftypemethod FeatureDescriptor {public void} setValue (java.lang.String@w{ }@var{name}, java.lang.Object@w{ }@var{value}) 
Set an arbitrary string-value pair with this feature.
@end deftypemethod
@deftypemethod FeatureDescriptor {public Enumeration} attributeNames () 
Get a list of the programmatic key names set with setValue().
@end deftypemethod
@deftypemethod IndexedPropertyDescriptor {public Class} getIndexedPropertyType () 

@end deftypemethod
@deftypemethod IndexedPropertyDescriptor {public Method} getIndexedReadMethod () 

@end deftypemethod
@deftypemethod IndexedPropertyDescriptor {public Method} getIndexedWriteMethod () 

@end deftypemethod
@deftypemethod Introspector {public static BeanInfo} getBeanInfo (java.lang.Class@w{ }@var{beanClass}) @*throws IntrospectionException
Get the BeanInfo for class @code{beanClass},
 first by looking for explicit information, next by
 using standard design patterns to determine
 information about the class.
@end deftypemethod
@deftypemethod Introspector {public static BeanInfo} getBeanInfo (java.lang.Class@w{ }@var{beanClass}, java.lang.Class@w{ }@var{stopClass}) @*throws IntrospectionException
Get the BeanInfo for class @code{beanClass},
 first by looking for explicit information, next by
 using standard design patterns to determine
 information about the class.  It crawls up the
 inheritance tree until it hits @code{topClass}.
@end deftypemethod
@deftypemethod Introspector {public static String} getBeanInfoSearchPath () 
Get the search path for BeanInfo classes.
@end deftypemethod
@deftypemethod Introspector {public static void} setBeanInfoSearchPath (java.lang.String[]@w{ }@var{beanInfoSearchPath}) 
Set the search path for BeanInfo classes.
@end deftypemethod
@deftypemethod Introspector {public static String} decapitalize (java.lang.String@w{ }@var{name}) 
A helper method to convert a name to standard Java
 naming conventions: anything with two capitals as the
 first two letters remains the same, otherwise the
 first letter is decapitalized.  URL = URL, I = i,
 MyMethod = myMethod.
@end deftypemethod
@deftypemethod MethodDescriptor {public ParameterDescriptor} getParameterDescriptors () 
Get the parameter descriptors from this method.
 Since MethodDescriptor has no way of determining what
 the parameter names were, this defaults to null.
@end deftypemethod
@deftypemethod MethodDescriptor {public Method} getMethod () 
Get the method this MethodDescriptor represents.
@end deftypemethod
@deftypemethod PropertyChangeEvent {public String} getPropertyName () 
Get the property name.
@end deftypemethod
@deftypemethod PropertyChangeEvent {public Object} getOldValue () 
Get the property's old value.
@end deftypemethod
@deftypemethod PropertyChangeEvent {public Object} getNewValue () 
Get the property's new value.
@end deftypemethod
@deftypemethod PropertyChangeEvent {public void} setPropagationId (java.lang.Object@w{ }@var{propagationId}) 
Set the propagation ID.  This is a way for the event
 to be passed from hand to hand and retain a little
 extra state.  Right now it is unused, but it should
 be propagated anyway so that future versions of
 JavaBeans can use it, for God knows what.
@end deftypemethod
@deftypemethod PropertyChangeEvent {public Object} getPropagationId () 
Get the propagation ID.
@end deftypemethod
@deftypemethod PropertyChangeListener {public void} propertyChange (java.beans.PropertyChangeEvent@w{ }@var{e}) 
Fired after a Bean's property has changed.
@end deftypemethod
@deftypemethod PropertyChangeSupport {public void} addPropertyChangeListener (java.beans.PropertyChangeListener@w{ }@var{l}) 
Adds a PropertyChangeListener to the list of listeners.
 All property change events will be sent to this listener.
 



 The listener add is not unique: that is, <em>n</em> adds with
 the same listener will result in <em>n</em> events being sent
 to that listener for every property change.
 



 Adding a null listener will cause undefined behavior.
@end deftypemethod
@deftypemethod PropertyChangeSupport {public void} addPropertyChangeListener (java.lang.String@w{ }@var{propertyName}, java.beans.PropertyChangeListener@w{ }@var{l}) 
Adds a PropertyChangeListener listening on the specified property.
 Events will be sent to the listener for that particular property.
 



 The listener add is not unique; that is, <em>n</em> adds on a
 particular property for a particular listener will result in
 <em>n</em> events being sent to that listener when that
 property is changed.
 



 The effect is cumulative, too; if you are registered to listen
 to receive events on all property changes, and then you
 register on a particular property, you will receive change
 events for that property twice.
 



 Adding a null listener will cause undefined behavior.
@end deftypemethod
@deftypemethod PropertyChangeSupport {public void} removePropertyChangeListener (java.beans.PropertyChangeListener@w{ }@var{l}) 
Removes a PropertyChangeListener from the list of listeners.
 If any specific properties are being listened on, they must
 be deregistered by themselves; this will only remove the
 general listener to all properties.
 



 If @code{add()} has been called multiple times for a
 particular listener, @code{remove()} will have to be
 called the same number of times to deregister it.
@end deftypemethod
@deftypemethod PropertyChangeSupport {public void} removePropertyChangeListener (java.lang.String@w{ }@var{propertyName}, java.beans.PropertyChangeListener@w{ }@var{l}) 
Removes a PropertyChangeListener from listening to a specific property.
 



 If @code{add()} has been called multiple times for a
 particular listener on a property, @code{remove()} will
 have to be called the same number of times to deregister it.
@end deftypemethod
@deftypemethod PropertyChangeSupport {public void} firePropertyChange (java.beans.PropertyChangeEvent@w{ }@var{event}) 
Fire a PropertyChangeEvent to all the listeners.
@end deftypemethod
@deftypemethod PropertyChangeSupport {public void} firePropertyChange (java.lang.String@w{ }@var{propertyName}, java.lang.Object@w{ }@var{oldVal}, java.lang.Object@w{ }@var{newVal}) 
Fire a PropertyChangeEvent containing the old and new values of the property to all the listeners.
@end deftypemethod
@deftypemethod PropertyChangeSupport {public void} firePropertyChange (java.lang.String@w{ }@var{propertyName}, boolean@w{ }@var{oldVal}, boolean@w{ }@var{newVal}) 
Fire a PropertyChangeEvent containing the old and new values of the property to all the listeners.
@end deftypemethod
@deftypemethod PropertyChangeSupport {public void} firePropertyChange (java.lang.String@w{ }@var{propertyName}, int@w{ }@var{oldVal}, int@w{ }@var{newVal}) 
Fire a PropertyChangeEvent containing the old and new values of the property to all the listeners.
@end deftypemethod
@deftypemethod PropertyChangeSupport {public boolean} hasListeners (java.lang.String@w{ }@var{propertyName}) 
Tell whether the specified property is being listened on or not.
 This will only return @code{true} if there are listeners
 on all properties or if there is a listener specifically on this
 property.
@end deftypemethod
@deftypemethod PropertyDescriptor {public Class} getPropertyType () 
Get the property type.
 This is the type the get method returns and the set method
 takes in.
@end deftypemethod
@deftypemethod PropertyDescriptor {public Method} getReadMethod () 
Get the get method.  Why they call it readMethod here and
 get everywhere else is beyond me.
@end deftypemethod
@deftypemethod PropertyDescriptor {public Method} getWriteMethod () 
Get the set method.  Why they call it writeMethod here and
 set everywhere else is beyond me.
@end deftypemethod
@deftypemethod PropertyDescriptor {public boolean} isBound () 
Get whether the property is bound.  Defaults to false.
@end deftypemethod
@deftypemethod PropertyDescriptor {public void} setBound (boolean@w{ }@var{bound}) 
Set whether the property is bound.
 As long as the the bean implements addPropertyChangeListener() and
 removePropertyChangeListener(), setBound(true) may safely be called.


 If these things are not true, then the behavior of the system
 will be undefined.



 When a property is bound, its set method is required to fire the
 @code{PropertyChangeListener.propertyChange())} event
 after the value has changed.
@end deftypemethod
@deftypemethod PropertyDescriptor {public boolean} isConstrained () 
Get whether the property is constrained.  Defaults to false.
@end deftypemethod
@deftypemethod PropertyDescriptor {public void} setConstrained (boolean@w{ }@var{constrained}) 
Set whether the property is constrained.
 If the set method throws @code{java.beans.PropertyVetoException}
 (or subclass thereof) and the bean implements addVetoableChangeListener()
 and removeVetoableChangeListener(), then setConstrained(true) may safely
 be called.  Otherwise, the system behavior is undefined.
 <B>Spec note:</B> given those strict parameters, it would be nice if it
 got set automatically by detection, but oh well.


 When a property is constrained, its set method is required to:


 
@itemize @bullet

 
@item
Fire the @code{VetoableChangeListener.vetoableChange()}
     event notifying others of the change and allowing them a chance to
     say it is a bad thing.

 
@item
If any of the listeners throws a PropertyVetoException, then
     it must fire another vetoableChange() event notifying the others
     of a reversion to the old value (though, of course, the change
     was never made).  Then it rethrows the PropertyVetoException and
     exits.

 
@item
If all has gone well to this point, the value may be changed.

 
@end itemize

@end deftypemethod
@deftypemethod PropertyDescriptor {public Class} getPropertyEditorClass () 
Get the PropertyEditor class.  Defaults to null.
@end deftypemethod
@deftypemethod PropertyDescriptor {public void} setPropertyEditorClass (java.lang.Class@w{ }@var{propertyEditorClass}) 
Set the PropertyEditor class.  If the class does not implement
 the PropertyEditor interface, you will likely get an exception
 late in the game.
@end deftypemethod
@deftypemethod PropertyEditor {public void} setValue (java.lang.Object@w{ }@var{value}) 
Called by the RAD tool to set the value of this property for the PropertyEditor.
 If the property type is native, it should be wrapped in the appropriate
 wrapper type.
@end deftypemethod
@deftypemethod PropertyEditor {public Object} getValue () 
Accessor method to get the current value the PropertyEditor is working with.
 If the property type is native, it will be wrapped in the appropriate
 wrapper type.
@end deftypemethod
@deftypemethod PropertyEditor {public void} setAsText (java.lang.String@w{ }@var{text}) @*throws IllegalArgumentException
Set the value of this property using a String.
 Whether or not this PropertyEditor is editing a String type, this converts
 the String into the type of the PropertyEditor.
@end deftypemethod
@deftypemethod PropertyEditor {public String} getAsText () 
Get the value of this property in String format.
 Many times this can simply use Object.toString().


 Return null if you do not support getAsText()/setAsText().
 @code{setAsText(getAsText())} should be valid; i.e. the stuff you spit out in
 getAsText() should be able to go into setAsText().
@end deftypemethod
@deftypemethod PropertyEditor {public String} getTags () 
Get a list of possible Strings which this property type can have.
 The value of these will be used by the RAD tool to construct some sort
 of list box or to check text box input, and the resulting String passed
 to setAsText() should be one of these.  Note, however, that like most things
 with this mammoth, unwieldy interface, this is not guaranteed.  Thus, you
 must check the value in setAsText() anyway.
@end deftypemethod
@deftypemethod PropertyEditor {public boolean} isPaintable () 
The RAD tool calls this to find out whether the PropertyEditor can paint itself.
@end deftypemethod
@deftypemethod PropertyEditor {public void} paintValue (java.awt.Graphics@w{ }@var{g}, java.awt.Rectangle@w{ }@var{bounds}) 
The RAD tool calls this to paint the actual value of the property.
 The Graphics context will have the same current font, color, etc. as the
 parent Container.  You may safely change the font, color, etc. and not
 change them back.


 This method should do a silent no-op if isPaintable() is false.
@end deftypemethod
@deftypemethod PropertyEditor {public boolean} supportsCustomEditor () 
The RAD tool calls this to find out whether the PropertyEditor supports a custom component to edit and display itself.
@end deftypemethod
@deftypemethod PropertyEditor {public Component} getCustomEditor () 
The RAD tool calls this to grab the component that can edit this type.
 The component may be painted anywhere the RAD tool wants to paint it--
 even in its own window.


 The component must hook up with the PropertyEditor and, whenever a
 change to the value is made, fire a PropertyChangeEvent to the source.


@end deftypemethod
@deftypemethod PropertyEditor {public void} addPropertyChangeListener (java.beans.PropertyChangeListener@w{ }@var{listener}) 
Adds a property change listener to this PropertyEditor.
@end deftypemethod
@deftypemethod PropertyEditor {public void} removePropertyChangeListener (java.beans.PropertyChangeListener@w{ }@var{listener}) 
Removes a property change listener from this PropertyEditor.
@end deftypemethod
@deftypemethod PropertyEditor {public String} getJavaInitializationString () 
Get a Java language-specific String which could be used to create an Object
 of the specified type.  Every PropertyEditor must support this.


 The reason for this is that while most RAD tools will serialize the Beans
 and deserialize them at runtime, some RAD tools will generate code that
 creates the Beans.  Examples of Java initialization strings would be:


 
@itemize @bullet

     
@item
@code{2}

     
@item
@code{"I am a String"}

     
@item
@code{new MyObject(2, "String", new StringBuffer())}

 
@end itemize

@end deftypemethod
@deftypemethod PropertyEditorManager {public static void} registerEditor (java.lang.Class@w{ }@var{editedClass}, java.lang.Class@w{ }@var{editorClass}) 
Register an editor for a class.  Replaces old editor
 if there was one registered before.
@end deftypemethod
@deftypemethod PropertyEditorManager {public static PropertyEditor} findEditor (java.lang.Class@w{ }@var{editedClass}) 
Returns a new instance of the property editor for the
 specified class.
@end deftypemethod
@deftypemethod PropertyEditorManager {public static String} getEditorSearchPath () 
Get the editor search path.
 As a minor departure from the spec, the default value
 for the editor search path is "gnu.java.beans.editors",
 "sun.beans.editors".
@end deftypemethod
@deftypemethod PropertyEditorManager {public static void} setEditorSearchPath (java.lang.String[]@w{ }@var{editorSearchPath}) 
Set the editor search path.
@end deftypemethod
@deftypemethod PropertyEditorSupport {public void} setValue (java.lang.Object@w{ }@var{val}) 
Set the current value of the property.
 <STRONG>Implementation Note</STRONG> Sun does not
 state what exactly this version of the method does.
 Thus, in this implementation, it sets the value, and
 then if the old and new values are different, it
 fires a property change event with no property name
 and the old and new values.
@end deftypemethod
@deftypemethod PropertyEditorSupport {public Object} getValue () 
Get the current value of the property.
@end deftypemethod
@deftypemethod PropertyEditorSupport {public boolean} isPaintable () 
Get whether this object is paintable or not.
@end deftypemethod
@deftypemethod PropertyEditorSupport {public void} paintValue (java.awt.Graphics@w{ }@var{g}, java.awt.Rectangle@w{ }@var{r}) 
Paint this object.  This class does nothing in
 this method.
@end deftypemethod
@deftypemethod PropertyEditorSupport {public String} getJavaInitializationString () 
Get the Java initialization String for the current
 value of the Object.  This class returns gibberish or
 null (though the spec does not say which).


 <STRONG>Implementation Note:</STRONG> This class
 returns the string "@$#^" to make sure the code will
 be broken, so that you will know to override it when
 you create your own property editor.
@end deftypemethod
@deftypemethod PropertyEditorSupport {public String} getAsText () 
Get the value as text.
 In this class, you cannot count on getAsText() doing
 anything useful, although in this implementation I
 do toString().
@end deftypemethod
@deftypemethod PropertyEditorSupport {public void} setAsText (java.lang.String@w{ }@var{s}) @*throws IllegalArgumentException
Set the value as text.
 In this class, you cannot count on setAsText() doing
 anything useful across implementations.
 <STRONG>Implementation Note:</STRONG> In this
 implementation it checks if the String is "null", and
 if it is, sets the value to null, otherwise it throws
 an IllegalArgumentException.
@end deftypemethod
@deftypemethod PropertyEditorSupport {public String} getTags () 
Returns a list of possible choices for the value.
@end deftypemethod
@deftypemethod PropertyEditorSupport {public Component} getCustomEditor () 
Return a custom component to edit the value.
@end deftypemethod
@deftypemethod PropertyEditorSupport {public boolean} supportsCustomEditor () 
Find out whether this property editor supports a
 custom component to edit its value.
@end deftypemethod
@deftypemethod PropertyEditorSupport {public void} addPropertyChangeListener (java.beans.PropertyChangeListener@w{ }@var{l}) 
Add a property change listener to this property editor.
@end deftypemethod
@deftypemethod PropertyEditorSupport {public void} removePropertyChangeListener (java.beans.PropertyChangeListener@w{ }@var{l}) 
Remove a property change listener from this property editor.
@end deftypemethod
@deftypemethod PropertyEditorSupport {public void} firePropertyChange () 
Notify people that we've changed, although we don't
 tell them just how.  The only thing I can think of to
 send in the event is the new value (since the old value
 is unavailable and there is no property name).
 I confess I do not understand the point of this method.
@end deftypemethod
@deftypemethod PropertyVetoException {public PropertyChangeEvent} getPropertyChangeEvent () 
Get the PropertyChange event that was vetoed.
@end deftypemethod
@deftypemethod SimpleBeanInfo {public BeanDescriptor} getBeanDescriptor () 
Force Introspection of the general bean info.
@end deftypemethod
@deftypemethod SimpleBeanInfo {public EventSetDescriptor} getEventSetDescriptors () 
Force Introspection of the events this Bean type
 fires.
@end deftypemethod
@deftypemethod SimpleBeanInfo {public int} getDefaultEventIndex () 
Say that there is no "default" event set.
@end deftypemethod
@deftypemethod SimpleBeanInfo {public PropertyDescriptor} getPropertyDescriptors () 
Force Introspection of the Bean properties.
@end deftypemethod
@deftypemethod SimpleBeanInfo {public int} getDefaultPropertyIndex () 
Say that there is no "default" property.
@end deftypemethod
@deftypemethod SimpleBeanInfo {public MethodDescriptor} getMethodDescriptors () 
Force Introspection of the Bean's methods.
@end deftypemethod
@deftypemethod SimpleBeanInfo {public BeanInfo} getAdditionalBeanInfo () 
Tell the Introspector to go look for other BeanInfo
 itself.
@end deftypemethod
@deftypemethod SimpleBeanInfo {public Image} getIcon (int@w{ }@var{iconType}) 
Say that this Bean has no icons.
@end deftypemethod
@deftypemethod SimpleBeanInfo {public Image} loadImage (java.lang.String@w{ }@var{location}) 
Helper method to load an image using the Bean class
 getResource() method on the BeanInfo class (using
 getClass(), since you'll extend this class to get
 the BeanInfo).  Basically it's assumed that the Bean
 and its BeanInfo are both loaded by the same
 ClassLoader, generally a reasonable assumption.
@end deftypemethod
@deftypemethod VetoableChangeListener {public void} vetoableChange (java.beans.PropertyChangeEvent@w{ }@var{e}) @*throws PropertyVetoException
Fired before a Bean's property changes.
@end deftypemethod
@deftypemethod VetoableChangeSupport {public void} addVetoableChangeListener (java.beans.VetoableChangeListener@w{ }@var{l}) 
Adds a VetoableChangeListener to the list of listeners.
 All property change events will be sent to this listener.
 



 The listener add is not unique: that is, <em>n</em> adds with
 the same listener will result in <em>n</em> events being sent
 to that listener for every property change.
 



 Adding a null listener will cause undefined behavior.
@end deftypemethod
@deftypemethod VetoableChangeSupport {public void} addVetoableChangeListener (java.lang.String@w{ }@var{propertyName}, java.beans.VetoableChangeListener@w{ }@var{l}) 
Adds a VetoableChangeListener listening on the specified property.
 Events will be sent to the listener for that particular property.
 



 The listener add is not unique; that is, <em>n</em> adds on a
 particular property for a particular listener will result in
 <em>n</em> events being sent to that listener when that
 property is changed.
 



 The effect is cumulative, too; if you are registered to listen
 to receive events on all property changes, and then you
 register on a particular property, you will receive change
 events for that property twice.
 



 Adding a null listener will cause undefined behavior.
@end deftypemethod
@deftypemethod VetoableChangeSupport {public void} removeVetoableChangeListener (java.beans.VetoableChangeListener@w{ }@var{l}) 
Removes a VetoableChangeListener from the list of listeners.
 If any specific properties are being listened on, they must
 be deregistered by themselves; this will only remove the
 general listener to all properties.
 



 If @code{add()} has been called multiple times for a
 particular listener, @code{remove()} will have to be
 called the same number of times to deregister it.
@end deftypemethod
@deftypemethod VetoableChangeSupport {public void} removeVetoableChangeListener (java.lang.String@w{ }@var{propertyName}, java.beans.VetoableChangeListener@w{ }@var{l}) 
Removes a VetoableChangeListener from listening to a specific property.
 



 If @code{add()} has been called multiple times for a
 particular listener on a property, @code{remove()} will
 have to be called the same number of times to deregister it.
@end deftypemethod
@deftypemethod VetoableChangeSupport {public void} fireVetoableChange (java.beans.PropertyChangeEvent@w{ }@var{proposedChange}) @*throws PropertyVetoException
Fire a VetoableChangeEvent to all the listeners.
 If any listener objects, a reversion event will be sent to
 those listeners who received the initial event.
@end deftypemethod
@deftypemethod VetoableChangeSupport {public void} fireVetoableChange (java.lang.String@w{ }@var{propertyName}, java.lang.Object@w{ }@var{oldVal}, java.lang.Object@w{ }@var{newVal}) @*throws PropertyVetoException
Fire a VetoableChangeEvent containing the old and new values of the property to all the listeners.
 If any listener objects, a reversion event will be sent to
 those listeners who received the initial event.
@end deftypemethod
@deftypemethod VetoableChangeSupport {public void} fireVetoableChange (java.lang.String@w{ }@var{propertyName}, boolean@w{ }@var{oldVal}, boolean@w{ }@var{newVal}) @*throws PropertyVetoException
Fire a VetoableChangeEvent containing the old and new values of the property to all the listeners.
 If any listener objects, a reversion event will be sent to
 those listeners who received the initial event.
@end deftypemethod
@deftypemethod VetoableChangeSupport {public void} fireVetoableChange (java.lang.String@w{ }@var{propertyName}, int@w{ }@var{oldVal}, int@w{ }@var{newVal}) @*throws PropertyVetoException
Fire a VetoableChangeEvent containing the old and new values of the property to all the listeners.
 If any listener objects, a reversion event will be sent to
 those listeners who received the initial event.
@end deftypemethod
@deftypemethod VetoableChangeSupport {public boolean} hasListeners (java.lang.String@w{ }@var{propertyName}) 
Tell whether the specified property is being listened on or not.
 This will only return @code{true} if there are listeners
 on all properties or if there is a listener specifically on this
 property.
@end deftypemethod
@deftypemethod Visibility {public boolean} needsGui () 
Tells whether the Bean can run without a GUI or not.
@end deftypemethod
@deftypemethod Visibility {public boolean} avoidingGui () 
Tells whether Bean is trying not to use the GUI.
 If needsGui() is true, this method should always return false.
@end deftypemethod
@deftypemethod Visibility {public void} dontUseGui () 
Tells the Bean not to use GUI methods.
 If needsGUI() is false, then after this method is called,
 avoidingGui() should return true.
@end deftypemethod
@deftypemethod Visibility {public void} okToUseGui () 
Tells the Bean it may use the GUI.
 The Bean is not required to use the GUI in this case, it is
 merely being <EM>permitted</EM> to use it.  If needsGui() is
 false, avoidingGui() may return true or false after this method
 is called.
@end deftypemethod
