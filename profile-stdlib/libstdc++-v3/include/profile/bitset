// Profiling bitset implementation -*- C++ -*-

// Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.

// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.

/** @file profile/bitset
 *  This file is a GNU profile extension to the Standard C++ Library.
 */

#ifndef _GLIBCXX_PROFILE_BITSET
#define _GLIBCXX_PROFILE_BITSET

#include <bitset>

namespace std
{
namespace __profile
{
  template<size_t _Nb>
    class bitset
    : public _GLIBCXX_STD_PR::bitset<_Nb> 
    {
      typedef _GLIBCXX_STD_PR::bitset<_Nb> _Base;

    public:
      bitset() : _Base() { }

      bitset(unsigned long __val) : _Base(__val) { }

      template<typename _CharT, typename _Traits, typename _Allocator>
        explicit
        bitset(const std::basic_string<_CharT,_Traits,_Allocator>& __str,
           typename std::basic_string<_CharT,_Traits,_Allocator>::size_type
           __pos = 0,
           typename std::basic_string<_CharT,_Traits,_Allocator>::size_type
           __n = (std::basic_string<_CharT,_Traits,_Allocator>::npos))
    : _Base(__str, __pos, __n) { }

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 778. std::bitset does not have any constructor taking a string literal
      explicit
      bitset(const char* __s)
      : _Base(__s) { }

      bitset(const _Base& __x) : _Base(__x) { }

      bool
      operator==(const bitset<_Nb>& __rhs) const
      { return _M_base() == __rhs; }

      bool
      operator!=(const bitset<_Nb>& __rhs) const
      { return _M_base() != __rhs; }

      bitset<_Nb>
      operator<<(size_t __pos) const
      { return bitset<_Nb>(_M_base() << __pos); }

      bitset<_Nb>
      operator>>(size_t __pos) const
      { return bitset<_Nb>(_M_base() >> __pos); }

      _Base&
      _M_base() { return *this; }

      const _Base&
      _M_base() const { return *this; }

    };

  template<size_t _Nb>
    bitset<_Nb>
    operator&(const bitset<_Nb>& __x, const bitset<_Nb>& __y)
    { return bitset<_Nb>(__x) &= __y; }

  template<size_t _Nb>
    bitset<_Nb>
    operator|(const bitset<_Nb>& __x, const bitset<_Nb>& __y)
    { return bitset<_Nb>(__x) |= __y; }

  template<size_t _Nb>
    bitset<_Nb>
    operator^(const bitset<_Nb>& __x, const bitset<_Nb>& __y)
    { return bitset<_Nb>(__x) ^= __y; }

  template<typename _CharT, typename _Traits, size_t _Nb>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is, bitset<_Nb>& __x)
    { return __is >> __x._M_base(); }

  template<typename _CharT, typename _Traits, size_t _Nb>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
           const bitset<_Nb>& __x)
    { return __os << __x._M_base(); }

} // namespace __profile
} // namespace std

#endif
