# Copyright (C) 1998, 1999 Cygnus Solutions

load_lib "libgloss.exp"

# GCJ_UNDER_TEST is the compiler under test.

global tmpdir

if ![info exists tmpdir] {
    set tmpdir "/tmp"
}

# Read an `xfail' file if it exists.  Returns a list of xfail tokens.
proc libjava_read_xfail {file} {
    if {! [file exists $file]} {
	return ""
    }
    set fd [open $file r]
    set tokens [string trim [read $fd]]
    close $fd
    return $tokens
}

# Find `jv-scan'.  FIXME: this relies on DejaGnu internals.  These
# should probably be exposed in a better way.
proc find_jvscan {} {
    global tool_root_dir

    set file [lookfor_file $tool_root_dir jv-scan]
    if { $file == "" } {
	set file [lookfor_file $tool_root_dir gcc/jv-scan];
    }
    if {$file == ""} {
	set file jv-scan
    }
    return $file
}

proc bytecompile_file { file objdir {classpath {}} } {
    global env
    set dirname  [file dirname $file];

    catch {unset env(CLASSPATH)}
    if {$classpath != ""} then {
        set env(CLASSPATH) $classpath
    }
    if {[catch {system "cd $dirname; javac $file -d $objdir"} msg]} then {
	verbose "couldn't compile $file: $msg"
	set r 0
    } else {
	set r 1
    }
    return $r
}

set libjava_initialized 0

#
# Build the status wrapper library as needed.
#
proc libjava_init { args } {
    global wrapper_file;
    global wrap_compile_flags;
    global libjava_initialized
    global GCJ_UNDER_TEST
    global TOOL_EXECUTABLE

    if { $libjava_initialized == 1 } { return; }

    if ![info exists GCJ_UNDER_TEST] {
	if [info exists TOOL_EXECUTABLE] {
	    set GCJ_UNDER_TEST $TOOL_EXECUTABLE;
	} else {
	    set GCJ_UNDER_TEST "[find_gcj]"
	}
    }

    set wrapper_file "";
    set wrap_compile_flags "";
    if [target_info exists needs_status_wrapper] {
	set result [build_wrapper "testglue.o"];
	if { $result != "" } {
	    set wrapper_file [lindex $result 0];
	    set wrap_compile_flags [lindex $result 1];
	} else {
	    warning "Status wrapper failed to build."
	}
    }

    set libjava_initialized 1
}

# Find a library.  We know where libtool puts the actual libraries,
# and we look there.  The implementation is fairly hacky.  We can't
# compile with -nodefaultlibs, because that will also eliminate the
# system libraries we need.  In order to have gcj still work, it must
# find the appropriate libraries so we must add -L options for their
# paths.  However we can't simply use those libraries; we still need
# libtool for linking.
proc libjava_find_lib {dir name} {
    global base_dir
    set gp [get_multilibs]
    foreach sub {.libs _libs} {
	if {$gp != ""} {
	    if {[file exists $gp/$dir/$sub/lib${name}.a]} then {
		return "$gp/$dir/lib${name}.la -L$gp/$dir/$sub"
	    }
	}
	set lib [findfile $base_dir/../../$dir/$sub/lib${name}.a \
		   "$base_dir/../../$dir/lib${name}.la -L$base_dir/../../$dir/$sub" \
		   ""]
	if {$lib != ""} {
	    return $lib
	}
    }
    return ""
}

# Compute arguments needed for compiler.  MODE is a libtool mode:
# either compile or link.
proc libjava_arguments {{mode compile}} {
    global base_dir
    global LIBJAVA
    global LIBGC
    global LIBQTHREADS
    global LIBZ
    global srcdir subdir objdir
    global TOOL_OPTIONS
    global GCJ_UNDER_TEST
    global tmpdir
    global runtests

    if [info exists LIBJAVA] {
	set libjava $LIBJAVA;
    } else {
	set libjava [libjava_find_lib libjava gcj]
    }

    if [info exists LIBGC] {
	set libgc $LIBGC;
    } else {
	set libgc [libjava_find_lib boehm-gc gcjgc]
    }

    if [info exists LIBQTHREADS] {
	set libqthreads $LIBQTHREADS
    } else {
	set libqthreads [libjava_find_lib qthreads gcjcoop]
    }

    if [info exists LIBZ] {
	set libz $LIBZ
    } else {
	set libz [libjava_find_lib zlib zgcj]
    }

    # FIXME: there's no way to determine whether -lpthread is
    # required.  We should get this info from configure, or it should
    # just be in the compiler driver.

    verbose "using LIBJAVA = $libjava" 2
    verbose "using LIBGC = $libgc" 2
    verbose "using LIBQTHREADS = $libqthreads" 2
    verbose "using LIBZ = $libz" 2
    set args ""

    # Basically we want to build up a colon separated path list from
    # the value of $libjava.

    # First strip away any -L arguments.
    regsub -all -- "-L" $libjava "" ld_library_path

    # Then remove any -lgcj argument.
    regsub -all -- " -lgcj.*" $ld_library_path "" ld_library_path

    # First strip away any -L arguments.
    regsub -all -- "-L" $libgc $ld_library_path ld_library_path

    # Then remove any -lgcjgc argument.
    regsub -all -- " -lgcjgc.*" $ld_library_path "" ld_library_path

    # That's enough to make things work for the normal case.
    # If we wanted to handle an arbitrary value of libjava,
    # then we'd have to do a lot more work.

    # Set variables the dynamic linker looks at.
    setenv LD_LIBRARY_PATH $ld_library_path
    setenv SHLIB_PATH $ld_library_path

    # Set the CLASSPATH environment variable
    verbose "CLASSPATH is $objdir/.."
    global env
    set env(CLASSPATH) "$objdir/.."

    global wrapper_file wrap_compile_flags;
    lappend args "additional_flags=$wrap_compile_flags";
    lappend args "libs=$wrapper_file";
    lappend args "libs=$libjava";
    lappend args "libs=$libgc";
    lappend args "libs=$libqthreads"
    lappend args "libs=$libz"
    lappend args debug

    if { [target_info needs_status_wrapper]!="" && [info exists gluefile] } {
	lappend args "libs=${gluefile}"
	lappend args "ldflags=$wrap_flags"
    }

    if [info exists TOOL_OPTIONS] {
	lappend args "additional_flags=$TOOL_OPTIONS"
    }

    # Search for libtool.  We need it to link.
    set found_compiler 0
    set d [absolute $objdir]
    foreach x {. .. ../.. ../../..} {
	if {[file exists $d/$x/libtool]} then {
	    # We have to run silently to avoid DejaGNU lossage.
	    lappend args \
	      "compiler=$d/$x/libtool --silent --mode=$mode $GCJ_UNDER_TEST"
	    set found_compiler 1
	    break
	}
    }
    if {! $found_compiler} {
	lappend args "compiler=$GCJ_UNDER_TEST"
    }

    return $args
}


#
# Run the test specified by srcfile and resultfile. compile_args and
# exec_args are options telling this proc how to work.
#   `no-exec'     don't try to run the test
#   `xfail-gcj'   compilation from source will fail
#   `xfail-javac' compilation with javac will fail
#   `xfail-gcjC'  compilation with gcj -C will fail
#   `xfail-byte'  compilation from bytecode will fail
#   `xfail-exec'  exec will fail
#   `xfail-output' output will be wrong
#   
#
proc test_libjava_from_source { options srcfile compile_args inpfile resultfile exec_args } {
    global base_dir
    global LIBJAVA
    global LIBGC
    global srcdir subdir objdir
    global TOOL_OPTIONS
    global GCJ_UNDER_TEST
    global tmpdir
    global runtests

    # Make opts into an array.
    set opts(_) x
    unset opts(_)
    foreach item $exec_args {
	set opts($item) x
    }

    set errname [file rootname [file tail $srcfile]]
    if {! [runtest_file_p $runtests $errname]} {
        return
    }

    set args [libjava_arguments link]
    # Add the --main flag
    lappend args "additional_flags=--main=[file rootname [file tail $srcfile]]"
    if { $compile_args != "" } {
	lappend args "additional_flags=$compile_args"
    }

    regsub "^.*/(\[^/.\]+)\[.\]\[^/]*$" "$srcfile" "\\1" out
    set executable "${objdir}/$out"
    if { $compile_args != "" } {
	set errname "$errname $compile_args"
    }

    set x [target_compile $srcfile "$executable" executable $args]
    if {[info exists opts(xfail-gcj)]} {
	setup_xfail *-*-*
    }
    if { $x != "" } {
	verbose "target_compile failed: $x" 2
	fail "$errname compilation from source"
	if {[info exists opts(xfail-gcj)] || ! [info exists opts(no-exec)]} {
	    setup_xfail "*-*-*"
	    fail "$errname execution from source compiled test"
	    setup_xfail "*-*-*"
	    fail "$errname output from source compiled test"
	}
	return;
    }
    pass "$errname compilation from source"

    if {[info exists opts(no-exec)]} {
	return
    }

    set result [libjava_load $executable "" "$inpfile"];
    set status [lindex $result 0];
    set output [lindex $result 1];
    if {[info exists opts(xfail-exec)]} then {
	setup_xfail *-*-*
    }
    $status "$errname execution from source compiled test"
    if { $status != "pass" } {
	setup_xfail "*-*-*"
	fail "$errname execution from source compiled test"
	return;
    }

    verbose "resultfile is $resultfile"
    set id [open $resultfile r];
    set expected ""
    append expected [read $id];
    regsub -all "\r" "$output" "" output;
    regsub "\n*$" $expected "" expected
    regsub "\n*$" $output "" output
    regsub "^\n*" $expected "" expected
    regsub "^\n*" $output "" output
    regsub -all "\[ \t\]\[ \t\]*" $expected " " expected
    regsub -all "\[ \t\]*\n\n*" $expected "\n" expected
    regsub -all "\[ \t\]\[ \t\]*" $output " " output
    regsub -all "\[ \t\]*\n\n*" $output "\n" output
    verbose "expected is $expected"
    verbose "actual is $output"
    set passed 0;
    if {$options == "regexp_match"} {
	if [regexp $expected $output] {
	    set passed 1;
	}
    } else {
	if { $expected == $output } {
	    set passed 1;
	}
    }
    if {[info exists opts(xfail-output)]} {
	setup_xfail *-*-*
    }
    if { $passed == 1 } {
	pass "$errname output from source compiled test"
    } else {
	clone_output "expected was $expected"
	clone_output "output was $output"
	fail "$errname output from source compiled test"
    }
    close $id;
}

#
# Run the test specified by srcfile and resultfile. compile_args and
# exec_args are options telling this proc how to work.
#   `no-exec' don't try to run the test
#   `xfail-gcj'   compilation from source will fail
#   `xfail-javac' compilation with javac will fail
#   `xfail-gcjC'  compilation with gcj -C will fail
#   `xfail-byte'  compilation from bytecode will fail
#   `xfail-exec'  exec will fail
#   `xfail-output' output will be wrong
#
proc test_libjava_from_javac { options srcfile compile_args inpfile resultfile exec_args } {
    global base_dir
    global LIBJAVA
    global LIBGC
    global srcdir subdir objdir
    global TOOL_OPTIONS
    global GCJ_UNDER_TEST
    global tmpdir
    global runtests

    # Make opts into an array.
    set opts(_) x
    unset opts(_)
    foreach item $exec_args {
	set opts($item) x
    }

    set errname [file rootname [file tail $srcfile]]
    if {! [runtest_file_p $runtests $errname]} {
        return
    }

    # bytecompile files with Sun's compiler for now.
    set bc_ok [bytecompile_file $srcfile $objdir]
    # FIXME: assumes we are using javac to compile to bytecode.
    # This is not always the case.
    if {[info exists opts(xfail-javac)]} {
	setup_xfail *-*-*
    }
    if {! $bc_ok} then {
	fail "$errname byte compilation"
	setup_xfail "*-*-*"
	fail "$errname compilation from bytecode"
	if {! [info exists opts(no-exec)]} {
	    setup_xfail "*-*-*"
	    fail "$errname execution from bytecode->native test"
	    setup_xfail "*-*-*"
	    fail "$errname output from bytecode->native test"
	}
	return
    }
    pass "$errname byte compilation"

    # Find name to use for --main, and name of all class files.
    set jvscan [find_jvscan]
    verbose "jvscan is $jvscan"
    set main_name [string trim \
		     [target_compile $srcfile "" none \
			"compiler=$jvscan additional_flags=--print-main"]]
    verbose "main name is $main_name"
    set class_out [string trim \
		     [target_compile $srcfile "" none \
			"compiler=$jvscan additional_flags=--list-class"]]
    verbose "class list is $class_out"
    # FIXME: As of Wed Feb 24 1999, `jv-scan --list-class' prints
    # nothing if the file contains an interface and not a class.  I
    # believe this is a jv-scan bug.
    if {$class_out == ""} then {
	set class_files \
	  [list $objdir/[file rootname [file tail $srcfile]].class]
    } else {
	# Turn "a b" into "a.class b.class".
	set class_files {}
        foreach file [split [string trim $class_out]] {
	    lappend class_files $objdir/$file.class
	}
    }

    # Usually it is an error for a test program not to have a `main'
    # method.  However, for no-exec tests it is ok.
    set largs {}
    if {$main_name == ""} {
	if {! [info exists opts(no-exec)]} {
	    perror "No `main' given in program $errname"
	    return
	} else {
	    set type object
	    set executable [file rootname [file tail $srcfile]].o
	    set mode compile
	}
    } else {
	set type executable
	lappend largs "additional_flags=--main=$main_name"
	set executable "${objdir}/$main_name"
	set mode link
    }

    # Initial arguments.
    set args [libjava_arguments $mode]
    eval lappend args $largs

    if { $compile_args != "" } {
	lappend args "additional_flags=$compile_args"
    }

    if { $compile_args != "" } {
	set errname "$errname $compile_args"
    }

    verbose "compilation command = $args" 2
    set x [target_compile $class_files "$executable" $type $args]
    if {[info exists opts(xfail-byte)]} {
	setup_xfail *-*-*
    }
    if { $x != "" } {
	verbose "target_compile failed: $x" 2
	fail "$errname compilation from bytecode"
	setup_xfail "*-*-*"
	if {! [info exists opts(no-exec)]} {
	    fail "$errname execution from bytecode->native test"
	    setup_xfail "*-*-*"
	    fail "$errname output from bytecode->native test"
	}
	return;
    }
    pass "$errname compilation from bytecode"

    if {[info exists opts(no-exec)]} {
	return
    }

    set result [libjava_load $executable "" "$inpfile"];
    set status [lindex $result 0];
    set output [lindex $result 1];
    if {[info exists opts(xfail-exec)]} {
	setup_xfail *-*-*
    }
    $status "$errname execution from bytecode->native test"
    if { $status != "pass" } {
	setup_xfail "*-*-*"
	fail "$errname output from bytecode->native test"
	return;
    }

    verbose "resultfile is $resultfile"
    set id [open $resultfile r];
    set expected ""
    append expected [read $id];
    regsub -all "\r" "$output" "" output;
    regsub "\n*$" $expected "" expected
    regsub "\n*$" $output "" output
    regsub "^\n*" $expected "" expected
    regsub "^\n*" $output "" output
    regsub -all "\[ \t\]\[ \t\]*" $expected " " expected
    regsub -all "\[ \t\]*\n\n*" $expected "\n" expected
    regsub -all "\[ \t\]\[ \t\]*" $output " " output
    regsub -all "\[ \t\]*\n\n*" $output "\n" output
    verbose "expected is $expected"
    verbose "actual is $output"
    set passed 0;
    if {[info exists opts(xfail-output)]} {
	setup_xfail *-*-*
    }
    if {$options == "regexp_match"} {
	if [regexp $expected $output] {
	    set passed 1;
	}
    } else {
	if { $expected == $output } {
	    set passed 1;
	}
    }
    if { $passed == 1 } {
	pass "$errname output from bytecode->native test"
    } else {
	clone_output "expected was $expected"
	clone_output "output was $output"
	fail "$errname output from bytecode->native test"
    }
    close $id;
}

#
# Run the test specified by srcfile and resultfile. compile_args and
# exec_args are options telling this proc how to work.
#   `no-exec' don't try to run the test
#   `xfail-gcj'   compilation from source will fail
#   `xfail-javac' compilation with javac will fail
#   `xfail-gcjC'  compilation with gcj -C will fail
#   `xfail-byte'  compilation from bytecode will fail
#   `xfail-exec'  exec will fail
#   `xfail-output' output will be wrong
#
proc test_libjava { options srcfile compile_args inpfile resultfile exec_args } {
    test_libjava_from_source $options $srcfile $compile_args $inpfile $resultfile $exec_args
    test_libjava_from_javac $options $srcfile $compile_args $inpfile $resultfile $exec_args
 }

#
# libjava_version -- extract and print the version number of libjavap
#
proc default_libjava_version {} {
}

proc default_libjava_start { } {
}

# Local Variables:
# tcl-indent-level:4
# End:
