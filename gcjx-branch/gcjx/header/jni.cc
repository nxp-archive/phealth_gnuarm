// Write a JNI header.

// Copyright (C) 2004, 2005 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// gcjx is free software; you can redistribute it and/or
// modify it under the terms of the GNU Library General Public
// License as published by the Free Software Foundation; either
// version 2 of the License, or (at your option) any later version.
//
// gcjx is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Library General Public License for more details.
//
// You should have received a copy of the GNU Library General Public
// License along with gcjx; see the file COPYING.LIB.  If
// not, write to the Free Software Foundation, Inc.,
// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

#include "typedefs.hh"
#include "header/jni.hh"

#include <fstream>

jni_code_generator::jni_code_generator (compiler *c, directory_cache &dirs)
  : code_generator (dirs),
    comp (c)
{
}

void
jni_code_generator::write_header (std::ostream &out,
				  const std::string &base)
{
  std::string define = "__" + base + "__";

  out << "/* DO NOT EDIT THIS FILE - it is machine generated */" << std::endl;
  out << std::endl;

  out << "#ifndef " << define << std::endl;
  out << "#define " << define << std::endl;
  out << std::endl;

  out << "#include <jni.h>" << std::endl;
  out << std::endl;
  out << "#ifdef __cplusplus" << std::endl;
  out << "extern \"C\"" << std::endl;
  out << "{" << std::endl;
  out << "#endif" << std::endl;
  out << std::endl;
}

void
jni_code_generator::write (std::ostream &out,
			   model_type *type)
{
  assert (type != null_type);

  bool is_array = type->array_p ();
  if (is_array)
    type = type->element_type ();

  if (type == primitive_void_type)
    {
      assert (! is_array);
      out << "void";
    }
  else if (type->primitive_p ())
    {
      out << "j" << type->get_pretty_name ();
      if (is_array)
	out << "Array";
    }
  else if (is_array)
    {
      if (type == comp->java_lang_Object ())
	out << "jobjectArray";
      else
	out << "jarray";
    }
  else if (type == comp->java_lang_String ())
    out << "jstring";
  else if (type == comp->java_lang_Class ())
    out << "jclass";
  else
    out << "jobject";
}

void
jni_code_generator::add_char (char *buf, jchar c, int *here)
{
  if (c == '_')
    {
      buf[(*here)++] = '_';
      buf[(*here)++] = '1';
    }
  else if (c == ';')
    {
      buf[(*here)++] = '_';
      buf[(*here)++] = '2';
    }
  else if (c == '[')
    {
      buf[(*here)++] = '_';
      buf[(*here)++] = '3';
    }

  // Also check for '.' here because we might be passed an internal
  // qualified class name like 'foo.bar'.
  else if (c == '/' || c == '.')
    buf[(*here)++] = '_';
  else if ((c >= '0' && c <= '9')
	   || (c >= 'a' && c <= 'z')
	   || (c >= 'A' && c <= 'Z'))
    buf[(*here)++] = (char) c;
  else
    {
      // "Unicode" character.
      buf[(*here)++] = '_';
      buf[(*here)++] = '0';
      for (int i = 0; i < 4; ++i)
	{
	  int val = c & 0x0f;
	  buf[(*here) + 3 - i] = (val > 10) ? ('a' + val - 10) : ('0' + val);
	  c >>= 4;
	}
      *here += 4;
    }
}

std::string
jni_code_generator::translate (model_element *request, const std::string &name)
{
  char out[1 + 6 * name.length ()];
  unsigned int i = 0;
  int where = 0;
  while (i < name.length ())
    {
      jchar ch;

      unsigned char c = name[i++];
      unsigned char c1, c2;
      if (c < 128)
	ch = c;
      else
	{
	  if ((c & 0xe0) == 0xc0)
	    {
	      assert (i < name.length ());  // FIXME
	      c1 = name[i++];
	      if ((c1 & 0xc0) == 0x80)
		{
		  jchar r = (jchar) (((c & 0x1f) << 6) + (c1 & 0x3f));
		  /* Check for valid 2-byte characters.  We explicitly
		     allow \0 because this encoding is common in the
		     Java world.  */
		  if (r == 0 || (r >= 0x80 && r <= 0x7ff))
		    ch = r;
		}
	      else
		throw request->error ("malformed UTF-8 character");
	    }
	  else if ((c & 0xf0) == 0xe0)
	    {
	      assert (i < name.length ());  // FIXME
	      c1 = name[i++];
	      if ((c1 & 0xc0) == 0x80)
		{
		  assert (i < name.length ());  // FIXME
		  c2 = name[i++];
		  if ((c2 & 0xc0) == 0x80)
		    {
		      jchar r =  (jchar) (((  c & 0xf) << 12) + 
					  (( c1 & 0x3f) << 6)
					  + (c2 & 0x3f));
		      /* Check for valid 3-byte characters.
			 Don't allow surrogate, \ufffe or \uffff.  */
		      if (r >= 0x800
			  && ! (r >= 0xd800 && r <= 0xdfff)
			  && r != 0xfffe && r != 0xffff)
			ch = r;
		      else
			throw request->error ("malformed UTF-8 character");
		    }
		  else
		    throw request->error ("malformed UTF-8 character");
		}
	      else
		throw request->error ("malformed UTF-8 character");
	    }
	  else
	    throw request->error ("malformed UTF-8 character");
	}

      add_char (out, ch, &where);
    }

  out[where] = '\0';
  return std::string (out);
}

void
jni_code_generator::write_method (std::ostream &out,
				  model_method *meth,
				  const std::string &class_name,
				  bool long_format)
{
  out << "JNIEXPORT ";
  write (out, meth->get_return_type ());
  out << " JNICALL ";

  out << "Java_" << class_name << "_";
  out << translate (meth, meth->get_name ());
  if (long_format)
    {
      std::string sig = meth->get_descriptor ();
      assert (sig[0] == '(');
      int roff = sig.rfind (')');
      assert (roff >= 1);
      sig = sig.substr (1, roff - 1);
      out << "_" << translate (meth, sig);
    }

  out << " (JNIEnv *env, " << (meth->static_p () ? "jclass" : "jobject");

  std::list<ref_variable_decl> params = meth->get_parameters ();
  for (std::list<ref_variable_decl>::const_iterator i = params.begin ();
       i != params.end ();
       ++i)
    {
      out << ", ";
      write (out, (*i)->type ());
    }

  out << ");" << std::endl;
}

void
jni_code_generator::write_field (std::ostream &out, const std::string &cname,
				 model_field *field)
{
  if (! field->static_p () || ! field->constant_p ()
      || ! field->type ()->primitive_p ())
    return;

  out << "#undef " << cname << "_" << field->get_name () << std::endl
      << "#define " << cname << "_" << field->get_name ()
      << " " << field->get_initializer ()->string_value ()
      << std::endl;
}

void
jni_code_generator::write_trailer (std::ostream &out,
				   const std::string &base)
{
  std::string define = "__" + base + "__";

  out << std::endl;
  out << "#ifdef __cplusplus" << std::endl;
  out << "}" << std::endl;
  out << "#endif" << std::endl;
  out << std::endl;
  out << "#endif /* " << define << " */" << std::endl;
}

std::string
jni_code_generator::file_name (const std::string &base)
{
  return base + ".h";
}

void
jni_code_generator::generate (model_class *klass)
{
  std::map<std::string, bool> name_map;
  std::list<ref_method> methods = klass->get_methods ();
  for (std::list<ref_method>::const_iterator i = methods.begin ();
       i != methods.end ();
       ++i)
    {
      if (((*i)->get_modifiers () & ACC_NATIVE) == 0)
	continue;

      std::string name = (*i)->get_name ();
      if (name_map.find (name) == name_map.end ())
	name_map[name] = false;
      else
	name_map[name] = true;
    }

#if 0
  // javah will write out a header even if there are no native
  // methods.  Perhaps not best, but we're compatible.
  if (name_map.empty ())
    return;
#endif

  // Compute the mangled class name.
  std::string cname = klass->get_fully_qualified_name ();
  // Ugly...
  for (unsigned int i = 0; i < cname.length (); ++i)
    {
      if (cname[i] == '$')
	cname[i] = '.';
    }
  cname = translate (klass, cname);

  std::string fname = (comp->get_output_directory ()
		       + FILE_SEPARATOR
		       + file_name (cname));
  std::ofstream out (fname.c_str ());

  if (global->get_compiler ()->verbose ())
    std::cout << " [writing " << fname << "]" << std::endl;

  write_header (out, cname);

  for (std::list<ref_method>::const_iterator i = methods.begin ();
       i != methods.end ();
       ++i)
    {
      if (((*i)->get_modifiers () & ACC_NATIVE) == 0)
	continue;
      std::string name = (*i)->get_name ();
      if (name_map.find (name) != name_map.end ())
	write_method (out, (*i).get (), cname, name_map[name]);
    }

  out << std::endl;

  // Note: we pick up fields from superclasses as well.  This is
  // intentional, as it mirrors what javah does.  Note however that
  // javah only, and IMO incorrectly, considers the concrete hierarchy
  // and ignores fields declared in superinterfaces.  It also
  // incorrectly considers private constants declared in superclasses.
  std::list<model_field *> fields = klass->get_all_fields ();
  for (std::list<model_field *>::const_iterator i = fields.begin ();
       i != fields.end ();
       ++i)
    write_field (out, cname, *i);

  out << std::endl;

  write_trailer (out, cname);
}
