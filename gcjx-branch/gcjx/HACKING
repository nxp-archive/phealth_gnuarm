This file explains the source layout of gcjx, and some of the rules
for developing it.

================================================================
== Hacking stuff

gcjx uses the GNU C style extended to C++

Use assert() liberally.  abort() in unrecoverable situations.  (We
should probably have a nice wrapper for abort so that it shows up in
Jacks logs.)


================================================================
== Source Code Road Map

Anything in model/ is related to the model of the program.  For the
most part things are self-explanatory, e.g., model_assert is the class
that models the "assert" statement.  Classes in this directory
starting with "I" are interface classes and are ordinarily used as
"mixins".

semantic analysis:
 - maybe move this code to new analyze/ directory?
    access.hh
    conversions.hh
    defassign.hh
    fold.hh
    name.hh
    resolve.hh
    scope.hh

class reading and writing:
    everything in bytecode/

parsing and lexing:
    everything in source/

helpers, utility code, etc:
    buffer.hh
    classcache.hh
    directory.hh
    location.hh
    owner.hh
    typedefs.hh
    util.hh
    watch.hh

general compiler framework:
    compiler.hh
    exception.hh
    factory.hh
    global.hh
    visitor.hh

code for helping ahead-of-time compilers:
    everything in aot/

A model_foo is a class in the model.  We use `model_' and not
`model::' because we want simple names like "while", which are C++
keywords.

A ref_foo is an owner<model_foo>.  Not every model class needs a ref
class.  If model_y is a subclass of model_x, then a ref_y can be
assigned to a ref_x -- owner<> understands this.

Ownership of model objects must be considered carefully.  If there is
a natural container for something, it should usually be the owner.
E.g., a class owns its members, but a class does not own its
superclass or interfaces.  Represent ownership with a ref_ and
otherwise with a pointer to a model_.

Right now we have some goofy things in the model where we have fields
based on implementation, e.g. deprecation is represented with a
javadoc object.  This is incorrect, deprecation should be represented
with a flag and then settor should handle conversion.
