This is a higher-level view of things to do than TODO.
It shows the big pieces and what is missing.

================================================================
== Lexer

The lexer itself is in ok shape.  There are some FIXME comments,
though, which must be cleaned up.

The token stream wrapper around the lexer has some serious performance
problems.  In particular peek() is too slow given the amount of use it
sees.  Also perhaps the design has too much overhead.  A lot of the
complexity is just for javadoc handling (which contributes only a
single "deprecated" flag); maybe we could make it simpler.


================================================================
== Model

Classes for the model mostly exist.

Annotations have been started but not finished
- handling package-info.java
  and give warnings if a class appears in that file
- package parsing buglet in parse::compilation_unit()
- non-circularity of annotations
- where should model_package call resolve_annotations ?

enums partly work.  They are completely untested but much of the code
is there.  some code generation work remains (at least switches on
enum type).  a little semantic analysis work remains, including
missing error checking

Generics partly work.  Generic methods have not been implemented at
all.

varargs, boxing, and unboxing work.  however there are a couple of
cases of {un,}boxing conversion that still don't work; see TODO
code generation for boxing/unboxing with foreach doesn't work.
some other cast cases may need work in the back ends.


================================================================
== Parser

The parser probably has performance problems.  Error handling and
recovery is quite weak.

we don't handle attributes correctly
they can be intermixed with modifiers

it is possible to explicitly pass the type arguments to a generic
method invocation.  we mostly handle this but there is one remaining
case in the parser.  the model parts haven't been finished yet.  see
parse::primary().  in the model we need to have a new virtual method
for handling genericization, with the default doing type inference


================================================================
== Semantic Analysis

static import works, but the internal APIs are broken and we don't do
the error checking we ought to do.

There's some ugliness in Iname; perhaps this interface should be
entirely removed.

The code in name.cc is fairly inefficient for the most part.

classify_ambiguous_name needs to be written.  Perhaps it should be
called classify_expression_name, as that is more correct.

some inner class things still don't work properly.  look through jacks
results to see the errors.  for example there are some variable
capture cases that are incorrect.  static context handling still
doesn't really work.


================================================================
== Class Reading

Many checks should be performed but are not.

The class reader doesn't handle debug information.

we don't handle some 1.5 features when reading .class files
- SourceFile
- line number and local variable tables
- enum, class, and attribute values for attributes
- parameter annotations
- enclosing method attribute

We want a mode where we don't actually read other classes,
for gcj-jit.  Perhaps this is as simple as passing an unresolved
class to the tree generating back end and putting the logic there?
Look into it.


================================================================
== Error Handling

We probably want location support to interact well with gcc's, if
that is possible.

Sometimes we want an error message that consists of multiple parts:
for instance the location and the message, plus extra locations of
redundant or ambiguous declarations.

We need some kind of recovery when there is an error during
resolution.  For instance, a statement could catch errors thrown
during resolution, emit them, and then return normally.

it might be nice if our error formatter could introduce newlines at
word breaks when appropriate


================================================================
== Code Generation

Bytecode generation mostly works, but it occasionally generates
incorrect bytecode.  Running the verifier over the output is helpful
here.  (Having a mode for "gcjx --verify-only" would be very useful
right now!)

The bytecode generator doesn't emit debug information.

JNI header generation is probably ok

CNI stub generation is not implemented

we don't yet generate trampolines for access to private constructors
of outer classes

should look at LLVM
probably easy to write a back end for it
if we compiled .class as well perhaps we could wind up with a jit


Some code for tree generation exists, but it is incomplete.  Some
random thoughts:
- find a nice way to factor the ABI code
  map a class to an ABI object
  call the ABI object to generate trees


================================================================
== Driver

We need to reconsider how compilations are ordered.  If we could
generate code earlier, we could free resources attached to a given
class more easily.  Right now we parse and analyze everything before
generating any code.

the driver should be able to read entire .jar files

we don't handle property files at all but we need to for GCC

we don't handle -extdirs yet


================================================================
== Weird Stuff

This isn't weird... we should put everything into a namespace
so gcjx can be reused more easily

dlopen()ing libgcj.so and using it as the core class library hasn't
been written.  Right now libgcj.so doesn't have enough reflective
info; see http://gcc.gnu.org/bugzilla/show_bug.cgi?id=4105
(The general idea is to allow a .so file to appear in the class
path.)  [ it isn't clear how well this will interact with annotations
that don't stick around until runtime -- will we put those in the
.so?  why would we? ]

I've been writing doxygen comments lately, but haven't done a
consistent sweep.


================================================================
== Threading

compiler::find_name needs a locking strategy
for instance what if two threads look up a class at once?
we need a fine-grained lock here

If we want MT semantic analysis we'll need to think about where to put
locks.
- when changing class state (classes resolved, members resolved, class
  resolved), acquire class lock
- acquire a lock when resolving a field's type
- avoiding deadlock...
- what about resolving compilation units?
- we should use `condition *' and `sync *' and use a factory method
  to construct instances

lock a class
  resolve_classes
  lock superclass when resolving parts of it


================================================================
== Source Code Road Map

Anything in model/ is related to the model of the program.  For the
most part things are self-explanatory, e.g., model_assert is the class
that models the "assert" statement.  Classes in this directory
starting with "I" are interface classes and are ordinarily used as
"mixins".

semantic analysis:
 - maybe move this code to new analyze/ directory?
    access.hh
    conversions.hh
    defassign.hh
    fold.hh
    name.hh
    resolve.hh
    scope.hh

class reading and writing:
    everything in bytecode/

parsing and lexing:
    everything in source/

helpers, utility code, etc:
    buffer.hh
    classcache.hh
    directory.hh
    location.hh
    owner.hh
    typedefs.hh
    util.hh
    watch.hh

general compiler framework:
    compiler.hh
    exception.hh
    factory.hh
    global.hh
    visitor.hh

code for helping ahead-of-time compilers:
    everything in aot/

if we write threading code, put in thread/; see bkoz's libthread++
and also thread-local extension class.

A model_foo is a class in the model.  We use `model_' and not
`model::' because we want simple names like "while", which are C++
keywords.

A ref_foo is an owner<model_foo>.  Not every model class needs a ref
class.  If model_y is a subclass of model_x, then a ref_y can be
assigned to a ref_x -- owner<> understands this.

Ownership of model objects must be considered carefully.  If there is
a natural container for something, it should usually be the owner.
E.g., a class owns its members, but a class does not own its
superclass or interfaces.  Represent ownership with a ref_ and
otherwise with a pointer to a model_.

Right now we have some goofy things in the model where we have fields
based on implementation, e.g. deprecation is represented with a
javadoc object.  This is incorrect, deprecation should be represented
with a flag and then settor should handle conversion.

Use assert() liberally.  abort() in unrecoverable situations.  (We
should probably have a nice wrapper for abort so that it shows up in
Jacks logs.)
