This is a higher-level view of things to do than TODO.
It shows the big pieces and what is missing.

================================================================
== Lexer

The lexer itself is in ok shape.  There are some FIXME comments,
though, which must be cleaned up.


================================================================
== Model

Classes for the model mostly exist.

Annotations have been started but not finished
- handling package-info.java
  and give warnings if a class appears in that file
- non-circularity of annotations
- where should model_package call resolve_annotations ?

enums mostly work.  Generics mostly work.  For both of these we need a
number of error checks at the very least; there are some lurking bugs
too.

varargs, boxing, and unboxing work.  however there are a couple of
cases of {un,}boxing conversion that still don't work; see TODO
code generation for boxing/unboxing with foreach doesn't work.
some other cast cases may need work in the back ends.


================================================================
== Parser

The parser has performance problems.  Error handling and recovery is
quite weak.

there's a package parsing buglet in parse::compilation_unit()

we don't handle attributes correctly
they can be intermixed with modifiers


================================================================
== Semantic Analysis

There's some ugliness in Iname; perhaps this interface should be
entirely removed.

The code in name.cc is fairly inefficient for the most part.
(But it doesn't show up in profiles)

classify_ambiguous_name needs to be written.  Perhaps it should be
called classify_expression_name, as that is more correct.

some inner class things still don't work properly.  look through jacks
results to see the errors.  for example there are some variable
capture cases that are incorrect.  static context handling still
doesn't really work.

there are some remaining definite assignment bugs; look through
jacks results to see


================================================================
== Class Reading

Many checks should be performed but are not.

The class reader doesn't handle debug information.

we don't handle some features when reading .class files
- SourceFile
- line number and local variable tables
- enclosing method attribute

We want a mode where we don't actually read other classes,
for gcj-jit.  Perhaps this is as simple as passing an unresolved
class to the tree generating back end and putting the logic there?
Look into it.


================================================================
== Error Handling

We probably want location support to interact well with gcc's, if
that is possible.

Sometimes we want an error message that consists of multiple parts:
for instance the location and the message, plus extra locations of
redundant or ambiguous declarations.

We need some kind of recovery when there is an error during
resolution.  For instance, a statement could catch errors thrown
during resolution, emit them, and then return normally.

it might be nice if our error formatter could introduce newlines at
word breaks when appropriate


================================================================
== Code Generation

Bytecode generation mostly works, but it occasionally generates
incorrect bytecode.  Running the verifier over the output is helpful
here.

JNI header generation is probably ok

CNI stub generation is not implemented

should look at LLVM
probably easy to write a back end for it
if we compiled .class as well perhaps we could wind up with a jit
if we do that, ideally we would share the code generator with libgcj

Some code for tree generation exists, but it is incomplete.  Some
random thoughts:
- find a nice way to factor the ABI code
  map a class to an ABI object
  call the ABI object to generate trees


================================================================
== Driver

We need to reconsider how compilations are ordered.  If we could
generate code earlier, we could free resources attached to a given
class more easily.  Right now we parse and analyze everything before
generating any code.

we don't handle -extdirs yet


================================================================
== Weird Stuff

This isn't weird... we should put everything into a namespace
so gcjx can be reused more easily

dlopen()ing libgcj.so and using it as the core class library hasn't
been written.  Right now libgcj.so doesn't have enough reflective
info; see http://gcc.gnu.org/bugzilla/show_bug.cgi?id=4105
(The general idea is to allow a .so file to appear in the class
path.)  [ it isn't clear how well this will interact with annotations
that don't stick around until runtime -- will we put those in the
.so?  why would we? ]

I've been writing doxygen comments lately, but haven't done a
consistent sweep.


================================================================
== Threading

compiler::find_name needs a locking strategy
for instance what if two threads look up a class at once?
we need a fine-grained lock here

If we want MT semantic analysis we'll need to think about where to put
locks.
- when changing class state (classes resolved, members resolved, class
  resolved), acquire class lock
- acquire a lock when resolving a field's type
- avoiding deadlock...
- what about resolving compilation units?
- we should use `condition *' and `sync *' and use a factory method
  to construct instances

lock a class
  resolve_classes
  lock superclass when resolving parts of it

it turns out that parsing can affect global state by creating packages
we need a lock somewhere to deal with this
