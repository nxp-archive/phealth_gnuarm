#!/bin/sh

# Copyright (C) 2008 Free Software Foundation, Inc.

#This file is part of GCC.

#GCC is free software; you can redistribute it and/or modify it under
#the terms of the GNU General Public License as published by the Free
#Software Foundation; either version 2, or (at your option) any later
#version.

#GCC is distributed in the hope that it will be useful, but WITHOUT
#ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
#FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
#for more details.

#You should have received a copy of the GNU General Public License
#along with GCC; see the file COPYING.  If not, write to the Free
#Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
#02110-1301, USA.


# This is the default ltrans_driver for LTO.  It takes a list of files
# output during WPA mode and expects the CC and CFLAGS environment variables
# to be set.  It generates a temporary Makefile, and uses it to convert .o
# files to .ltrans.o files.

# See if CFLAGS includes -v or -save-temps to react accordingly.
verbose=0
save_temps=0
for f in $CFLAGS ; do
  if [ "$f" = "'-v'" ] ; then
    verbose=1
  elif [ "$f" = "'-save-temps'" ] ; then
    save_temps=1
  fi
done

# Create a temporary directory $tmp in $TMPDIR (default /tmp).
# Use mktemp if possible; otherwise fall back on mkdir,
# with $RANDOM to make collisions less likely.
: ${TMPDIR=/tmp}
{
  tmp=`
    (umask 077 && mktemp -d "$TMPDIR/ltrans_driverXXXXXX") 2>/dev/null
  ` &&
  test -n "$tmp" && test -d "$tmp"
} || {
  tmp=$TMPDIR/ltrans_driver$$-$RANDOM
  (umask 077 && mkdir "$tmp")
} || exit $?

# Remove the temporary directory on exit or if a SIGTERM or SIGINT is
# received.
if [ $save_temps -eq 0 ] ; then
  trap 'rm -rf $tmp' TERM INT EXIT
fi

# Create a temporary Makefile.
makefile=$tmp/Makefile
touch $makefile

# We have to clear these to avoid problems with this make invocation getting
# confused with variables set by (for example) "make -j 2 check".
unset MAKEFLAGS
unset MAKEINFO
unset MAKELEVEL

inputlist="$@"
outputlist=
for input in $inputlist
do
  output=`dirname $input`/`basename $input .o`.ltrans.o
  outputlist="$outputlist $output"

  echo "$output: $input" >> $makefile
  echo "	\$(CC) \$(CFLAGS) -o $output $input" >> $makefile
  echo >> $makefile
done

echo "all: $outputlist" >> $makefile
echo "	@true"		>> $makefile

if [ $verbose -eq 1 ] ; then
  set -x
fi

# Use some simple heuristics to determine how much parallelism to use
# when invoking make.  Note that this probably only works reliably on
# Linux.  Also, the load may spike right after the calculation, so
# it's not foolproof.
awk=/usr/bin/awk
uptime=/usr/bin/uptime
getconf=/usr/bin/getconf
par=1
if [ $verbose -ne 1 -a -x $awk -a -x $uptime -a -x $getconf ] ; then
  loadavg=$($uptime | $awk '{ l = $(NF - 2); print int (strtonum (l)); }')
  nprocs=$($getconf _NPROCESSORS_ONLN)
  if [ $loadavg -lt $nprocs ] ; then
    par=$[($nprocs - $loadavg) * 2]
  fi
fi
${MAKE-make} -s -f $makefile -j $par all
exit $?
